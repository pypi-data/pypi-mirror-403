from pkgutil import extend_path
__path__ = extend_path(__path__, __name__)

import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

import typeguard
from importlib.metadata import version as _metadata_package_version
TYPEGUARD_MAJOR_VERSION = int(_metadata_package_version('typeguard').split('.')[0])

def check_type(argname: str, value: object, expected_type: typing.Any) -> typing.Any:
    if TYPEGUARD_MAJOR_VERSION <= 2:
        return typeguard.check_type(argname=argname, value=value, expected_type=expected_type) # type:ignore
    else:
        if isinstance(value, jsii._reference_map.InterfaceDynamicProxy): # pyright: ignore [reportAttributeAccessIssue]
           pass
        else:
            if TYPEGUARD_MAJOR_VERSION == 3:
                typeguard.config.collection_check_strategy = typeguard.CollectionCheckStrategy.ALL_ITEMS # type:ignore
                typeguard.check_type(value=value, expected_type=expected_type) # type:ignore
            else:
                typeguard.check_type(value=value, expected_type=expected_type, collection_check_strategy=typeguard.CollectionCheckStrategy.ALL_ITEMS) # type:ignore

from ..._jsii import *

import aws_cdk as _aws_cdk_ceddda9d
import aws_cdk.interfaces.aws_kinesisfirehose as _aws_cdk_interfaces_aws_kinesisfirehose_ceddda9d
import aws_cdk.interfaces.aws_logs as _aws_cdk_interfaces_aws_logs_ceddda9d
import aws_cdk.interfaces.aws_s3 as _aws_cdk_interfaces_aws_s3_ceddda9d
import constructs as _constructs_77d1e7e8
from ...aws_logs import ILogsDelivery as _ILogsDelivery_0d3c9e29
from ...core import IMixin as _IMixin_11e4b965, Mixin as _Mixin_a69446c0
from ...mixins import (
    CfnPropertyMixinOptions as _CfnPropertyMixinOptions_9cbff649,
    PropertyMergeStrategy as _PropertyMergeStrategy_49c157e8,
)


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnCapacityManagerDataExportMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "output_format": "outputFormat",
        "s3_bucket_name": "s3BucketName",
        "s3_bucket_prefix": "s3BucketPrefix",
        "schedule": "schedule",
        "tags": "tags",
    },
)
class CfnCapacityManagerDataExportMixinProps:
    def __init__(
        self,
        *,
        output_format: typing.Optional[builtins.str] = None,
        s3_bucket_name: typing.Optional[builtins.str] = None,
        s3_bucket_prefix: typing.Optional[builtins.str] = None,
        schedule: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnCapacityManagerDataExportPropsMixin.

        :param output_format: The file format of the exported data.
        :param s3_bucket_name: The name of the S3 bucket where export files are delivered.
        :param s3_bucket_prefix: The S3 key prefix used for organizing export files within the bucket.
        :param schedule: The frequency at which data exports are generated.
        :param tags: The tags associated with the data export configuration.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacitymanagerdataexport.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_capacity_manager_data_export_mixin_props = ec2_mixins.CfnCapacityManagerDataExportMixinProps(
                output_format="outputFormat",
                s3_bucket_name="s3BucketName",
                s3_bucket_prefix="s3BucketPrefix",
                schedule="schedule",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cb9428cd38efead942b6c73c8728a06f2a7512171c4eba67cb608c413fa1d734)
            check_type(argname="argument output_format", value=output_format, expected_type=type_hints["output_format"])
            check_type(argname="argument s3_bucket_name", value=s3_bucket_name, expected_type=type_hints["s3_bucket_name"])
            check_type(argname="argument s3_bucket_prefix", value=s3_bucket_prefix, expected_type=type_hints["s3_bucket_prefix"])
            check_type(argname="argument schedule", value=schedule, expected_type=type_hints["schedule"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if output_format is not None:
            self._values["output_format"] = output_format
        if s3_bucket_name is not None:
            self._values["s3_bucket_name"] = s3_bucket_name
        if s3_bucket_prefix is not None:
            self._values["s3_bucket_prefix"] = s3_bucket_prefix
        if schedule is not None:
            self._values["schedule"] = schedule
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def output_format(self) -> typing.Optional[builtins.str]:
        '''The file format of the exported data.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacitymanagerdataexport.html#cfn-ec2-capacitymanagerdataexport-outputformat
        '''
        result = self._values.get("output_format")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def s3_bucket_name(self) -> typing.Optional[builtins.str]:
        '''The name of the S3 bucket where export files are delivered.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacitymanagerdataexport.html#cfn-ec2-capacitymanagerdataexport-s3bucketname
        '''
        result = self._values.get("s3_bucket_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def s3_bucket_prefix(self) -> typing.Optional[builtins.str]:
        '''The S3 key prefix used for organizing export files within the bucket.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacitymanagerdataexport.html#cfn-ec2-capacitymanagerdataexport-s3bucketprefix
        '''
        result = self._values.get("s3_bucket_prefix")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def schedule(self) -> typing.Optional[builtins.str]:
        '''The frequency at which data exports are generated.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacitymanagerdataexport.html#cfn-ec2-capacitymanagerdataexport-schedule
        '''
        result = self._values.get("schedule")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags associated with the data export configuration.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacitymanagerdataexport.html#cfn-ec2-capacitymanagerdataexport-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnCapacityManagerDataExportMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnCapacityManagerDataExportPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnCapacityManagerDataExportPropsMixin",
):
    '''Creates a new data export configuration for EC2 Capacity Manager.

    This allows you to automatically export capacity usage data to an S3 bucket on a scheduled basis. The exported data includes metrics for On-Demand, Spot, and Capacity Reservations usage across your organization.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacitymanagerdataexport.html
    :cloudformationResource: AWS::EC2::CapacityManagerDataExport
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_capacity_manager_data_export_props_mixin = ec2_mixins.CfnCapacityManagerDataExportPropsMixin(ec2_mixins.CfnCapacityManagerDataExportMixinProps(
            output_format="outputFormat",
            s3_bucket_name="s3BucketName",
            s3_bucket_prefix="s3BucketPrefix",
            schedule="schedule",
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnCapacityManagerDataExportMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::CapacityManagerDataExport``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c47485cda4d9350b4895b86984f81dbf78a8afba86714b2fe381f5d20d69e44f)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ace914deb2d176085468b292e65af5010728491ed79f134caba1f80a7e80c169)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__413d46007c5e1f6585631c2dcbc3b7c62e9e16249e43e47f4bd75cbe1dd9424d)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnCapacityManagerDataExportMixinProps":
        return typing.cast("CfnCapacityManagerDataExportMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnCapacityReservationFleetMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "allocation_strategy": "allocationStrategy",
        "end_date": "endDate",
        "instance_match_criteria": "instanceMatchCriteria",
        "instance_type_specifications": "instanceTypeSpecifications",
        "no_remove_end_date": "noRemoveEndDate",
        "remove_end_date": "removeEndDate",
        "tag_specifications": "tagSpecifications",
        "tenancy": "tenancy",
        "total_target_capacity": "totalTargetCapacity",
    },
)
class CfnCapacityReservationFleetMixinProps:
    def __init__(
        self,
        *,
        allocation_strategy: typing.Optional[builtins.str] = None,
        end_date: typing.Optional[builtins.str] = None,
        instance_match_criteria: typing.Optional[builtins.str] = None,
        instance_type_specifications: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnCapacityReservationFleetPropsMixin.InstanceTypeSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        no_remove_end_date: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        remove_end_date: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        tag_specifications: typing.Optional[typing.Sequence[typing.Union["CfnCapacityReservationFleetPropsMixin.TagSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        tenancy: typing.Optional[builtins.str] = None,
        total_target_capacity: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Properties for CfnCapacityReservationFleetPropsMixin.

        :param allocation_strategy: The strategy used by the Capacity Reservation Fleet to determine which of the specified instance types to use. Currently, only the ``prioritized`` allocation strategy is supported. For more information, see `Allocation strategy <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#allocation-strategy>`_ in the *Amazon EC2 User Guide* . Valid values: ``prioritized``
        :param end_date: The date and time at which the Capacity Reservation Fleet expires. When the Capacity Reservation Fleet expires, its state changes to ``expired`` and all of the Capacity Reservations in the Fleet expire. The Capacity Reservation Fleet expires within an hour after the specified time. For example, if you specify ``5/31/2019`` , ``13:30:55`` , the Capacity Reservation Fleet is guaranteed to expire between ``13:30:55`` and ``14:30:55`` on ``5/31/2019`` .
        :param instance_match_criteria: Indicates the type of instance launches that the Capacity Reservation Fleet accepts. All Capacity Reservations in the Fleet inherit this instance matching criteria. Currently, Capacity Reservation Fleets support ``open`` instance matching criteria only. This means that instances that have matching attributes (instance type, platform, and Availability Zone) run in the Capacity Reservations automatically. Instances do not need to explicitly target a Capacity Reservation Fleet to use its reserved capacity.
        :param instance_type_specifications: Information about the instance types for which to reserve the capacity.
        :param no_remove_end_date: Used to add an end date to a Capacity Reservation Fleet that has no end date and time. To add an end date to a Capacity Reservation Fleet, specify ``true`` for this paramater and specify the end date and time (in UTC time format) for the *EndDate* parameter.
        :param remove_end_date: Used to remove an end date from a Capacity Reservation Fleet that is configured to end automatically at a specific date and time. To remove the end date from a Capacity Reservation Fleet, specify ``true`` for this paramater and omit the *EndDate* parameter.
        :param tag_specifications: The tags to assign to the Capacity Reservation Fleet. The tags are automatically assigned to the Capacity Reservations in the Fleet.
        :param tenancy: Indicates the tenancy of the Capacity Reservation Fleet. All Capacity Reservations in the Fleet inherit this tenancy. The Capacity Reservation Fleet can have one of the following tenancy settings: - ``default`` - The Capacity Reservation Fleet is created on hardware that is shared with other AWS accounts . - ``dedicated`` - The Capacity Reservations are created on single-tenant hardware that is dedicated to a single AWS account .
        :param total_target_capacity: The total number of capacity units to be reserved by the Capacity Reservation Fleet. This value, together with the instance type weights that you assign to each instance type used by the Fleet determine the number of instances for which the Fleet reserves capacity. Both values are based on units that make sense for your workload. For more information, see `Total target capacity <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#target-capacity>`_ in the *Amazon EC2 User Guide* .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_capacity_reservation_fleet_mixin_props = ec2_mixins.CfnCapacityReservationFleetMixinProps(
                allocation_strategy="allocationStrategy",
                end_date="endDate",
                instance_match_criteria="instanceMatchCriteria",
                instance_type_specifications=[ec2_mixins.CfnCapacityReservationFleetPropsMixin.InstanceTypeSpecificationProperty(
                    availability_zone="availabilityZone",
                    availability_zone_id="availabilityZoneId",
                    ebs_optimized=False,
                    instance_platform="instancePlatform",
                    instance_type="instanceType",
                    priority=123,
                    weight=123
                )],
                no_remove_end_date=False,
                remove_end_date=False,
                tag_specifications=[ec2_mixins.CfnCapacityReservationFleetPropsMixin.TagSpecificationProperty(
                    resource_type="resourceType",
                    tags=[CfnTag(
                        key="key",
                        value="value"
                    )]
                )],
                tenancy="tenancy",
                total_target_capacity=123
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4267f13608148016d60f4cc03a1edac5d15ea9c20824066ff0ea16f7eb9be649)
            check_type(argname="argument allocation_strategy", value=allocation_strategy, expected_type=type_hints["allocation_strategy"])
            check_type(argname="argument end_date", value=end_date, expected_type=type_hints["end_date"])
            check_type(argname="argument instance_match_criteria", value=instance_match_criteria, expected_type=type_hints["instance_match_criteria"])
            check_type(argname="argument instance_type_specifications", value=instance_type_specifications, expected_type=type_hints["instance_type_specifications"])
            check_type(argname="argument no_remove_end_date", value=no_remove_end_date, expected_type=type_hints["no_remove_end_date"])
            check_type(argname="argument remove_end_date", value=remove_end_date, expected_type=type_hints["remove_end_date"])
            check_type(argname="argument tag_specifications", value=tag_specifications, expected_type=type_hints["tag_specifications"])
            check_type(argname="argument tenancy", value=tenancy, expected_type=type_hints["tenancy"])
            check_type(argname="argument total_target_capacity", value=total_target_capacity, expected_type=type_hints["total_target_capacity"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if allocation_strategy is not None:
            self._values["allocation_strategy"] = allocation_strategy
        if end_date is not None:
            self._values["end_date"] = end_date
        if instance_match_criteria is not None:
            self._values["instance_match_criteria"] = instance_match_criteria
        if instance_type_specifications is not None:
            self._values["instance_type_specifications"] = instance_type_specifications
        if no_remove_end_date is not None:
            self._values["no_remove_end_date"] = no_remove_end_date
        if remove_end_date is not None:
            self._values["remove_end_date"] = remove_end_date
        if tag_specifications is not None:
            self._values["tag_specifications"] = tag_specifications
        if tenancy is not None:
            self._values["tenancy"] = tenancy
        if total_target_capacity is not None:
            self._values["total_target_capacity"] = total_target_capacity

    @builtins.property
    def allocation_strategy(self) -> typing.Optional[builtins.str]:
        '''The strategy used by the Capacity Reservation Fleet to determine which of the specified instance types to use.

        Currently, only the ``prioritized`` allocation strategy is supported. For more information, see `Allocation strategy <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#allocation-strategy>`_ in the *Amazon EC2 User Guide* .

        Valid values: ``prioritized``

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-allocationstrategy
        '''
        result = self._values.get("allocation_strategy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def end_date(self) -> typing.Optional[builtins.str]:
        '''The date and time at which the Capacity Reservation Fleet expires.

        When the Capacity Reservation Fleet expires, its state changes to ``expired`` and all of the Capacity Reservations in the Fleet expire.

        The Capacity Reservation Fleet expires within an hour after the specified time. For example, if you specify ``5/31/2019`` , ``13:30:55`` , the Capacity Reservation Fleet is guaranteed to expire between ``13:30:55`` and ``14:30:55`` on ``5/31/2019`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-enddate
        '''
        result = self._values.get("end_date")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def instance_match_criteria(self) -> typing.Optional[builtins.str]:
        '''Indicates the type of instance launches that the Capacity Reservation Fleet accepts.

        All Capacity Reservations in the Fleet inherit this instance matching criteria.

        Currently, Capacity Reservation Fleets support ``open`` instance matching criteria only. This means that instances that have matching attributes (instance type, platform, and Availability Zone) run in the Capacity Reservations automatically. Instances do not need to explicitly target a Capacity Reservation Fleet to use its reserved capacity.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-instancematchcriteria
        '''
        result = self._values.get("instance_match_criteria")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def instance_type_specifications(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnCapacityReservationFleetPropsMixin.InstanceTypeSpecificationProperty"]]]]:
        '''Information about the instance types for which to reserve the capacity.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-instancetypespecifications
        '''
        result = self._values.get("instance_type_specifications")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnCapacityReservationFleetPropsMixin.InstanceTypeSpecificationProperty"]]]], result)

    @builtins.property
    def no_remove_end_date(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Used to add an end date to a Capacity Reservation Fleet that has no end date and time.

        To add an end date to a Capacity Reservation Fleet, specify ``true`` for this paramater and specify the end date and time (in UTC time format) for the *EndDate* parameter.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-noremoveenddate
        '''
        result = self._values.get("no_remove_end_date")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def remove_end_date(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Used to remove an end date from a Capacity Reservation Fleet that is configured to end automatically at a specific date and time.

        To remove the end date from a Capacity Reservation Fleet, specify ``true`` for this paramater and omit the *EndDate* parameter.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-removeenddate
        '''
        result = self._values.get("remove_end_date")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def tag_specifications(
        self,
    ) -> typing.Optional[typing.List["CfnCapacityReservationFleetPropsMixin.TagSpecificationProperty"]]:
        '''The tags to assign to the Capacity Reservation Fleet.

        The tags are automatically assigned to the Capacity Reservations in the Fleet.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-tagspecifications
        '''
        result = self._values.get("tag_specifications")
        return typing.cast(typing.Optional[typing.List["CfnCapacityReservationFleetPropsMixin.TagSpecificationProperty"]], result)

    @builtins.property
    def tenancy(self) -> typing.Optional[builtins.str]:
        '''Indicates the tenancy of the Capacity Reservation Fleet.

        All Capacity Reservations in the Fleet inherit this tenancy. The Capacity Reservation Fleet can have one of the following tenancy settings:

        - ``default`` - The Capacity Reservation Fleet is created on hardware that is shared with other AWS accounts .
        - ``dedicated`` - The Capacity Reservations are created on single-tenant hardware that is dedicated to a single AWS account .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-tenancy
        '''
        result = self._values.get("tenancy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def total_target_capacity(self) -> typing.Optional[jsii.Number]:
        '''The total number of capacity units to be reserved by the Capacity Reservation Fleet.

        This value, together with the instance type weights that you assign to each instance type used by the Fleet determine the number of instances for which the Fleet reserves capacity. Both values are based on units that make sense for your workload. For more information, see `Total target capacity <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#target-capacity>`_ in the *Amazon EC2 User Guide* .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-totaltargetcapacity
        '''
        result = self._values.get("total_target_capacity")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnCapacityReservationFleetMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnCapacityReservationFleetPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnCapacityReservationFleetPropsMixin",
):
    '''Creates a new Capacity Reservation Fleet with the specified attributes.

    For more information, see `Capacity Reservation Fleets <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/cr-fleets.html>`_ in the *Amazon EC2 User Guide* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html
    :cloudformationResource: AWS::EC2::CapacityReservationFleet
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_capacity_reservation_fleet_props_mixin = ec2_mixins.CfnCapacityReservationFleetPropsMixin(ec2_mixins.CfnCapacityReservationFleetMixinProps(
            allocation_strategy="allocationStrategy",
            end_date="endDate",
            instance_match_criteria="instanceMatchCriteria",
            instance_type_specifications=[ec2_mixins.CfnCapacityReservationFleetPropsMixin.InstanceTypeSpecificationProperty(
                availability_zone="availabilityZone",
                availability_zone_id="availabilityZoneId",
                ebs_optimized=False,
                instance_platform="instancePlatform",
                instance_type="instanceType",
                priority=123,
                weight=123
            )],
            no_remove_end_date=False,
            remove_end_date=False,
            tag_specifications=[ec2_mixins.CfnCapacityReservationFleetPropsMixin.TagSpecificationProperty(
                resource_type="resourceType",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )],
            tenancy="tenancy",
            total_target_capacity=123
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnCapacityReservationFleetMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::CapacityReservationFleet``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eb1ea5538acaee5bd733345aae21fc24d00a6bf27e5959f36d3246c9fd777d69)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__85d0faf66c66a6b5040c775038cd2ea758ecec4a80b1ca84619337a0edd91415)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__948f0599a9f723dddadb636bbad085a1f0d4efefc261fdc0c3b8a7edc261d2d2)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnCapacityReservationFleetMixinProps":
        return typing.cast("CfnCapacityReservationFleetMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnCapacityReservationFleetPropsMixin.InstanceTypeSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "availability_zone": "availabilityZone",
            "availability_zone_id": "availabilityZoneId",
            "ebs_optimized": "ebsOptimized",
            "instance_platform": "instancePlatform",
            "instance_type": "instanceType",
            "priority": "priority",
            "weight": "weight",
        },
    )
    class InstanceTypeSpecificationProperty:
        def __init__(
            self,
            *,
            availability_zone: typing.Optional[builtins.str] = None,
            availability_zone_id: typing.Optional[builtins.str] = None,
            ebs_optimized: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            instance_platform: typing.Optional[builtins.str] = None,
            instance_type: typing.Optional[builtins.str] = None,
            priority: typing.Optional[jsii.Number] = None,
            weight: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Specifies information about an instance type to use in a Capacity Reservation Fleet.

            ``InstanceTypeSpecification`` is a property of the `AWS::EC2::CapacityReservationFleet <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html>`_ resource.

            :param availability_zone: The Availability Zone in which the Capacity Reservation Fleet reserves the capacity. A Capacity Reservation Fleet can't span Availability Zones. All instance type specifications that you specify for the Fleet must use the same Availability Zone.
            :param availability_zone_id: The ID of the Availability Zone in which the Capacity Reservation Fleet reserves the capacity. A Capacity Reservation Fleet can't span Availability Zones. All instance type specifications that you specify for the Fleet must use the same Availability Zone.
            :param ebs_optimized: Indicates whether the Capacity Reservation Fleet supports EBS-optimized instances types. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using EBS-optimized instance types.
            :param instance_platform: The type of operating system for which the Capacity Reservation Fleet reserves capacity.
            :param instance_type: The instance type for which the Capacity Reservation Fleet reserves capacity.
            :param priority: The priority to assign to the instance type. This value is used to determine which of the instance types specified for the Fleet should be prioritized for use. A lower value indicates a high priority. For more information, see `Instance type priority <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#instance-priority>`_ in the *Amazon EC2 User Guide* .
            :param weight: The number of capacity units provided by the specified instance type. This value, together with the total target capacity that you specify for the Fleet determine the number of instances for which the Fleet reserves capacity. Both values are based on units that make sense for your workload. For more information, see `Total target capacity <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#target-capacity>`_ in the Amazon EC2 User Guide. Valid Range: Minimum value of ``0.001`` . Maximum value of ``99.999`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                instance_type_specification_property = ec2_mixins.CfnCapacityReservationFleetPropsMixin.InstanceTypeSpecificationProperty(
                    availability_zone="availabilityZone",
                    availability_zone_id="availabilityZoneId",
                    ebs_optimized=False,
                    instance_platform="instancePlatform",
                    instance_type="instanceType",
                    priority=123,
                    weight=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__8c365b5e08a5052ee666da92cd3212fae896d8c6ca1b939f46286967afad626c)
                check_type(argname="argument availability_zone", value=availability_zone, expected_type=type_hints["availability_zone"])
                check_type(argname="argument availability_zone_id", value=availability_zone_id, expected_type=type_hints["availability_zone_id"])
                check_type(argname="argument ebs_optimized", value=ebs_optimized, expected_type=type_hints["ebs_optimized"])
                check_type(argname="argument instance_platform", value=instance_platform, expected_type=type_hints["instance_platform"])
                check_type(argname="argument instance_type", value=instance_type, expected_type=type_hints["instance_type"])
                check_type(argname="argument priority", value=priority, expected_type=type_hints["priority"])
                check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if availability_zone is not None:
                self._values["availability_zone"] = availability_zone
            if availability_zone_id is not None:
                self._values["availability_zone_id"] = availability_zone_id
            if ebs_optimized is not None:
                self._values["ebs_optimized"] = ebs_optimized
            if instance_platform is not None:
                self._values["instance_platform"] = instance_platform
            if instance_type is not None:
                self._values["instance_type"] = instance_type
            if priority is not None:
                self._values["priority"] = priority
            if weight is not None:
                self._values["weight"] = weight

        @builtins.property
        def availability_zone(self) -> typing.Optional[builtins.str]:
            '''The Availability Zone in which the Capacity Reservation Fleet reserves the capacity.

            A Capacity Reservation Fleet can't span Availability Zones. All instance type specifications that you specify for the Fleet must use the same Availability Zone.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-availabilityzone
            '''
            result = self._values.get("availability_zone")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def availability_zone_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the Availability Zone in which the Capacity Reservation Fleet reserves the capacity.

            A Capacity Reservation Fleet can't span Availability Zones. All instance type specifications that you specify for the Fleet must use the same Availability Zone.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-availabilityzoneid
            '''
            result = self._values.get("availability_zone_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def ebs_optimized(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether the Capacity Reservation Fleet supports EBS-optimized instances types.

            This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using EBS-optimized instance types.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-ebsoptimized
            '''
            result = self._values.get("ebs_optimized")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def instance_platform(self) -> typing.Optional[builtins.str]:
            '''The type of operating system for which the Capacity Reservation Fleet reserves capacity.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-instanceplatform
            '''
            result = self._values.get("instance_platform")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def instance_type(self) -> typing.Optional[builtins.str]:
            '''The instance type for which the Capacity Reservation Fleet reserves capacity.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-instancetype
            '''
            result = self._values.get("instance_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def priority(self) -> typing.Optional[jsii.Number]:
            '''The priority to assign to the instance type.

            This value is used to determine which of the instance types specified for the Fleet should be prioritized for use. A lower value indicates a high priority. For more information, see `Instance type priority <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#instance-priority>`_ in the *Amazon EC2 User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-priority
            '''
            result = self._values.get("priority")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def weight(self) -> typing.Optional[jsii.Number]:
            '''The number of capacity units provided by the specified instance type.

            This value, together with the total target capacity that you specify for the Fleet determine the number of instances for which the Fleet reserves capacity. Both values are based on units that make sense for your workload. For more information, see `Total target capacity <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#target-capacity>`_ in the Amazon EC2 User Guide.

            Valid Range: Minimum value of ``0.001`` . Maximum value of ``99.999`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-weight
            '''
            result = self._values.get("weight")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "InstanceTypeSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnCapacityReservationFleetPropsMixin.TagSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={"resource_type": "resourceType", "tags": "tags"},
    )
    class TagSpecificationProperty:
        def __init__(
            self,
            *,
            resource_type: typing.Optional[builtins.str] = None,
            tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''The tags to apply to a resource when the resource is being created.

            When you specify a tag, you must specify the resource type to tag, otherwise the request will fail.
            .. epigraph::

               The ``Valid Values`` lists all the resource types that can be tagged. However, the action you're using might not support tagging all of these resource types. If you try to tag a resource type that is unsupported for the action you're using, you'll get an error.

            :param resource_type: The type of resource to tag on creation. Specify ``capacity-reservation-fleet`` . To tag a resource after it has been created, see `CreateTags <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html>`_ .
            :param tags: The tags to apply to the resource.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-tagspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                from aws_cdk import CfnTag
                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                tag_specification_property = ec2_mixins.CfnCapacityReservationFleetPropsMixin.TagSpecificationProperty(
                    resource_type="resourceType",
                    tags=[CfnTag(
                        key="key",
                        value="value"
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__bb36bac7a98fe9455333ccc52e0259303f483b04dd668b064e130ce9d61a2ec6)
                check_type(argname="argument resource_type", value=resource_type, expected_type=type_hints["resource_type"])
                check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if resource_type is not None:
                self._values["resource_type"] = resource_type
            if tags is not None:
                self._values["tags"] = tags

        @builtins.property
        def resource_type(self) -> typing.Optional[builtins.str]:
            '''The type of resource to tag on creation. Specify ``capacity-reservation-fleet`` .

            To tag a resource after it has been created, see `CreateTags <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-tagspecification.html#cfn-ec2-capacityreservationfleet-tagspecification-resourcetype
            '''
            result = self._values.get("resource_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
            '''The tags to apply to the resource.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-tagspecification.html#cfn-ec2-capacityreservationfleet-tagspecification-tags
            '''
            result = self._values.get("tags")
            return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TagSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnCapacityReservationMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "availability_zone": "availabilityZone",
        "availability_zone_id": "availabilityZoneId",
        "ebs_optimized": "ebsOptimized",
        "end_date": "endDate",
        "end_date_type": "endDateType",
        "ephemeral_storage": "ephemeralStorage",
        "instance_count": "instanceCount",
        "instance_match_criteria": "instanceMatchCriteria",
        "instance_platform": "instancePlatform",
        "instance_type": "instanceType",
        "out_post_arn": "outPostArn",
        "placement_group_arn": "placementGroupArn",
        "tag_specifications": "tagSpecifications",
        "tenancy": "tenancy",
        "unused_reservation_billing_owner_id": "unusedReservationBillingOwnerId",
    },
)
class CfnCapacityReservationMixinProps:
    def __init__(
        self,
        *,
        availability_zone: typing.Optional[builtins.str] = None,
        availability_zone_id: typing.Optional[builtins.str] = None,
        ebs_optimized: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        end_date: typing.Optional[builtins.str] = None,
        end_date_type: typing.Optional[builtins.str] = None,
        ephemeral_storage: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        instance_count: typing.Optional[jsii.Number] = None,
        instance_match_criteria: typing.Optional[builtins.str] = None,
        instance_platform: typing.Optional[builtins.str] = None,
        instance_type: typing.Optional[builtins.str] = None,
        out_post_arn: typing.Optional[builtins.str] = None,
        placement_group_arn: typing.Optional[builtins.str] = None,
        tag_specifications: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnCapacityReservationPropsMixin.TagSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        tenancy: typing.Optional[builtins.str] = None,
        unused_reservation_billing_owner_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnCapacityReservationPropsMixin.

        :param availability_zone: The Availability Zone in which to create the Capacity Reservation.
        :param availability_zone_id: The ID of the Availability Zone in which the capacity is reserved.
        :param ebs_optimized: Indicates whether the Capacity Reservation supports EBS-optimized instances. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS- optimized instance.
        :param end_date: The date and time at which the Capacity Reservation expires. When a Capacity Reservation expires, the reserved capacity is released and you can no longer launch instances into it. The Capacity Reservation's state changes to ``expired`` when it reaches its end date and time. You must provide an ``EndDate`` value if ``EndDateType`` is ``limited`` . Omit ``EndDate`` if ``EndDateType`` is ``unlimited`` . If the ``EndDateType`` is ``limited`` , the Capacity Reservation is cancelled within an hour from the specified time. For example, if you specify 5/31/2019, 13:30:55, the Capacity Reservation is guaranteed to end between 13:30:55 and 14:30:55 on 5/31/2019. If you are requesting a future-dated Capacity Reservation, you can't specify an end date and time that is within the commitment duration.
        :param end_date_type: Indicates the way in which the Capacity Reservation ends. A Capacity Reservation can have one of the following end types: - ``unlimited`` - The Capacity Reservation remains active until you explicitly cancel it. Do not provide an ``EndDate`` if the ``EndDateType`` is ``unlimited`` . - ``limited`` - The Capacity Reservation expires automatically at a specified date and time. You must provide an ``EndDate`` value if the ``EndDateType`` value is ``limited`` .
        :param ephemeral_storage: *Deprecated.*.
        :param instance_count: The number of instances for which to reserve capacity. .. epigraph:: You can request future-dated Capacity Reservations for an instance count with a minimum of 32 vCPUs. For example, if you request a future-dated Capacity Reservation for ``m5.xlarge`` instances, you must request at least 8 instances ( *8 * m5.xlarge = 32 vCPUs* ). Valid range: 1 - 1000
        :param instance_match_criteria: Indicates the type of instance launches that the Capacity Reservation accepts. The options include:. - ``open`` - The Capacity Reservation automatically matches all instances that have matching attributes (instance type, platform, and Availability Zone). Instances that have matching attributes run in the Capacity Reservation automatically without specifying any additional parameters. - ``targeted`` - The Capacity Reservation only accepts instances that have matching attributes (instance type, platform, and Availability Zone), and explicitly target the Capacity Reservation. This ensures that only permitted instances can use the reserved capacity. .. epigraph:: If you are requesting a future-dated Capacity Reservation, you must specify ``targeted`` . Default: ``open``
        :param instance_platform: The type of operating system for which to reserve capacity.
        :param instance_type: The instance type for which to reserve capacity. .. epigraph:: You can request future-dated Capacity Reservations for instance types in the C, M, R, I, T, and G instance families only. For more information, see `Instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html>`_ in the *Amazon EC2 User Guide* .
        :param out_post_arn: .. epigraph:: Not supported for future-dated Capacity Reservations. The Amazon Resource Name (ARN) of the Outpost on which to create the Capacity Reservation.
        :param placement_group_arn: .. epigraph:: Not supported for future-dated Capacity Reservations. The Amazon Resource Name (ARN) of the cluster placement group in which to create the Capacity Reservation. For more information, see `Capacity Reservations for cluster placement groups <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/cr-cpg.html>`_ in the *Amazon EC2 User Guide* .
        :param tag_specifications: The tags to apply to the Capacity Reservation during launch.
        :param tenancy: Indicates the tenancy of the Capacity Reservation. A Capacity Reservation can have one of the following tenancy settings:. - ``default`` - The Capacity Reservation is created on hardware that is shared with other AWS accounts . - ``dedicated`` - The Capacity Reservation is created on single-tenant hardware that is dedicated to a single AWS account .
        :param unused_reservation_billing_owner_id: The ID of the AWS account to which to assign billing of the unused capacity of the Capacity Reservation. A request will be sent to the specified account. That account must accept the request for the billing to be assigned to their account. For more information, see `Billing assignment for shared Amazon EC2 Capacity Reservations <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/assign-billing.html>`_ . You can assign billing only for shared Capacity Reservations. To share a Capacity Reservation, you must add it to a resource share. For more information, see `AWS::RAM::ResourceShare <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ram-resourceshare.html>`_ .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_capacity_reservation_mixin_props = ec2_mixins.CfnCapacityReservationMixinProps(
                availability_zone="availabilityZone",
                availability_zone_id="availabilityZoneId",
                ebs_optimized=False,
                end_date="endDate",
                end_date_type="endDateType",
                ephemeral_storage=False,
                instance_count=123,
                instance_match_criteria="instanceMatchCriteria",
                instance_platform="instancePlatform",
                instance_type="instanceType",
                out_post_arn="outPostArn",
                placement_group_arn="placementGroupArn",
                tag_specifications=[ec2_mixins.CfnCapacityReservationPropsMixin.TagSpecificationProperty(
                    resource_type="resourceType",
                    tags=[CfnTag(
                        key="key",
                        value="value"
                    )]
                )],
                tenancy="tenancy",
                unused_reservation_billing_owner_id="unusedReservationBillingOwnerId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c14409d6f07ae8fd53e2088206631a7147684cffae15cd3c12f30e577a21a738)
            check_type(argname="argument availability_zone", value=availability_zone, expected_type=type_hints["availability_zone"])
            check_type(argname="argument availability_zone_id", value=availability_zone_id, expected_type=type_hints["availability_zone_id"])
            check_type(argname="argument ebs_optimized", value=ebs_optimized, expected_type=type_hints["ebs_optimized"])
            check_type(argname="argument end_date", value=end_date, expected_type=type_hints["end_date"])
            check_type(argname="argument end_date_type", value=end_date_type, expected_type=type_hints["end_date_type"])
            check_type(argname="argument ephemeral_storage", value=ephemeral_storage, expected_type=type_hints["ephemeral_storage"])
            check_type(argname="argument instance_count", value=instance_count, expected_type=type_hints["instance_count"])
            check_type(argname="argument instance_match_criteria", value=instance_match_criteria, expected_type=type_hints["instance_match_criteria"])
            check_type(argname="argument instance_platform", value=instance_platform, expected_type=type_hints["instance_platform"])
            check_type(argname="argument instance_type", value=instance_type, expected_type=type_hints["instance_type"])
            check_type(argname="argument out_post_arn", value=out_post_arn, expected_type=type_hints["out_post_arn"])
            check_type(argname="argument placement_group_arn", value=placement_group_arn, expected_type=type_hints["placement_group_arn"])
            check_type(argname="argument tag_specifications", value=tag_specifications, expected_type=type_hints["tag_specifications"])
            check_type(argname="argument tenancy", value=tenancy, expected_type=type_hints["tenancy"])
            check_type(argname="argument unused_reservation_billing_owner_id", value=unused_reservation_billing_owner_id, expected_type=type_hints["unused_reservation_billing_owner_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if availability_zone is not None:
            self._values["availability_zone"] = availability_zone
        if availability_zone_id is not None:
            self._values["availability_zone_id"] = availability_zone_id
        if ebs_optimized is not None:
            self._values["ebs_optimized"] = ebs_optimized
        if end_date is not None:
            self._values["end_date"] = end_date
        if end_date_type is not None:
            self._values["end_date_type"] = end_date_type
        if ephemeral_storage is not None:
            self._values["ephemeral_storage"] = ephemeral_storage
        if instance_count is not None:
            self._values["instance_count"] = instance_count
        if instance_match_criteria is not None:
            self._values["instance_match_criteria"] = instance_match_criteria
        if instance_platform is not None:
            self._values["instance_platform"] = instance_platform
        if instance_type is not None:
            self._values["instance_type"] = instance_type
        if out_post_arn is not None:
            self._values["out_post_arn"] = out_post_arn
        if placement_group_arn is not None:
            self._values["placement_group_arn"] = placement_group_arn
        if tag_specifications is not None:
            self._values["tag_specifications"] = tag_specifications
        if tenancy is not None:
            self._values["tenancy"] = tenancy
        if unused_reservation_billing_owner_id is not None:
            self._values["unused_reservation_billing_owner_id"] = unused_reservation_billing_owner_id

    @builtins.property
    def availability_zone(self) -> typing.Optional[builtins.str]:
        '''The Availability Zone in which to create the Capacity Reservation.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-availabilityzone
        '''
        result = self._values.get("availability_zone")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def availability_zone_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the Availability Zone in which the capacity is reserved.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-availabilityzoneid
        '''
        result = self._values.get("availability_zone_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ebs_optimized(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Indicates whether the Capacity Reservation supports EBS-optimized instances.

        This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS- optimized instance.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-ebsoptimized
        '''
        result = self._values.get("ebs_optimized")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def end_date(self) -> typing.Optional[builtins.str]:
        '''The date and time at which the Capacity Reservation expires.

        When a Capacity Reservation expires, the reserved capacity is released and you can no longer launch instances into it. The Capacity Reservation's state changes to ``expired`` when it reaches its end date and time.

        You must provide an ``EndDate`` value if ``EndDateType`` is ``limited`` . Omit ``EndDate`` if ``EndDateType`` is ``unlimited`` .

        If the ``EndDateType`` is ``limited`` , the Capacity Reservation is cancelled within an hour from the specified time. For example, if you specify 5/31/2019, 13:30:55, the Capacity Reservation is guaranteed to end between 13:30:55 and 14:30:55 on 5/31/2019.

        If you are requesting a future-dated Capacity Reservation, you can't specify an end date and time that is within the commitment duration.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-enddate
        '''
        result = self._values.get("end_date")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def end_date_type(self) -> typing.Optional[builtins.str]:
        '''Indicates the way in which the Capacity Reservation ends.

        A Capacity Reservation can have one of the following end types:

        - ``unlimited`` - The Capacity Reservation remains active until you explicitly cancel it. Do not provide an ``EndDate`` if the ``EndDateType`` is ``unlimited`` .
        - ``limited`` - The Capacity Reservation expires automatically at a specified date and time. You must provide an ``EndDate`` value if the ``EndDateType`` value is ``limited`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-enddatetype
        '''
        result = self._values.get("end_date_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ephemeral_storage(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''*Deprecated.*.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-ephemeralstorage
        '''
        result = self._values.get("ephemeral_storage")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def instance_count(self) -> typing.Optional[jsii.Number]:
        '''The number of instances for which to reserve capacity.

        .. epigraph::

           You can request future-dated Capacity Reservations for an instance count with a minimum of 32 vCPUs. For example, if you request a future-dated Capacity Reservation for ``m5.xlarge`` instances, you must request at least 8 instances ( *8 * m5.xlarge = 32 vCPUs* ).

        Valid range: 1 - 1000

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-instancecount
        '''
        result = self._values.get("instance_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def instance_match_criteria(self) -> typing.Optional[builtins.str]:
        '''Indicates the type of instance launches that the Capacity Reservation accepts. The options include:.

        - ``open`` - The Capacity Reservation automatically matches all instances that have matching attributes (instance type, platform, and Availability Zone). Instances that have matching attributes run in the Capacity Reservation automatically without specifying any additional parameters.
        - ``targeted`` - The Capacity Reservation only accepts instances that have matching attributes (instance type, platform, and Availability Zone), and explicitly target the Capacity Reservation. This ensures that only permitted instances can use the reserved capacity.

        .. epigraph::

           If you are requesting a future-dated Capacity Reservation, you must specify ``targeted`` .

        Default: ``open``

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-instancematchcriteria
        '''
        result = self._values.get("instance_match_criteria")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def instance_platform(self) -> typing.Optional[builtins.str]:
        '''The type of operating system for which to reserve capacity.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-instanceplatform
        '''
        result = self._values.get("instance_platform")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def instance_type(self) -> typing.Optional[builtins.str]:
        '''The instance type for which to reserve capacity.

        .. epigraph::

           You can request future-dated Capacity Reservations for instance types in the C, M, R, I, T, and G instance families only.

        For more information, see `Instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html>`_ in the *Amazon EC2 User Guide* .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-instancetype
        '''
        result = self._values.get("instance_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def out_post_arn(self) -> typing.Optional[builtins.str]:
        '''.. epigraph::

   Not supported for future-dated Capacity Reservations.

        The Amazon Resource Name (ARN) of the Outpost on which to create the Capacity Reservation.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-outpostarn
        '''
        result = self._values.get("out_post_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def placement_group_arn(self) -> typing.Optional[builtins.str]:
        '''.. epigraph::

   Not supported for future-dated Capacity Reservations.

        The Amazon Resource Name (ARN) of the cluster placement group in which to create the Capacity Reservation. For more information, see `Capacity Reservations for cluster placement groups <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/cr-cpg.html>`_ in the *Amazon EC2 User Guide* .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-placementgrouparn
        '''
        result = self._values.get("placement_group_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tag_specifications(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnCapacityReservationPropsMixin.TagSpecificationProperty"]]]]:
        '''The tags to apply to the Capacity Reservation during launch.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-tagspecifications
        '''
        result = self._values.get("tag_specifications")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnCapacityReservationPropsMixin.TagSpecificationProperty"]]]], result)

    @builtins.property
    def tenancy(self) -> typing.Optional[builtins.str]:
        '''Indicates the tenancy of the Capacity Reservation. A Capacity Reservation can have one of the following tenancy settings:.

        - ``default`` - The Capacity Reservation is created on hardware that is shared with other AWS accounts .
        - ``dedicated`` - The Capacity Reservation is created on single-tenant hardware that is dedicated to a single AWS account .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-tenancy
        '''
        result = self._values.get("tenancy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def unused_reservation_billing_owner_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the AWS account to which to assign billing of the unused capacity of the Capacity Reservation.

        A request will be sent to the specified account. That account must accept the request for the billing to be assigned to their account. For more information, see `Billing assignment for shared Amazon EC2 Capacity Reservations <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/assign-billing.html>`_ .

        You can assign billing only for shared Capacity Reservations. To share a Capacity Reservation, you must add it to a resource share. For more information, see `AWS::RAM::ResourceShare <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ram-resourceshare.html>`_ .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-unusedreservationbillingownerid
        '''
        result = self._values.get("unused_reservation_billing_owner_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnCapacityReservationMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnCapacityReservationPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnCapacityReservationPropsMixin",
):
    '''Creates a new Capacity Reservation with the specified attributes.

    For more information, see `Capacity Reservations <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-capacity-reservations.html>`_ in the *Amazon EC2 User Guide* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html
    :cloudformationResource: AWS::EC2::CapacityReservation
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_capacity_reservation_props_mixin = ec2_mixins.CfnCapacityReservationPropsMixin(ec2_mixins.CfnCapacityReservationMixinProps(
            availability_zone="availabilityZone",
            availability_zone_id="availabilityZoneId",
            ebs_optimized=False,
            end_date="endDate",
            end_date_type="endDateType",
            ephemeral_storage=False,
            instance_count=123,
            instance_match_criteria="instanceMatchCriteria",
            instance_platform="instancePlatform",
            instance_type="instanceType",
            out_post_arn="outPostArn",
            placement_group_arn="placementGroupArn",
            tag_specifications=[ec2_mixins.CfnCapacityReservationPropsMixin.TagSpecificationProperty(
                resource_type="resourceType",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )],
            tenancy="tenancy",
            unused_reservation_billing_owner_id="unusedReservationBillingOwnerId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnCapacityReservationMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::CapacityReservation``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__12085d72c1c23e0db75116f97d1bb46f9cb70b3a042db7587345cfe66eed5596)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__92005209ebc2470e8042c90da0e83b59acce46a5716df008c0202583720869de)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1fe0dc6876ca4af33b52097b63b29606611daf58358b74f2c82268a18811409b)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnCapacityReservationMixinProps":
        return typing.cast("CfnCapacityReservationMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnCapacityReservationPropsMixin.CapacityAllocationProperty",
        jsii_struct_bases=[],
        name_mapping={"allocation_type": "allocationType", "count": "count"},
    )
    class CapacityAllocationProperty:
        def __init__(
            self,
            *,
            allocation_type: typing.Optional[builtins.str] = None,
            count: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Information about instance capacity usage for a Capacity Reservation.

            :param allocation_type: The usage type. ``used`` indicates that the instance capacity is in use by instances that are running in the Capacity Reservation.
            :param count: The amount of instance capacity associated with the usage. For example a value of ``4`` indicates that instance capacity for 4 instances is currently in use.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservation-capacityallocation.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                capacity_allocation_property = ec2_mixins.CfnCapacityReservationPropsMixin.CapacityAllocationProperty(
                    allocation_type="allocationType",
                    count=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__99ffa74931853cb6aa8ba127c435f44a3bdc7ee0fb48a6f9d0688b4c6156b123)
                check_type(argname="argument allocation_type", value=allocation_type, expected_type=type_hints["allocation_type"])
                check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if allocation_type is not None:
                self._values["allocation_type"] = allocation_type
            if count is not None:
                self._values["count"] = count

        @builtins.property
        def allocation_type(self) -> typing.Optional[builtins.str]:
            '''The usage type.

            ``used`` indicates that the instance capacity is in use by instances that are running in the Capacity Reservation.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservation-capacityallocation.html#cfn-ec2-capacityreservation-capacityallocation-allocationtype
            '''
            result = self._values.get("allocation_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def count(self) -> typing.Optional[jsii.Number]:
            '''The amount of instance capacity associated with the usage.

            For example a value of ``4`` indicates that instance capacity for 4 instances is currently in use.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservation-capacityallocation.html#cfn-ec2-capacityreservation-capacityallocation-count
            '''
            result = self._values.get("count")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "CapacityAllocationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnCapacityReservationPropsMixin.CommitmentInfoProperty",
        jsii_struct_bases=[],
        name_mapping={
            "commitment_end_date": "commitmentEndDate",
            "committed_instance_count": "committedInstanceCount",
        },
    )
    class CommitmentInfoProperty:
        def __init__(
            self,
            *,
            commitment_end_date: typing.Optional[builtins.str] = None,
            committed_instance_count: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Information about your commitment for a future-dated Capacity Reservation.

            :param commitment_end_date: The date and time at which the commitment duration expires, in the ISO8601 format in the UTC time zone ( ``YYYY-MM-DDThh:mm:ss.sssZ`` ). You can't decrease the instance count or cancel the Capacity Reservation before this date and time.
            :param committed_instance_count: The instance capacity that you committed to when you requested the future-dated Capacity Reservation.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservation-commitmentinfo.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                commitment_info_property = ec2_mixins.CfnCapacityReservationPropsMixin.CommitmentInfoProperty(
                    commitment_end_date="commitmentEndDate",
                    committed_instance_count=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__ffcdb15aefbc9de358a5ed691aea25b91d21a45704532e04dd7d028886f644a1)
                check_type(argname="argument commitment_end_date", value=commitment_end_date, expected_type=type_hints["commitment_end_date"])
                check_type(argname="argument committed_instance_count", value=committed_instance_count, expected_type=type_hints["committed_instance_count"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if commitment_end_date is not None:
                self._values["commitment_end_date"] = commitment_end_date
            if committed_instance_count is not None:
                self._values["committed_instance_count"] = committed_instance_count

        @builtins.property
        def commitment_end_date(self) -> typing.Optional[builtins.str]:
            '''The date and time at which the commitment duration expires, in the ISO8601 format in the UTC time zone ( ``YYYY-MM-DDThh:mm:ss.sssZ`` ). You can't decrease the instance count or cancel the Capacity Reservation before this date and time.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservation-commitmentinfo.html#cfn-ec2-capacityreservation-commitmentinfo-commitmentenddate
            '''
            result = self._values.get("commitment_end_date")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def committed_instance_count(self) -> typing.Optional[jsii.Number]:
            '''The instance capacity that you committed to when you requested the future-dated Capacity Reservation.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservation-commitmentinfo.html#cfn-ec2-capacityreservation-commitmentinfo-committedinstancecount
            '''
            result = self._values.get("committed_instance_count")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "CommitmentInfoProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnCapacityReservationPropsMixin.TagSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={"resource_type": "resourceType", "tags": "tags"},
    )
    class TagSpecificationProperty:
        def __init__(
            self,
            *,
            resource_type: typing.Optional[builtins.str] = None,
            tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''An array of key-value pairs to apply to this resource.

            For more information, see `Tag <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html>`_ .

            :param resource_type: The type of resource to tag. Specify ``capacity-reservation`` .
            :param tags: The tags to apply to the resource.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservation-tagspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                from aws_cdk import CfnTag
                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                tag_specification_property = ec2_mixins.CfnCapacityReservationPropsMixin.TagSpecificationProperty(
                    resource_type="resourceType",
                    tags=[CfnTag(
                        key="key",
                        value="value"
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__68615a49147a5f741deef9593164692843e2831fad36f56e4b91ccc872d2dd26)
                check_type(argname="argument resource_type", value=resource_type, expected_type=type_hints["resource_type"])
                check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if resource_type is not None:
                self._values["resource_type"] = resource_type
            if tags is not None:
                self._values["tags"] = tags

        @builtins.property
        def resource_type(self) -> typing.Optional[builtins.str]:
            '''The type of resource to tag.

            Specify ``capacity-reservation`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservation-tagspecification.html#cfn-ec2-capacityreservation-tagspecification-resourcetype
            '''
            result = self._values.get("resource_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
            '''The tags to apply to the resource.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservation-tagspecification.html#cfn-ec2-capacityreservation-tagspecification-tags
            '''
            result = self._values.get("tags")
            return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TagSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnCarrierGatewayMixinProps",
    jsii_struct_bases=[],
    name_mapping={"tags": "tags", "vpc_id": "vpcId"},
)
class CfnCarrierGatewayMixinProps:
    def __init__(
        self,
        *,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        vpc_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnCarrierGatewayPropsMixin.

        :param tags: The tags assigned to the carrier gateway.
        :param vpc_id: The ID of the VPC associated with the carrier gateway.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-carriergateway.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_carrier_gateway_mixin_props = ec2_mixins.CfnCarrierGatewayMixinProps(
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                vpc_id="vpcId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b75d8d831b2a1bafe4ce5a6792759efb0c8c9b002526f5c20dbc1b5d70ceb083)
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument vpc_id", value=vpc_id, expected_type=type_hints["vpc_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if tags is not None:
            self._values["tags"] = tags
        if vpc_id is not None:
            self._values["vpc_id"] = vpc_id

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags assigned to the carrier gateway.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-carriergateway.html#cfn-ec2-carriergateway-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def vpc_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the VPC associated with the carrier gateway.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-carriergateway.html#cfn-ec2-carriergateway-vpcid
        '''
        result = self._values.get("vpc_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnCarrierGatewayMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnCarrierGatewayPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnCarrierGatewayPropsMixin",
):
    '''Creates a carrier gateway.

    For more information about carrier gateways, see `Carrier gateways <https://docs.aws.amazon.com/wavelength/latest/developerguide/how-wavelengths-work.html#wavelength-carrier-gateway>`_ in the *AWS Wavelength Developer Guide* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-carriergateway.html
    :cloudformationResource: AWS::EC2::CarrierGateway
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_carrier_gateway_props_mixin = ec2_mixins.CfnCarrierGatewayPropsMixin(ec2_mixins.CfnCarrierGatewayMixinProps(
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            vpc_id="vpcId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnCarrierGatewayMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::CarrierGateway``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b4db07a5e08b8fd1e21101be5f20d49b5614cc938ce1e2507e569b678c72fdde)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d001f36d0cefe6a908568eb819ef0ba06db68582ea879d541c7fb0c0aecc38cb)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cea6fffe5117f573c19cefacc7bbcda644d377cf49d4a363b869241501cea45f)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnCarrierGatewayMixinProps":
        return typing.cast("CfnCarrierGatewayMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnClientVpnAuthorizationRuleMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "access_group_id": "accessGroupId",
        "authorize_all_groups": "authorizeAllGroups",
        "client_vpn_endpoint_id": "clientVpnEndpointId",
        "description": "description",
        "target_network_cidr": "targetNetworkCidr",
    },
)
class CfnClientVpnAuthorizationRuleMixinProps:
    def __init__(
        self,
        *,
        access_group_id: typing.Optional[builtins.str] = None,
        authorize_all_groups: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        client_vpn_endpoint_id: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        target_network_cidr: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnClientVpnAuthorizationRulePropsMixin.

        :param access_group_id: The ID of the group to grant access to, for example, the Active Directory group or identity provider (IdP) group. Required if ``AuthorizeAllGroups`` is ``false`` or not specified.
        :param authorize_all_groups: Indicates whether to grant access to all clients. Specify ``true`` to grant all clients who successfully establish a VPN connection access to the network. Must be set to ``true`` if ``AccessGroupId`` is not specified.
        :param client_vpn_endpoint_id: The ID of the Client VPN endpoint.
        :param description: A brief description of the authorization rule.
        :param target_network_cidr: The IPv4 address range, in CIDR notation, of the network for which access is being authorized.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_client_vpn_authorization_rule_mixin_props = ec2_mixins.CfnClientVpnAuthorizationRuleMixinProps(
                access_group_id="accessGroupId",
                authorize_all_groups=False,
                client_vpn_endpoint_id="clientVpnEndpointId",
                description="description",
                target_network_cidr="targetNetworkCidr"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3ec649f17e001bab7d0bb3610c3849f7811459d1e3e6ac476c3460724de2bd6f)
            check_type(argname="argument access_group_id", value=access_group_id, expected_type=type_hints["access_group_id"])
            check_type(argname="argument authorize_all_groups", value=authorize_all_groups, expected_type=type_hints["authorize_all_groups"])
            check_type(argname="argument client_vpn_endpoint_id", value=client_vpn_endpoint_id, expected_type=type_hints["client_vpn_endpoint_id"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument target_network_cidr", value=target_network_cidr, expected_type=type_hints["target_network_cidr"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if access_group_id is not None:
            self._values["access_group_id"] = access_group_id
        if authorize_all_groups is not None:
            self._values["authorize_all_groups"] = authorize_all_groups
        if client_vpn_endpoint_id is not None:
            self._values["client_vpn_endpoint_id"] = client_vpn_endpoint_id
        if description is not None:
            self._values["description"] = description
        if target_network_cidr is not None:
            self._values["target_network_cidr"] = target_network_cidr

    @builtins.property
    def access_group_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the group to grant access to, for example, the Active Directory group or identity provider (IdP) group.

        Required if ``AuthorizeAllGroups`` is ``false`` or not specified.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html#cfn-ec2-clientvpnauthorizationrule-accessgroupid
        '''
        result = self._values.get("access_group_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def authorize_all_groups(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Indicates whether to grant access to all clients.

        Specify ``true`` to grant all clients who successfully establish a VPN connection access to the network. Must be set to ``true`` if ``AccessGroupId`` is not specified.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html#cfn-ec2-clientvpnauthorizationrule-authorizeallgroups
        '''
        result = self._values.get("authorize_all_groups")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def client_vpn_endpoint_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the Client VPN endpoint.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html#cfn-ec2-clientvpnauthorizationrule-clientvpnendpointid
        '''
        result = self._values.get("client_vpn_endpoint_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''A brief description of the authorization rule.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html#cfn-ec2-clientvpnauthorizationrule-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def target_network_cidr(self) -> typing.Optional[builtins.str]:
        '''The IPv4 address range, in CIDR notation, of the network for which access is being authorized.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html#cfn-ec2-clientvpnauthorizationrule-targetnetworkcidr
        '''
        result = self._values.get("target_network_cidr")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnClientVpnAuthorizationRuleMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnClientVpnAuthorizationRulePropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnClientVpnAuthorizationRulePropsMixin",
):
    '''Specifies an ingress authorization rule to add to a Client VPN endpoint.

    Ingress authorization rules act as firewall rules that grant access to networks. You must configure ingress authorization rules to enable clients to access resources in AWS or on-premises networks.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html
    :cloudformationResource: AWS::EC2::ClientVpnAuthorizationRule
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_client_vpn_authorization_rule_props_mixin = ec2_mixins.CfnClientVpnAuthorizationRulePropsMixin(ec2_mixins.CfnClientVpnAuthorizationRuleMixinProps(
            access_group_id="accessGroupId",
            authorize_all_groups=False,
            client_vpn_endpoint_id="clientVpnEndpointId",
            description="description",
            target_network_cidr="targetNetworkCidr"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnClientVpnAuthorizationRuleMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::ClientVpnAuthorizationRule``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__27a5846cfcacaa5f7648545f5b88c5bef186ca01edacdee14bae10ab5674322c)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f93bb1d1dcc37260a4ce8fcdadeafeaf83750714799ed6f08534cf0358a6be6e)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__edb0eb5db04efe81c1838e21bccee2734766b6930aaefed2188d4981116abf62)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnClientVpnAuthorizationRuleMixinProps":
        return typing.cast("CfnClientVpnAuthorizationRuleMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnClientVpnEndpointMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "authentication_options": "authenticationOptions",
        "client_cidr_block": "clientCidrBlock",
        "client_connect_options": "clientConnectOptions",
        "client_login_banner_options": "clientLoginBannerOptions",
        "client_route_enforcement_options": "clientRouteEnforcementOptions",
        "connection_log_options": "connectionLogOptions",
        "description": "description",
        "disconnect_on_session_timeout": "disconnectOnSessionTimeout",
        "dns_servers": "dnsServers",
        "endpoint_ip_address_type": "endpointIpAddressType",
        "security_group_ids": "securityGroupIds",
        "self_service_portal": "selfServicePortal",
        "server_certificate_arn": "serverCertificateArn",
        "session_timeout_hours": "sessionTimeoutHours",
        "split_tunnel": "splitTunnel",
        "tag_specifications": "tagSpecifications",
        "traffic_ip_address_type": "trafficIpAddressType",
        "transport_protocol": "transportProtocol",
        "vpc_id": "vpcId",
        "vpn_port": "vpnPort",
    },
)
class CfnClientVpnEndpointMixinProps:
    def __init__(
        self,
        *,
        authentication_options: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnClientVpnEndpointPropsMixin.ClientAuthenticationRequestProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        client_cidr_block: typing.Optional[builtins.str] = None,
        client_connect_options: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnClientVpnEndpointPropsMixin.ClientConnectOptionsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        client_login_banner_options: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnClientVpnEndpointPropsMixin.ClientLoginBannerOptionsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        client_route_enforcement_options: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnClientVpnEndpointPropsMixin.ClientRouteEnforcementOptionsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        connection_log_options: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnClientVpnEndpointPropsMixin.ConnectionLogOptionsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        description: typing.Optional[builtins.str] = None,
        disconnect_on_session_timeout: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        dns_servers: typing.Optional[typing.Sequence[builtins.str]] = None,
        endpoint_ip_address_type: typing.Optional[builtins.str] = None,
        security_group_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        self_service_portal: typing.Optional[builtins.str] = None,
        server_certificate_arn: typing.Optional[builtins.str] = None,
        session_timeout_hours: typing.Optional[jsii.Number] = None,
        split_tunnel: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        tag_specifications: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnClientVpnEndpointPropsMixin.TagSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        traffic_ip_address_type: typing.Optional[builtins.str] = None,
        transport_protocol: typing.Optional[builtins.str] = None,
        vpc_id: typing.Optional[builtins.str] = None,
        vpn_port: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Properties for CfnClientVpnEndpointPropsMixin.

        :param authentication_options: Information about the authentication method to be used to authenticate clients.
        :param client_cidr_block: The IPv4 address range, in CIDR notation, from which to assign client IP addresses. The address range cannot overlap with the local CIDR of the VPC in which the associated subnet is located, or the routes that you add manually. The address range cannot be changed after the Client VPN endpoint has been created. Client CIDR range must have a size of at least /22 and must not be greater than /12.
        :param client_connect_options: The options for managing connection authorization for new client connections.
        :param client_login_banner_options: Options for enabling a customizable text banner that will be displayed on AWS provided clients when a VPN session is established.
        :param client_route_enforcement_options: Client route enforcement is a feature of the Client VPN service that helps enforce administrator defined routes on devices connected through the VPN. T his feature helps improve your security posture by ensuring that network traffic originating from a connected client is not inadvertently sent outside the VPN tunnel. Client route enforcement works by monitoring the route table of a connected device for routing policy changes to the VPN connection. If the feature detects any VPN routing policy modifications, it will automatically force an update to the route table, reverting it back to the expected route configurations.
        :param connection_log_options: Information about the client connection logging options. If you enable client connection logging, data about client connections is sent to a Cloudwatch Logs log stream. The following information is logged: - Client connection requests - Client connection results (successful and unsuccessful) - Reasons for unsuccessful client connection requests - Client connection termination time
        :param description: A brief description of the Client VPN endpoint.
        :param disconnect_on_session_timeout: Indicates whether the client VPN session is disconnected after the maximum ``sessionTimeoutHours`` is reached. If ``true`` , users are prompted to reconnect client VPN. If ``false`` , client VPN attempts to reconnect automatically. The default value is ``true`` .
        :param dns_servers: Information about the DNS servers to be used for DNS resolution. A Client VPN endpoint can have up to two DNS servers. If no DNS server is specified, the DNS address configured on the device is used for the DNS server.
        :param endpoint_ip_address_type: The IP address type of the Client VPN endpoint. Possible values are ``ipv4`` for IPv4 addressing only, ``ipv6`` for IPv6 addressing only, or ``dual-stack`` for both IPv4 and IPv6 addressing.
        :param security_group_ids: The IDs of one or more security groups to apply to the target network. You must also specify the ID of the VPC that contains the security groups.
        :param self_service_portal: Specify whether to enable the self-service portal for the Client VPN endpoint. Default Value: ``enabled``
        :param server_certificate_arn: The ARN of the server certificate. For more information, see the `Certificate Manager User Guide <https://docs.aws.amazon.com/acm/latest/userguide/>`_ .
        :param session_timeout_hours: The maximum VPN session duration time in hours. Valid values: ``8 | 10 | 12 | 24`` Default value: ``24``
        :param split_tunnel: Indicates whether split-tunnel is enabled on the AWS Client VPN endpoint. By default, split-tunnel on a VPN endpoint is disabled. For information about split-tunnel VPN endpoints, see `Split-tunnel AWS Client VPN endpoint <https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/split-tunnel-vpn.html>`_ in the *AWS Client VPN Administrator Guide* .
        :param tag_specifications: The tags to apply to the Client VPN endpoint during creation.
        :param traffic_ip_address_type: The IP address type of the Client VPN endpoint. Possible values are either ``ipv4`` for IPv4 addressing only, ``ipv6`` for IPv6 addressing only, or ``dual-stack`` for both IPv4 and IPv6 addressing.
        :param transport_protocol: The transport protocol to be used by the VPN session. Default value: ``udp``
        :param vpc_id: The ID of the VPC to associate with the Client VPN endpoint. If no security group IDs are specified in the request, the default security group for the VPC is applied.
        :param vpn_port: The port number to assign to the Client VPN endpoint for TCP and UDP traffic. Valid Values: ``443`` | ``1194`` Default Value: ``443``

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_client_vpn_endpoint_mixin_props = ec2_mixins.CfnClientVpnEndpointMixinProps(
                authentication_options=[ec2_mixins.CfnClientVpnEndpointPropsMixin.ClientAuthenticationRequestProperty(
                    active_directory=ec2_mixins.CfnClientVpnEndpointPropsMixin.DirectoryServiceAuthenticationRequestProperty(
                        directory_id="directoryId"
                    ),
                    federated_authentication=ec2_mixins.CfnClientVpnEndpointPropsMixin.FederatedAuthenticationRequestProperty(
                        saml_provider_arn="samlProviderArn",
                        self_service_saml_provider_arn="selfServiceSamlProviderArn"
                    ),
                    mutual_authentication=ec2_mixins.CfnClientVpnEndpointPropsMixin.CertificateAuthenticationRequestProperty(
                        client_root_certificate_chain_arn="clientRootCertificateChainArn"
                    ),
                    type="type"
                )],
                client_cidr_block="clientCidrBlock",
                client_connect_options=ec2_mixins.CfnClientVpnEndpointPropsMixin.ClientConnectOptionsProperty(
                    enabled=False,
                    lambda_function_arn="lambdaFunctionArn"
                ),
                client_login_banner_options=ec2_mixins.CfnClientVpnEndpointPropsMixin.ClientLoginBannerOptionsProperty(
                    banner_text="bannerText",
                    enabled=False
                ),
                client_route_enforcement_options=ec2_mixins.CfnClientVpnEndpointPropsMixin.ClientRouteEnforcementOptionsProperty(
                    enforced=False
                ),
                connection_log_options=ec2_mixins.CfnClientVpnEndpointPropsMixin.ConnectionLogOptionsProperty(
                    cloudwatch_log_group="cloudwatchLogGroup",
                    cloudwatch_log_stream="cloudwatchLogStream",
                    enabled=False
                ),
                description="description",
                disconnect_on_session_timeout=False,
                dns_servers=["dnsServers"],
                endpoint_ip_address_type="endpointIpAddressType",
                security_group_ids=["securityGroupIds"],
                self_service_portal="selfServicePortal",
                server_certificate_arn="serverCertificateArn",
                session_timeout_hours=123,
                split_tunnel=False,
                tag_specifications=[ec2_mixins.CfnClientVpnEndpointPropsMixin.TagSpecificationProperty(
                    resource_type="resourceType",
                    tags=[CfnTag(
                        key="key",
                        value="value"
                    )]
                )],
                traffic_ip_address_type="trafficIpAddressType",
                transport_protocol="transportProtocol",
                vpc_id="vpcId",
                vpn_port=123
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ca3d88a9a0a35db755b106702b6a5fdad6d638967bac5e9dbfdaf1def3b1959c)
            check_type(argname="argument authentication_options", value=authentication_options, expected_type=type_hints["authentication_options"])
            check_type(argname="argument client_cidr_block", value=client_cidr_block, expected_type=type_hints["client_cidr_block"])
            check_type(argname="argument client_connect_options", value=client_connect_options, expected_type=type_hints["client_connect_options"])
            check_type(argname="argument client_login_banner_options", value=client_login_banner_options, expected_type=type_hints["client_login_banner_options"])
            check_type(argname="argument client_route_enforcement_options", value=client_route_enforcement_options, expected_type=type_hints["client_route_enforcement_options"])
            check_type(argname="argument connection_log_options", value=connection_log_options, expected_type=type_hints["connection_log_options"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument disconnect_on_session_timeout", value=disconnect_on_session_timeout, expected_type=type_hints["disconnect_on_session_timeout"])
            check_type(argname="argument dns_servers", value=dns_servers, expected_type=type_hints["dns_servers"])
            check_type(argname="argument endpoint_ip_address_type", value=endpoint_ip_address_type, expected_type=type_hints["endpoint_ip_address_type"])
            check_type(argname="argument security_group_ids", value=security_group_ids, expected_type=type_hints["security_group_ids"])
            check_type(argname="argument self_service_portal", value=self_service_portal, expected_type=type_hints["self_service_portal"])
            check_type(argname="argument server_certificate_arn", value=server_certificate_arn, expected_type=type_hints["server_certificate_arn"])
            check_type(argname="argument session_timeout_hours", value=session_timeout_hours, expected_type=type_hints["session_timeout_hours"])
            check_type(argname="argument split_tunnel", value=split_tunnel, expected_type=type_hints["split_tunnel"])
            check_type(argname="argument tag_specifications", value=tag_specifications, expected_type=type_hints["tag_specifications"])
            check_type(argname="argument traffic_ip_address_type", value=traffic_ip_address_type, expected_type=type_hints["traffic_ip_address_type"])
            check_type(argname="argument transport_protocol", value=transport_protocol, expected_type=type_hints["transport_protocol"])
            check_type(argname="argument vpc_id", value=vpc_id, expected_type=type_hints["vpc_id"])
            check_type(argname="argument vpn_port", value=vpn_port, expected_type=type_hints["vpn_port"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if authentication_options is not None:
            self._values["authentication_options"] = authentication_options
        if client_cidr_block is not None:
            self._values["client_cidr_block"] = client_cidr_block
        if client_connect_options is not None:
            self._values["client_connect_options"] = client_connect_options
        if client_login_banner_options is not None:
            self._values["client_login_banner_options"] = client_login_banner_options
        if client_route_enforcement_options is not None:
            self._values["client_route_enforcement_options"] = client_route_enforcement_options
        if connection_log_options is not None:
            self._values["connection_log_options"] = connection_log_options
        if description is not None:
            self._values["description"] = description
        if disconnect_on_session_timeout is not None:
            self._values["disconnect_on_session_timeout"] = disconnect_on_session_timeout
        if dns_servers is not None:
            self._values["dns_servers"] = dns_servers
        if endpoint_ip_address_type is not None:
            self._values["endpoint_ip_address_type"] = endpoint_ip_address_type
        if security_group_ids is not None:
            self._values["security_group_ids"] = security_group_ids
        if self_service_portal is not None:
            self._values["self_service_portal"] = self_service_portal
        if server_certificate_arn is not None:
            self._values["server_certificate_arn"] = server_certificate_arn
        if session_timeout_hours is not None:
            self._values["session_timeout_hours"] = session_timeout_hours
        if split_tunnel is not None:
            self._values["split_tunnel"] = split_tunnel
        if tag_specifications is not None:
            self._values["tag_specifications"] = tag_specifications
        if traffic_ip_address_type is not None:
            self._values["traffic_ip_address_type"] = traffic_ip_address_type
        if transport_protocol is not None:
            self._values["transport_protocol"] = transport_protocol
        if vpc_id is not None:
            self._values["vpc_id"] = vpc_id
        if vpn_port is not None:
            self._values["vpn_port"] = vpn_port

    @builtins.property
    def authentication_options(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnClientVpnEndpointPropsMixin.ClientAuthenticationRequestProperty"]]]]:
        '''Information about the authentication method to be used to authenticate clients.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-authenticationoptions
        '''
        result = self._values.get("authentication_options")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnClientVpnEndpointPropsMixin.ClientAuthenticationRequestProperty"]]]], result)

    @builtins.property
    def client_cidr_block(self) -> typing.Optional[builtins.str]:
        '''The IPv4 address range, in CIDR notation, from which to assign client IP addresses.

        The address range cannot overlap with the local CIDR of the VPC in which the associated subnet is located, or the routes that you add manually. The address range cannot be changed after the Client VPN endpoint has been created. Client CIDR range must have a size of at least /22 and must not be greater than /12.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-clientcidrblock
        '''
        result = self._values.get("client_cidr_block")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def client_connect_options(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnClientVpnEndpointPropsMixin.ClientConnectOptionsProperty"]]:
        '''The options for managing connection authorization for new client connections.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-clientconnectoptions
        '''
        result = self._values.get("client_connect_options")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnClientVpnEndpointPropsMixin.ClientConnectOptionsProperty"]], result)

    @builtins.property
    def client_login_banner_options(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnClientVpnEndpointPropsMixin.ClientLoginBannerOptionsProperty"]]:
        '''Options for enabling a customizable text banner that will be displayed on AWS provided clients when a VPN session is established.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-clientloginbanneroptions
        '''
        result = self._values.get("client_login_banner_options")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnClientVpnEndpointPropsMixin.ClientLoginBannerOptionsProperty"]], result)

    @builtins.property
    def client_route_enforcement_options(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnClientVpnEndpointPropsMixin.ClientRouteEnforcementOptionsProperty"]]:
        '''Client route enforcement is a feature of the Client VPN service that helps enforce administrator defined routes on devices connected through the VPN.

        T his feature helps improve your security posture by ensuring that network traffic originating from a connected client is not inadvertently sent outside the VPN tunnel.

        Client route enforcement works by monitoring the route table of a connected device for routing policy changes to the VPN connection. If the feature detects any VPN routing policy modifications, it will automatically force an update to the route table, reverting it back to the expected route configurations.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-clientrouteenforcementoptions
        '''
        result = self._values.get("client_route_enforcement_options")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnClientVpnEndpointPropsMixin.ClientRouteEnforcementOptionsProperty"]], result)

    @builtins.property
    def connection_log_options(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnClientVpnEndpointPropsMixin.ConnectionLogOptionsProperty"]]:
        '''Information about the client connection logging options.

        If you enable client connection logging, data about client connections is sent to a Cloudwatch Logs log stream. The following information is logged:

        - Client connection requests
        - Client connection results (successful and unsuccessful)
        - Reasons for unsuccessful client connection requests
        - Client connection termination time

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-connectionlogoptions
        '''
        result = self._values.get("connection_log_options")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnClientVpnEndpointPropsMixin.ConnectionLogOptionsProperty"]], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''A brief description of the Client VPN endpoint.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def disconnect_on_session_timeout(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Indicates whether the client VPN session is disconnected after the maximum ``sessionTimeoutHours`` is reached.

        If ``true`` , users are prompted to reconnect client VPN. If ``false`` , client VPN attempts to reconnect automatically. The default value is ``true`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-disconnectonsessiontimeout
        '''
        result = self._values.get("disconnect_on_session_timeout")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def dns_servers(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Information about the DNS servers to be used for DNS resolution.

        A Client VPN endpoint can have up to two DNS servers. If no DNS server is specified, the DNS address configured on the device is used for the DNS server.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-dnsservers
        '''
        result = self._values.get("dns_servers")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def endpoint_ip_address_type(self) -> typing.Optional[builtins.str]:
        '''The IP address type of the Client VPN endpoint.

        Possible values are ``ipv4`` for IPv4 addressing only, ``ipv6`` for IPv6 addressing only, or ``dual-stack`` for both IPv4 and IPv6 addressing.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-endpointipaddresstype
        '''
        result = self._values.get("endpoint_ip_address_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def security_group_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The IDs of one or more security groups to apply to the target network.

        You must also specify the ID of the VPC that contains the security groups.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-securitygroupids
        '''
        result = self._values.get("security_group_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def self_service_portal(self) -> typing.Optional[builtins.str]:
        '''Specify whether to enable the self-service portal for the Client VPN endpoint.

        Default Value: ``enabled``

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-selfserviceportal
        '''
        result = self._values.get("self_service_portal")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def server_certificate_arn(self) -> typing.Optional[builtins.str]:
        '''The ARN of the server certificate.

        For more information, see the `Certificate Manager User Guide <https://docs.aws.amazon.com/acm/latest/userguide/>`_ .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-servercertificatearn
        '''
        result = self._values.get("server_certificate_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def session_timeout_hours(self) -> typing.Optional[jsii.Number]:
        '''The maximum VPN session duration time in hours.

        Valid values: ``8 | 10 | 12 | 24``

        Default value: ``24``

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-sessiontimeouthours
        '''
        result = self._values.get("session_timeout_hours")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def split_tunnel(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Indicates whether split-tunnel is enabled on the AWS Client VPN endpoint.

        By default, split-tunnel on a VPN endpoint is disabled.

        For information about split-tunnel VPN endpoints, see `Split-tunnel AWS Client VPN endpoint <https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/split-tunnel-vpn.html>`_ in the *AWS Client VPN Administrator Guide* .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-splittunnel
        '''
        result = self._values.get("split_tunnel")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def tag_specifications(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnClientVpnEndpointPropsMixin.TagSpecificationProperty"]]]]:
        '''The tags to apply to the Client VPN endpoint during creation.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-tagspecifications
        '''
        result = self._values.get("tag_specifications")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnClientVpnEndpointPropsMixin.TagSpecificationProperty"]]]], result)

    @builtins.property
    def traffic_ip_address_type(self) -> typing.Optional[builtins.str]:
        '''The IP address type of the Client VPN endpoint.

        Possible values are either ``ipv4`` for IPv4 addressing only, ``ipv6`` for IPv6 addressing only, or ``dual-stack`` for both IPv4 and IPv6 addressing.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-trafficipaddresstype
        '''
        result = self._values.get("traffic_ip_address_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def transport_protocol(self) -> typing.Optional[builtins.str]:
        '''The transport protocol to be used by the VPN session.

        Default value: ``udp``

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-transportprotocol
        '''
        result = self._values.get("transport_protocol")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpc_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the VPC to associate with the Client VPN endpoint.

        If no security group IDs are specified in the request, the default security group for the VPC is applied.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-vpcid
        '''
        result = self._values.get("vpc_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpn_port(self) -> typing.Optional[jsii.Number]:
        '''The port number to assign to the Client VPN endpoint for TCP and UDP traffic.

        Valid Values: ``443`` | ``1194``

        Default Value: ``443``

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-vpnport
        '''
        result = self._values.get("vpn_port")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnClientVpnEndpointMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnClientVpnEndpointPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnClientVpnEndpointPropsMixin",
):
    '''Specifies a Client VPN endpoint.

    A Client VPN endpoint is the resource you create and configure to enable and manage client VPN sessions. It is the destination endpoint at which all client VPN sessions are terminated.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html
    :cloudformationResource: AWS::EC2::ClientVpnEndpoint
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_client_vpn_endpoint_props_mixin = ec2_mixins.CfnClientVpnEndpointPropsMixin(ec2_mixins.CfnClientVpnEndpointMixinProps(
            authentication_options=[ec2_mixins.CfnClientVpnEndpointPropsMixin.ClientAuthenticationRequestProperty(
                active_directory=ec2_mixins.CfnClientVpnEndpointPropsMixin.DirectoryServiceAuthenticationRequestProperty(
                    directory_id="directoryId"
                ),
                federated_authentication=ec2_mixins.CfnClientVpnEndpointPropsMixin.FederatedAuthenticationRequestProperty(
                    saml_provider_arn="samlProviderArn",
                    self_service_saml_provider_arn="selfServiceSamlProviderArn"
                ),
                mutual_authentication=ec2_mixins.CfnClientVpnEndpointPropsMixin.CertificateAuthenticationRequestProperty(
                    client_root_certificate_chain_arn="clientRootCertificateChainArn"
                ),
                type="type"
            )],
            client_cidr_block="clientCidrBlock",
            client_connect_options=ec2_mixins.CfnClientVpnEndpointPropsMixin.ClientConnectOptionsProperty(
                enabled=False,
                lambda_function_arn="lambdaFunctionArn"
            ),
            client_login_banner_options=ec2_mixins.CfnClientVpnEndpointPropsMixin.ClientLoginBannerOptionsProperty(
                banner_text="bannerText",
                enabled=False
            ),
            client_route_enforcement_options=ec2_mixins.CfnClientVpnEndpointPropsMixin.ClientRouteEnforcementOptionsProperty(
                enforced=False
            ),
            connection_log_options=ec2_mixins.CfnClientVpnEndpointPropsMixin.ConnectionLogOptionsProperty(
                cloudwatch_log_group="cloudwatchLogGroup",
                cloudwatch_log_stream="cloudwatchLogStream",
                enabled=False
            ),
            description="description",
            disconnect_on_session_timeout=False,
            dns_servers=["dnsServers"],
            endpoint_ip_address_type="endpointIpAddressType",
            security_group_ids=["securityGroupIds"],
            self_service_portal="selfServicePortal",
            server_certificate_arn="serverCertificateArn",
            session_timeout_hours=123,
            split_tunnel=False,
            tag_specifications=[ec2_mixins.CfnClientVpnEndpointPropsMixin.TagSpecificationProperty(
                resource_type="resourceType",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )],
            traffic_ip_address_type="trafficIpAddressType",
            transport_protocol="transportProtocol",
            vpc_id="vpcId",
            vpn_port=123
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnClientVpnEndpointMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::ClientVpnEndpoint``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__37ce4ab8625879fce12cbc125fc6e3fa18fdcb88a43281c3fa179173cbd7a7da)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1a70605cb8bdf5ac0460e106a19d1d66ea7f06cae58a73c59f8907eabd16c5b1)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__92cd0b05373c52b71927efcf04fc64f975338a2850bfe56c56a8470f283e6d6a)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnClientVpnEndpointMixinProps":
        return typing.cast("CfnClientVpnEndpointMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnClientVpnEndpointPropsMixin.CertificateAuthenticationRequestProperty",
        jsii_struct_bases=[],
        name_mapping={
            "client_root_certificate_chain_arn": "clientRootCertificateChainArn",
        },
    )
    class CertificateAuthenticationRequestProperty:
        def __init__(
            self,
            *,
            client_root_certificate_chain_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Information about the client certificate to be used for authentication.

            :param client_root_certificate_chain_arn: The ARN of the client certificate. The certificate must be signed by a certificate authority (CA) and it must be provisioned in Certificate Manager (ACM).

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-certificateauthenticationrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                certificate_authentication_request_property = ec2_mixins.CfnClientVpnEndpointPropsMixin.CertificateAuthenticationRequestProperty(
                    client_root_certificate_chain_arn="clientRootCertificateChainArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__d520cfd5ed167ff4c5107bb396a564decebcf2a781a352f2d7a1ed27944854d7)
                check_type(argname="argument client_root_certificate_chain_arn", value=client_root_certificate_chain_arn, expected_type=type_hints["client_root_certificate_chain_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if client_root_certificate_chain_arn is not None:
                self._values["client_root_certificate_chain_arn"] = client_root_certificate_chain_arn

        @builtins.property
        def client_root_certificate_chain_arn(self) -> typing.Optional[builtins.str]:
            '''The ARN of the client certificate.

            The certificate must be signed by a certificate authority (CA) and it must be provisioned in Certificate Manager (ACM).

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-certificateauthenticationrequest.html#cfn-ec2-clientvpnendpoint-certificateauthenticationrequest-clientrootcertificatechainarn
            '''
            result = self._values.get("client_root_certificate_chain_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "CertificateAuthenticationRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnClientVpnEndpointPropsMixin.ClientAuthenticationRequestProperty",
        jsii_struct_bases=[],
        name_mapping={
            "active_directory": "activeDirectory",
            "federated_authentication": "federatedAuthentication",
            "mutual_authentication": "mutualAuthentication",
            "type": "type",
        },
    )
    class ClientAuthenticationRequestProperty:
        def __init__(
            self,
            *,
            active_directory: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnClientVpnEndpointPropsMixin.DirectoryServiceAuthenticationRequestProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            federated_authentication: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnClientVpnEndpointPropsMixin.FederatedAuthenticationRequestProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            mutual_authentication: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnClientVpnEndpointPropsMixin.CertificateAuthenticationRequestProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes the authentication method to be used by a Client VPN endpoint.

            For more information, see `Authentication <https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/authentication-authrization.html#client-authentication>`_ in the *AWS Client VPN Administrator Guide* .

            :param active_directory: Information about the Active Directory to be used, if applicable. You must provide this information if *Type* is ``directory-service-authentication`` .
            :param federated_authentication: Information about the IAM SAML identity provider, if applicable.
            :param mutual_authentication: Information about the authentication certificates to be used, if applicable. You must provide this information if *Type* is ``certificate-authentication`` .
            :param type: The type of client authentication to be used.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                client_authentication_request_property = ec2_mixins.CfnClientVpnEndpointPropsMixin.ClientAuthenticationRequestProperty(
                    active_directory=ec2_mixins.CfnClientVpnEndpointPropsMixin.DirectoryServiceAuthenticationRequestProperty(
                        directory_id="directoryId"
                    ),
                    federated_authentication=ec2_mixins.CfnClientVpnEndpointPropsMixin.FederatedAuthenticationRequestProperty(
                        saml_provider_arn="samlProviderArn",
                        self_service_saml_provider_arn="selfServiceSamlProviderArn"
                    ),
                    mutual_authentication=ec2_mixins.CfnClientVpnEndpointPropsMixin.CertificateAuthenticationRequestProperty(
                        client_root_certificate_chain_arn="clientRootCertificateChainArn"
                    ),
                    type="type"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__e0370f0d85d6a1fd1c7f88a7f9c44241ce1e3518d04cd8e26db389ce0a1dae0b)
                check_type(argname="argument active_directory", value=active_directory, expected_type=type_hints["active_directory"])
                check_type(argname="argument federated_authentication", value=federated_authentication, expected_type=type_hints["federated_authentication"])
                check_type(argname="argument mutual_authentication", value=mutual_authentication, expected_type=type_hints["mutual_authentication"])
                check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if active_directory is not None:
                self._values["active_directory"] = active_directory
            if federated_authentication is not None:
                self._values["federated_authentication"] = federated_authentication
            if mutual_authentication is not None:
                self._values["mutual_authentication"] = mutual_authentication
            if type is not None:
                self._values["type"] = type

        @builtins.property
        def active_directory(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnClientVpnEndpointPropsMixin.DirectoryServiceAuthenticationRequestProperty"]]:
            '''Information about the Active Directory to be used, if applicable.

            You must provide this information if *Type* is ``directory-service-authentication`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html#cfn-ec2-clientvpnendpoint-clientauthenticationrequest-activedirectory
            '''
            result = self._values.get("active_directory")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnClientVpnEndpointPropsMixin.DirectoryServiceAuthenticationRequestProperty"]], result)

        @builtins.property
        def federated_authentication(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnClientVpnEndpointPropsMixin.FederatedAuthenticationRequestProperty"]]:
            '''Information about the IAM SAML identity provider, if applicable.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html#cfn-ec2-clientvpnendpoint-clientauthenticationrequest-federatedauthentication
            '''
            result = self._values.get("federated_authentication")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnClientVpnEndpointPropsMixin.FederatedAuthenticationRequestProperty"]], result)

        @builtins.property
        def mutual_authentication(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnClientVpnEndpointPropsMixin.CertificateAuthenticationRequestProperty"]]:
            '''Information about the authentication certificates to be used, if applicable.

            You must provide this information if *Type* is ``certificate-authentication`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html#cfn-ec2-clientvpnendpoint-clientauthenticationrequest-mutualauthentication
            '''
            result = self._values.get("mutual_authentication")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnClientVpnEndpointPropsMixin.CertificateAuthenticationRequestProperty"]], result)

        @builtins.property
        def type(self) -> typing.Optional[builtins.str]:
            '''The type of client authentication to be used.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html#cfn-ec2-clientvpnendpoint-clientauthenticationrequest-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ClientAuthenticationRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnClientVpnEndpointPropsMixin.ClientConnectOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "enabled": "enabled",
            "lambda_function_arn": "lambdaFunctionArn",
        },
    )
    class ClientConnectOptionsProperty:
        def __init__(
            self,
            *,
            enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            lambda_function_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Indicates whether client connect options are enabled.

            The default is ``false`` (not enabled).

            :param enabled: Indicates whether client connect options are enabled. The default is ``false`` (not enabled).
            :param lambda_function_arn: The Amazon Resource Name (ARN) of the AWS Lambda function used for connection authorization.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientconnectoptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                client_connect_options_property = ec2_mixins.CfnClientVpnEndpointPropsMixin.ClientConnectOptionsProperty(
                    enabled=False,
                    lambda_function_arn="lambdaFunctionArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__99f1868876ae828e5c7582fa50577396204153ec4ce41c19f8ab9d11de254ab1)
                check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
                check_type(argname="argument lambda_function_arn", value=lambda_function_arn, expected_type=type_hints["lambda_function_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if enabled is not None:
                self._values["enabled"] = enabled
            if lambda_function_arn is not None:
                self._values["lambda_function_arn"] = lambda_function_arn

        @builtins.property
        def enabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether client connect options are enabled.

            The default is ``false`` (not enabled).

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientconnectoptions.html#cfn-ec2-clientvpnendpoint-clientconnectoptions-enabled
            '''
            result = self._values.get("enabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def lambda_function_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the AWS Lambda function used for connection authorization.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientconnectoptions.html#cfn-ec2-clientvpnendpoint-clientconnectoptions-lambdafunctionarn
            '''
            result = self._values.get("lambda_function_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ClientConnectOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnClientVpnEndpointPropsMixin.ClientLoginBannerOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={"banner_text": "bannerText", "enabled": "enabled"},
    )
    class ClientLoginBannerOptionsProperty:
        def __init__(
            self,
            *,
            banner_text: typing.Optional[builtins.str] = None,
            enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        ) -> None:
            '''Options for enabling a customizable text banner that will be displayed on AWS provided clients when a VPN session is established.

            :param banner_text: Customizable text that will be displayed in a banner on AWS provided clients when a VPN session is established. UTF-8 encoded characters only. Maximum of 1400 characters.
            :param enabled: Enable or disable a customizable text banner that will be displayed on AWS provided clients when a VPN session is established. Valid values: ``true | false`` Default value: ``false``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientloginbanneroptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                client_login_banner_options_property = ec2_mixins.CfnClientVpnEndpointPropsMixin.ClientLoginBannerOptionsProperty(
                    banner_text="bannerText",
                    enabled=False
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__4d14612524e7d9922e4288c8e9192513b0ea4b78e23743f1bd9496b2452de2d2)
                check_type(argname="argument banner_text", value=banner_text, expected_type=type_hints["banner_text"])
                check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if banner_text is not None:
                self._values["banner_text"] = banner_text
            if enabled is not None:
                self._values["enabled"] = enabled

        @builtins.property
        def banner_text(self) -> typing.Optional[builtins.str]:
            '''Customizable text that will be displayed in a banner on AWS provided clients when a VPN session is established.

            UTF-8 encoded characters only. Maximum of 1400 characters.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientloginbanneroptions.html#cfn-ec2-clientvpnendpoint-clientloginbanneroptions-bannertext
            '''
            result = self._values.get("banner_text")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def enabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Enable or disable a customizable text banner that will be displayed on AWS provided clients when a VPN session is established.

            Valid values: ``true | false``

            Default value: ``false``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientloginbanneroptions.html#cfn-ec2-clientvpnendpoint-clientloginbanneroptions-enabled
            '''
            result = self._values.get("enabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ClientLoginBannerOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnClientVpnEndpointPropsMixin.ClientRouteEnforcementOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={"enforced": "enforced"},
    )
    class ClientRouteEnforcementOptionsProperty:
        def __init__(
            self,
            *,
            enforced: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        ) -> None:
            '''Client Route Enforcement is a feature of Client VPN that helps enforce administrator defined routes on devices connected through the VPN.

            This feature helps improve your security posture by ensuring that network traffic originating from a connected client is not inadvertently sent outside the VPN tunnel.

            Client Route Enforcement works by monitoring the route table of a connected device for routing policy changes to the VPN connection. If the feature detects any VPN routing policy modifications, it will automatically force an update to the route table, reverting it back to the expected route configurations.

            :param enforced: Enable or disable Client Route Enforcement. The state can either be ``true`` (enabled) or ``false`` (disabled). The default is ``false`` . Valid values: ``true | false`` Default value: ``false``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientrouteenforcementoptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                client_route_enforcement_options_property = ec2_mixins.CfnClientVpnEndpointPropsMixin.ClientRouteEnforcementOptionsProperty(
                    enforced=False
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__f09a2a48682d3a7e5b9e9ac1b5d67964e1a25da769ee6e8c05cecd4ff8d08a14)
                check_type(argname="argument enforced", value=enforced, expected_type=type_hints["enforced"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if enforced is not None:
                self._values["enforced"] = enforced

        @builtins.property
        def enforced(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Enable or disable Client Route Enforcement.

            The state can either be ``true`` (enabled) or ``false`` (disabled). The default is ``false`` .

            Valid values: ``true | false``

            Default value: ``false``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientrouteenforcementoptions.html#cfn-ec2-clientvpnendpoint-clientrouteenforcementoptions-enforced
            '''
            result = self._values.get("enforced")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ClientRouteEnforcementOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnClientVpnEndpointPropsMixin.ConnectionLogOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "cloudwatch_log_group": "cloudwatchLogGroup",
            "cloudwatch_log_stream": "cloudwatchLogStream",
            "enabled": "enabled",
        },
    )
    class ConnectionLogOptionsProperty:
        def __init__(
            self,
            *,
            cloudwatch_log_group: typing.Optional[builtins.str] = None,
            cloudwatch_log_stream: typing.Optional[builtins.str] = None,
            enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        ) -> None:
            '''Describes the client connection logging options for the Client VPN endpoint.

            :param cloudwatch_log_group: The name of the CloudWatch Logs log group. Required if connection logging is enabled.
            :param cloudwatch_log_stream: The name of the CloudWatch Logs log stream to which the connection data is published.
            :param enabled: Indicates whether connection logging is enabled.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-connectionlogoptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                connection_log_options_property = ec2_mixins.CfnClientVpnEndpointPropsMixin.ConnectionLogOptionsProperty(
                    cloudwatch_log_group="cloudwatchLogGroup",
                    cloudwatch_log_stream="cloudwatchLogStream",
                    enabled=False
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__e5b61b7536eaf574f22502fb413043a4380aab58e67cf426cdfaa474b3e8e604)
                check_type(argname="argument cloudwatch_log_group", value=cloudwatch_log_group, expected_type=type_hints["cloudwatch_log_group"])
                check_type(argname="argument cloudwatch_log_stream", value=cloudwatch_log_stream, expected_type=type_hints["cloudwatch_log_stream"])
                check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if cloudwatch_log_group is not None:
                self._values["cloudwatch_log_group"] = cloudwatch_log_group
            if cloudwatch_log_stream is not None:
                self._values["cloudwatch_log_stream"] = cloudwatch_log_stream
            if enabled is not None:
                self._values["enabled"] = enabled

        @builtins.property
        def cloudwatch_log_group(self) -> typing.Optional[builtins.str]:
            '''The name of the CloudWatch Logs log group.

            Required if connection logging is enabled.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-connectionlogoptions.html#cfn-ec2-clientvpnendpoint-connectionlogoptions-cloudwatchloggroup
            '''
            result = self._values.get("cloudwatch_log_group")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def cloudwatch_log_stream(self) -> typing.Optional[builtins.str]:
            '''The name of the CloudWatch Logs log stream to which the connection data is published.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-connectionlogoptions.html#cfn-ec2-clientvpnendpoint-connectionlogoptions-cloudwatchlogstream
            '''
            result = self._values.get("cloudwatch_log_stream")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def enabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether connection logging is enabled.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-connectionlogoptions.html#cfn-ec2-clientvpnendpoint-connectionlogoptions-enabled
            '''
            result = self._values.get("enabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ConnectionLogOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnClientVpnEndpointPropsMixin.DirectoryServiceAuthenticationRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"directory_id": "directoryId"},
    )
    class DirectoryServiceAuthenticationRequestProperty:
        def __init__(
            self,
            *,
            directory_id: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes the Active Directory to be used for client authentication.

            :param directory_id: The ID of the Active Directory to be used for authentication.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-directoryserviceauthenticationrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                directory_service_authentication_request_property = ec2_mixins.CfnClientVpnEndpointPropsMixin.DirectoryServiceAuthenticationRequestProperty(
                    directory_id="directoryId"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__440ed12d26871abeeb7a8eeb3eac1f7ca6bc1f28c50f22b36e227e1f7b4ba7bd)
                check_type(argname="argument directory_id", value=directory_id, expected_type=type_hints["directory_id"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if directory_id is not None:
                self._values["directory_id"] = directory_id

        @builtins.property
        def directory_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the Active Directory to be used for authentication.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-directoryserviceauthenticationrequest.html#cfn-ec2-clientvpnendpoint-directoryserviceauthenticationrequest-directoryid
            '''
            result = self._values.get("directory_id")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "DirectoryServiceAuthenticationRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnClientVpnEndpointPropsMixin.FederatedAuthenticationRequestProperty",
        jsii_struct_bases=[],
        name_mapping={
            "saml_provider_arn": "samlProviderArn",
            "self_service_saml_provider_arn": "selfServiceSamlProviderArn",
        },
    )
    class FederatedAuthenticationRequestProperty:
        def __init__(
            self,
            *,
            saml_provider_arn: typing.Optional[builtins.str] = None,
            self_service_saml_provider_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The IAM SAML identity provider used for federated authentication.

            :param saml_provider_arn: The Amazon Resource Name (ARN) of the IAM SAML identity provider.
            :param self_service_saml_provider_arn: The Amazon Resource Name (ARN) of the IAM SAML identity provider for the self-service portal.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-federatedauthenticationrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                federated_authentication_request_property = ec2_mixins.CfnClientVpnEndpointPropsMixin.FederatedAuthenticationRequestProperty(
                    saml_provider_arn="samlProviderArn",
                    self_service_saml_provider_arn="selfServiceSamlProviderArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__a3a260415294a9eb202d056946081d95f5f3e7bda69d013b4655fa213b75c6c2)
                check_type(argname="argument saml_provider_arn", value=saml_provider_arn, expected_type=type_hints["saml_provider_arn"])
                check_type(argname="argument self_service_saml_provider_arn", value=self_service_saml_provider_arn, expected_type=type_hints["self_service_saml_provider_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if saml_provider_arn is not None:
                self._values["saml_provider_arn"] = saml_provider_arn
            if self_service_saml_provider_arn is not None:
                self._values["self_service_saml_provider_arn"] = self_service_saml_provider_arn

        @builtins.property
        def saml_provider_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the IAM SAML identity provider.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-federatedauthenticationrequest.html#cfn-ec2-clientvpnendpoint-federatedauthenticationrequest-samlproviderarn
            '''
            result = self._values.get("saml_provider_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def self_service_saml_provider_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the IAM SAML identity provider for the self-service portal.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-federatedauthenticationrequest.html#cfn-ec2-clientvpnendpoint-federatedauthenticationrequest-selfservicesamlproviderarn
            '''
            result = self._values.get("self_service_saml_provider_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "FederatedAuthenticationRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnClientVpnEndpointPropsMixin.TagSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={"resource_type": "resourceType", "tags": "tags"},
    )
    class TagSpecificationProperty:
        def __init__(
            self,
            *,
            resource_type: typing.Optional[builtins.str] = None,
            tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Specifies the tags to apply to the Client VPN endpoint.

            :param resource_type: The type of resource to tag. To tag a Client VPN endpoint, ``ResourceType`` must be ``client-vpn-endpoint`` .
            :param tags: The tags to apply to the resource.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-tagspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                from aws_cdk import CfnTag
                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                tag_specification_property = ec2_mixins.CfnClientVpnEndpointPropsMixin.TagSpecificationProperty(
                    resource_type="resourceType",
                    tags=[CfnTag(
                        key="key",
                        value="value"
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__5b9a0676460c8f9b10d514869c961d91cce9cd0cb7967e299c018706ca9c2c44)
                check_type(argname="argument resource_type", value=resource_type, expected_type=type_hints["resource_type"])
                check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if resource_type is not None:
                self._values["resource_type"] = resource_type
            if tags is not None:
                self._values["tags"] = tags

        @builtins.property
        def resource_type(self) -> typing.Optional[builtins.str]:
            '''The type of resource to tag.

            To tag a Client VPN endpoint, ``ResourceType`` must be ``client-vpn-endpoint`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-tagspecification.html#cfn-ec2-clientvpnendpoint-tagspecification-resourcetype
            '''
            result = self._values.get("resource_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
            '''The tags to apply to the resource.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-tagspecification.html#cfn-ec2-clientvpnendpoint-tagspecification-tags
            '''
            result = self._values.get("tags")
            return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TagSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnClientVpnRouteMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "client_vpn_endpoint_id": "clientVpnEndpointId",
        "description": "description",
        "destination_cidr_block": "destinationCidrBlock",
        "target_vpc_subnet_id": "targetVpcSubnetId",
    },
)
class CfnClientVpnRouteMixinProps:
    def __init__(
        self,
        *,
        client_vpn_endpoint_id: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        destination_cidr_block: typing.Optional[builtins.str] = None,
        target_vpc_subnet_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnClientVpnRoutePropsMixin.

        :param client_vpn_endpoint_id: The ID of the Client VPN endpoint to which to add the route.
        :param description: A brief description of the route.
        :param destination_cidr_block: The IPv4 address range, in CIDR notation, of the route destination. For example:. - To add a route for Internet access, enter ``0.0.0.0/0`` - To add a route for a peered VPC, enter the peered VPC's IPv4 CIDR range - To add a route for an on-premises network, enter the AWS Site-to-Site VPN connection's IPv4 CIDR range - To add a route for the local network, enter the client CIDR range
        :param target_vpc_subnet_id: The ID of the subnet through which you want to route traffic. The specified subnet must be an existing target network of the Client VPN endpoint. Alternatively, if you're adding a route for the local network, specify ``local`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_client_vpn_route_mixin_props = ec2_mixins.CfnClientVpnRouteMixinProps(
                client_vpn_endpoint_id="clientVpnEndpointId",
                description="description",
                destination_cidr_block="destinationCidrBlock",
                target_vpc_subnet_id="targetVpcSubnetId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__27b7fdac4d9ad4979d05165c65c29f7e365bf171ba919e4ffcb8c962807f82cb)
            check_type(argname="argument client_vpn_endpoint_id", value=client_vpn_endpoint_id, expected_type=type_hints["client_vpn_endpoint_id"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument destination_cidr_block", value=destination_cidr_block, expected_type=type_hints["destination_cidr_block"])
            check_type(argname="argument target_vpc_subnet_id", value=target_vpc_subnet_id, expected_type=type_hints["target_vpc_subnet_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if client_vpn_endpoint_id is not None:
            self._values["client_vpn_endpoint_id"] = client_vpn_endpoint_id
        if description is not None:
            self._values["description"] = description
        if destination_cidr_block is not None:
            self._values["destination_cidr_block"] = destination_cidr_block
        if target_vpc_subnet_id is not None:
            self._values["target_vpc_subnet_id"] = target_vpc_subnet_id

    @builtins.property
    def client_vpn_endpoint_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the Client VPN endpoint to which to add the route.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html#cfn-ec2-clientvpnroute-clientvpnendpointid
        '''
        result = self._values.get("client_vpn_endpoint_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''A brief description of the route.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html#cfn-ec2-clientvpnroute-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def destination_cidr_block(self) -> typing.Optional[builtins.str]:
        '''The IPv4 address range, in CIDR notation, of the route destination. For example:.

        - To add a route for Internet access, enter ``0.0.0.0/0``
        - To add a route for a peered VPC, enter the peered VPC's IPv4 CIDR range
        - To add a route for an on-premises network, enter the AWS Site-to-Site VPN connection's IPv4 CIDR range
        - To add a route for the local network, enter the client CIDR range

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html#cfn-ec2-clientvpnroute-destinationcidrblock
        '''
        result = self._values.get("destination_cidr_block")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def target_vpc_subnet_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the subnet through which you want to route traffic.

        The specified subnet must be an existing target network of the Client VPN endpoint.

        Alternatively, if you're adding a route for the local network, specify ``local`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html#cfn-ec2-clientvpnroute-targetvpcsubnetid
        '''
        result = self._values.get("target_vpc_subnet_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnClientVpnRouteMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnClientVpnRoutePropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnClientVpnRoutePropsMixin",
):
    '''Specifies a network route to add to a Client VPN endpoint.

    Each Client VPN endpoint has a route table that describes the available destination network routes. Each route in the route table specifies the path for traffic to specific resources or networks.

    A target network association must be created before you can specify a route. If you're setting up all the components of a Client VPN endpoint at the same time, you must use the `DependsOn Attribute <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html>`_ to declare a dependency on the ``AWS::EC2::ClientVpnTargetNetworkAssociation`` resource.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html
    :cloudformationResource: AWS::EC2::ClientVpnRoute
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_client_vpn_route_props_mixin = ec2_mixins.CfnClientVpnRoutePropsMixin(ec2_mixins.CfnClientVpnRouteMixinProps(
            client_vpn_endpoint_id="clientVpnEndpointId",
            description="description",
            destination_cidr_block="destinationCidrBlock",
            target_vpc_subnet_id="targetVpcSubnetId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnClientVpnRouteMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::ClientVpnRoute``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b7f4e2ff941bc083820e4f1be4dc5f22dfc13389bb6475e570ebbcb05ff6ae43)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c01cb807916550c476361405be6ec7e8a4219c0736145b91c050af95f3884584)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bdb5d8472d1422cab13f8b2fe7ecdc3aa9d84a5731c08b866562750d5fecfa7d)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnClientVpnRouteMixinProps":
        return typing.cast("CfnClientVpnRouteMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnClientVpnTargetNetworkAssociationMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "client_vpn_endpoint_id": "clientVpnEndpointId",
        "subnet_id": "subnetId",
    },
)
class CfnClientVpnTargetNetworkAssociationMixinProps:
    def __init__(
        self,
        *,
        client_vpn_endpoint_id: typing.Optional[builtins.str] = None,
        subnet_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnClientVpnTargetNetworkAssociationPropsMixin.

        :param client_vpn_endpoint_id: The ID of the Client VPN endpoint.
        :param subnet_id: The ID of the subnet to associate with the Client VPN endpoint.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpntargetnetworkassociation.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_client_vpn_target_network_association_mixin_props = ec2_mixins.CfnClientVpnTargetNetworkAssociationMixinProps(
                client_vpn_endpoint_id="clientVpnEndpointId",
                subnet_id="subnetId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fc48cdb59418350b2e1c0b19ff5d850f70004279adfa44d745fd9f19a8d0b05b)
            check_type(argname="argument client_vpn_endpoint_id", value=client_vpn_endpoint_id, expected_type=type_hints["client_vpn_endpoint_id"])
            check_type(argname="argument subnet_id", value=subnet_id, expected_type=type_hints["subnet_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if client_vpn_endpoint_id is not None:
            self._values["client_vpn_endpoint_id"] = client_vpn_endpoint_id
        if subnet_id is not None:
            self._values["subnet_id"] = subnet_id

    @builtins.property
    def client_vpn_endpoint_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the Client VPN endpoint.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpntargetnetworkassociation.html#cfn-ec2-clientvpntargetnetworkassociation-clientvpnendpointid
        '''
        result = self._values.get("client_vpn_endpoint_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def subnet_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the subnet to associate with the Client VPN endpoint.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpntargetnetworkassociation.html#cfn-ec2-clientvpntargetnetworkassociation-subnetid
        '''
        result = self._values.get("subnet_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnClientVpnTargetNetworkAssociationMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnClientVpnTargetNetworkAssociationPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnClientVpnTargetNetworkAssociationPropsMixin",
):
    '''Specifies a target network to associate with a Client VPN endpoint.

    A target network is a subnet in a VPC. You can associate multiple subnets from the same VPC with a Client VPN endpoint. You can associate only one subnet in each Availability Zone. We recommend that you associate at least two subnets to provide Availability Zone redundancy.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpntargetnetworkassociation.html
    :cloudformationResource: AWS::EC2::ClientVpnTargetNetworkAssociation
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_client_vpn_target_network_association_props_mixin = ec2_mixins.CfnClientVpnTargetNetworkAssociationPropsMixin(ec2_mixins.CfnClientVpnTargetNetworkAssociationMixinProps(
            client_vpn_endpoint_id="clientVpnEndpointId",
            subnet_id="subnetId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnClientVpnTargetNetworkAssociationMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::ClientVpnTargetNetworkAssociation``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f5ee9caf9d0d66d98d6604b6f1c61ea4f49bfdb34856a603ed4e638b0179167f)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cf67c6ebb706aefb40fceba9afd038a462f163d63a3676a02d780a99dd9a33ea)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7f109488fe397938197f1f86d0e602b5874753d15bd9e9174da315eed84993cb)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnClientVpnTargetNetworkAssociationMixinProps":
        return typing.cast("CfnClientVpnTargetNetworkAssociationMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnCustomerGatewayMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "bgp_asn": "bgpAsn",
        "bgp_asn_extended": "bgpAsnExtended",
        "certificate_arn": "certificateArn",
        "device_name": "deviceName",
        "ip_address": "ipAddress",
        "tags": "tags",
        "type": "type",
    },
)
class CfnCustomerGatewayMixinProps:
    def __init__(
        self,
        *,
        bgp_asn: typing.Optional[jsii.Number] = None,
        bgp_asn_extended: typing.Optional[jsii.Number] = None,
        certificate_arn: typing.Optional[builtins.str] = None,
        device_name: typing.Optional[builtins.str] = None,
        ip_address: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnCustomerGatewayPropsMixin.

        :param bgp_asn: For customer gateway devices that support BGP, specify the device's ASN. You must specify either ``BgpAsn`` or ``BgpAsnExtended`` when creating the customer gateway. If the ASN is larger than ``2,147,483,647`` , you must use ``BgpAsnExtended`` . Default: 65000 Valid values: ``1`` to ``2,147,483,647`` Default: - 65000
        :param bgp_asn_extended: For customer gateway devices that support BGP, specify the device's ASN. You must specify either ``BgpAsn`` or ``BgpAsnExtended`` when creating the customer gateway. If the ASN is larger than ``2,147,483,647`` , you must use ``BgpAsnExtended`` . Valid values: ``2,147,483,648`` to ``4,294,967,295``
        :param certificate_arn: The Amazon Resource Name (ARN) for the customer gateway certificate.
        :param device_name: The name of customer gateway device.
        :param ip_address: The IP address for the customer gateway device's outside interface. The address must be static. If ``OutsideIpAddressType`` in your VPN connection options is set to ``PrivateIpv4`` , you can use an RFC6598 or RFC1918 private IPv4 address. If ``OutsideIpAddressType`` is set to ``Ipv6`` , you can use an IPv6 address.
        :param tags: One or more tags for the customer gateway.
        :param type: The type of VPN connection that this customer gateway supports ( ``ipsec.1`` ).

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_customer_gateway_mixin_props = ec2_mixins.CfnCustomerGatewayMixinProps(
                bgp_asn=123,
                bgp_asn_extended=123,
                certificate_arn="certificateArn",
                device_name="deviceName",
                ip_address="ipAddress",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                type="type"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8a2e95085bf0186789d5a669e4aafbfccb76b81df7555fa4a6105a90c4a177bb)
            check_type(argname="argument bgp_asn", value=bgp_asn, expected_type=type_hints["bgp_asn"])
            check_type(argname="argument bgp_asn_extended", value=bgp_asn_extended, expected_type=type_hints["bgp_asn_extended"])
            check_type(argname="argument certificate_arn", value=certificate_arn, expected_type=type_hints["certificate_arn"])
            check_type(argname="argument device_name", value=device_name, expected_type=type_hints["device_name"])
            check_type(argname="argument ip_address", value=ip_address, expected_type=type_hints["ip_address"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if bgp_asn is not None:
            self._values["bgp_asn"] = bgp_asn
        if bgp_asn_extended is not None:
            self._values["bgp_asn_extended"] = bgp_asn_extended
        if certificate_arn is not None:
            self._values["certificate_arn"] = certificate_arn
        if device_name is not None:
            self._values["device_name"] = device_name
        if ip_address is not None:
            self._values["ip_address"] = ip_address
        if tags is not None:
            self._values["tags"] = tags
        if type is not None:
            self._values["type"] = type

    @builtins.property
    def bgp_asn(self) -> typing.Optional[jsii.Number]:
        '''For customer gateway devices that support BGP, specify the device's ASN.

        You must specify either ``BgpAsn`` or ``BgpAsnExtended`` when creating the customer gateway. If the ASN is larger than ``2,147,483,647`` , you must use ``BgpAsnExtended`` .

        Default: 65000

        Valid values: ``1`` to ``2,147,483,647``

        :default: - 65000

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-bgpasn
        '''
        result = self._values.get("bgp_asn")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def bgp_asn_extended(self) -> typing.Optional[jsii.Number]:
        '''For customer gateway devices that support BGP, specify the device's ASN.

        You must specify either ``BgpAsn`` or ``BgpAsnExtended`` when creating the customer gateway. If the ASN is larger than ``2,147,483,647`` , you must use ``BgpAsnExtended`` .

        Valid values: ``2,147,483,648`` to ``4,294,967,295``

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-bgpasnextended
        '''
        result = self._values.get("bgp_asn_extended")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def certificate_arn(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) for the customer gateway certificate.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-certificatearn
        '''
        result = self._values.get("certificate_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def device_name(self) -> typing.Optional[builtins.str]:
        '''The name of customer gateway device.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-devicename
        '''
        result = self._values.get("device_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ip_address(self) -> typing.Optional[builtins.str]:
        '''The IP address for the customer gateway device's outside interface.

        The address must be static. If ``OutsideIpAddressType`` in your VPN connection options is set to ``PrivateIpv4`` , you can use an RFC6598 or RFC1918 private IPv4 address. If ``OutsideIpAddressType`` is set to ``Ipv6`` , you can use an IPv6 address.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-ipaddress
        '''
        result = self._values.get("ip_address")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''One or more tags for the customer gateway.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''The type of VPN connection that this customer gateway supports ( ``ipsec.1`` ).

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnCustomerGatewayMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnCustomerGatewayPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnCustomerGatewayPropsMixin",
):
    '''Specifies a customer gateway.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html
    :cloudformationResource: AWS::EC2::CustomerGateway
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_customer_gateway_props_mixin = ec2_mixins.CfnCustomerGatewayPropsMixin(ec2_mixins.CfnCustomerGatewayMixinProps(
            bgp_asn=123,
            bgp_asn_extended=123,
            certificate_arn="certificateArn",
            device_name="deviceName",
            ip_address="ipAddress",
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            type="type"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnCustomerGatewayMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::CustomerGateway``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5d34645a188b514496b583b1124d1bd38209128df1697f55ff5bb6b5ab791c6c)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dd3a73060d433be76a89d7b8832c7bbc055a26eed8b1dda9e6abd7b6686cb548)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3eaccf33ebad31c4b13616f48f12a22de01b3adc6afc01764060a919e9e9fb51)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnCustomerGatewayMixinProps":
        return typing.cast("CfnCustomerGatewayMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnDHCPOptionsMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "domain_name": "domainName",
        "domain_name_servers": "domainNameServers",
        "ipv6_address_preferred_lease_time": "ipv6AddressPreferredLeaseTime",
        "netbios_name_servers": "netbiosNameServers",
        "netbios_node_type": "netbiosNodeType",
        "ntp_servers": "ntpServers",
        "tags": "tags",
    },
)
class CfnDHCPOptionsMixinProps:
    def __init__(
        self,
        *,
        domain_name: typing.Optional[builtins.str] = None,
        domain_name_servers: typing.Optional[typing.Sequence[builtins.str]] = None,
        ipv6_address_preferred_lease_time: typing.Optional[jsii.Number] = None,
        netbios_name_servers: typing.Optional[typing.Sequence[builtins.str]] = None,
        netbios_node_type: typing.Optional[jsii.Number] = None,
        ntp_servers: typing.Optional[typing.Sequence[builtins.str]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnDHCPOptionsPropsMixin.

        :param domain_name: This value is used to complete unqualified DNS hostnames. If you're using AmazonProvidedDNS in ``us-east-1`` , specify ``ec2.internal`` . If you're using AmazonProvidedDNS in another Region, specify *region* . ``compute.internal`` (for example, ``ap-northeast-1.compute.internal`` ). Otherwise, specify a domain name (for example, *MyCompany.com* ).
        :param domain_name_servers: The IPv4 addresses of up to four domain name servers, or ``AmazonProvidedDNS`` . The default is ``AmazonProvidedDNS`` . To have your instance receive a custom DNS hostname as specified in ``DomainName`` , you must set this property to a custom DNS server.
        :param ipv6_address_preferred_lease_time: A value (in seconds, minutes, hours, or years) for how frequently a running instance with an IPv6 assigned to it goes through DHCPv6 lease renewal. Acceptable values are between 140 and 2147483647 seconds (approximately 68 years). If no value is entered, the default lease time is 140 seconds. If you use long-term addressing for EC2 instances, you can increase the lease time and avoid frequent lease renewal requests. Lease renewal typically occurs when half of the lease time has elapsed.
        :param netbios_name_servers: The IPv4 addresses of up to four NetBIOS name servers.
        :param netbios_node_type: The NetBIOS node type (1, 2, 4, or 8). We recommend that you specify 2 (broadcast and multicast are not currently supported).
        :param ntp_servers: The IPv4 addresses of up to four Network Time Protocol (NTP) servers.
        :param tags: Any tags assigned to the DHCP options set.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_dHCPOptions_mixin_props = ec2_mixins.CfnDHCPOptionsMixinProps(
                domain_name="domainName",
                domain_name_servers=["domainNameServers"],
                ipv6_address_preferred_lease_time=123,
                netbios_name_servers=["netbiosNameServers"],
                netbios_node_type=123,
                ntp_servers=["ntpServers"],
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__799fad1100366695f0ac1c8833a574ffe01aa6bcb7304b73926899a84bf9fa2b)
            check_type(argname="argument domain_name", value=domain_name, expected_type=type_hints["domain_name"])
            check_type(argname="argument domain_name_servers", value=domain_name_servers, expected_type=type_hints["domain_name_servers"])
            check_type(argname="argument ipv6_address_preferred_lease_time", value=ipv6_address_preferred_lease_time, expected_type=type_hints["ipv6_address_preferred_lease_time"])
            check_type(argname="argument netbios_name_servers", value=netbios_name_servers, expected_type=type_hints["netbios_name_servers"])
            check_type(argname="argument netbios_node_type", value=netbios_node_type, expected_type=type_hints["netbios_node_type"])
            check_type(argname="argument ntp_servers", value=ntp_servers, expected_type=type_hints["ntp_servers"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if domain_name is not None:
            self._values["domain_name"] = domain_name
        if domain_name_servers is not None:
            self._values["domain_name_servers"] = domain_name_servers
        if ipv6_address_preferred_lease_time is not None:
            self._values["ipv6_address_preferred_lease_time"] = ipv6_address_preferred_lease_time
        if netbios_name_servers is not None:
            self._values["netbios_name_servers"] = netbios_name_servers
        if netbios_node_type is not None:
            self._values["netbios_node_type"] = netbios_node_type
        if ntp_servers is not None:
            self._values["ntp_servers"] = ntp_servers
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def domain_name(self) -> typing.Optional[builtins.str]:
        '''This value is used to complete unqualified DNS hostnames.

        If you're using AmazonProvidedDNS in ``us-east-1`` , specify ``ec2.internal`` . If you're using AmazonProvidedDNS in another Region, specify *region* . ``compute.internal`` (for example, ``ap-northeast-1.compute.internal`` ). Otherwise, specify a domain name (for example, *MyCompany.com* ).

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-domainname
        '''
        result = self._values.get("domain_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def domain_name_servers(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The IPv4 addresses of up to four domain name servers, or ``AmazonProvidedDNS`` .

        The default is ``AmazonProvidedDNS`` . To have your instance receive a custom DNS hostname as specified in ``DomainName`` , you must set this property to a custom DNS server.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-domainnameservers
        '''
        result = self._values.get("domain_name_servers")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def ipv6_address_preferred_lease_time(self) -> typing.Optional[jsii.Number]:
        '''A value (in seconds, minutes, hours, or years) for how frequently a running instance with an IPv6 assigned to it goes through DHCPv6 lease renewal.

        Acceptable values are between 140 and 2147483647 seconds (approximately 68 years). If no value is entered, the default lease time is 140 seconds. If you use long-term addressing for EC2 instances, you can increase the lease time and avoid frequent lease renewal requests. Lease renewal typically occurs when half of the lease time has elapsed.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-ipv6addresspreferredleasetime
        '''
        result = self._values.get("ipv6_address_preferred_lease_time")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def netbios_name_servers(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The IPv4 addresses of up to four NetBIOS name servers.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-netbiosnameservers
        '''
        result = self._values.get("netbios_name_servers")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def netbios_node_type(self) -> typing.Optional[jsii.Number]:
        '''The NetBIOS node type (1, 2, 4, or 8).

        We recommend that you specify 2 (broadcast and multicast are not currently supported).

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-netbiosnodetype
        '''
        result = self._values.get("netbios_node_type")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def ntp_servers(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The IPv4 addresses of up to four Network Time Protocol (NTP) servers.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-ntpservers
        '''
        result = self._values.get("ntp_servers")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''Any tags assigned to the DHCP options set.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnDHCPOptionsMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnDHCPOptionsPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnDHCPOptionsPropsMixin",
):
    '''Specifies a set of DHCP options for your VPC.

    You must specify at least one of the following properties: ``DomainNameServers`` , ``NetbiosNameServers`` , ``NtpServers`` . If you specify ``NetbiosNameServers`` , you must specify ``NetbiosNodeType`` .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html
    :cloudformationResource: AWS::EC2::DHCPOptions
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_dHCPOptions_props_mixin = ec2_mixins.CfnDHCPOptionsPropsMixin(ec2_mixins.CfnDHCPOptionsMixinProps(
            domain_name="domainName",
            domain_name_servers=["domainNameServers"],
            ipv6_address_preferred_lease_time=123,
            netbios_name_servers=["netbiosNameServers"],
            netbios_node_type=123,
            ntp_servers=["ntpServers"],
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnDHCPOptionsMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::DHCPOptions``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0d479c7abddf1a54a1dce44652673f5ce118cdbb7e931410766923dea112b457)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ef32be983feb9e5248c51a0a61e65dcaa877b0106e2c53a83f98b28a1e7beaa2)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__882967bec9f0d4da3ffb3cd532a9dc9fb1e2c8f1dcb68c77bb659d7943853529)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnDHCPOptionsMixinProps":
        return typing.cast("CfnDHCPOptionsMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnEC2FleetMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "context": "context",
        "excess_capacity_termination_policy": "excessCapacityTerminationPolicy",
        "launch_template_configs": "launchTemplateConfigs",
        "on_demand_options": "onDemandOptions",
        "replace_unhealthy_instances": "replaceUnhealthyInstances",
        "spot_options": "spotOptions",
        "tag_specifications": "tagSpecifications",
        "target_capacity_specification": "targetCapacitySpecification",
        "terminate_instances_with_expiration": "terminateInstancesWithExpiration",
        "type": "type",
        "valid_from": "validFrom",
        "valid_until": "validUntil",
    },
)
class CfnEC2FleetMixinProps:
    def __init__(
        self,
        *,
        context: typing.Optional[builtins.str] = None,
        excess_capacity_termination_policy: typing.Optional[builtins.str] = None,
        launch_template_configs: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnEC2FleetPropsMixin.FleetLaunchTemplateConfigRequestProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        on_demand_options: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnEC2FleetPropsMixin.OnDemandOptionsRequestProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        replace_unhealthy_instances: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        spot_options: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnEC2FleetPropsMixin.SpotOptionsRequestProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        tag_specifications: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnEC2FleetPropsMixin.TagSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        target_capacity_specification: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnEC2FleetPropsMixin.TargetCapacitySpecificationRequestProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        terminate_instances_with_expiration: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        type: typing.Optional[builtins.str] = None,
        valid_from: typing.Optional[builtins.str] = None,
        valid_until: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnEC2FleetPropsMixin.

        :param context: Reserved.
        :param excess_capacity_termination_policy: Indicates whether running instances should be terminated if the total target capacity of the EC2 Fleet is decreased below the current size of the EC2 Fleet. Supported only for fleets of type ``maintain`` .
        :param launch_template_configs: The configuration for the EC2 Fleet.
        :param on_demand_options: Describes the configuration of On-Demand Instances in an EC2 Fleet.
        :param replace_unhealthy_instances: Indicates whether EC2 Fleet should replace unhealthy Spot Instances. Supported only for fleets of type ``maintain`` . For more information, see `EC2 Fleet health checks <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/manage-ec2-fleet.html#ec2-fleet-health-checks>`_ in the *Amazon EC2 User Guide* .
        :param spot_options: Describes the configuration of Spot Instances in an EC2 Fleet.
        :param tag_specifications: The key-value pair for tagging the EC2 Fleet request on creation. For more information, see `Tag your resources <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#tag-resources>`_ . If the fleet type is ``instant`` , specify a resource type of ``fleet`` to tag the fleet or ``instance`` to tag the instances at launch. If the fleet type is ``maintain`` or ``request`` , specify a resource type of ``fleet`` to tag the fleet. You cannot specify a resource type of ``instance`` . To tag instances at launch, specify the tags in a `launch template <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#create-launch-template>`_ .
        :param target_capacity_specification: The number of units to request.
        :param terminate_instances_with_expiration: Indicates whether running instances should be terminated when the EC2 Fleet expires.
        :param type: The fleet type. The default value is ``maintain`` . - ``maintain`` - The EC2 Fleet places an asynchronous request for your desired capacity, and continues to maintain your desired Spot capacity by replenishing interrupted Spot Instances. - ``request`` - The EC2 Fleet places an asynchronous one-time request for your desired capacity, but does submit Spot requests in alternative capacity pools if Spot capacity is unavailable, and does not maintain Spot capacity if Spot Instances are interrupted. - ``instant`` - The EC2 Fleet places a synchronous one-time request for your desired capacity, and returns errors for any instances that could not be launched. For more information, see `EC2 Fleet request types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-request-type.html>`_ in the *Amazon EC2 User Guide* .
        :param valid_from: The start date and time of the request, in UTC format (for example, *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z). The default is to start fulfilling the request immediately.
        :param valid_until: The end date and time of the request, in UTC format (for example, *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z). At this point, no new EC2 Fleet requests are placed or able to fulfill the request. If no value is specified, the request remains until you cancel it.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_eC2_fleet_mixin_props = ec2_mixins.CfnEC2FleetMixinProps(
                context="context",
                excess_capacity_termination_policy="excessCapacityTerminationPolicy",
                launch_template_configs=[ec2_mixins.CfnEC2FleetPropsMixin.FleetLaunchTemplateConfigRequestProperty(
                    launch_template_specification=ec2_mixins.CfnEC2FleetPropsMixin.FleetLaunchTemplateSpecificationRequestProperty(
                        launch_template_id="launchTemplateId",
                        launch_template_name="launchTemplateName",
                        version="version"
                    ),
                    overrides=[ec2_mixins.CfnEC2FleetPropsMixin.FleetLaunchTemplateOverridesRequestProperty(
                        availability_zone="availabilityZone",
                        availability_zone_id="availabilityZoneId",
                        block_device_mappings=[ec2_mixins.CfnEC2FleetPropsMixin.BlockDeviceMappingProperty(
                            device_name="deviceName",
                            ebs=ec2_mixins.CfnEC2FleetPropsMixin.EbsBlockDeviceProperty(
                                delete_on_termination=False,
                                encrypted=False,
                                iops=123,
                                kms_key_id="kmsKeyId",
                                snapshot_id="snapshotId",
                                volume_size=123,
                                volume_type="volumeType"
                            ),
                            no_device="noDevice",
                            virtual_name="virtualName"
                        )],
                        instance_requirements=ec2_mixins.CfnEC2FleetPropsMixin.InstanceRequirementsRequestProperty(
                            accelerator_count=ec2_mixins.CfnEC2FleetPropsMixin.AcceleratorCountRequestProperty(
                                max=123,
                                min=123
                            ),
                            accelerator_manufacturers=["acceleratorManufacturers"],
                            accelerator_names=["acceleratorNames"],
                            accelerator_total_memory_mi_b=ec2_mixins.CfnEC2FleetPropsMixin.AcceleratorTotalMemoryMiBRequestProperty(
                                max=123,
                                min=123
                            ),
                            accelerator_types=["acceleratorTypes"],
                            allowed_instance_types=["allowedInstanceTypes"],
                            bare_metal="bareMetal",
                            baseline_ebs_bandwidth_mbps=ec2_mixins.CfnEC2FleetPropsMixin.BaselineEbsBandwidthMbpsRequestProperty(
                                max=123,
                                min=123
                            ),
                            baseline_performance_factors=ec2_mixins.CfnEC2FleetPropsMixin.BaselinePerformanceFactorsRequestProperty(
                                cpu=ec2_mixins.CfnEC2FleetPropsMixin.CpuPerformanceFactorRequestProperty(
                                    references=[ec2_mixins.CfnEC2FleetPropsMixin.PerformanceFactorReferenceRequestProperty(
                                        instance_family="instanceFamily"
                                    )]
                                )
                            ),
                            burstable_performance="burstablePerformance",
                            cpu_manufacturers=["cpuManufacturers"],
                            excluded_instance_types=["excludedInstanceTypes"],
                            instance_generations=["instanceGenerations"],
                            local_storage="localStorage",
                            local_storage_types=["localStorageTypes"],
                            max_spot_price_as_percentage_of_optimal_on_demand_price=123,
                            memory_gi_bPer_vCpu=ec2_mixins.CfnEC2FleetPropsMixin.MemoryGiBPerVCpuRequestProperty(
                                max=123,
                                min=123
                            ),
                            memory_mi_b=ec2_mixins.CfnEC2FleetPropsMixin.MemoryMiBRequestProperty(
                                max=123,
                                min=123
                            ),
                            network_bandwidth_gbps=ec2_mixins.CfnEC2FleetPropsMixin.NetworkBandwidthGbpsRequestProperty(
                                max=123,
                                min=123
                            ),
                            network_interface_count=ec2_mixins.CfnEC2FleetPropsMixin.NetworkInterfaceCountRequestProperty(
                                max=123,
                                min=123
                            ),
                            on_demand_max_price_percentage_over_lowest_price=123,
                            require_encryption_in_transit=False,
                            require_hibernate_support=False,
                            spot_max_price_percentage_over_lowest_price=123,
                            total_local_storage_gb=ec2_mixins.CfnEC2FleetPropsMixin.TotalLocalStorageGBRequestProperty(
                                max=123,
                                min=123
                            ),
                            v_cpu_count=ec2_mixins.CfnEC2FleetPropsMixin.VCpuCountRangeRequestProperty(
                                max=123,
                                min=123
                            )
                        ),
                        instance_type="instanceType",
                        max_price="maxPrice",
                        placement=ec2_mixins.CfnEC2FleetPropsMixin.PlacementProperty(
                            affinity="affinity",
                            availability_zone="availabilityZone",
                            group_name="groupName",
                            host_id="hostId",
                            host_resource_group_arn="hostResourceGroupArn",
                            partition_number=123,
                            spread_domain="spreadDomain",
                            tenancy="tenancy"
                        ),
                        priority=123,
                        subnet_id="subnetId",
                        weighted_capacity=123
                    )]
                )],
                on_demand_options=ec2_mixins.CfnEC2FleetPropsMixin.OnDemandOptionsRequestProperty(
                    allocation_strategy="allocationStrategy",
                    capacity_reservation_options=ec2_mixins.CfnEC2FleetPropsMixin.CapacityReservationOptionsRequestProperty(
                        usage_strategy="usageStrategy"
                    ),
                    max_total_price="maxTotalPrice",
                    min_target_capacity=123,
                    single_availability_zone=False,
                    single_instance_type=False
                ),
                replace_unhealthy_instances=False,
                spot_options=ec2_mixins.CfnEC2FleetPropsMixin.SpotOptionsRequestProperty(
                    allocation_strategy="allocationStrategy",
                    instance_interruption_behavior="instanceInterruptionBehavior",
                    instance_pools_to_use_count=123,
                    maintenance_strategies=ec2_mixins.CfnEC2FleetPropsMixin.MaintenanceStrategiesProperty(
                        capacity_rebalance=ec2_mixins.CfnEC2FleetPropsMixin.CapacityRebalanceProperty(
                            replacement_strategy="replacementStrategy",
                            termination_delay=123
                        )
                    ),
                    max_total_price="maxTotalPrice",
                    min_target_capacity=123,
                    single_availability_zone=False,
                    single_instance_type=False
                ),
                tag_specifications=[ec2_mixins.CfnEC2FleetPropsMixin.TagSpecificationProperty(
                    resource_type="resourceType",
                    tags=[CfnTag(
                        key="key",
                        value="value"
                    )]
                )],
                target_capacity_specification=ec2_mixins.CfnEC2FleetPropsMixin.TargetCapacitySpecificationRequestProperty(
                    default_target_capacity_type="defaultTargetCapacityType",
                    on_demand_target_capacity=123,
                    spot_target_capacity=123,
                    target_capacity_unit_type="targetCapacityUnitType",
                    total_target_capacity=123
                ),
                terminate_instances_with_expiration=False,
                type="type",
                valid_from="validFrom",
                valid_until="validUntil"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4fa11ea760cb56b087bfc05ec40127de0799fc3f623aa1ad453fad507443bf8f)
            check_type(argname="argument context", value=context, expected_type=type_hints["context"])
            check_type(argname="argument excess_capacity_termination_policy", value=excess_capacity_termination_policy, expected_type=type_hints["excess_capacity_termination_policy"])
            check_type(argname="argument launch_template_configs", value=launch_template_configs, expected_type=type_hints["launch_template_configs"])
            check_type(argname="argument on_demand_options", value=on_demand_options, expected_type=type_hints["on_demand_options"])
            check_type(argname="argument replace_unhealthy_instances", value=replace_unhealthy_instances, expected_type=type_hints["replace_unhealthy_instances"])
            check_type(argname="argument spot_options", value=spot_options, expected_type=type_hints["spot_options"])
            check_type(argname="argument tag_specifications", value=tag_specifications, expected_type=type_hints["tag_specifications"])
            check_type(argname="argument target_capacity_specification", value=target_capacity_specification, expected_type=type_hints["target_capacity_specification"])
            check_type(argname="argument terminate_instances_with_expiration", value=terminate_instances_with_expiration, expected_type=type_hints["terminate_instances_with_expiration"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument valid_from", value=valid_from, expected_type=type_hints["valid_from"])
            check_type(argname="argument valid_until", value=valid_until, expected_type=type_hints["valid_until"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if context is not None:
            self._values["context"] = context
        if excess_capacity_termination_policy is not None:
            self._values["excess_capacity_termination_policy"] = excess_capacity_termination_policy
        if launch_template_configs is not None:
            self._values["launch_template_configs"] = launch_template_configs
        if on_demand_options is not None:
            self._values["on_demand_options"] = on_demand_options
        if replace_unhealthy_instances is not None:
            self._values["replace_unhealthy_instances"] = replace_unhealthy_instances
        if spot_options is not None:
            self._values["spot_options"] = spot_options
        if tag_specifications is not None:
            self._values["tag_specifications"] = tag_specifications
        if target_capacity_specification is not None:
            self._values["target_capacity_specification"] = target_capacity_specification
        if terminate_instances_with_expiration is not None:
            self._values["terminate_instances_with_expiration"] = terminate_instances_with_expiration
        if type is not None:
            self._values["type"] = type
        if valid_from is not None:
            self._values["valid_from"] = valid_from
        if valid_until is not None:
            self._values["valid_until"] = valid_until

    @builtins.property
    def context(self) -> typing.Optional[builtins.str]:
        '''Reserved.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-context
        '''
        result = self._values.get("context")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def excess_capacity_termination_policy(self) -> typing.Optional[builtins.str]:
        '''Indicates whether running instances should be terminated if the total target capacity of the EC2 Fleet is decreased below the current size of the EC2 Fleet.

        Supported only for fleets of type ``maintain`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-excesscapacityterminationpolicy
        '''
        result = self._values.get("excess_capacity_termination_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def launch_template_configs(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.FleetLaunchTemplateConfigRequestProperty"]]]]:
        '''The configuration for the EC2 Fleet.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-launchtemplateconfigs
        '''
        result = self._values.get("launch_template_configs")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.FleetLaunchTemplateConfigRequestProperty"]]]], result)

    @builtins.property
    def on_demand_options(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.OnDemandOptionsRequestProperty"]]:
        '''Describes the configuration of On-Demand Instances in an EC2 Fleet.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-ondemandoptions
        '''
        result = self._values.get("on_demand_options")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.OnDemandOptionsRequestProperty"]], result)

    @builtins.property
    def replace_unhealthy_instances(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Indicates whether EC2 Fleet should replace unhealthy Spot Instances.

        Supported only for fleets of type ``maintain`` . For more information, see `EC2 Fleet health checks <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/manage-ec2-fleet.html#ec2-fleet-health-checks>`_ in the *Amazon EC2 User Guide* .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-replaceunhealthyinstances
        '''
        result = self._values.get("replace_unhealthy_instances")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def spot_options(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.SpotOptionsRequestProperty"]]:
        '''Describes the configuration of Spot Instances in an EC2 Fleet.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-spotoptions
        '''
        result = self._values.get("spot_options")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.SpotOptionsRequestProperty"]], result)

    @builtins.property
    def tag_specifications(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.TagSpecificationProperty"]]]]:
        '''The key-value pair for tagging the EC2 Fleet request on creation. For more information, see `Tag your resources <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#tag-resources>`_ .

        If the fleet type is ``instant`` , specify a resource type of ``fleet`` to tag the fleet or ``instance`` to tag the instances at launch.

        If the fleet type is ``maintain`` or ``request`` , specify a resource type of ``fleet`` to tag the fleet. You cannot specify a resource type of ``instance`` . To tag instances at launch, specify the tags in a `launch template <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#create-launch-template>`_ .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-tagspecifications
        '''
        result = self._values.get("tag_specifications")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.TagSpecificationProperty"]]]], result)

    @builtins.property
    def target_capacity_specification(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.TargetCapacitySpecificationRequestProperty"]]:
        '''The number of units to request.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-targetcapacityspecification
        '''
        result = self._values.get("target_capacity_specification")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.TargetCapacitySpecificationRequestProperty"]], result)

    @builtins.property
    def terminate_instances_with_expiration(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Indicates whether running instances should be terminated when the EC2 Fleet expires.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-terminateinstanceswithexpiration
        '''
        result = self._values.get("terminate_instances_with_expiration")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''The fleet type. The default value is ``maintain`` .

        - ``maintain`` - The EC2 Fleet places an asynchronous request for your desired capacity, and continues to maintain your desired Spot capacity by replenishing interrupted Spot Instances.
        - ``request`` - The EC2 Fleet places an asynchronous one-time request for your desired capacity, but does submit Spot requests in alternative capacity pools if Spot capacity is unavailable, and does not maintain Spot capacity if Spot Instances are interrupted.
        - ``instant`` - The EC2 Fleet places a synchronous one-time request for your desired capacity, and returns errors for any instances that could not be launched.

        For more information, see `EC2 Fleet request types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-request-type.html>`_ in the *Amazon EC2 User Guide* .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def valid_from(self) -> typing.Optional[builtins.str]:
        '''The start date and time of the request, in UTC format (for example, *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z).

        The default is to start fulfilling the request immediately.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-validfrom
        '''
        result = self._values.get("valid_from")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def valid_until(self) -> typing.Optional[builtins.str]:
        '''The end date and time of the request, in UTC format (for example, *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z).

        At this point, no new EC2 Fleet requests are placed or able to fulfill the request. If no value is specified, the request remains until you cancel it.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-validuntil
        '''
        result = self._values.get("valid_until")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnEC2FleetMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnEC2FleetPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnEC2FleetPropsMixin",
):
    '''Specifies the configuration information to launch a fleet--or group--of instances.

    An EC2 Fleet can launch multiple instance types across multiple Availability Zones, using the On-Demand Instance, Reserved Instance, and Spot Instance purchasing models together. Using EC2 Fleet, you can define separate On-Demand and Spot capacity targets, specify the instance types that work best for your applications, and specify how Amazon EC2 should distribute your fleet capacity within each purchasing model. For more information, see `Launching an EC2 Fleet <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet.html>`_ in the *Amazon EC2 User Guide* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html
    :cloudformationResource: AWS::EC2::EC2Fleet
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_eC2_fleet_props_mixin = ec2_mixins.CfnEC2FleetPropsMixin(ec2_mixins.CfnEC2FleetMixinProps(
            context="context",
            excess_capacity_termination_policy="excessCapacityTerminationPolicy",
            launch_template_configs=[ec2_mixins.CfnEC2FleetPropsMixin.FleetLaunchTemplateConfigRequestProperty(
                launch_template_specification=ec2_mixins.CfnEC2FleetPropsMixin.FleetLaunchTemplateSpecificationRequestProperty(
                    launch_template_id="launchTemplateId",
                    launch_template_name="launchTemplateName",
                    version="version"
                ),
                overrides=[ec2_mixins.CfnEC2FleetPropsMixin.FleetLaunchTemplateOverridesRequestProperty(
                    availability_zone="availabilityZone",
                    availability_zone_id="availabilityZoneId",
                    block_device_mappings=[ec2_mixins.CfnEC2FleetPropsMixin.BlockDeviceMappingProperty(
                        device_name="deviceName",
                        ebs=ec2_mixins.CfnEC2FleetPropsMixin.EbsBlockDeviceProperty(
                            delete_on_termination=False,
                            encrypted=False,
                            iops=123,
                            kms_key_id="kmsKeyId",
                            snapshot_id="snapshotId",
                            volume_size=123,
                            volume_type="volumeType"
                        ),
                        no_device="noDevice",
                        virtual_name="virtualName"
                    )],
                    instance_requirements=ec2_mixins.CfnEC2FleetPropsMixin.InstanceRequirementsRequestProperty(
                        accelerator_count=ec2_mixins.CfnEC2FleetPropsMixin.AcceleratorCountRequestProperty(
                            max=123,
                            min=123
                        ),
                        accelerator_manufacturers=["acceleratorManufacturers"],
                        accelerator_names=["acceleratorNames"],
                        accelerator_total_memory_mi_b=ec2_mixins.CfnEC2FleetPropsMixin.AcceleratorTotalMemoryMiBRequestProperty(
                            max=123,
                            min=123
                        ),
                        accelerator_types=["acceleratorTypes"],
                        allowed_instance_types=["allowedInstanceTypes"],
                        bare_metal="bareMetal",
                        baseline_ebs_bandwidth_mbps=ec2_mixins.CfnEC2FleetPropsMixin.BaselineEbsBandwidthMbpsRequestProperty(
                            max=123,
                            min=123
                        ),
                        baseline_performance_factors=ec2_mixins.CfnEC2FleetPropsMixin.BaselinePerformanceFactorsRequestProperty(
                            cpu=ec2_mixins.CfnEC2FleetPropsMixin.CpuPerformanceFactorRequestProperty(
                                references=[ec2_mixins.CfnEC2FleetPropsMixin.PerformanceFactorReferenceRequestProperty(
                                    instance_family="instanceFamily"
                                )]
                            )
                        ),
                        burstable_performance="burstablePerformance",
                        cpu_manufacturers=["cpuManufacturers"],
                        excluded_instance_types=["excludedInstanceTypes"],
                        instance_generations=["instanceGenerations"],
                        local_storage="localStorage",
                        local_storage_types=["localStorageTypes"],
                        max_spot_price_as_percentage_of_optimal_on_demand_price=123,
                        memory_gi_bPer_vCpu=ec2_mixins.CfnEC2FleetPropsMixin.MemoryGiBPerVCpuRequestProperty(
                            max=123,
                            min=123
                        ),
                        memory_mi_b=ec2_mixins.CfnEC2FleetPropsMixin.MemoryMiBRequestProperty(
                            max=123,
                            min=123
                        ),
                        network_bandwidth_gbps=ec2_mixins.CfnEC2FleetPropsMixin.NetworkBandwidthGbpsRequestProperty(
                            max=123,
                            min=123
                        ),
                        network_interface_count=ec2_mixins.CfnEC2FleetPropsMixin.NetworkInterfaceCountRequestProperty(
                            max=123,
                            min=123
                        ),
                        on_demand_max_price_percentage_over_lowest_price=123,
                        require_encryption_in_transit=False,
                        require_hibernate_support=False,
                        spot_max_price_percentage_over_lowest_price=123,
                        total_local_storage_gb=ec2_mixins.CfnEC2FleetPropsMixin.TotalLocalStorageGBRequestProperty(
                            max=123,
                            min=123
                        ),
                        v_cpu_count=ec2_mixins.CfnEC2FleetPropsMixin.VCpuCountRangeRequestProperty(
                            max=123,
                            min=123
                        )
                    ),
                    instance_type="instanceType",
                    max_price="maxPrice",
                    placement=ec2_mixins.CfnEC2FleetPropsMixin.PlacementProperty(
                        affinity="affinity",
                        availability_zone="availabilityZone",
                        group_name="groupName",
                        host_id="hostId",
                        host_resource_group_arn="hostResourceGroupArn",
                        partition_number=123,
                        spread_domain="spreadDomain",
                        tenancy="tenancy"
                    ),
                    priority=123,
                    subnet_id="subnetId",
                    weighted_capacity=123
                )]
            )],
            on_demand_options=ec2_mixins.CfnEC2FleetPropsMixin.OnDemandOptionsRequestProperty(
                allocation_strategy="allocationStrategy",
                capacity_reservation_options=ec2_mixins.CfnEC2FleetPropsMixin.CapacityReservationOptionsRequestProperty(
                    usage_strategy="usageStrategy"
                ),
                max_total_price="maxTotalPrice",
                min_target_capacity=123,
                single_availability_zone=False,
                single_instance_type=False
            ),
            replace_unhealthy_instances=False,
            spot_options=ec2_mixins.CfnEC2FleetPropsMixin.SpotOptionsRequestProperty(
                allocation_strategy="allocationStrategy",
                instance_interruption_behavior="instanceInterruptionBehavior",
                instance_pools_to_use_count=123,
                maintenance_strategies=ec2_mixins.CfnEC2FleetPropsMixin.MaintenanceStrategiesProperty(
                    capacity_rebalance=ec2_mixins.CfnEC2FleetPropsMixin.CapacityRebalanceProperty(
                        replacement_strategy="replacementStrategy",
                        termination_delay=123
                    )
                ),
                max_total_price="maxTotalPrice",
                min_target_capacity=123,
                single_availability_zone=False,
                single_instance_type=False
            ),
            tag_specifications=[ec2_mixins.CfnEC2FleetPropsMixin.TagSpecificationProperty(
                resource_type="resourceType",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )],
            target_capacity_specification=ec2_mixins.CfnEC2FleetPropsMixin.TargetCapacitySpecificationRequestProperty(
                default_target_capacity_type="defaultTargetCapacityType",
                on_demand_target_capacity=123,
                spot_target_capacity=123,
                target_capacity_unit_type="targetCapacityUnitType",
                total_target_capacity=123
            ),
            terminate_instances_with_expiration=False,
            type="type",
            valid_from="validFrom",
            valid_until="validUntil"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnEC2FleetMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::EC2Fleet``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0a0ade40dd8375fa37b4226524a397ab1e9114fb72e7737155dd78a5b76e75bc)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5bfe67ab3699fc3f4c738ad48abe6388d54243f98492d69f4c93c7c3618189b6)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6ba37d3a19b49ccecd0f4db3ea26c1da03393cce53dd9e04ccf26eb102e2bfdf)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnEC2FleetMixinProps":
        return typing.cast("CfnEC2FleetMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnEC2FleetPropsMixin.AcceleratorCountRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class AcceleratorCountRequestProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.

            To exclude accelerator-enabled instance types, set ``Max`` to ``0`` .

            :param max: The maximum number of accelerators. To specify no maximum limit, omit this parameter. To exclude accelerator-enabled instance types, set ``Max`` to ``0`` .
            :param min: The minimum number of accelerators. To specify no minimum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-acceleratorcountrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                accelerator_count_request_property = ec2_mixins.CfnEC2FleetPropsMixin.AcceleratorCountRequestProperty(
                    max=123,
                    min=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__cfec8755e0a8853197672fda7e7aeee5b7cb713427780e884e7907ef384db5c4)
                check_type(argname="argument max", value=max, expected_type=type_hints["max"])
                check_type(argname="argument min", value=min, expected_type=type_hints["min"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum number of accelerators.

            To specify no maximum limit, omit this parameter. To exclude accelerator-enabled instance types, set ``Max`` to ``0`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-acceleratorcountrequest.html#cfn-ec2-ec2fleet-acceleratorcountrequest-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum number of accelerators.

            To specify no minimum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-acceleratorcountrequest.html#cfn-ec2-ec2fleet-acceleratorcountrequest-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AcceleratorCountRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnEC2FleetPropsMixin.AcceleratorTotalMemoryMiBRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class AcceleratorTotalMemoryMiBRequestProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum amount of total accelerator memory, in MiB.

            :param max: The maximum amount of accelerator memory, in MiB. To specify no maximum limit, omit this parameter.
            :param min: The minimum amount of accelerator memory, in MiB. To specify no minimum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-acceleratortotalmemorymibrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                accelerator_total_memory_mi_bRequest_property = ec2_mixins.CfnEC2FleetPropsMixin.AcceleratorTotalMemoryMiBRequestProperty(
                    max=123,
                    min=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__dcba1647314dce68af996609fa426ff261a7978f1d4e868f14ee6c53f4a2bf15)
                check_type(argname="argument max", value=max, expected_type=type_hints["max"])
                check_type(argname="argument min", value=min, expected_type=type_hints["min"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum amount of accelerator memory, in MiB.

            To specify no maximum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-acceleratortotalmemorymibrequest.html#cfn-ec2-ec2fleet-acceleratortotalmemorymibrequest-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum amount of accelerator memory, in MiB.

            To specify no minimum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-acceleratortotalmemorymibrequest.html#cfn-ec2-ec2fleet-acceleratortotalmemorymibrequest-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AcceleratorTotalMemoryMiBRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnEC2FleetPropsMixin.BaselineEbsBandwidthMbpsRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class BaselineEbsBandwidthMbpsRequestProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps.

            For more information, see `Amazon EBSoptimized instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html>`_ in the *Amazon EC2 User Guide* .

            :param max: The maximum baseline bandwidth, in Mbps. To specify no maximum limit, omit this parameter.
            :param min: The minimum baseline bandwidth, in Mbps. To specify no minimum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-baselineebsbandwidthmbpsrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                baseline_ebs_bandwidth_mbps_request_property = ec2_mixins.CfnEC2FleetPropsMixin.BaselineEbsBandwidthMbpsRequestProperty(
                    max=123,
                    min=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__b874a0c58e0ab53171020a26fffc614eb0c506a9876948d1decf218cb338aff9)
                check_type(argname="argument max", value=max, expected_type=type_hints["max"])
                check_type(argname="argument min", value=min, expected_type=type_hints["min"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum baseline bandwidth, in Mbps.

            To specify no maximum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-baselineebsbandwidthmbpsrequest.html#cfn-ec2-ec2fleet-baselineebsbandwidthmbpsrequest-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum baseline bandwidth, in Mbps.

            To specify no minimum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-baselineebsbandwidthmbpsrequest.html#cfn-ec2-ec2fleet-baselineebsbandwidthmbpsrequest-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "BaselineEbsBandwidthMbpsRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnEC2FleetPropsMixin.BaselinePerformanceFactorsRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"cpu": "cpu"},
    )
    class BaselinePerformanceFactorsRequestProperty:
        def __init__(
            self,
            *,
            cpu: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnEC2FleetPropsMixin.CpuPerformanceFactorRequestProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''The baseline performance to consider, using an instance family as a baseline reference.

            The instance family establishes the lowest acceptable level of performance. Amazon EC2 uses this baseline to guide instance type selection, but there is no guarantee that the selected instance types will always exceed the baseline for every application.

            Currently, this parameter only supports CPU performance as a baseline performance factor. For example, specifying ``c6i`` would use the CPU performance of the ``c6i`` family as the baseline reference.

            :param cpu: The CPU performance to consider, using an instance family as the baseline reference.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-baselineperformancefactorsrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                baseline_performance_factors_request_property = ec2_mixins.CfnEC2FleetPropsMixin.BaselinePerformanceFactorsRequestProperty(
                    cpu=ec2_mixins.CfnEC2FleetPropsMixin.CpuPerformanceFactorRequestProperty(
                        references=[ec2_mixins.CfnEC2FleetPropsMixin.PerformanceFactorReferenceRequestProperty(
                            instance_family="instanceFamily"
                        )]
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__a4df1876735bf0fe3c6cc2993137ee84f2df8761e5e36a6a72caf618ca23e147)
                check_type(argname="argument cpu", value=cpu, expected_type=type_hints["cpu"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if cpu is not None:
                self._values["cpu"] = cpu

        @builtins.property
        def cpu(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.CpuPerformanceFactorRequestProperty"]]:
            '''The CPU performance to consider, using an instance family as the baseline reference.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-baselineperformancefactorsrequest.html#cfn-ec2-ec2fleet-baselineperformancefactorsrequest-cpu
            '''
            result = self._values.get("cpu")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.CpuPerformanceFactorRequestProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "BaselinePerformanceFactorsRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnEC2FleetPropsMixin.BlockDeviceMappingProperty",
        jsii_struct_bases=[],
        name_mapping={
            "device_name": "deviceName",
            "ebs": "ebs",
            "no_device": "noDevice",
            "virtual_name": "virtualName",
        },
    )
    class BlockDeviceMappingProperty:
        def __init__(
            self,
            *,
            device_name: typing.Optional[builtins.str] = None,
            ebs: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnEC2FleetPropsMixin.EbsBlockDeviceProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            no_device: typing.Optional[builtins.str] = None,
            virtual_name: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes a block device mapping, which defines the EBS volumes and instance store volumes to attach to an instance at launch.

            :param device_name: The device name. For available device names, see `Device names for volumes <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/device_naming.html>`_ .
            :param ebs: Parameters used to automatically set up EBS volumes when the instance is launched.
            :param no_device: To omit the device from the block device mapping, specify an empty string. When this property is specified, the device is removed from the block device mapping regardless of the assigned value.
            :param virtual_name: The virtual device name ( ``ephemeral`` N). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for ``ephemeral0`` and ``ephemeral1`` . The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume. NVMe instance store volumes are automatically enumerated and assigned a device name. Including them in your block device mapping has no effect. Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-blockdevicemapping.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                block_device_mapping_property = ec2_mixins.CfnEC2FleetPropsMixin.BlockDeviceMappingProperty(
                    device_name="deviceName",
                    ebs=ec2_mixins.CfnEC2FleetPropsMixin.EbsBlockDeviceProperty(
                        delete_on_termination=False,
                        encrypted=False,
                        iops=123,
                        kms_key_id="kmsKeyId",
                        snapshot_id="snapshotId",
                        volume_size=123,
                        volume_type="volumeType"
                    ),
                    no_device="noDevice",
                    virtual_name="virtualName"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__53f20dcd475275e245a8e352d10b4134acc05d1ae953a0d94ba3ba13f86429fe)
                check_type(argname="argument device_name", value=device_name, expected_type=type_hints["device_name"])
                check_type(argname="argument ebs", value=ebs, expected_type=type_hints["ebs"])
                check_type(argname="argument no_device", value=no_device, expected_type=type_hints["no_device"])
                check_type(argname="argument virtual_name", value=virtual_name, expected_type=type_hints["virtual_name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if device_name is not None:
                self._values["device_name"] = device_name
            if ebs is not None:
                self._values["ebs"] = ebs
            if no_device is not None:
                self._values["no_device"] = no_device
            if virtual_name is not None:
                self._values["virtual_name"] = virtual_name

        @builtins.property
        def device_name(self) -> typing.Optional[builtins.str]:
            '''The device name.

            For available device names, see `Device names for volumes <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/device_naming.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-blockdevicemapping.html#cfn-ec2-ec2fleet-blockdevicemapping-devicename
            '''
            result = self._values.get("device_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def ebs(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.EbsBlockDeviceProperty"]]:
            '''Parameters used to automatically set up EBS volumes when the instance is launched.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-blockdevicemapping.html#cfn-ec2-ec2fleet-blockdevicemapping-ebs
            '''
            result = self._values.get("ebs")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.EbsBlockDeviceProperty"]], result)

        @builtins.property
        def no_device(self) -> typing.Optional[builtins.str]:
            '''To omit the device from the block device mapping, specify an empty string.

            When this property is specified, the device is removed from the block device mapping regardless of the assigned value.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-blockdevicemapping.html#cfn-ec2-ec2fleet-blockdevicemapping-nodevice
            '''
            result = self._values.get("no_device")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def virtual_name(self) -> typing.Optional[builtins.str]:
            '''The virtual device name ( ``ephemeral`` N).

            Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for ``ephemeral0`` and ``ephemeral1`` . The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.

            NVMe instance store volumes are automatically enumerated and assigned a device name. Including them in your block device mapping has no effect.

            Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-blockdevicemapping.html#cfn-ec2-ec2fleet-blockdevicemapping-virtualname
            '''
            result = self._values.get("virtual_name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "BlockDeviceMappingProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnEC2FleetPropsMixin.CapacityRebalanceProperty",
        jsii_struct_bases=[],
        name_mapping={
            "replacement_strategy": "replacementStrategy",
            "termination_delay": "terminationDelay",
        },
    )
    class CapacityRebalanceProperty:
        def __init__(
            self,
            *,
            replacement_strategy: typing.Optional[builtins.str] = None,
            termination_delay: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The Spot Instance replacement strategy to use when Amazon EC2 emits a rebalance notification signal that your Spot Instance is at an elevated risk of being interrupted.

            For more information, see `Capacity rebalancing <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-capacity-rebalance.html>`_ in the *Amazon EC2 User Guide* .

            :param replacement_strategy: The replacement strategy to use. Only available for fleets of type ``maintain`` . ``launch`` - EC2 Fleet launches a replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet. EC2 Fleet does not terminate the instances that receive a rebalance notification. You can terminate the old instances, or you can leave them running. You are charged for all instances while they are running. ``launch-before-terminate`` - EC2 Fleet launches a replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet, and then, after a delay that you specify (in ``TerminationDelay`` ), terminates the instances that received a rebalance notification.
            :param termination_delay: The amount of time (in seconds) that Amazon EC2 waits before terminating the old Spot Instance after launching a new replacement Spot Instance. Required when ``ReplacementStrategy`` is set to ``launch-before-terminate`` . Not valid when ``ReplacementStrategy`` is set to ``launch`` . Valid values: Minimum value of ``120`` seconds. Maximum value of ``7200`` seconds.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-capacityrebalance.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                capacity_rebalance_property = ec2_mixins.CfnEC2FleetPropsMixin.CapacityRebalanceProperty(
                    replacement_strategy="replacementStrategy",
                    termination_delay=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__01e71c82d4b4a997b932b845ac413428604802ef5500fc521e3d7ed23e3759aa)
                check_type(argname="argument replacement_strategy", value=replacement_strategy, expected_type=type_hints["replacement_strategy"])
                check_type(argname="argument termination_delay", value=termination_delay, expected_type=type_hints["termination_delay"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if replacement_strategy is not None:
                self._values["replacement_strategy"] = replacement_strategy
            if termination_delay is not None:
                self._values["termination_delay"] = termination_delay

        @builtins.property
        def replacement_strategy(self) -> typing.Optional[builtins.str]:
            '''The replacement strategy to use. Only available for fleets of type ``maintain`` .

            ``launch`` - EC2 Fleet launches a replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet. EC2 Fleet does not terminate the instances that receive a rebalance notification. You can terminate the old instances, or you can leave them running. You are charged for all instances while they are running.

            ``launch-before-terminate`` - EC2 Fleet launches a replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet, and then, after a delay that you specify (in ``TerminationDelay`` ), terminates the instances that received a rebalance notification.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-capacityrebalance.html#cfn-ec2-ec2fleet-capacityrebalance-replacementstrategy
            '''
            result = self._values.get("replacement_strategy")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def termination_delay(self) -> typing.Optional[jsii.Number]:
            '''The amount of time (in seconds) that Amazon EC2 waits before terminating the old Spot Instance after launching a new replacement Spot Instance.

            Required when ``ReplacementStrategy`` is set to ``launch-before-terminate`` .

            Not valid when ``ReplacementStrategy`` is set to ``launch`` .

            Valid values: Minimum value of ``120`` seconds. Maximum value of ``7200`` seconds.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-capacityrebalance.html#cfn-ec2-ec2fleet-capacityrebalance-terminationdelay
            '''
            result = self._values.get("termination_delay")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "CapacityRebalanceProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnEC2FleetPropsMixin.CapacityReservationOptionsRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"usage_strategy": "usageStrategy"},
    )
    class CapacityReservationOptionsRequestProperty:
        def __init__(
            self,
            *,
            usage_strategy: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes the strategy for using unused Capacity Reservations for fulfilling On-Demand capacity.

            .. epigraph::

               This strategy can only be used if the EC2 Fleet is of type ``instant`` .

            For more information about Capacity Reservations, see `On-Demand Capacity Reservations <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-capacity-reservations.html>`_ in the *Amazon EC2 User Guide* . For examples of using Capacity Reservations in an EC2 Fleet, see `EC2 Fleet example configurations <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-examples.html>`_ in the *Amazon EC2 User Guide* .

            :param usage_strategy: Indicates whether to use unused Capacity Reservations for fulfilling On-Demand capacity. If you specify ``use-capacity-reservations-first`` , the fleet uses unused Capacity Reservations to fulfill On-Demand capacity up to the target On-Demand capacity. If multiple instance pools have unused Capacity Reservations, the On-Demand allocation strategy ( ``lowest-price`` or ``prioritized`` ) is applied. If the number of unused Capacity Reservations is less than the On-Demand target capacity, the remaining On-Demand target capacity is launched according to the On-Demand allocation strategy ( ``lowest-price`` or ``prioritized`` ). If you do not specify a value, the fleet fulfils the On-Demand capacity according to the chosen On-Demand allocation strategy.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-capacityreservationoptionsrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                capacity_reservation_options_request_property = ec2_mixins.CfnEC2FleetPropsMixin.CapacityReservationOptionsRequestProperty(
                    usage_strategy="usageStrategy"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__b4983a1d19e4a2078d9191504bc7e94ada1a5a53bd8e873380d4716683c2df12)
                check_type(argname="argument usage_strategy", value=usage_strategy, expected_type=type_hints["usage_strategy"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if usage_strategy is not None:
                self._values["usage_strategy"] = usage_strategy

        @builtins.property
        def usage_strategy(self) -> typing.Optional[builtins.str]:
            '''Indicates whether to use unused Capacity Reservations for fulfilling On-Demand capacity.

            If you specify ``use-capacity-reservations-first`` , the fleet uses unused Capacity Reservations to fulfill On-Demand capacity up to the target On-Demand capacity. If multiple instance pools have unused Capacity Reservations, the On-Demand allocation strategy ( ``lowest-price`` or ``prioritized`` ) is applied. If the number of unused Capacity Reservations is less than the On-Demand target capacity, the remaining On-Demand target capacity is launched according to the On-Demand allocation strategy ( ``lowest-price`` or ``prioritized`` ).

            If you do not specify a value, the fleet fulfils the On-Demand capacity according to the chosen On-Demand allocation strategy.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-capacityreservationoptionsrequest.html#cfn-ec2-ec2fleet-capacityreservationoptionsrequest-usagestrategy
            '''
            result = self._values.get("usage_strategy")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "CapacityReservationOptionsRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnEC2FleetPropsMixin.CpuPerformanceFactorRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"references": "references"},
    )
    class CpuPerformanceFactorRequestProperty:
        def __init__(
            self,
            *,
            references: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnEC2FleetPropsMixin.PerformanceFactorReferenceRequestProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ) -> None:
            '''The CPU performance to consider, using an instance family as the baseline reference.

            :param references: Specify an instance family to use as the baseline reference for CPU performance. All instance types that match your specified attributes will be compared against the CPU performance of the referenced instance family, regardless of CPU manufacturer or architecture differences. .. epigraph:: Currently, only one instance family can be specified in the list.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-cpuperformancefactorrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                cpu_performance_factor_request_property = ec2_mixins.CfnEC2FleetPropsMixin.CpuPerformanceFactorRequestProperty(
                    references=[ec2_mixins.CfnEC2FleetPropsMixin.PerformanceFactorReferenceRequestProperty(
                        instance_family="instanceFamily"
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__ac34f70b114a4821e78e30f4c5d37930ed5122d709c6d576ee23c09380a9ea6c)
                check_type(argname="argument references", value=references, expected_type=type_hints["references"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if references is not None:
                self._values["references"] = references

        @builtins.property
        def references(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.PerformanceFactorReferenceRequestProperty"]]]]:
            '''Specify an instance family to use as the baseline reference for CPU performance.

            All instance types that match your specified attributes will be compared against the CPU performance of the referenced instance family, regardless of CPU manufacturer or architecture differences.
            .. epigraph::

               Currently, only one instance family can be specified in the list.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-cpuperformancefactorrequest.html#cfn-ec2-ec2fleet-cpuperformancefactorrequest-references
            '''
            result = self._values.get("references")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.PerformanceFactorReferenceRequestProperty"]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "CpuPerformanceFactorRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnEC2FleetPropsMixin.EbsBlockDeviceProperty",
        jsii_struct_bases=[],
        name_mapping={
            "delete_on_termination": "deleteOnTermination",
            "encrypted": "encrypted",
            "iops": "iops",
            "kms_key_id": "kmsKeyId",
            "snapshot_id": "snapshotId",
            "volume_size": "volumeSize",
            "volume_type": "volumeType",
        },
    )
    class EbsBlockDeviceProperty:
        def __init__(
            self,
            *,
            delete_on_termination: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            encrypted: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            iops: typing.Optional[jsii.Number] = None,
            kms_key_id: typing.Optional[builtins.str] = None,
            snapshot_id: typing.Optional[builtins.str] = None,
            volume_size: typing.Optional[jsii.Number] = None,
            volume_type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes a block device for an EBS volume.

            :param delete_on_termination: Indicates whether the EBS volume is deleted on instance termination. For more information, see `Preserving Amazon EBS volumes on instance termination <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination>`_ in the *Amazon EC2 User Guide* .
            :param encrypted: Indicates whether the encryption state of an EBS volume is changed while being restored from a backing snapshot. The effect of setting the encryption state to ``true`` depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see `Amazon EBS encryption <https://docs.aws.amazon.com/ebs/latest/userguide/ebs-encryption.html#encryption-parameters>`_ in the *Amazon EBS User Guide* . In no case can you remove encryption from an encrypted volume. Encrypted volumes can only be attached to instances that support Amazon EBS encryption. For more information, see `Supported instance types <https://docs.aws.amazon.com/ebs/latest/userguide/ebs-encryption-requirements.html#ebs-encryption_supported_instances>`_ . - If you are creating a block device mapping for a *new (empty) volume* , you can include this parameter, and specify either ``true`` for an encrypted volume, or ``false`` for an unencrypted volume. If you omit this parameter, it defaults to ``false`` (unencrypted). - If you are creating a block device mapping from an *existing encrypted or unencrypted snapshot* , you must omit this parameter. If you include this parameter, the request will fail, regardless of the value that you specify. - If you are creating a block device mapping from an *existing unencrypted volume* , you can include this parameter, but you must specify ``false`` . If you specify ``true`` , the request will fail. In this case, we recommend that you omit the parameter. - If you are creating a block device mapping from an *existing encrypted volume* , you can include this parameter, and specify either ``true`` or ``false`` . However, if you specify ``false`` , the parameter is ignored and the block device mapping is always encrypted. In this case, we recommend that you omit the parameter.
            :param iops: The number of I/O operations per second (IOPS). For ``gp3`` , ``io1`` , and ``io2`` volumes, this represents the number of IOPS that are provisioned for the volume. For ``gp2`` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. The following are the supported values for each volume type: - ``gp3`` : 3,000 - 80,000 IOPS - ``io1`` : 100 - 64,000 IOPS - ``io2`` : 100 - 256,000 IOPS For ``io2`` volumes, you can achieve up to 256,000 IOPS on `instances built on the Nitro System <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances>`_ . On other instances, you can achieve performance up to 32,000 IOPS. This parameter is required for ``io1`` and ``io2`` volumes. The default for ``gp3`` volumes is 3,000 IOPS.
            :param kms_key_id: Identifier (key ID, key alias, key ARN, or alias ARN) of the customer managed KMS key to use for EBS encryption. This parameter is only supported on ``BlockDeviceMapping`` objects called by `RunInstances <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html>`_ , `RequestSpotFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotFleet.html>`_ , and `RequestSpotInstances <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotInstances.html>`_ .
            :param snapshot_id: The ID of the snapshot.
            :param volume_size: The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size. The following are the supported sizes for each volume type: - ``gp2`` : 1 - 16,384 GiB - ``gp3`` : 1 - 65,536 GiB - ``io1`` : 4 - 16,384 GiB - ``io2`` : 4 - 65,536 GiB - ``st1`` and ``sc1`` : 125 - 16,384 GiB - ``standard`` : 1 - 1024 GiB
            :param volume_type: The volume type. For more information, see `Amazon EBS volume types <https://docs.aws.amazon.com/ebs/latest/userguide/ebs-volume-types.html>`_ in the *Amazon EBS User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ebsblockdevice.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                ebs_block_device_property = ec2_mixins.CfnEC2FleetPropsMixin.EbsBlockDeviceProperty(
                    delete_on_termination=False,
                    encrypted=False,
                    iops=123,
                    kms_key_id="kmsKeyId",
                    snapshot_id="snapshotId",
                    volume_size=123,
                    volume_type="volumeType"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__388deb8d8cce1233cbf8ec2981e1d6458148d81f0142257a2480a5867413ae8d)
                check_type(argname="argument delete_on_termination", value=delete_on_termination, expected_type=type_hints["delete_on_termination"])
                check_type(argname="argument encrypted", value=encrypted, expected_type=type_hints["encrypted"])
                check_type(argname="argument iops", value=iops, expected_type=type_hints["iops"])
                check_type(argname="argument kms_key_id", value=kms_key_id, expected_type=type_hints["kms_key_id"])
                check_type(argname="argument snapshot_id", value=snapshot_id, expected_type=type_hints["snapshot_id"])
                check_type(argname="argument volume_size", value=volume_size, expected_type=type_hints["volume_size"])
                check_type(argname="argument volume_type", value=volume_type, expected_type=type_hints["volume_type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if delete_on_termination is not None:
                self._values["delete_on_termination"] = delete_on_termination
            if encrypted is not None:
                self._values["encrypted"] = encrypted
            if iops is not None:
                self._values["iops"] = iops
            if kms_key_id is not None:
                self._values["kms_key_id"] = kms_key_id
            if snapshot_id is not None:
                self._values["snapshot_id"] = snapshot_id
            if volume_size is not None:
                self._values["volume_size"] = volume_size
            if volume_type is not None:
                self._values["volume_type"] = volume_type

        @builtins.property
        def delete_on_termination(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether the EBS volume is deleted on instance termination.

            For more information, see `Preserving Amazon EBS volumes on instance termination <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination>`_ in the *Amazon EC2 User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ebsblockdevice.html#cfn-ec2-ec2fleet-ebsblockdevice-deleteontermination
            '''
            result = self._values.get("delete_on_termination")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def encrypted(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether the encryption state of an EBS volume is changed while being restored from a backing snapshot.

            The effect of setting the encryption state to ``true`` depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see `Amazon EBS encryption <https://docs.aws.amazon.com/ebs/latest/userguide/ebs-encryption.html#encryption-parameters>`_ in the *Amazon EBS User Guide* .

            In no case can you remove encryption from an encrypted volume.

            Encrypted volumes can only be attached to instances that support Amazon EBS encryption. For more information, see `Supported instance types <https://docs.aws.amazon.com/ebs/latest/userguide/ebs-encryption-requirements.html#ebs-encryption_supported_instances>`_ .

            - If you are creating a block device mapping for a *new (empty) volume* , you can include this parameter, and specify either ``true`` for an encrypted volume, or ``false`` for an unencrypted volume. If you omit this parameter, it defaults to ``false`` (unencrypted).
            - If you are creating a block device mapping from an *existing encrypted or unencrypted snapshot* , you must omit this parameter. If you include this parameter, the request will fail, regardless of the value that you specify.
            - If you are creating a block device mapping from an *existing unencrypted volume* , you can include this parameter, but you must specify ``false`` . If you specify ``true`` , the request will fail. In this case, we recommend that you omit the parameter.
            - If you are creating a block device mapping from an *existing encrypted volume* , you can include this parameter, and specify either ``true`` or ``false`` . However, if you specify ``false`` , the parameter is ignored and the block device mapping is always encrypted. In this case, we recommend that you omit the parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ebsblockdevice.html#cfn-ec2-ec2fleet-ebsblockdevice-encrypted
            '''
            result = self._values.get("encrypted")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def iops(self) -> typing.Optional[jsii.Number]:
            '''The number of I/O operations per second (IOPS).

            For ``gp3`` , ``io1`` , and ``io2`` volumes, this represents the number of IOPS that are provisioned for the volume. For ``gp2`` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.

            The following are the supported values for each volume type:

            - ``gp3`` : 3,000 - 80,000 IOPS
            - ``io1`` : 100 - 64,000 IOPS
            - ``io2`` : 100 - 256,000 IOPS

            For ``io2`` volumes, you can achieve up to 256,000 IOPS on `instances built on the Nitro System <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances>`_ . On other instances, you can achieve performance up to 32,000 IOPS.

            This parameter is required for ``io1`` and ``io2`` volumes. The default for ``gp3`` volumes is 3,000 IOPS.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ebsblockdevice.html#cfn-ec2-ec2fleet-ebsblockdevice-iops
            '''
            result = self._values.get("iops")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def kms_key_id(self) -> typing.Optional[builtins.str]:
            '''Identifier (key ID, key alias, key ARN, or alias ARN) of the customer managed KMS key to use for EBS encryption.

            This parameter is only supported on ``BlockDeviceMapping`` objects called by `RunInstances <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html>`_ , `RequestSpotFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotFleet.html>`_ , and `RequestSpotInstances <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotInstances.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ebsblockdevice.html#cfn-ec2-ec2fleet-ebsblockdevice-kmskeyid
            '''
            result = self._values.get("kms_key_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def snapshot_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the snapshot.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ebsblockdevice.html#cfn-ec2-ec2fleet-ebsblockdevice-snapshotid
            '''
            result = self._values.get("snapshot_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def volume_size(self) -> typing.Optional[jsii.Number]:
            '''The size of the volume, in GiBs.

            You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size.

            The following are the supported sizes for each volume type:

            - ``gp2`` : 1 - 16,384 GiB
            - ``gp3`` : 1 - 65,536 GiB
            - ``io1`` : 4 - 16,384 GiB
            - ``io2`` : 4 - 65,536 GiB
            - ``st1`` and ``sc1`` : 125 - 16,384 GiB
            - ``standard`` : 1 - 1024 GiB

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ebsblockdevice.html#cfn-ec2-ec2fleet-ebsblockdevice-volumesize
            '''
            result = self._values.get("volume_size")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def volume_type(self) -> typing.Optional[builtins.str]:
            '''The volume type.

            For more information, see `Amazon EBS volume types <https://docs.aws.amazon.com/ebs/latest/userguide/ebs-volume-types.html>`_ in the *Amazon EBS User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ebsblockdevice.html#cfn-ec2-ec2fleet-ebsblockdevice-volumetype
            '''
            result = self._values.get("volume_type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "EbsBlockDeviceProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnEC2FleetPropsMixin.FleetLaunchTemplateConfigRequestProperty",
        jsii_struct_bases=[],
        name_mapping={
            "launch_template_specification": "launchTemplateSpecification",
            "overrides": "overrides",
        },
    )
    class FleetLaunchTemplateConfigRequestProperty:
        def __init__(
            self,
            *,
            launch_template_specification: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnEC2FleetPropsMixin.FleetLaunchTemplateSpecificationRequestProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            overrides: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnEC2FleetPropsMixin.FleetLaunchTemplateOverridesRequestProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ) -> None:
            '''Specifies a launch template and overrides for an EC2 Fleet.

            ``FleetLaunchTemplateConfigRequest`` is a property of the `AWS::EC2::EC2Fleet <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html>`_ resource.

            :param launch_template_specification: The launch template to use. You must specify either the launch template ID or launch template name in the request.
            :param overrides: Any parameters that you specify override the same parameters in the launch template. For fleets of type ``request`` and ``maintain`` , a maximum of 300 items is allowed across all launch templates.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateconfigrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                fleet_launch_template_config_request_property = ec2_mixins.CfnEC2FleetPropsMixin.FleetLaunchTemplateConfigRequestProperty(
                    launch_template_specification=ec2_mixins.CfnEC2FleetPropsMixin.FleetLaunchTemplateSpecificationRequestProperty(
                        launch_template_id="launchTemplateId",
                        launch_template_name="launchTemplateName",
                        version="version"
                    ),
                    overrides=[ec2_mixins.CfnEC2FleetPropsMixin.FleetLaunchTemplateOverridesRequestProperty(
                        availability_zone="availabilityZone",
                        availability_zone_id="availabilityZoneId",
                        block_device_mappings=[ec2_mixins.CfnEC2FleetPropsMixin.BlockDeviceMappingProperty(
                            device_name="deviceName",
                            ebs=ec2_mixins.CfnEC2FleetPropsMixin.EbsBlockDeviceProperty(
                                delete_on_termination=False,
                                encrypted=False,
                                iops=123,
                                kms_key_id="kmsKeyId",
                                snapshot_id="snapshotId",
                                volume_size=123,
                                volume_type="volumeType"
                            ),
                            no_device="noDevice",
                            virtual_name="virtualName"
                        )],
                        instance_requirements=ec2_mixins.CfnEC2FleetPropsMixin.InstanceRequirementsRequestProperty(
                            accelerator_count=ec2_mixins.CfnEC2FleetPropsMixin.AcceleratorCountRequestProperty(
                                max=123,
                                min=123
                            ),
                            accelerator_manufacturers=["acceleratorManufacturers"],
                            accelerator_names=["acceleratorNames"],
                            accelerator_total_memory_mi_b=ec2_mixins.CfnEC2FleetPropsMixin.AcceleratorTotalMemoryMiBRequestProperty(
                                max=123,
                                min=123
                            ),
                            accelerator_types=["acceleratorTypes"],
                            allowed_instance_types=["allowedInstanceTypes"],
                            bare_metal="bareMetal",
                            baseline_ebs_bandwidth_mbps=ec2_mixins.CfnEC2FleetPropsMixin.BaselineEbsBandwidthMbpsRequestProperty(
                                max=123,
                                min=123
                            ),
                            baseline_performance_factors=ec2_mixins.CfnEC2FleetPropsMixin.BaselinePerformanceFactorsRequestProperty(
                                cpu=ec2_mixins.CfnEC2FleetPropsMixin.CpuPerformanceFactorRequestProperty(
                                    references=[ec2_mixins.CfnEC2FleetPropsMixin.PerformanceFactorReferenceRequestProperty(
                                        instance_family="instanceFamily"
                                    )]
                                )
                            ),
                            burstable_performance="burstablePerformance",
                            cpu_manufacturers=["cpuManufacturers"],
                            excluded_instance_types=["excludedInstanceTypes"],
                            instance_generations=["instanceGenerations"],
                            local_storage="localStorage",
                            local_storage_types=["localStorageTypes"],
                            max_spot_price_as_percentage_of_optimal_on_demand_price=123,
                            memory_gi_bPer_vCpu=ec2_mixins.CfnEC2FleetPropsMixin.MemoryGiBPerVCpuRequestProperty(
                                max=123,
                                min=123
                            ),
                            memory_mi_b=ec2_mixins.CfnEC2FleetPropsMixin.MemoryMiBRequestProperty(
                                max=123,
                                min=123
                            ),
                            network_bandwidth_gbps=ec2_mixins.CfnEC2FleetPropsMixin.NetworkBandwidthGbpsRequestProperty(
                                max=123,
                                min=123
                            ),
                            network_interface_count=ec2_mixins.CfnEC2FleetPropsMixin.NetworkInterfaceCountRequestProperty(
                                max=123,
                                min=123
                            ),
                            on_demand_max_price_percentage_over_lowest_price=123,
                            require_encryption_in_transit=False,
                            require_hibernate_support=False,
                            spot_max_price_percentage_over_lowest_price=123,
                            total_local_storage_gb=ec2_mixins.CfnEC2FleetPropsMixin.TotalLocalStorageGBRequestProperty(
                                max=123,
                                min=123
                            ),
                            v_cpu_count=ec2_mixins.CfnEC2FleetPropsMixin.VCpuCountRangeRequestProperty(
                                max=123,
                                min=123
                            )
                        ),
                        instance_type="instanceType",
                        max_price="maxPrice",
                        placement=ec2_mixins.CfnEC2FleetPropsMixin.PlacementProperty(
                            affinity="affinity",
                            availability_zone="availabilityZone",
                            group_name="groupName",
                            host_id="hostId",
                            host_resource_group_arn="hostResourceGroupArn",
                            partition_number=123,
                            spread_domain="spreadDomain",
                            tenancy="tenancy"
                        ),
                        priority=123,
                        subnet_id="subnetId",
                        weighted_capacity=123
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__dd6edd78c182d5ba8d931f4764b3876c56b2fca323b8e198b814db85587c1304)
                check_type(argname="argument launch_template_specification", value=launch_template_specification, expected_type=type_hints["launch_template_specification"])
                check_type(argname="argument overrides", value=overrides, expected_type=type_hints["overrides"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if launch_template_specification is not None:
                self._values["launch_template_specification"] = launch_template_specification
            if overrides is not None:
                self._values["overrides"] = overrides

        @builtins.property
        def launch_template_specification(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.FleetLaunchTemplateSpecificationRequestProperty"]]:
            '''The launch template to use.

            You must specify either the launch template ID or launch template name in the request.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateconfigrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateconfigrequest-launchtemplatespecification
            '''
            result = self._values.get("launch_template_specification")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.FleetLaunchTemplateSpecificationRequestProperty"]], result)

        @builtins.property
        def overrides(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.FleetLaunchTemplateOverridesRequestProperty"]]]]:
            '''Any parameters that you specify override the same parameters in the launch template.

            For fleets of type ``request`` and ``maintain`` , a maximum of 300 items is allowed across all launch templates.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateconfigrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateconfigrequest-overrides
            '''
            result = self._values.get("overrides")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.FleetLaunchTemplateOverridesRequestProperty"]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "FleetLaunchTemplateConfigRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnEC2FleetPropsMixin.FleetLaunchTemplateOverridesRequestProperty",
        jsii_struct_bases=[],
        name_mapping={
            "availability_zone": "availabilityZone",
            "availability_zone_id": "availabilityZoneId",
            "block_device_mappings": "blockDeviceMappings",
            "instance_requirements": "instanceRequirements",
            "instance_type": "instanceType",
            "max_price": "maxPrice",
            "placement": "placement",
            "priority": "priority",
            "subnet_id": "subnetId",
            "weighted_capacity": "weightedCapacity",
        },
    )
    class FleetLaunchTemplateOverridesRequestProperty:
        def __init__(
            self,
            *,
            availability_zone: typing.Optional[builtins.str] = None,
            availability_zone_id: typing.Optional[builtins.str] = None,
            block_device_mappings: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnEC2FleetPropsMixin.BlockDeviceMappingProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            instance_requirements: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnEC2FleetPropsMixin.InstanceRequirementsRequestProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            instance_type: typing.Optional[builtins.str] = None,
            max_price: typing.Optional[builtins.str] = None,
            placement: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnEC2FleetPropsMixin.PlacementProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            priority: typing.Optional[jsii.Number] = None,
            subnet_id: typing.Optional[builtins.str] = None,
            weighted_capacity: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Specifies overrides for a launch template for an EC2 Fleet.

            ``FleetLaunchTemplateOverridesRequest`` is a property of the `FleetLaunchTemplateConfigRequest <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateconfigrequest.html>`_ property type.

            :param availability_zone: The Availability Zone in which to launch the instances. For example, ``us-east-2a`` . Either ``AvailabilityZone`` or ``AvailabilityZoneId`` must be specified in the request, but not both.
            :param availability_zone_id: The ID of the Availability Zone in which to launch the instances. For example, ``use2-az1`` . Either ``AvailabilityZone`` or ``AvailabilityZoneId`` must be specified in the request, but not both.
            :param block_device_mappings: The block device mappings, which define the EBS volumes and instance store volumes to attach to the instance at launch. Supported only for fleets of type ``instant`` . For more information, see `Block device mappings for volumes on Amazon EC2 instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/block-device-mapping-concepts.html>`_ in the *Amazon EC2 User Guide* .
            :param instance_requirements: The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with those attributes. .. epigraph:: If you specify ``InstanceRequirements`` , you can't specify ``InstanceType`` .
            :param instance_type: The instance type. ``mac1.metal`` is not supported as a launch template override. .. epigraph:: If you specify ``InstanceType`` , you can't specify ``InstanceRequirements`` .
            :param max_price: The maximum price per unit hour that you are willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price. .. epigraph:: If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter. If you specify a maximum price, it must be more than USD $0.001. Specifying a value below USD $0.001 will result in an ``InvalidParameterValue`` error message.
            :param placement: The location where the instance launched, if applicable.
            :param priority: The priority for the launch template override. The highest priority is launched first. If the On-Demand ``AllocationStrategy`` is set to ``prioritized`` , EC2 Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity. If the Spot ``AllocationStrategy`` is set to ``capacity-optimized-prioritized`` , EC2 Fleet uses priority on a best-effort basis to determine which launch template override to use in fulfilling Spot capacity, but optimizes for capacity first. Valid values are whole numbers starting at ``0`` . The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority. You can set the same priority for different launch template overrides.
            :param subnet_id: The IDs of the subnets in which to launch the instances. Separate multiple subnet IDs using commas (for example, ``subnet-1234abcdeexample1, subnet-0987cdef6example2`` ). A request of type ``instant`` can have only one subnet ID.
            :param weighted_capacity: The number of units provided by the specified instance type. These are the same units that you chose to set the target capacity in terms of instances, or a performance characteristic such as vCPUs, memory, or I/O. If the target capacity divided by this value is not a whole number, Amazon EC2 rounds the number of instances to the next whole number. If this value is not specified, the default is 1. .. epigraph:: When specifying weights, the price used in the ``lowest-price`` and ``price-capacity-optimized`` allocation strategies is per *unit* hour (where the instance price is divided by the specified weight). However, if all the specified weights are above the requested ``TargetCapacity`` , resulting in only 1 instance being launched, the price used is per *instance* hour.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                fleet_launch_template_overrides_request_property = ec2_mixins.CfnEC2FleetPropsMixin.FleetLaunchTemplateOverridesRequestProperty(
                    availability_zone="availabilityZone",
                    availability_zone_id="availabilityZoneId",
                    block_device_mappings=[ec2_mixins.CfnEC2FleetPropsMixin.BlockDeviceMappingProperty(
                        device_name="deviceName",
                        ebs=ec2_mixins.CfnEC2FleetPropsMixin.EbsBlockDeviceProperty(
                            delete_on_termination=False,
                            encrypted=False,
                            iops=123,
                            kms_key_id="kmsKeyId",
                            snapshot_id="snapshotId",
                            volume_size=123,
                            volume_type="volumeType"
                        ),
                        no_device="noDevice",
                        virtual_name="virtualName"
                    )],
                    instance_requirements=ec2_mixins.CfnEC2FleetPropsMixin.InstanceRequirementsRequestProperty(
                        accelerator_count=ec2_mixins.CfnEC2FleetPropsMixin.AcceleratorCountRequestProperty(
                            max=123,
                            min=123
                        ),
                        accelerator_manufacturers=["acceleratorManufacturers"],
                        accelerator_names=["acceleratorNames"],
                        accelerator_total_memory_mi_b=ec2_mixins.CfnEC2FleetPropsMixin.AcceleratorTotalMemoryMiBRequestProperty(
                            max=123,
                            min=123
                        ),
                        accelerator_types=["acceleratorTypes"],
                        allowed_instance_types=["allowedInstanceTypes"],
                        bare_metal="bareMetal",
                        baseline_ebs_bandwidth_mbps=ec2_mixins.CfnEC2FleetPropsMixin.BaselineEbsBandwidthMbpsRequestProperty(
                            max=123,
                            min=123
                        ),
                        baseline_performance_factors=ec2_mixins.CfnEC2FleetPropsMixin.BaselinePerformanceFactorsRequestProperty(
                            cpu=ec2_mixins.CfnEC2FleetPropsMixin.CpuPerformanceFactorRequestProperty(
                                references=[ec2_mixins.CfnEC2FleetPropsMixin.PerformanceFactorReferenceRequestProperty(
                                    instance_family="instanceFamily"
                                )]
                            )
                        ),
                        burstable_performance="burstablePerformance",
                        cpu_manufacturers=["cpuManufacturers"],
                        excluded_instance_types=["excludedInstanceTypes"],
                        instance_generations=["instanceGenerations"],
                        local_storage="localStorage",
                        local_storage_types=["localStorageTypes"],
                        max_spot_price_as_percentage_of_optimal_on_demand_price=123,
                        memory_gi_bPer_vCpu=ec2_mixins.CfnEC2FleetPropsMixin.MemoryGiBPerVCpuRequestProperty(
                            max=123,
                            min=123
                        ),
                        memory_mi_b=ec2_mixins.CfnEC2FleetPropsMixin.MemoryMiBRequestProperty(
                            max=123,
                            min=123
                        ),
                        network_bandwidth_gbps=ec2_mixins.CfnEC2FleetPropsMixin.NetworkBandwidthGbpsRequestProperty(
                            max=123,
                            min=123
                        ),
                        network_interface_count=ec2_mixins.CfnEC2FleetPropsMixin.NetworkInterfaceCountRequestProperty(
                            max=123,
                            min=123
                        ),
                        on_demand_max_price_percentage_over_lowest_price=123,
                        require_encryption_in_transit=False,
                        require_hibernate_support=False,
                        spot_max_price_percentage_over_lowest_price=123,
                        total_local_storage_gb=ec2_mixins.CfnEC2FleetPropsMixin.TotalLocalStorageGBRequestProperty(
                            max=123,
                            min=123
                        ),
                        v_cpu_count=ec2_mixins.CfnEC2FleetPropsMixin.VCpuCountRangeRequestProperty(
                            max=123,
                            min=123
                        )
                    ),
                    instance_type="instanceType",
                    max_price="maxPrice",
                    placement=ec2_mixins.CfnEC2FleetPropsMixin.PlacementProperty(
                        affinity="affinity",
                        availability_zone="availabilityZone",
                        group_name="groupName",
                        host_id="hostId",
                        host_resource_group_arn="hostResourceGroupArn",
                        partition_number=123,
                        spread_domain="spreadDomain",
                        tenancy="tenancy"
                    ),
                    priority=123,
                    subnet_id="subnetId",
                    weighted_capacity=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__7e74815cc8aea50de1461d2341e9c78df1cc47803ee7eb255fb1ea541fbc0fd7)
                check_type(argname="argument availability_zone", value=availability_zone, expected_type=type_hints["availability_zone"])
                check_type(argname="argument availability_zone_id", value=availability_zone_id, expected_type=type_hints["availability_zone_id"])
                check_type(argname="argument block_device_mappings", value=block_device_mappings, expected_type=type_hints["block_device_mappings"])
                check_type(argname="argument instance_requirements", value=instance_requirements, expected_type=type_hints["instance_requirements"])
                check_type(argname="argument instance_type", value=instance_type, expected_type=type_hints["instance_type"])
                check_type(argname="argument max_price", value=max_price, expected_type=type_hints["max_price"])
                check_type(argname="argument placement", value=placement, expected_type=type_hints["placement"])
                check_type(argname="argument priority", value=priority, expected_type=type_hints["priority"])
                check_type(argname="argument subnet_id", value=subnet_id, expected_type=type_hints["subnet_id"])
                check_type(argname="argument weighted_capacity", value=weighted_capacity, expected_type=type_hints["weighted_capacity"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if availability_zone is not None:
                self._values["availability_zone"] = availability_zone
            if availability_zone_id is not None:
                self._values["availability_zone_id"] = availability_zone_id
            if block_device_mappings is not None:
                self._values["block_device_mappings"] = block_device_mappings
            if instance_requirements is not None:
                self._values["instance_requirements"] = instance_requirements
            if instance_type is not None:
                self._values["instance_type"] = instance_type
            if max_price is not None:
                self._values["max_price"] = max_price
            if placement is not None:
                self._values["placement"] = placement
            if priority is not None:
                self._values["priority"] = priority
            if subnet_id is not None:
                self._values["subnet_id"] = subnet_id
            if weighted_capacity is not None:
                self._values["weighted_capacity"] = weighted_capacity

        @builtins.property
        def availability_zone(self) -> typing.Optional[builtins.str]:
            '''The Availability Zone in which to launch the instances. For example, ``us-east-2a`` .

            Either ``AvailabilityZone`` or ``AvailabilityZoneId`` must be specified in the request, but not both.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest-availabilityzone
            '''
            result = self._values.get("availability_zone")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def availability_zone_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the Availability Zone in which to launch the instances. For example, ``use2-az1`` .

            Either ``AvailabilityZone`` or ``AvailabilityZoneId`` must be specified in the request, but not both.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest-availabilityzoneid
            '''
            result = self._values.get("availability_zone_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def block_device_mappings(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.BlockDeviceMappingProperty"]]]]:
            '''The block device mappings, which define the EBS volumes and instance store volumes to attach to the instance at launch.

            Supported only for fleets of type ``instant`` .

            For more information, see `Block device mappings for volumes on Amazon EC2 instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/block-device-mapping-concepts.html>`_ in the *Amazon EC2 User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest-blockdevicemappings
            '''
            result = self._values.get("block_device_mappings")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.BlockDeviceMappingProperty"]]]], result)

        @builtins.property
        def instance_requirements(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.InstanceRequirementsRequestProperty"]]:
            '''The attributes for the instance types.

            When you specify instance attributes, Amazon EC2 will identify instance types with those attributes.
            .. epigraph::

               If you specify ``InstanceRequirements`` , you can't specify ``InstanceType`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest-instancerequirements
            '''
            result = self._values.get("instance_requirements")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.InstanceRequirementsRequestProperty"]], result)

        @builtins.property
        def instance_type(self) -> typing.Optional[builtins.str]:
            '''The instance type.

            ``mac1.metal`` is not supported as a launch template override.
            .. epigraph::

               If you specify ``InstanceType`` , you can't specify ``InstanceRequirements`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest-instancetype
            '''
            result = self._values.get("instance_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def max_price(self) -> typing.Optional[builtins.str]:
            '''The maximum price per unit hour that you are willing to pay for a Spot Instance.

            We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.
            .. epigraph::

               If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.

               If you specify a maximum price, it must be more than USD $0.001. Specifying a value below USD $0.001 will result in an ``InvalidParameterValue`` error message.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest-maxprice
            '''
            result = self._values.get("max_price")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def placement(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.PlacementProperty"]]:
            '''The location where the instance launched, if applicable.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest-placement
            '''
            result = self._values.get("placement")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.PlacementProperty"]], result)

        @builtins.property
        def priority(self) -> typing.Optional[jsii.Number]:
            '''The priority for the launch template override. The highest priority is launched first.

            If the On-Demand ``AllocationStrategy`` is set to ``prioritized`` , EC2 Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity.

            If the Spot ``AllocationStrategy`` is set to ``capacity-optimized-prioritized`` , EC2 Fleet uses priority on a best-effort basis to determine which launch template override to use in fulfilling Spot capacity, but optimizes for capacity first.

            Valid values are whole numbers starting at ``0`` . The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority. You can set the same priority for different launch template overrides.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest-priority
            '''
            result = self._values.get("priority")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def subnet_id(self) -> typing.Optional[builtins.str]:
            '''The IDs of the subnets in which to launch the instances.

            Separate multiple subnet IDs using commas (for example, ``subnet-1234abcdeexample1, subnet-0987cdef6example2`` ). A request of type ``instant`` can have only one subnet ID.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest-subnetid
            '''
            result = self._values.get("subnet_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def weighted_capacity(self) -> typing.Optional[jsii.Number]:
            '''The number of units provided by the specified instance type.

            These are the same units that you chose to set the target capacity in terms of instances, or a performance characteristic such as vCPUs, memory, or I/O.

            If the target capacity divided by this value is not a whole number, Amazon EC2 rounds the number of instances to the next whole number. If this value is not specified, the default is 1.
            .. epigraph::

               When specifying weights, the price used in the ``lowest-price`` and ``price-capacity-optimized`` allocation strategies is per *unit* hour (where the instance price is divided by the specified weight). However, if all the specified weights are above the requested ``TargetCapacity`` , resulting in only 1 instance being launched, the price used is per *instance* hour.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest-weightedcapacity
            '''
            result = self._values.get("weighted_capacity")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "FleetLaunchTemplateOverridesRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnEC2FleetPropsMixin.FleetLaunchTemplateSpecificationRequestProperty",
        jsii_struct_bases=[],
        name_mapping={
            "launch_template_id": "launchTemplateId",
            "launch_template_name": "launchTemplateName",
            "version": "version",
        },
    )
    class FleetLaunchTemplateSpecificationRequestProperty:
        def __init__(
            self,
            *,
            launch_template_id: typing.Optional[builtins.str] = None,
            launch_template_name: typing.Optional[builtins.str] = None,
            version: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies the launch template to be used by the EC2 Fleet for configuring Amazon EC2 instances.

            You must specify the following:

            - The ID or the name of the launch template, but not both.
            - The version of the launch template.

            ``FleetLaunchTemplateSpecificationRequest`` is a property of the `FleetLaunchTemplateConfigRequest <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateconfigrequest.html>`_ property type.

            For information about creating a launch template, see `AWS::EC2::LaunchTemplate <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html>`_ and `Create a launch template <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#create-launch-template>`_ in the *Amazon EC2 User Guide* .

            For examples of launch templates, see `Examples <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#aws-resource-ec2-launchtemplate--examples>`_ .

            :param launch_template_id: The ID of the launch template. You must specify the ``LaunchTemplateId`` or the ``LaunchTemplateName`` , but not both.
            :param launch_template_name: The name of the launch template. You must specify the ``LaunchTemplateName`` or the ``LaunchTemplateId`` , but not both.
            :param version: The launch template version number, ``$Latest`` , or ``$Default`` . You must specify a value, otherwise the request fails. If the value is ``$Latest`` , Amazon EC2 uses the latest version of the launch template. If the value is ``$Default`` , Amazon EC2 uses the default version of the launch template.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplatespecificationrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                fleet_launch_template_specification_request_property = ec2_mixins.CfnEC2FleetPropsMixin.FleetLaunchTemplateSpecificationRequestProperty(
                    launch_template_id="launchTemplateId",
                    launch_template_name="launchTemplateName",
                    version="version"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__a82fbbd23ee3ac25d49eaf556d29da470ec6f00ccf3a92e64afe0accc8e0a9cb)
                check_type(argname="argument launch_template_id", value=launch_template_id, expected_type=type_hints["launch_template_id"])
                check_type(argname="argument launch_template_name", value=launch_template_name, expected_type=type_hints["launch_template_name"])
                check_type(argname="argument version", value=version, expected_type=type_hints["version"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if launch_template_id is not None:
                self._values["launch_template_id"] = launch_template_id
            if launch_template_name is not None:
                self._values["launch_template_name"] = launch_template_name
            if version is not None:
                self._values["version"] = version

        @builtins.property
        def launch_template_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the launch template.

            You must specify the ``LaunchTemplateId`` or the ``LaunchTemplateName`` , but not both.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplatespecificationrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplatespecificationrequest-launchtemplateid
            '''
            result = self._values.get("launch_template_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def launch_template_name(self) -> typing.Optional[builtins.str]:
            '''The name of the launch template.

            You must specify the ``LaunchTemplateName`` or the ``LaunchTemplateId`` , but not both.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplatespecificationrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplatespecificationrequest-launchtemplatename
            '''
            result = self._values.get("launch_template_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def version(self) -> typing.Optional[builtins.str]:
            '''The launch template version number, ``$Latest`` , or ``$Default`` . You must specify a value, otherwise the request fails.

            If the value is ``$Latest`` , Amazon EC2 uses the latest version of the launch template.

            If the value is ``$Default`` , Amazon EC2 uses the default version of the launch template.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplatespecificationrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplatespecificationrequest-version
            '''
            result = self._values.get("version")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "FleetLaunchTemplateSpecificationRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnEC2FleetPropsMixin.InstanceRequirementsRequestProperty",
        jsii_struct_bases=[],
        name_mapping={
            "accelerator_count": "acceleratorCount",
            "accelerator_manufacturers": "acceleratorManufacturers",
            "accelerator_names": "acceleratorNames",
            "accelerator_total_memory_mib": "acceleratorTotalMemoryMiB",
            "accelerator_types": "acceleratorTypes",
            "allowed_instance_types": "allowedInstanceTypes",
            "bare_metal": "bareMetal",
            "baseline_ebs_bandwidth_mbps": "baselineEbsBandwidthMbps",
            "baseline_performance_factors": "baselinePerformanceFactors",
            "burstable_performance": "burstablePerformance",
            "cpu_manufacturers": "cpuManufacturers",
            "excluded_instance_types": "excludedInstanceTypes",
            "instance_generations": "instanceGenerations",
            "local_storage": "localStorage",
            "local_storage_types": "localStorageTypes",
            "max_spot_price_as_percentage_of_optimal_on_demand_price": "maxSpotPriceAsPercentageOfOptimalOnDemandPrice",
            "memory_gib_per_v_cpu": "memoryGiBPerVCpu",
            "memory_mib": "memoryMiB",
            "network_bandwidth_gbps": "networkBandwidthGbps",
            "network_interface_count": "networkInterfaceCount",
            "on_demand_max_price_percentage_over_lowest_price": "onDemandMaxPricePercentageOverLowestPrice",
            "require_encryption_in_transit": "requireEncryptionInTransit",
            "require_hibernate_support": "requireHibernateSupport",
            "spot_max_price_percentage_over_lowest_price": "spotMaxPricePercentageOverLowestPrice",
            "total_local_storage_gb": "totalLocalStorageGb",
            "v_cpu_count": "vCpuCount",
        },
    )
    class InstanceRequirementsRequestProperty:
        def __init__(
            self,
            *,
            accelerator_count: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnEC2FleetPropsMixin.AcceleratorCountRequestProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            accelerator_manufacturers: typing.Optional[typing.Sequence[builtins.str]] = None,
            accelerator_names: typing.Optional[typing.Sequence[builtins.str]] = None,
            accelerator_total_memory_mib: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnEC2FleetPropsMixin.AcceleratorTotalMemoryMiBRequestProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            accelerator_types: typing.Optional[typing.Sequence[builtins.str]] = None,
            allowed_instance_types: typing.Optional[typing.Sequence[builtins.str]] = None,
            bare_metal: typing.Optional[builtins.str] = None,
            baseline_ebs_bandwidth_mbps: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnEC2FleetPropsMixin.BaselineEbsBandwidthMbpsRequestProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            baseline_performance_factors: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnEC2FleetPropsMixin.BaselinePerformanceFactorsRequestProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            burstable_performance: typing.Optional[builtins.str] = None,
            cpu_manufacturers: typing.Optional[typing.Sequence[builtins.str]] = None,
            excluded_instance_types: typing.Optional[typing.Sequence[builtins.str]] = None,
            instance_generations: typing.Optional[typing.Sequence[builtins.str]] = None,
            local_storage: typing.Optional[builtins.str] = None,
            local_storage_types: typing.Optional[typing.Sequence[builtins.str]] = None,
            max_spot_price_as_percentage_of_optimal_on_demand_price: typing.Optional[jsii.Number] = None,
            memory_gib_per_v_cpu: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnEC2FleetPropsMixin.MemoryGiBPerVCpuRequestProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            memory_mib: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnEC2FleetPropsMixin.MemoryMiBRequestProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            network_bandwidth_gbps: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnEC2FleetPropsMixin.NetworkBandwidthGbpsRequestProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            network_interface_count: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnEC2FleetPropsMixin.NetworkInterfaceCountRequestProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            on_demand_max_price_percentage_over_lowest_price: typing.Optional[jsii.Number] = None,
            require_encryption_in_transit: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            require_hibernate_support: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            spot_max_price_percentage_over_lowest_price: typing.Optional[jsii.Number] = None,
            total_local_storage_gb: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnEC2FleetPropsMixin.TotalLocalStorageGBRequestProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            v_cpu_count: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnEC2FleetPropsMixin.VCpuCountRangeRequestProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''The attributes for the instance types.

            When you specify instance attributes, Amazon EC2 will identify instance types with these attributes.

            You must specify ``VCpuCount`` and ``MemoryMiB`` . All other attributes are optional. Any unspecified optional attribute is set to its default.

            When you specify multiple attributes, you get instance types that satisfy all of the specified attributes. If you specify multiple values for an attribute, you get instance types that satisfy any of the specified values.

            To limit the list of instance types from which Amazon EC2 can identify matching instance types, you can use one of the following parameters, but not both in the same request:

            - ``AllowedInstanceTypes`` - The instance types to include in the list. All other instance types are ignored, even if they match your specified attributes.
            - ``ExcludedInstanceTypes`` - The instance types to exclude from the list, even if they match your specified attributes.

            .. epigraph::

               If you specify ``InstanceRequirements`` , you can't specify ``InstanceType`` .

               Attribute-based instance type selection is only supported when using Auto Scaling groups, EC2 Fleet, and Spot Fleet to launch instances. If you plan to use the launch template in the `launch instance wizard <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-instance-wizard.html>`_ , or with the `RunInstances <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html>`_ API or `AWS::EC2::Instance <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html>`_ AWS CloudFormation resource, you can't specify ``InstanceRequirements`` .

            For more information, see `Specify attributes for instance type selection for EC2 Fleet or Spot Fleet <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html>`_ and `Spot placement score <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html>`_ in the *Amazon EC2 User Guide* .

            :param accelerator_count: The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance. To exclude accelerator-enabled instance types, set ``Max`` to ``0`` . Default: No minimum or maximum limits
            :param accelerator_manufacturers: Indicates whether instance types must have accelerators by specific manufacturers. - For instance types with AWS devices, specify ``amazon-web-services`` . - For instance types with AMD devices, specify ``amd`` . - For instance types with Habana devices, specify ``habana`` . - For instance types with NVIDIA devices, specify ``nvidia`` . - For instance types with Xilinx devices, specify ``xilinx`` . Default: Any manufacturer
            :param accelerator_names: The accelerators that must be on the instance type. - For instance types with NVIDIA A10G GPUs, specify ``a10g`` . - For instance types with NVIDIA A100 GPUs, specify ``a100`` . - For instance types with NVIDIA H100 GPUs, specify ``h100`` . - For instance types with AWS Inferentia chips, specify ``inferentia`` . - For instance types with AWS Inferentia2 chips, specify ``inferentia2`` . - For instance types with Habana Gaudi HL-205 GPUs, specify ``gaudi-hl-205`` . - For instance types with NVIDIA GRID K520 GPUs, specify ``k520`` . - For instance types with NVIDIA K80 GPUs, specify ``k80`` . - For instance types with NVIDIA L4 GPUs, specify ``l4`` . - For instance types with NVIDIA L40S GPUs, specify ``l40s`` . - For instance types with NVIDIA M60 GPUs, specify ``m60`` . - For instance types with AMD Radeon Pro V520 GPUs, specify ``radeon-pro-v520`` . - For instance types with AWS Trainium chips, specify ``trainium`` . - For instance types with AWS Trainium2 chips, specify ``trainium2`` . - For instance types with NVIDIA T4 GPUs, specify ``t4`` . - For instance types with NVIDIA T4G GPUs, specify ``t4g`` . - For instance types with Xilinx U30 cards, specify ``u30`` . - For instance types with Xilinx VU9P FPGAs, specify ``vu9p`` . - For instance types with NVIDIA V100 GPUs, specify ``v100`` . Default: Any accelerator
            :param accelerator_total_memory_mib: The minimum and maximum amount of total accelerator memory, in MiB. Default: No minimum or maximum limits
            :param accelerator_types: The accelerator types that must be on the instance type. - For instance types with FPGA accelerators, specify ``fpga`` . - For instance types with GPU accelerators, specify ``gpu`` . - For instance types with Inference accelerators, specify ``inference`` . - For instance types with Media accelerators, specify ``media`` . Default: Any accelerator type
            :param allowed_instance_types: The instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes. You can use strings with one or more wild cards, represented by an asterisk ( ``*`` ), to allow an instance type, size, or generation. The following are examples: ``m5.8xlarge`` , ``c5*.*`` , ``m5a.*`` , ``r*`` , ``*3*`` . For example, if you specify ``c5*`` ,Amazon EC2 will allow the entire C5 instance family, which includes all C5a and C5n instance types. If you specify ``m5a.*`` , Amazon EC2 will allow all the M5a instance types, but not the M5n instance types. .. epigraph:: If you specify ``AllowedInstanceTypes`` , you can't specify ``ExcludedInstanceTypes`` . Default: All instance types
            :param bare_metal: Indicates whether bare metal instance types must be included, excluded, or required. - To include bare metal instance types, specify ``included`` . - To require only bare metal instance types, specify ``required`` . - To exclude bare metal instance types, specify ``excluded`` . Default: ``excluded``
            :param baseline_ebs_bandwidth_mbps: The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see `Amazon EBSoptimized instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html>`_ in the *Amazon EC2 User Guide* . Default: No minimum or maximum limits
            :param baseline_performance_factors: The baseline performance to consider, using an instance family as a baseline reference. The instance family establishes the lowest acceptable level of performance. Amazon EC2 uses this baseline to guide instance type selection, but there is no guarantee that the selected instance types will always exceed the baseline for every application. Currently, this parameter only supports CPU performance as a baseline performance factor. For more information, see `Performance protection <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html#ec2fleet-abis-performance-protection>`_ in the *Amazon EC2 User Guide* .
            :param burstable_performance: Indicates whether burstable performance T instance types are included, excluded, or required. For more information, see `Burstable performance instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html>`_ . - To include burstable performance instance types, specify ``included`` . - To require only burstable performance instance types, specify ``required`` . - To exclude burstable performance instance types, specify ``excluded`` . Default: ``excluded``
            :param cpu_manufacturers: The CPU manufacturers to include. - For instance types with Intel CPUs, specify ``intel`` . - For instance types with AMD CPUs, specify ``amd`` . - For instance types with AWS CPUs, specify ``amazon-web-services`` . - For instance types with Apple CPUs, specify ``apple`` . .. epigraph:: Don't confuse the CPU manufacturer with the CPU architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template. Default: Any manufacturer
            :param excluded_instance_types: The instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk ( ``*`` ), to exclude an instance family, type, size, or generation. The following are examples: ``m5.8xlarge`` , ``c5*.*`` , ``m5a.*`` , ``r*`` , ``*3*`` . For example, if you specify ``c5*`` ,Amazon EC2 will exclude the entire C5 instance family, which includes all C5a and C5n instance types. If you specify ``m5a.*`` , Amazon EC2 will exclude all the M5a instance types, but not the M5n instance types. .. epigraph:: If you specify ``ExcludedInstanceTypes`` , you can't specify ``AllowedInstanceTypes`` . Default: No excluded instance types
            :param instance_generations: Indicates whether current or previous generation instance types are included. The current generation instance types are recommended for use. Current generation instance types are typically the latest two to three generations in each instance family. For more information, see `Instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html>`_ in the *Amazon EC2 User Guide* . For current generation instance types, specify ``current`` . For previous generation instance types, specify ``previous`` . Default: Current and previous generation instance types
            :param local_storage: Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, `Amazon EC2 instance store <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html>`_ in the *Amazon EC2 User Guide* . - To include instance types with instance store volumes, specify ``included`` . - To require only instance types with instance store volumes, specify ``required`` . - To exclude instance types with instance store volumes, specify ``excluded`` . Default: ``included``
            :param local_storage_types: The type of local storage that is required. - For instance types with hard disk drive (HDD) storage, specify ``hdd`` . - For instance types with solid state drive (SSD) storage, specify ``ssd`` . Default: ``hdd`` and ``ssd``
            :param max_spot_price_as_percentage_of_optimal_on_demand_price: [Price protection] The price protection threshold for Spot Instances, as a percentage of an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold. The parameter accepts an integer, which Amazon EC2 interprets as a percentage. If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib`` , the price protection threshold is based on the per vCPU or per memory price instead of the per instance price. .. epigraph:: Only one of ``SpotMaxPricePercentageOverLowestPrice`` or ``MaxSpotPriceAsPercentageOfOptimalOnDemandPrice`` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as ``999999`` .
            :param memory_gib_per_v_cpu: The minimum and maximum amount of memory per vCPU, in GiB. Default: No minimum or maximum limits
            :param memory_mib: The minimum and maximum amount of memory, in MiB.
            :param network_bandwidth_gbps: The minimum and maximum amount of baseline network bandwidth, in gigabits per second (Gbps). For more information, see `Amazon EC2 instance network bandwidth <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-network-bandwidth.html>`_ in the *Amazon EC2 User Guide* . Default: No minimum or maximum limits
            :param network_interface_count: The minimum and maximum number of network interfaces. Default: No minimum or maximum limits
            :param on_demand_max_price_percentage_over_lowest_price: [Price protection] The price protection threshold for On-Demand Instances, as a percentage higher than an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold. The parameter accepts an integer, which Amazon EC2 interprets as a percentage. To indicate no price protection threshold, specify a high value, such as ``999999`` . This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ and `GetInstanceTypesFromInstanceRequirements <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html>`_ . .. epigraph:: If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib`` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price. Default: ``20``
            :param require_encryption_in_transit: Specifies whether instance types must support encrypting in-transit traffic between instances. For more information, including the supported instance types, see `Encryption in transit <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/data-protection.html#encryption-transit>`_ in the *Amazon EC2 User Guide* . Default: ``false``
            :param require_hibernate_support: Indicates whether instance types must support hibernation for On-Demand Instances. This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ . Default: ``false``
            :param spot_max_price_percentage_over_lowest_price: [Price protection] The price protection threshold for Spot Instances, as a percentage higher than an identified Spot price. The identified Spot price is the Spot price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified Spot price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose Spot price exceeds your specified threshold. The parameter accepts an integer, which Amazon EC2 interprets as a percentage. If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib`` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price. This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ and `GetInstanceTypesFromInstanceRequirements <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html>`_ . .. epigraph:: Only one of ``SpotMaxPricePercentageOverLowestPrice`` or ``MaxSpotPriceAsPercentageOfOptimalOnDemandPrice`` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as ``999999`` . Default: ``100``
            :param total_local_storage_gb: The minimum and maximum amount of total local storage, in GB. Default: No minimum or maximum limits
            :param v_cpu_count: The minimum and maximum number of vCPUs.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                instance_requirements_request_property = ec2_mixins.CfnEC2FleetPropsMixin.InstanceRequirementsRequestProperty(
                    accelerator_count=ec2_mixins.CfnEC2FleetPropsMixin.AcceleratorCountRequestProperty(
                        max=123,
                        min=123
                    ),
                    accelerator_manufacturers=["acceleratorManufacturers"],
                    accelerator_names=["acceleratorNames"],
                    accelerator_total_memory_mi_b=ec2_mixins.CfnEC2FleetPropsMixin.AcceleratorTotalMemoryMiBRequestProperty(
                        max=123,
                        min=123
                    ),
                    accelerator_types=["acceleratorTypes"],
                    allowed_instance_types=["allowedInstanceTypes"],
                    bare_metal="bareMetal",
                    baseline_ebs_bandwidth_mbps=ec2_mixins.CfnEC2FleetPropsMixin.BaselineEbsBandwidthMbpsRequestProperty(
                        max=123,
                        min=123
                    ),
                    baseline_performance_factors=ec2_mixins.CfnEC2FleetPropsMixin.BaselinePerformanceFactorsRequestProperty(
                        cpu=ec2_mixins.CfnEC2FleetPropsMixin.CpuPerformanceFactorRequestProperty(
                            references=[ec2_mixins.CfnEC2FleetPropsMixin.PerformanceFactorReferenceRequestProperty(
                                instance_family="instanceFamily"
                            )]
                        )
                    ),
                    burstable_performance="burstablePerformance",
                    cpu_manufacturers=["cpuManufacturers"],
                    excluded_instance_types=["excludedInstanceTypes"],
                    instance_generations=["instanceGenerations"],
                    local_storage="localStorage",
                    local_storage_types=["localStorageTypes"],
                    max_spot_price_as_percentage_of_optimal_on_demand_price=123,
                    memory_gi_bPer_vCpu=ec2_mixins.CfnEC2FleetPropsMixin.MemoryGiBPerVCpuRequestProperty(
                        max=123,
                        min=123
                    ),
                    memory_mi_b=ec2_mixins.CfnEC2FleetPropsMixin.MemoryMiBRequestProperty(
                        max=123,
                        min=123
                    ),
                    network_bandwidth_gbps=ec2_mixins.CfnEC2FleetPropsMixin.NetworkBandwidthGbpsRequestProperty(
                        max=123,
                        min=123
                    ),
                    network_interface_count=ec2_mixins.CfnEC2FleetPropsMixin.NetworkInterfaceCountRequestProperty(
                        max=123,
                        min=123
                    ),
                    on_demand_max_price_percentage_over_lowest_price=123,
                    require_encryption_in_transit=False,
                    require_hibernate_support=False,
                    spot_max_price_percentage_over_lowest_price=123,
                    total_local_storage_gb=ec2_mixins.CfnEC2FleetPropsMixin.TotalLocalStorageGBRequestProperty(
                        max=123,
                        min=123
                    ),
                    v_cpu_count=ec2_mixins.CfnEC2FleetPropsMixin.VCpuCountRangeRequestProperty(
                        max=123,
                        min=123
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__b9effd05486d429b9da8f8da7ffaa9bf0b229d9201b671cfcc6d6319a746879d)
                check_type(argname="argument accelerator_count", value=accelerator_count, expected_type=type_hints["accelerator_count"])
                check_type(argname="argument accelerator_manufacturers", value=accelerator_manufacturers, expected_type=type_hints["accelerator_manufacturers"])
                check_type(argname="argument accelerator_names", value=accelerator_names, expected_type=type_hints["accelerator_names"])
                check_type(argname="argument accelerator_total_memory_mib", value=accelerator_total_memory_mib, expected_type=type_hints["accelerator_total_memory_mib"])
                check_type(argname="argument accelerator_types", value=accelerator_types, expected_type=type_hints["accelerator_types"])
                check_type(argname="argument allowed_instance_types", value=allowed_instance_types, expected_type=type_hints["allowed_instance_types"])
                check_type(argname="argument bare_metal", value=bare_metal, expected_type=type_hints["bare_metal"])
                check_type(argname="argument baseline_ebs_bandwidth_mbps", value=baseline_ebs_bandwidth_mbps, expected_type=type_hints["baseline_ebs_bandwidth_mbps"])
                check_type(argname="argument baseline_performance_factors", value=baseline_performance_factors, expected_type=type_hints["baseline_performance_factors"])
                check_type(argname="argument burstable_performance", value=burstable_performance, expected_type=type_hints["burstable_performance"])
                check_type(argname="argument cpu_manufacturers", value=cpu_manufacturers, expected_type=type_hints["cpu_manufacturers"])
                check_type(argname="argument excluded_instance_types", value=excluded_instance_types, expected_type=type_hints["excluded_instance_types"])
                check_type(argname="argument instance_generations", value=instance_generations, expected_type=type_hints["instance_generations"])
                check_type(argname="argument local_storage", value=local_storage, expected_type=type_hints["local_storage"])
                check_type(argname="argument local_storage_types", value=local_storage_types, expected_type=type_hints["local_storage_types"])
                check_type(argname="argument max_spot_price_as_percentage_of_optimal_on_demand_price", value=max_spot_price_as_percentage_of_optimal_on_demand_price, expected_type=type_hints["max_spot_price_as_percentage_of_optimal_on_demand_price"])
                check_type(argname="argument memory_gib_per_v_cpu", value=memory_gib_per_v_cpu, expected_type=type_hints["memory_gib_per_v_cpu"])
                check_type(argname="argument memory_mib", value=memory_mib, expected_type=type_hints["memory_mib"])
                check_type(argname="argument network_bandwidth_gbps", value=network_bandwidth_gbps, expected_type=type_hints["network_bandwidth_gbps"])
                check_type(argname="argument network_interface_count", value=network_interface_count, expected_type=type_hints["network_interface_count"])
                check_type(argname="argument on_demand_max_price_percentage_over_lowest_price", value=on_demand_max_price_percentage_over_lowest_price, expected_type=type_hints["on_demand_max_price_percentage_over_lowest_price"])
                check_type(argname="argument require_encryption_in_transit", value=require_encryption_in_transit, expected_type=type_hints["require_encryption_in_transit"])
                check_type(argname="argument require_hibernate_support", value=require_hibernate_support, expected_type=type_hints["require_hibernate_support"])
                check_type(argname="argument spot_max_price_percentage_over_lowest_price", value=spot_max_price_percentage_over_lowest_price, expected_type=type_hints["spot_max_price_percentage_over_lowest_price"])
                check_type(argname="argument total_local_storage_gb", value=total_local_storage_gb, expected_type=type_hints["total_local_storage_gb"])
                check_type(argname="argument v_cpu_count", value=v_cpu_count, expected_type=type_hints["v_cpu_count"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if accelerator_count is not None:
                self._values["accelerator_count"] = accelerator_count
            if accelerator_manufacturers is not None:
                self._values["accelerator_manufacturers"] = accelerator_manufacturers
            if accelerator_names is not None:
                self._values["accelerator_names"] = accelerator_names
            if accelerator_total_memory_mib is not None:
                self._values["accelerator_total_memory_mib"] = accelerator_total_memory_mib
            if accelerator_types is not None:
                self._values["accelerator_types"] = accelerator_types
            if allowed_instance_types is not None:
                self._values["allowed_instance_types"] = allowed_instance_types
            if bare_metal is not None:
                self._values["bare_metal"] = bare_metal
            if baseline_ebs_bandwidth_mbps is not None:
                self._values["baseline_ebs_bandwidth_mbps"] = baseline_ebs_bandwidth_mbps
            if baseline_performance_factors is not None:
                self._values["baseline_performance_factors"] = baseline_performance_factors
            if burstable_performance is not None:
                self._values["burstable_performance"] = burstable_performance
            if cpu_manufacturers is not None:
                self._values["cpu_manufacturers"] = cpu_manufacturers
            if excluded_instance_types is not None:
                self._values["excluded_instance_types"] = excluded_instance_types
            if instance_generations is not None:
                self._values["instance_generations"] = instance_generations
            if local_storage is not None:
                self._values["local_storage"] = local_storage
            if local_storage_types is not None:
                self._values["local_storage_types"] = local_storage_types
            if max_spot_price_as_percentage_of_optimal_on_demand_price is not None:
                self._values["max_spot_price_as_percentage_of_optimal_on_demand_price"] = max_spot_price_as_percentage_of_optimal_on_demand_price
            if memory_gib_per_v_cpu is not None:
                self._values["memory_gib_per_v_cpu"] = memory_gib_per_v_cpu
            if memory_mib is not None:
                self._values["memory_mib"] = memory_mib
            if network_bandwidth_gbps is not None:
                self._values["network_bandwidth_gbps"] = network_bandwidth_gbps
            if network_interface_count is not None:
                self._values["network_interface_count"] = network_interface_count
            if on_demand_max_price_percentage_over_lowest_price is not None:
                self._values["on_demand_max_price_percentage_over_lowest_price"] = on_demand_max_price_percentage_over_lowest_price
            if require_encryption_in_transit is not None:
                self._values["require_encryption_in_transit"] = require_encryption_in_transit
            if require_hibernate_support is not None:
                self._values["require_hibernate_support"] = require_hibernate_support
            if spot_max_price_percentage_over_lowest_price is not None:
                self._values["spot_max_price_percentage_over_lowest_price"] = spot_max_price_percentage_over_lowest_price
            if total_local_storage_gb is not None:
                self._values["total_local_storage_gb"] = total_local_storage_gb
            if v_cpu_count is not None:
                self._values["v_cpu_count"] = v_cpu_count

        @builtins.property
        def accelerator_count(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.AcceleratorCountRequestProperty"]]:
            '''The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.

            To exclude accelerator-enabled instance types, set ``Max`` to ``0`` .

            Default: No minimum or maximum limits

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-acceleratorcount
            '''
            result = self._values.get("accelerator_count")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.AcceleratorCountRequestProperty"]], result)

        @builtins.property
        def accelerator_manufacturers(
            self,
        ) -> typing.Optional[typing.List[builtins.str]]:
            '''Indicates whether instance types must have accelerators by specific manufacturers.

            - For instance types with AWS devices, specify ``amazon-web-services`` .
            - For instance types with AMD devices, specify ``amd`` .
            - For instance types with Habana devices, specify ``habana`` .
            - For instance types with NVIDIA devices, specify ``nvidia`` .
            - For instance types with Xilinx devices, specify ``xilinx`` .

            Default: Any manufacturer

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-acceleratormanufacturers
            '''
            result = self._values.get("accelerator_manufacturers")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def accelerator_names(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The accelerators that must be on the instance type.

            - For instance types with NVIDIA A10G GPUs, specify ``a10g`` .
            - For instance types with NVIDIA A100 GPUs, specify ``a100`` .
            - For instance types with NVIDIA H100 GPUs, specify ``h100`` .
            - For instance types with AWS Inferentia chips, specify ``inferentia`` .
            - For instance types with AWS Inferentia2 chips, specify ``inferentia2`` .
            - For instance types with Habana Gaudi HL-205 GPUs, specify ``gaudi-hl-205`` .
            - For instance types with NVIDIA GRID K520 GPUs, specify ``k520`` .
            - For instance types with NVIDIA K80 GPUs, specify ``k80`` .
            - For instance types with NVIDIA L4 GPUs, specify ``l4`` .
            - For instance types with NVIDIA L40S GPUs, specify ``l40s`` .
            - For instance types with NVIDIA M60 GPUs, specify ``m60`` .
            - For instance types with AMD Radeon Pro V520 GPUs, specify ``radeon-pro-v520`` .
            - For instance types with AWS Trainium chips, specify ``trainium`` .
            - For instance types with AWS Trainium2 chips, specify ``trainium2`` .
            - For instance types with NVIDIA T4 GPUs, specify ``t4`` .
            - For instance types with NVIDIA T4G GPUs, specify ``t4g`` .
            - For instance types with Xilinx U30 cards, specify ``u30`` .
            - For instance types with Xilinx VU9P FPGAs, specify ``vu9p`` .
            - For instance types with NVIDIA V100 GPUs, specify ``v100`` .

            Default: Any accelerator

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-acceleratornames
            '''
            result = self._values.get("accelerator_names")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def accelerator_total_memory_mib(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.AcceleratorTotalMemoryMiBRequestProperty"]]:
            '''The minimum and maximum amount of total accelerator memory, in MiB.

            Default: No minimum or maximum limits

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-acceleratortotalmemorymib
            '''
            result = self._values.get("accelerator_total_memory_mib")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.AcceleratorTotalMemoryMiBRequestProperty"]], result)

        @builtins.property
        def accelerator_types(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The accelerator types that must be on the instance type.

            - For instance types with FPGA accelerators, specify ``fpga`` .
            - For instance types with GPU accelerators, specify ``gpu`` .
            - For instance types with Inference accelerators, specify ``inference`` .
            - For instance types with Media accelerators, specify ``media`` .

            Default: Any accelerator type

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-acceleratortypes
            '''
            result = self._values.get("accelerator_types")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def allowed_instance_types(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The instance types to apply your specified attributes against.

            All other instance types are ignored, even if they match your specified attributes.

            You can use strings with one or more wild cards, represented by an asterisk ( ``*`` ), to allow an instance type, size, or generation. The following are examples: ``m5.8xlarge`` , ``c5*.*`` , ``m5a.*`` , ``r*`` , ``*3*`` .

            For example, if you specify ``c5*`` ,Amazon EC2 will allow the entire C5 instance family, which includes all C5a and C5n instance types. If you specify ``m5a.*`` , Amazon EC2 will allow all the M5a instance types, but not the M5n instance types.
            .. epigraph::

               If you specify ``AllowedInstanceTypes`` , you can't specify ``ExcludedInstanceTypes`` .

            Default: All instance types

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-allowedinstancetypes
            '''
            result = self._values.get("allowed_instance_types")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def bare_metal(self) -> typing.Optional[builtins.str]:
            '''Indicates whether bare metal instance types must be included, excluded, or required.

            - To include bare metal instance types, specify ``included`` .
            - To require only bare metal instance types, specify ``required`` .
            - To exclude bare metal instance types, specify ``excluded`` .

            Default: ``excluded``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-baremetal
            '''
            result = self._values.get("bare_metal")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def baseline_ebs_bandwidth_mbps(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.BaselineEbsBandwidthMbpsRequestProperty"]]:
            '''The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps.

            For more information, see `Amazon EBSoptimized instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html>`_ in the *Amazon EC2 User Guide* .

            Default: No minimum or maximum limits

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-baselineebsbandwidthmbps
            '''
            result = self._values.get("baseline_ebs_bandwidth_mbps")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.BaselineEbsBandwidthMbpsRequestProperty"]], result)

        @builtins.property
        def baseline_performance_factors(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.BaselinePerformanceFactorsRequestProperty"]]:
            '''The baseline performance to consider, using an instance family as a baseline reference.

            The instance family establishes the lowest acceptable level of performance. Amazon EC2 uses this baseline to guide instance type selection, but there is no guarantee that the selected instance types will always exceed the baseline for every application. Currently, this parameter only supports CPU performance as a baseline performance factor. For more information, see `Performance protection <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html#ec2fleet-abis-performance-protection>`_ in the *Amazon EC2 User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-baselineperformancefactors
            '''
            result = self._values.get("baseline_performance_factors")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.BaselinePerformanceFactorsRequestProperty"]], result)

        @builtins.property
        def burstable_performance(self) -> typing.Optional[builtins.str]:
            '''Indicates whether burstable performance T instance types are included, excluded, or required.

            For more information, see `Burstable performance instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html>`_ .

            - To include burstable performance instance types, specify ``included`` .
            - To require only burstable performance instance types, specify ``required`` .
            - To exclude burstable performance instance types, specify ``excluded`` .

            Default: ``excluded``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-burstableperformance
            '''
            result = self._values.get("burstable_performance")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def cpu_manufacturers(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The CPU manufacturers to include.

            - For instance types with Intel CPUs, specify ``intel`` .
            - For instance types with AMD CPUs, specify ``amd`` .
            - For instance types with AWS CPUs, specify ``amazon-web-services`` .
            - For instance types with Apple CPUs, specify ``apple`` .

            .. epigraph::

               Don't confuse the CPU manufacturer with the CPU architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.

            Default: Any manufacturer

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-cpumanufacturers
            '''
            result = self._values.get("cpu_manufacturers")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def excluded_instance_types(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The instance types to exclude.

            You can use strings with one or more wild cards, represented by an asterisk ( ``*`` ), to exclude an instance family, type, size, or generation. The following are examples: ``m5.8xlarge`` , ``c5*.*`` , ``m5a.*`` , ``r*`` , ``*3*`` .

            For example, if you specify ``c5*`` ,Amazon EC2 will exclude the entire C5 instance family, which includes all C5a and C5n instance types. If you specify ``m5a.*`` , Amazon EC2 will exclude all the M5a instance types, but not the M5n instance types.
            .. epigraph::

               If you specify ``ExcludedInstanceTypes`` , you can't specify ``AllowedInstanceTypes`` .

            Default: No excluded instance types

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-excludedinstancetypes
            '''
            result = self._values.get("excluded_instance_types")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def instance_generations(self) -> typing.Optional[typing.List[builtins.str]]:
            '''Indicates whether current or previous generation instance types are included.

            The current generation instance types are recommended for use. Current generation instance types are typically the latest two to three generations in each instance family. For more information, see `Instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html>`_ in the *Amazon EC2 User Guide* .

            For current generation instance types, specify ``current`` .

            For previous generation instance types, specify ``previous`` .

            Default: Current and previous generation instance types

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-instancegenerations
            '''
            result = self._values.get("instance_generations")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def local_storage(self) -> typing.Optional[builtins.str]:
            '''Indicates whether instance types with instance store volumes are included, excluded, or required.

            For more information, `Amazon EC2 instance store <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html>`_ in the *Amazon EC2 User Guide* .

            - To include instance types with instance store volumes, specify ``included`` .
            - To require only instance types with instance store volumes, specify ``required`` .
            - To exclude instance types with instance store volumes, specify ``excluded`` .

            Default: ``included``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-localstorage
            '''
            result = self._values.get("local_storage")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def local_storage_types(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The type of local storage that is required.

            - For instance types with hard disk drive (HDD) storage, specify ``hdd`` .
            - For instance types with solid state drive (SSD) storage, specify ``ssd`` .

            Default: ``hdd`` and ``ssd``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-localstoragetypes
            '''
            result = self._values.get("local_storage_types")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def max_spot_price_as_percentage_of_optimal_on_demand_price(
            self,
        ) -> typing.Optional[jsii.Number]:
            '''[Price protection] The price protection threshold for Spot Instances, as a percentage of an identified On-Demand price.

            The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.

            The parameter accepts an integer, which Amazon EC2 interprets as a percentage.

            If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib`` , the price protection threshold is based on the per vCPU or per memory price instead of the per instance price.
            .. epigraph::

               Only one of ``SpotMaxPricePercentageOverLowestPrice`` or ``MaxSpotPriceAsPercentageOfOptimalOnDemandPrice`` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as ``999999`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-maxspotpriceaspercentageofoptimalondemandprice
            '''
            result = self._values.get("max_spot_price_as_percentage_of_optimal_on_demand_price")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def memory_gib_per_v_cpu(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.MemoryGiBPerVCpuRequestProperty"]]:
            '''The minimum and maximum amount of memory per vCPU, in GiB.

            Default: No minimum or maximum limits

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-memorygibpervcpu
            '''
            result = self._values.get("memory_gib_per_v_cpu")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.MemoryGiBPerVCpuRequestProperty"]], result)

        @builtins.property
        def memory_mib(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.MemoryMiBRequestProperty"]]:
            '''The minimum and maximum amount of memory, in MiB.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-memorymib
            '''
            result = self._values.get("memory_mib")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.MemoryMiBRequestProperty"]], result)

        @builtins.property
        def network_bandwidth_gbps(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.NetworkBandwidthGbpsRequestProperty"]]:
            '''The minimum and maximum amount of baseline network bandwidth, in gigabits per second (Gbps).

            For more information, see `Amazon EC2 instance network bandwidth <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-network-bandwidth.html>`_ in the *Amazon EC2 User Guide* .

            Default: No minimum or maximum limits

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-networkbandwidthgbps
            '''
            result = self._values.get("network_bandwidth_gbps")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.NetworkBandwidthGbpsRequestProperty"]], result)

        @builtins.property
        def network_interface_count(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.NetworkInterfaceCountRequestProperty"]]:
            '''The minimum and maximum number of network interfaces.

            Default: No minimum or maximum limits

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-networkinterfacecount
            '''
            result = self._values.get("network_interface_count")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.NetworkInterfaceCountRequestProperty"]], result)

        @builtins.property
        def on_demand_max_price_percentage_over_lowest_price(
            self,
        ) -> typing.Optional[jsii.Number]:
            '''[Price protection] The price protection threshold for On-Demand Instances, as a percentage higher than an identified On-Demand price.

            The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.

            The parameter accepts an integer, which Amazon EC2 interprets as a percentage.

            To indicate no price protection threshold, specify a high value, such as ``999999`` .

            This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ and `GetInstanceTypesFromInstanceRequirements <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html>`_ .
            .. epigraph::

               If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib`` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.

            Default: ``20``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-ondemandmaxpricepercentageoverlowestprice
            '''
            result = self._values.get("on_demand_max_price_percentage_over_lowest_price")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def require_encryption_in_transit(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Specifies whether instance types must support encrypting in-transit traffic between instances.

            For more information, including the supported instance types, see `Encryption in transit <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/data-protection.html#encryption-transit>`_ in the *Amazon EC2 User Guide* .

            Default: ``false``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-requireencryptionintransit
            '''
            result = self._values.get("require_encryption_in_transit")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def require_hibernate_support(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether instance types must support hibernation for On-Demand Instances.

            This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ .

            Default: ``false``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-requirehibernatesupport
            '''
            result = self._values.get("require_hibernate_support")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def spot_max_price_percentage_over_lowest_price(
            self,
        ) -> typing.Optional[jsii.Number]:
            '''[Price protection] The price protection threshold for Spot Instances, as a percentage higher than an identified Spot price.

            The identified Spot price is the Spot price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified Spot price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose Spot price exceeds your specified threshold.

            The parameter accepts an integer, which Amazon EC2 interprets as a percentage.

            If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib`` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.

            This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ and `GetInstanceTypesFromInstanceRequirements <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html>`_ .
            .. epigraph::

               Only one of ``SpotMaxPricePercentageOverLowestPrice`` or ``MaxSpotPriceAsPercentageOfOptimalOnDemandPrice`` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as ``999999`` .

            Default: ``100``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-spotmaxpricepercentageoverlowestprice
            '''
            result = self._values.get("spot_max_price_percentage_over_lowest_price")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def total_local_storage_gb(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.TotalLocalStorageGBRequestProperty"]]:
            '''The minimum and maximum amount of total local storage, in GB.

            Default: No minimum or maximum limits

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-totallocalstoragegb
            '''
            result = self._values.get("total_local_storage_gb")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.TotalLocalStorageGBRequestProperty"]], result)

        @builtins.property
        def v_cpu_count(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.VCpuCountRangeRequestProperty"]]:
            '''The minimum and maximum number of vCPUs.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-vcpucount
            '''
            result = self._values.get("v_cpu_count")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.VCpuCountRangeRequestProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "InstanceRequirementsRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnEC2FleetPropsMixin.MaintenanceStrategiesProperty",
        jsii_struct_bases=[],
        name_mapping={"capacity_rebalance": "capacityRebalance"},
    )
    class MaintenanceStrategiesProperty:
        def __init__(
            self,
            *,
            capacity_rebalance: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnEC2FleetPropsMixin.CapacityRebalanceProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''The strategies for managing your Spot Instances that are at an elevated risk of being interrupted.

            :param capacity_rebalance: The strategy to use when Amazon EC2 emits a signal that your Spot Instance is at an elevated risk of being interrupted.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-maintenancestrategies.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                maintenance_strategies_property = ec2_mixins.CfnEC2FleetPropsMixin.MaintenanceStrategiesProperty(
                    capacity_rebalance=ec2_mixins.CfnEC2FleetPropsMixin.CapacityRebalanceProperty(
                        replacement_strategy="replacementStrategy",
                        termination_delay=123
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__805379d61902900b02b5c2d0666783c20b83674bf5f317d67c0e008bb6df1ea1)
                check_type(argname="argument capacity_rebalance", value=capacity_rebalance, expected_type=type_hints["capacity_rebalance"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if capacity_rebalance is not None:
                self._values["capacity_rebalance"] = capacity_rebalance

        @builtins.property
        def capacity_rebalance(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.CapacityRebalanceProperty"]]:
            '''The strategy to use when Amazon EC2 emits a signal that your Spot Instance is at an elevated risk of being interrupted.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-maintenancestrategies.html#cfn-ec2-ec2fleet-maintenancestrategies-capacityrebalance
            '''
            result = self._values.get("capacity_rebalance")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.CapacityRebalanceProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "MaintenanceStrategiesProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnEC2FleetPropsMixin.MemoryGiBPerVCpuRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class MemoryGiBPerVCpuRequestProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum amount of memory per vCPU, in GiB.

            :param max: The maximum amount of memory per vCPU, in GiB. To specify no maximum limit, omit this parameter.
            :param min: The minimum amount of memory per vCPU, in GiB. To specify no minimum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-memorygibpervcpurequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                memory_gi_bPer_vCpu_request_property = ec2_mixins.CfnEC2FleetPropsMixin.MemoryGiBPerVCpuRequestProperty(
                    max=123,
                    min=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__8ed74afd75bee0f596d8af3510d69d28456a90ef309b7bb4a4a241b1af6c0b63)
                check_type(argname="argument max", value=max, expected_type=type_hints["max"])
                check_type(argname="argument min", value=min, expected_type=type_hints["min"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum amount of memory per vCPU, in GiB.

            To specify no maximum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-memorygibpervcpurequest.html#cfn-ec2-ec2fleet-memorygibpervcpurequest-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum amount of memory per vCPU, in GiB.

            To specify no minimum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-memorygibpervcpurequest.html#cfn-ec2-ec2fleet-memorygibpervcpurequest-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "MemoryGiBPerVCpuRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnEC2FleetPropsMixin.MemoryMiBRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class MemoryMiBRequestProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum amount of memory, in MiB.

            :param max: The maximum amount of memory, in MiB. To specify no maximum limit, omit this parameter.
            :param min: The minimum amount of memory, in MiB. To specify no minimum limit, specify ``0`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-memorymibrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                memory_mi_bRequest_property = ec2_mixins.CfnEC2FleetPropsMixin.MemoryMiBRequestProperty(
                    max=123,
                    min=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__3b874376ac9fa043f15d858e6ee829b9dfb2afab9f404b26659517d41d2f2907)
                check_type(argname="argument max", value=max, expected_type=type_hints["max"])
                check_type(argname="argument min", value=min, expected_type=type_hints["min"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum amount of memory, in MiB.

            To specify no maximum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-memorymibrequest.html#cfn-ec2-ec2fleet-memorymibrequest-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum amount of memory, in MiB.

            To specify no minimum limit, specify ``0`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-memorymibrequest.html#cfn-ec2-ec2fleet-memorymibrequest-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "MemoryMiBRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnEC2FleetPropsMixin.NetworkBandwidthGbpsRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class NetworkBandwidthGbpsRequestProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps).

            .. epigraph::

               Setting the minimum bandwidth does not guarantee that your instance will achieve the minimum bandwidth. Amazon EC2 will identify instance types that support the specified minimum bandwidth, but the actual bandwidth of your instance might go below the specified minimum at times. For more information, see `Available instance bandwidth <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-network-bandwidth.html#available-instance-bandwidth>`_ in the *Amazon EC2 User Guide* .

            :param max: The maximum amount of network bandwidth, in Gbps. To specify no maximum limit, omit this parameter.
            :param min: The minimum amount of network bandwidth, in Gbps. To specify no minimum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-networkbandwidthgbpsrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                network_bandwidth_gbps_request_property = ec2_mixins.CfnEC2FleetPropsMixin.NetworkBandwidthGbpsRequestProperty(
                    max=123,
                    min=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__5bdf53d88616dbede6d1ca141faf743b623b658b71543c2542b823c1dbaae16a)
                check_type(argname="argument max", value=max, expected_type=type_hints["max"])
                check_type(argname="argument min", value=min, expected_type=type_hints["min"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum amount of network bandwidth, in Gbps.

            To specify no maximum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-networkbandwidthgbpsrequest.html#cfn-ec2-ec2fleet-networkbandwidthgbpsrequest-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum amount of network bandwidth, in Gbps.

            To specify no minimum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-networkbandwidthgbpsrequest.html#cfn-ec2-ec2fleet-networkbandwidthgbpsrequest-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "NetworkBandwidthGbpsRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnEC2FleetPropsMixin.NetworkInterfaceCountRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class NetworkInterfaceCountRequestProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum number of network interfaces.

            :param max: The maximum number of network interfaces. To specify no maximum limit, omit this parameter.
            :param min: The minimum number of network interfaces. To specify no minimum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-networkinterfacecountrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                network_interface_count_request_property = ec2_mixins.CfnEC2FleetPropsMixin.NetworkInterfaceCountRequestProperty(
                    max=123,
                    min=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__fe339aa933ed5af10bcef3ac04afe48d018b77f9f5e10e6506483babd36030de)
                check_type(argname="argument max", value=max, expected_type=type_hints["max"])
                check_type(argname="argument min", value=min, expected_type=type_hints["min"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum number of network interfaces.

            To specify no maximum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-networkinterfacecountrequest.html#cfn-ec2-ec2fleet-networkinterfacecountrequest-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum number of network interfaces.

            To specify no minimum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-networkinterfacecountrequest.html#cfn-ec2-ec2fleet-networkinterfacecountrequest-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "NetworkInterfaceCountRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnEC2FleetPropsMixin.OnDemandOptionsRequestProperty",
        jsii_struct_bases=[],
        name_mapping={
            "allocation_strategy": "allocationStrategy",
            "capacity_reservation_options": "capacityReservationOptions",
            "max_total_price": "maxTotalPrice",
            "min_target_capacity": "minTargetCapacity",
            "single_availability_zone": "singleAvailabilityZone",
            "single_instance_type": "singleInstanceType",
        },
    )
    class OnDemandOptionsRequestProperty:
        def __init__(
            self,
            *,
            allocation_strategy: typing.Optional[builtins.str] = None,
            capacity_reservation_options: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnEC2FleetPropsMixin.CapacityReservationOptionsRequestProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            max_total_price: typing.Optional[builtins.str] = None,
            min_target_capacity: typing.Optional[jsii.Number] = None,
            single_availability_zone: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            single_instance_type: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        ) -> None:
            '''Specifies the allocation strategy of On-Demand Instances in an EC2 Fleet.

            ``OnDemandOptionsRequest`` is a property of the `AWS::EC2::EC2Fleet <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html>`_ resource.

            :param allocation_strategy: The strategy that determines the order of the launch template overrides to use in fulfilling On-Demand capacity. ``lowest-price`` - EC2 Fleet uses price to determine the order, launching the lowest price first. ``prioritized`` - EC2 Fleet uses the priority that you assigned to each launch template override, launching the highest priority first. Default: ``lowest-price``
            :param capacity_reservation_options: The strategy for using unused Capacity Reservations for fulfilling On-Demand capacity. Supported only for fleets of type ``instant`` .
            :param max_total_price: The maximum amount per hour for On-Demand Instances that you're willing to pay. .. epigraph:: If your fleet includes T instances that are configured as ``unlimited`` , and if their average CPU usage exceeds the baseline utilization, you will incur a charge for surplus credits. The ``MaxTotalPrice`` does not account for surplus credits, and, if you use surplus credits, your final cost might be higher than what you specified for ``MaxTotalPrice`` . For more information, see `Surplus credits can incur charges <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-unlimited-mode-concepts.html#unlimited-mode-surplus-credits>`_ in the *Amazon EC2 User Guide* .
            :param min_target_capacity: The minimum target capacity for On-Demand Instances in the fleet. If this minimum capacity isn't reached, no instances are launched. Constraints: Maximum value of ``1000`` . Supported only for fleets of type ``instant`` . At least one of the following must be specified: ``SingleAvailabilityZone`` | ``SingleInstanceType``
            :param single_availability_zone: Indicates that the fleet launches all On-Demand Instances into a single Availability Zone. Supported only for fleets of type ``instant`` .
            :param single_instance_type: Indicates that the fleet uses a single instance type to launch all On-Demand Instances in the fleet. Supported only for fleets of type ``instant`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                on_demand_options_request_property = ec2_mixins.CfnEC2FleetPropsMixin.OnDemandOptionsRequestProperty(
                    allocation_strategy="allocationStrategy",
                    capacity_reservation_options=ec2_mixins.CfnEC2FleetPropsMixin.CapacityReservationOptionsRequestProperty(
                        usage_strategy="usageStrategy"
                    ),
                    max_total_price="maxTotalPrice",
                    min_target_capacity=123,
                    single_availability_zone=False,
                    single_instance_type=False
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__571dfa5900fdfad08d914819390c179e4ee1593849ab4425721658aa1b538b71)
                check_type(argname="argument allocation_strategy", value=allocation_strategy, expected_type=type_hints["allocation_strategy"])
                check_type(argname="argument capacity_reservation_options", value=capacity_reservation_options, expected_type=type_hints["capacity_reservation_options"])
                check_type(argname="argument max_total_price", value=max_total_price, expected_type=type_hints["max_total_price"])
                check_type(argname="argument min_target_capacity", value=min_target_capacity, expected_type=type_hints["min_target_capacity"])
                check_type(argname="argument single_availability_zone", value=single_availability_zone, expected_type=type_hints["single_availability_zone"])
                check_type(argname="argument single_instance_type", value=single_instance_type, expected_type=type_hints["single_instance_type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if allocation_strategy is not None:
                self._values["allocation_strategy"] = allocation_strategy
            if capacity_reservation_options is not None:
                self._values["capacity_reservation_options"] = capacity_reservation_options
            if max_total_price is not None:
                self._values["max_total_price"] = max_total_price
            if min_target_capacity is not None:
                self._values["min_target_capacity"] = min_target_capacity
            if single_availability_zone is not None:
                self._values["single_availability_zone"] = single_availability_zone
            if single_instance_type is not None:
                self._values["single_instance_type"] = single_instance_type

        @builtins.property
        def allocation_strategy(self) -> typing.Optional[builtins.str]:
            '''The strategy that determines the order of the launch template overrides to use in fulfilling On-Demand capacity.

            ``lowest-price`` - EC2 Fleet uses price to determine the order, launching the lowest price first.

            ``prioritized`` - EC2 Fleet uses the priority that you assigned to each launch template override, launching the highest priority first.

            Default: ``lowest-price``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html#cfn-ec2-ec2fleet-ondemandoptionsrequest-allocationstrategy
            '''
            result = self._values.get("allocation_strategy")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def capacity_reservation_options(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.CapacityReservationOptionsRequestProperty"]]:
            '''The strategy for using unused Capacity Reservations for fulfilling On-Demand capacity.

            Supported only for fleets of type ``instant`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html#cfn-ec2-ec2fleet-ondemandoptionsrequest-capacityreservationoptions
            '''
            result = self._values.get("capacity_reservation_options")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.CapacityReservationOptionsRequestProperty"]], result)

        @builtins.property
        def max_total_price(self) -> typing.Optional[builtins.str]:
            '''The maximum amount per hour for On-Demand Instances that you're willing to pay.

            .. epigraph::

               If your fleet includes T instances that are configured as ``unlimited`` , and if their average CPU usage exceeds the baseline utilization, you will incur a charge for surplus credits. The ``MaxTotalPrice`` does not account for surplus credits, and, if you use surplus credits, your final cost might be higher than what you specified for ``MaxTotalPrice`` . For more information, see `Surplus credits can incur charges <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-unlimited-mode-concepts.html#unlimited-mode-surplus-credits>`_ in the *Amazon EC2 User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html#cfn-ec2-ec2fleet-ondemandoptionsrequest-maxtotalprice
            '''
            result = self._values.get("max_total_price")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def min_target_capacity(self) -> typing.Optional[jsii.Number]:
            '''The minimum target capacity for On-Demand Instances in the fleet.

            If this minimum capacity isn't reached, no instances are launched.

            Constraints: Maximum value of ``1000`` . Supported only for fleets of type ``instant`` .

            At least one of the following must be specified: ``SingleAvailabilityZone`` | ``SingleInstanceType``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html#cfn-ec2-ec2fleet-ondemandoptionsrequest-mintargetcapacity
            '''
            result = self._values.get("min_target_capacity")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def single_availability_zone(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates that the fleet launches all On-Demand Instances into a single Availability Zone.

            Supported only for fleets of type ``instant`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html#cfn-ec2-ec2fleet-ondemandoptionsrequest-singleavailabilityzone
            '''
            result = self._values.get("single_availability_zone")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def single_instance_type(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates that the fleet uses a single instance type to launch all On-Demand Instances in the fleet.

            Supported only for fleets of type ``instant`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html#cfn-ec2-ec2fleet-ondemandoptionsrequest-singleinstancetype
            '''
            result = self._values.get("single_instance_type")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "OnDemandOptionsRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnEC2FleetPropsMixin.PerformanceFactorReferenceRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"instance_family": "instanceFamily"},
    )
    class PerformanceFactorReferenceRequestProperty:
        def __init__(
            self,
            *,
            instance_family: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specify an instance family to use as the baseline reference for CPU performance.

            All instance types that match your specified attributes will be compared against the CPU performance of the referenced instance family, regardless of CPU manufacturer or architecture.
            .. epigraph::

               Currently, only one instance family can be specified in the list.

            :param instance_family: The instance family to use as a baseline reference. .. epigraph:: Ensure that you specify the correct value for the instance family. The instance family is everything before the period ( ``.`` ) in the instance type name. For example, in the instance type ``c6i.large`` , the instance family is ``c6i`` , not ``c6`` . For more information, see `Amazon EC2 instance type naming conventions <https://docs.aws.amazon.com/ec2/latest/instancetypes/instance-type-names.html>`_ in *Amazon EC2 Instance Types* . The following instance families are *not supported* for performance protection: - ``c1`` - ``g3`` | ``g3s`` - ``hpc7g`` - ``m1`` | ``m2`` - ``mac1`` | ``mac2`` | ``mac2-m1ultra`` | ``mac2-m2`` | ``mac2-m2pro`` - ``p3dn`` | ``p4d`` | ``p5`` - ``t1`` - ``u-12tb1`` | ``u-18tb1`` | ``u-24tb1`` | ``u-3tb1`` | ``u-6tb1`` | ``u-9tb1`` | ``u7i-12tb`` | ``u7in-16tb`` | ``u7in-24tb`` | ``u7in-32tb`` If you enable performance protection by specifying a supported instance family, the returned instance types will exclude the above unsupported instance families. If you specify an unsupported instance family as a value for baseline performance, the API returns an empty response response for `GetInstanceTypesFromInstanceRequirements <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html>`_ and an exception for `CreateFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet.html>`_ , `RequestSpotFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotFleet.html>`_ , `ModifyFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyFleet.html>`_ , and `ModifySpotFleetRequest <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifySpotFleetRequest.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-performancefactorreferencerequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                performance_factor_reference_request_property = ec2_mixins.CfnEC2FleetPropsMixin.PerformanceFactorReferenceRequestProperty(
                    instance_family="instanceFamily"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__bcedb1280014d05a3aa4be64f1e9fca8a6ac46ecf146aed642e6818f6ecc69d7)
                check_type(argname="argument instance_family", value=instance_family, expected_type=type_hints["instance_family"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if instance_family is not None:
                self._values["instance_family"] = instance_family

        @builtins.property
        def instance_family(self) -> typing.Optional[builtins.str]:
            '''The instance family to use as a baseline reference.

            .. epigraph::

               Ensure that you specify the correct value for the instance family. The instance family is everything before the period ( ``.`` ) in the instance type name. For example, in the instance type ``c6i.large`` , the instance family is ``c6i`` , not ``c6`` . For more information, see `Amazon EC2 instance type naming conventions <https://docs.aws.amazon.com/ec2/latest/instancetypes/instance-type-names.html>`_ in *Amazon EC2 Instance Types* .

            The following instance families are *not supported* for performance protection:

            - ``c1``
            - ``g3`` | ``g3s``
            - ``hpc7g``
            - ``m1`` | ``m2``
            - ``mac1`` | ``mac2`` | ``mac2-m1ultra`` | ``mac2-m2`` | ``mac2-m2pro``
            - ``p3dn`` | ``p4d`` | ``p5``
            - ``t1``
            - ``u-12tb1`` | ``u-18tb1`` | ``u-24tb1`` | ``u-3tb1`` | ``u-6tb1`` | ``u-9tb1`` | ``u7i-12tb`` | ``u7in-16tb`` | ``u7in-24tb`` | ``u7in-32tb``

            If you enable performance protection by specifying a supported instance family, the returned instance types will exclude the above unsupported instance families.

            If you specify an unsupported instance family as a value for baseline performance, the API returns an empty response response for `GetInstanceTypesFromInstanceRequirements <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html>`_ and an exception for `CreateFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet.html>`_ , `RequestSpotFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotFleet.html>`_ , `ModifyFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyFleet.html>`_ , and `ModifySpotFleetRequest <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifySpotFleetRequest.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-performancefactorreferencerequest.html#cfn-ec2-ec2fleet-performancefactorreferencerequest-instancefamily
            '''
            result = self._values.get("instance_family")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PerformanceFactorReferenceRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnEC2FleetPropsMixin.PlacementProperty",
        jsii_struct_bases=[],
        name_mapping={
            "affinity": "affinity",
            "availability_zone": "availabilityZone",
            "group_name": "groupName",
            "host_id": "hostId",
            "host_resource_group_arn": "hostResourceGroupArn",
            "partition_number": "partitionNumber",
            "spread_domain": "spreadDomain",
            "tenancy": "tenancy",
        },
    )
    class PlacementProperty:
        def __init__(
            self,
            *,
            affinity: typing.Optional[builtins.str] = None,
            availability_zone: typing.Optional[builtins.str] = None,
            group_name: typing.Optional[builtins.str] = None,
            host_id: typing.Optional[builtins.str] = None,
            host_resource_group_arn: typing.Optional[builtins.str] = None,
            partition_number: typing.Optional[jsii.Number] = None,
            spread_domain: typing.Optional[builtins.str] = None,
            tenancy: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes the placement of an instance.

            :param affinity: The affinity setting for the instance on the Dedicated Host. This parameter is not supported for `CreateFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet>`_ or `ImportInstance <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html>`_ .
            :param availability_zone: The Availability Zone of the instance. On input, you can specify ``AvailabilityZone`` or ``AvailabilityZoneId`` , but not both. If you specify neither one, Amazon EC2 automatically selects an Availability Zone for you. This parameter is not supported for `CreateFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet>`_ .
            :param group_name: The name of the placement group that the instance is in. On input, you can specify ``GroupId`` or ``GroupName`` , but not both.
            :param host_id: The ID of the Dedicated Host on which the instance resides. This parameter is not supported for `CreateFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet>`_ or `ImportInstance <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html>`_ .
            :param host_resource_group_arn: The ARN of the host resource group in which to launch the instances. On input, if you specify this parameter, either omit the *Tenancy* parameter or set it to ``host`` . This parameter is not supported for `CreateFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet>`_ .
            :param partition_number: The number of the partition that the instance is in. Valid only if the placement group strategy is set to ``partition`` . This parameter is not supported for `CreateFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet>`_ .
            :param spread_domain: Reserved for future use.
            :param tenancy: The tenancy of the instance. An instance with a tenancy of ``dedicated`` runs on single-tenant hardware. This parameter is not supported for `CreateFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet>`_ . The ``host`` tenancy is not supported for `ImportInstance <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html>`_ or for T3 instances that are configured for the ``unlimited`` CPU credit option.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                placement_property = ec2_mixins.CfnEC2FleetPropsMixin.PlacementProperty(
                    affinity="affinity",
                    availability_zone="availabilityZone",
                    group_name="groupName",
                    host_id="hostId",
                    host_resource_group_arn="hostResourceGroupArn",
                    partition_number=123,
                    spread_domain="spreadDomain",
                    tenancy="tenancy"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__f6977c793ee2a964db400526ee24bd97e47272bee1a25b1df60ae7e447978db5)
                check_type(argname="argument affinity", value=affinity, expected_type=type_hints["affinity"])
                check_type(argname="argument availability_zone", value=availability_zone, expected_type=type_hints["availability_zone"])
                check_type(argname="argument group_name", value=group_name, expected_type=type_hints["group_name"])
                check_type(argname="argument host_id", value=host_id, expected_type=type_hints["host_id"])
                check_type(argname="argument host_resource_group_arn", value=host_resource_group_arn, expected_type=type_hints["host_resource_group_arn"])
                check_type(argname="argument partition_number", value=partition_number, expected_type=type_hints["partition_number"])
                check_type(argname="argument spread_domain", value=spread_domain, expected_type=type_hints["spread_domain"])
                check_type(argname="argument tenancy", value=tenancy, expected_type=type_hints["tenancy"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if affinity is not None:
                self._values["affinity"] = affinity
            if availability_zone is not None:
                self._values["availability_zone"] = availability_zone
            if group_name is not None:
                self._values["group_name"] = group_name
            if host_id is not None:
                self._values["host_id"] = host_id
            if host_resource_group_arn is not None:
                self._values["host_resource_group_arn"] = host_resource_group_arn
            if partition_number is not None:
                self._values["partition_number"] = partition_number
            if spread_domain is not None:
                self._values["spread_domain"] = spread_domain
            if tenancy is not None:
                self._values["tenancy"] = tenancy

        @builtins.property
        def affinity(self) -> typing.Optional[builtins.str]:
            '''The affinity setting for the instance on the Dedicated Host.

            This parameter is not supported for `CreateFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet>`_ or `ImportInstance <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html#cfn-ec2-ec2fleet-placement-affinity
            '''
            result = self._values.get("affinity")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def availability_zone(self) -> typing.Optional[builtins.str]:
            '''The Availability Zone of the instance.

            On input, you can specify ``AvailabilityZone`` or ``AvailabilityZoneId`` , but not both. If you specify neither one, Amazon EC2 automatically selects an Availability Zone for you.

            This parameter is not supported for `CreateFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html#cfn-ec2-ec2fleet-placement-availabilityzone
            '''
            result = self._values.get("availability_zone")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def group_name(self) -> typing.Optional[builtins.str]:
            '''The name of the placement group that the instance is in.

            On input, you can specify ``GroupId`` or ``GroupName`` , but not both.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html#cfn-ec2-ec2fleet-placement-groupname
            '''
            result = self._values.get("group_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def host_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the Dedicated Host on which the instance resides.

            This parameter is not supported for `CreateFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet>`_ or `ImportInstance <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html#cfn-ec2-ec2fleet-placement-hostid
            '''
            result = self._values.get("host_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def host_resource_group_arn(self) -> typing.Optional[builtins.str]:
            '''The ARN of the host resource group in which to launch the instances.

            On input, if you specify this parameter, either omit the *Tenancy* parameter or set it to ``host`` .

            This parameter is not supported for `CreateFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html#cfn-ec2-ec2fleet-placement-hostresourcegrouparn
            '''
            result = self._values.get("host_resource_group_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def partition_number(self) -> typing.Optional[jsii.Number]:
            '''The number of the partition that the instance is in.

            Valid only if the placement group strategy is set to ``partition`` .

            This parameter is not supported for `CreateFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html#cfn-ec2-ec2fleet-placement-partitionnumber
            '''
            result = self._values.get("partition_number")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def spread_domain(self) -> typing.Optional[builtins.str]:
            '''Reserved for future use.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html#cfn-ec2-ec2fleet-placement-spreaddomain
            '''
            result = self._values.get("spread_domain")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def tenancy(self) -> typing.Optional[builtins.str]:
            '''The tenancy of the instance. An instance with a tenancy of ``dedicated`` runs on single-tenant hardware.

            This parameter is not supported for `CreateFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet>`_ . The ``host`` tenancy is not supported for `ImportInstance <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html>`_ or for T3 instances that are configured for the ``unlimited`` CPU credit option.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html#cfn-ec2-ec2fleet-placement-tenancy
            '''
            result = self._values.get("tenancy")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PlacementProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnEC2FleetPropsMixin.SpotOptionsRequestProperty",
        jsii_struct_bases=[],
        name_mapping={
            "allocation_strategy": "allocationStrategy",
            "instance_interruption_behavior": "instanceInterruptionBehavior",
            "instance_pools_to_use_count": "instancePoolsToUseCount",
            "maintenance_strategies": "maintenanceStrategies",
            "max_total_price": "maxTotalPrice",
            "min_target_capacity": "minTargetCapacity",
            "single_availability_zone": "singleAvailabilityZone",
            "single_instance_type": "singleInstanceType",
        },
    )
    class SpotOptionsRequestProperty:
        def __init__(
            self,
            *,
            allocation_strategy: typing.Optional[builtins.str] = None,
            instance_interruption_behavior: typing.Optional[builtins.str] = None,
            instance_pools_to_use_count: typing.Optional[jsii.Number] = None,
            maintenance_strategies: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnEC2FleetPropsMixin.MaintenanceStrategiesProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            max_total_price: typing.Optional[builtins.str] = None,
            min_target_capacity: typing.Optional[jsii.Number] = None,
            single_availability_zone: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            single_instance_type: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        ) -> None:
            '''Specifies the configuration of Spot Instances for an EC2 Fleet.

            ``SpotOptionsRequest`` is a property of the `AWS::EC2::EC2Fleet <https://docs.aws.amazon.com//AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html>`_ resource.

            :param allocation_strategy: Indicates how to allocate the target Spot Instance capacity across the Spot Instance pools specified by the EC2 Fleet. If the allocation strategy is ``lowestPrice`` , EC2 Fleet launches instances from the Spot Instance pools with the lowest price. This is the default allocation strategy. If the allocation strategy is ``diversified`` , EC2 Fleet launches instances from all the Spot Instance pools that you specify. If the allocation strategy is ``capacityOptimized`` , EC2 Fleet launches instances from Spot Instance pools that are optimally chosen based on the available Spot Instance capacity. *Allowed Values* : ``lowestPrice`` | ``diversified`` | ``capacityOptimized`` | ``capacityOptimizedPrioritized``
            :param instance_interruption_behavior: The behavior when a Spot Instance is interrupted. Default: ``terminate``
            :param instance_pools_to_use_count: The number of Spot pools across which to allocate your target Spot capacity. Supported only when Spot ``AllocationStrategy`` is set to ``lowest-price`` . EC2 Fleet selects the cheapest Spot pools and evenly allocates your target Spot capacity across the number of Spot pools that you specify. Note that EC2 Fleet attempts to draw Spot Instances from the number of pools that you specify on a best effort basis. If a pool runs out of Spot capacity before fulfilling your target capacity, EC2 Fleet will continue to fulfill your request by drawing from the next cheapest pool. To ensure that your target capacity is met, you might receive Spot Instances from more than the number of pools that you specified. Similarly, if most of the pools have no Spot capacity, you might receive your full target capacity from fewer than the number of pools that you specified.
            :param maintenance_strategies: The strategies for managing your Spot Instances that are at an elevated risk of being interrupted.
            :param max_total_price: The maximum amount per hour for Spot Instances that you're willing to pay. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price. .. epigraph:: If you specify a maximum price, your Spot Instances will be interrupted more frequently than if you do not specify this parameter. > If your fleet includes T instances that are configured as ``unlimited`` , and if their average CPU usage exceeds the baseline utilization, you will incur a charge for surplus credits. The ``MaxTotalPrice`` does not account for surplus credits, and, if you use surplus credits, your final cost might be higher than what you specified for ``MaxTotalPrice`` . For more information, see `Surplus credits can incur charges <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-unlimited-mode-concepts.html#unlimited-mode-surplus-credits>`_ in the *Amazon EC2 User Guide* .
            :param min_target_capacity: The minimum target capacity for Spot Instances in the fleet. If this minimum capacity isn't reached, no instances are launched. Constraints: Maximum value of ``1000`` . Supported only for fleets of type ``instant`` . At least one of the following must be specified: ``SingleAvailabilityZone`` | ``SingleInstanceType``
            :param single_availability_zone: Indicates that the fleet launches all Spot Instances into a single Availability Zone. Supported only for fleets of type ``instant`` .
            :param single_instance_type: Indicates that the fleet uses a single instance type to launch all Spot Instances in the fleet. Supported only for fleets of type ``instant`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                spot_options_request_property = ec2_mixins.CfnEC2FleetPropsMixin.SpotOptionsRequestProperty(
                    allocation_strategy="allocationStrategy",
                    instance_interruption_behavior="instanceInterruptionBehavior",
                    instance_pools_to_use_count=123,
                    maintenance_strategies=ec2_mixins.CfnEC2FleetPropsMixin.MaintenanceStrategiesProperty(
                        capacity_rebalance=ec2_mixins.CfnEC2FleetPropsMixin.CapacityRebalanceProperty(
                            replacement_strategy="replacementStrategy",
                            termination_delay=123
                        )
                    ),
                    max_total_price="maxTotalPrice",
                    min_target_capacity=123,
                    single_availability_zone=False,
                    single_instance_type=False
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__3c6b2df71255bf48ab1c14a395b17e27504d9951e17b7f1a4e11b258b5820a2a)
                check_type(argname="argument allocation_strategy", value=allocation_strategy, expected_type=type_hints["allocation_strategy"])
                check_type(argname="argument instance_interruption_behavior", value=instance_interruption_behavior, expected_type=type_hints["instance_interruption_behavior"])
                check_type(argname="argument instance_pools_to_use_count", value=instance_pools_to_use_count, expected_type=type_hints["instance_pools_to_use_count"])
                check_type(argname="argument maintenance_strategies", value=maintenance_strategies, expected_type=type_hints["maintenance_strategies"])
                check_type(argname="argument max_total_price", value=max_total_price, expected_type=type_hints["max_total_price"])
                check_type(argname="argument min_target_capacity", value=min_target_capacity, expected_type=type_hints["min_target_capacity"])
                check_type(argname="argument single_availability_zone", value=single_availability_zone, expected_type=type_hints["single_availability_zone"])
                check_type(argname="argument single_instance_type", value=single_instance_type, expected_type=type_hints["single_instance_type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if allocation_strategy is not None:
                self._values["allocation_strategy"] = allocation_strategy
            if instance_interruption_behavior is not None:
                self._values["instance_interruption_behavior"] = instance_interruption_behavior
            if instance_pools_to_use_count is not None:
                self._values["instance_pools_to_use_count"] = instance_pools_to_use_count
            if maintenance_strategies is not None:
                self._values["maintenance_strategies"] = maintenance_strategies
            if max_total_price is not None:
                self._values["max_total_price"] = max_total_price
            if min_target_capacity is not None:
                self._values["min_target_capacity"] = min_target_capacity
            if single_availability_zone is not None:
                self._values["single_availability_zone"] = single_availability_zone
            if single_instance_type is not None:
                self._values["single_instance_type"] = single_instance_type

        @builtins.property
        def allocation_strategy(self) -> typing.Optional[builtins.str]:
            '''Indicates how to allocate the target Spot Instance capacity across the Spot Instance pools specified by the EC2 Fleet.

            If the allocation strategy is ``lowestPrice`` , EC2 Fleet launches instances from the Spot Instance pools with the lowest price. This is the default allocation strategy.

            If the allocation strategy is ``diversified`` , EC2 Fleet launches instances from all the Spot Instance pools that you specify.

            If the allocation strategy is ``capacityOptimized`` , EC2 Fleet launches instances from Spot Instance pools that are optimally chosen based on the available Spot Instance capacity.

            *Allowed Values* : ``lowestPrice`` | ``diversified`` | ``capacityOptimized`` | ``capacityOptimizedPrioritized``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-allocationstrategy
            '''
            result = self._values.get("allocation_strategy")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def instance_interruption_behavior(self) -> typing.Optional[builtins.str]:
            '''The behavior when a Spot Instance is interrupted.

            Default: ``terminate``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-instanceinterruptionbehavior
            '''
            result = self._values.get("instance_interruption_behavior")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def instance_pools_to_use_count(self) -> typing.Optional[jsii.Number]:
            '''The number of Spot pools across which to allocate your target Spot capacity.

            Supported only when Spot ``AllocationStrategy`` is set to ``lowest-price`` . EC2 Fleet selects the cheapest Spot pools and evenly allocates your target Spot capacity across the number of Spot pools that you specify.

            Note that EC2 Fleet attempts to draw Spot Instances from the number of pools that you specify on a best effort basis. If a pool runs out of Spot capacity before fulfilling your target capacity, EC2 Fleet will continue to fulfill your request by drawing from the next cheapest pool. To ensure that your target capacity is met, you might receive Spot Instances from more than the number of pools that you specified. Similarly, if most of the pools have no Spot capacity, you might receive your full target capacity from fewer than the number of pools that you specified.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-instancepoolstousecount
            '''
            result = self._values.get("instance_pools_to_use_count")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def maintenance_strategies(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.MaintenanceStrategiesProperty"]]:
            '''The strategies for managing your Spot Instances that are at an elevated risk of being interrupted.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-maintenancestrategies
            '''
            result = self._values.get("maintenance_strategies")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnEC2FleetPropsMixin.MaintenanceStrategiesProperty"]], result)

        @builtins.property
        def max_total_price(self) -> typing.Optional[builtins.str]:
            '''The maximum amount per hour for Spot Instances that you're willing to pay.

            We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.
            .. epigraph::

               If you specify a maximum price, your Spot Instances will be interrupted more frequently than if you do not specify this parameter. > If your fleet includes T instances that are configured as ``unlimited`` , and if their average CPU usage exceeds the baseline utilization, you will incur a charge for surplus credits. The ``MaxTotalPrice`` does not account for surplus credits, and, if you use surplus credits, your final cost might be higher than what you specified for ``MaxTotalPrice`` . For more information, see `Surplus credits can incur charges <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-unlimited-mode-concepts.html#unlimited-mode-surplus-credits>`_ in the *Amazon EC2 User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-maxtotalprice
            '''
            result = self._values.get("max_total_price")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def min_target_capacity(self) -> typing.Optional[jsii.Number]:
            '''The minimum target capacity for Spot Instances in the fleet.

            If this minimum capacity isn't reached, no instances are launched.

            Constraints: Maximum value of ``1000`` . Supported only for fleets of type ``instant`` .

            At least one of the following must be specified: ``SingleAvailabilityZone`` | ``SingleInstanceType``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-mintargetcapacity
            '''
            result = self._values.get("min_target_capacity")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def single_availability_zone(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates that the fleet launches all Spot Instances into a single Availability Zone.

            Supported only for fleets of type ``instant`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-singleavailabilityzone
            '''
            result = self._values.get("single_availability_zone")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def single_instance_type(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates that the fleet uses a single instance type to launch all Spot Instances in the fleet.

            Supported only for fleets of type ``instant`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-singleinstancetype
            '''
            result = self._values.get("single_instance_type")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SpotOptionsRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnEC2FleetPropsMixin.TagSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={"resource_type": "resourceType", "tags": "tags"},
    )
    class TagSpecificationProperty:
        def __init__(
            self,
            *,
            resource_type: typing.Optional[builtins.str] = None,
            tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Specifies the tags to apply to a resource when the resource is being created for an EC2 Fleet.

            ``TagSpecification`` is a property of the `AWS::EC2::EC2Fleet <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html>`_ resource.

            :param resource_type: The type of resource to tag.
            :param tags: The tags to apply to the resource.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-tagspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                from aws_cdk import CfnTag
                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                tag_specification_property = ec2_mixins.CfnEC2FleetPropsMixin.TagSpecificationProperty(
                    resource_type="resourceType",
                    tags=[CfnTag(
                        key="key",
                        value="value"
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__0d1313bc805ea3d571eecff01f484d33857f91316f4ca3393781c20fa63e20eb)
                check_type(argname="argument resource_type", value=resource_type, expected_type=type_hints["resource_type"])
                check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if resource_type is not None:
                self._values["resource_type"] = resource_type
            if tags is not None:
                self._values["tags"] = tags

        @builtins.property
        def resource_type(self) -> typing.Optional[builtins.str]:
            '''The type of resource to tag.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-tagspecification.html#cfn-ec2-ec2fleet-tagspecification-resourcetype
            '''
            result = self._values.get("resource_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
            '''The tags to apply to the resource.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-tagspecification.html#cfn-ec2-ec2fleet-tagspecification-tags
            '''
            result = self._values.get("tags")
            return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TagSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnEC2FleetPropsMixin.TargetCapacitySpecificationRequestProperty",
        jsii_struct_bases=[],
        name_mapping={
            "default_target_capacity_type": "defaultTargetCapacityType",
            "on_demand_target_capacity": "onDemandTargetCapacity",
            "spot_target_capacity": "spotTargetCapacity",
            "target_capacity_unit_type": "targetCapacityUnitType",
            "total_target_capacity": "totalTargetCapacity",
        },
    )
    class TargetCapacitySpecificationRequestProperty:
        def __init__(
            self,
            *,
            default_target_capacity_type: typing.Optional[builtins.str] = None,
            on_demand_target_capacity: typing.Optional[jsii.Number] = None,
            spot_target_capacity: typing.Optional[jsii.Number] = None,
            target_capacity_unit_type: typing.Optional[builtins.str] = None,
            total_target_capacity: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Specifies the number of units to request for an EC2 Fleet.

            You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is ``maintain`` , you can specify a target capacity of ``0`` and add capacity later.

            ``TargetCapacitySpecificationRequest`` is a property of the `AWS::EC2::EC2Fleet <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html>`_ resource.

            :param default_target_capacity_type: The default target capacity type.
            :param on_demand_target_capacity: The number of On-Demand units to request.
            :param spot_target_capacity: The number of Spot units to request.
            :param target_capacity_unit_type: The unit for the target capacity. You can specify this parameter only when using attributed-based instance type selection. Default: ``units`` (the number of instances)
            :param total_target_capacity: The number of units to request, filled using the default target capacity type.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                target_capacity_specification_request_property = ec2_mixins.CfnEC2FleetPropsMixin.TargetCapacitySpecificationRequestProperty(
                    default_target_capacity_type="defaultTargetCapacityType",
                    on_demand_target_capacity=123,
                    spot_target_capacity=123,
                    target_capacity_unit_type="targetCapacityUnitType",
                    total_target_capacity=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__a89ddaeb76525805a280e3a769f5b4aaaad797551f31f57265001a2ad94a07d4)
                check_type(argname="argument default_target_capacity_type", value=default_target_capacity_type, expected_type=type_hints["default_target_capacity_type"])
                check_type(argname="argument on_demand_target_capacity", value=on_demand_target_capacity, expected_type=type_hints["on_demand_target_capacity"])
                check_type(argname="argument spot_target_capacity", value=spot_target_capacity, expected_type=type_hints["spot_target_capacity"])
                check_type(argname="argument target_capacity_unit_type", value=target_capacity_unit_type, expected_type=type_hints["target_capacity_unit_type"])
                check_type(argname="argument total_target_capacity", value=total_target_capacity, expected_type=type_hints["total_target_capacity"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if default_target_capacity_type is not None:
                self._values["default_target_capacity_type"] = default_target_capacity_type
            if on_demand_target_capacity is not None:
                self._values["on_demand_target_capacity"] = on_demand_target_capacity
            if spot_target_capacity is not None:
                self._values["spot_target_capacity"] = spot_target_capacity
            if target_capacity_unit_type is not None:
                self._values["target_capacity_unit_type"] = target_capacity_unit_type
            if total_target_capacity is not None:
                self._values["total_target_capacity"] = total_target_capacity

        @builtins.property
        def default_target_capacity_type(self) -> typing.Optional[builtins.str]:
            '''The default target capacity type.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html#cfn-ec2-ec2fleet-targetcapacityspecificationrequest-defaulttargetcapacitytype
            '''
            result = self._values.get("default_target_capacity_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def on_demand_target_capacity(self) -> typing.Optional[jsii.Number]:
            '''The number of On-Demand units to request.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html#cfn-ec2-ec2fleet-targetcapacityspecificationrequest-ondemandtargetcapacity
            '''
            result = self._values.get("on_demand_target_capacity")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def spot_target_capacity(self) -> typing.Optional[jsii.Number]:
            '''The number of Spot units to request.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html#cfn-ec2-ec2fleet-targetcapacityspecificationrequest-spottargetcapacity
            '''
            result = self._values.get("spot_target_capacity")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def target_capacity_unit_type(self) -> typing.Optional[builtins.str]:
            '''The unit for the target capacity. You can specify this parameter only when using attributed-based instance type selection.

            Default: ``units`` (the number of instances)

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html#cfn-ec2-ec2fleet-targetcapacityspecificationrequest-targetcapacityunittype
            '''
            result = self._values.get("target_capacity_unit_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def total_target_capacity(self) -> typing.Optional[jsii.Number]:
            '''The number of units to request, filled using the default target capacity type.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html#cfn-ec2-ec2fleet-targetcapacityspecificationrequest-totaltargetcapacity
            '''
            result = self._values.get("total_target_capacity")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TargetCapacitySpecificationRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnEC2FleetPropsMixin.TotalLocalStorageGBRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class TotalLocalStorageGBRequestProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum amount of total local storage, in GB.

            :param max: The maximum amount of total local storage, in GB. To specify no maximum limit, omit this parameter.
            :param min: The minimum amount of total local storage, in GB. To specify no minimum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-totallocalstoragegbrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                total_local_storage_gBRequest_property = ec2_mixins.CfnEC2FleetPropsMixin.TotalLocalStorageGBRequestProperty(
                    max=123,
                    min=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__c2d5aa9bc115dfae49e05201b78d29a9edad7a8e5c3359ffdf29c098f343f2a0)
                check_type(argname="argument max", value=max, expected_type=type_hints["max"])
                check_type(argname="argument min", value=min, expected_type=type_hints["min"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum amount of total local storage, in GB.

            To specify no maximum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-totallocalstoragegbrequest.html#cfn-ec2-ec2fleet-totallocalstoragegbrequest-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum amount of total local storage, in GB.

            To specify no minimum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-totallocalstoragegbrequest.html#cfn-ec2-ec2fleet-totallocalstoragegbrequest-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TotalLocalStorageGBRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnEC2FleetPropsMixin.VCpuCountRangeRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class VCpuCountRangeRequestProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum number of vCPUs.

            :param max: The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
            :param min: The minimum number of vCPUs. To specify no minimum limit, specify ``0`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-vcpucountrangerequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                v_cpu_count_range_request_property = ec2_mixins.CfnEC2FleetPropsMixin.VCpuCountRangeRequestProperty(
                    max=123,
                    min=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__3ab7ac48ded16bf8f6123977a0a0ab9b350c145e5e2c4dc1aa8e00cf511f258f)
                check_type(argname="argument max", value=max, expected_type=type_hints["max"])
                check_type(argname="argument min", value=min, expected_type=type_hints["min"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum number of vCPUs.

            To specify no maximum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-vcpucountrangerequest.html#cfn-ec2-ec2fleet-vcpucountrangerequest-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum number of vCPUs.

            To specify no minimum limit, specify ``0`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-vcpucountrangerequest.html#cfn-ec2-ec2fleet-vcpucountrangerequest-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "VCpuCountRangeRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnEIPAssociationMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "allocation_id": "allocationId",
        "eip": "eip",
        "instance_id": "instanceId",
        "network_interface_id": "networkInterfaceId",
        "private_ip_address": "privateIpAddress",
    },
)
class CfnEIPAssociationMixinProps:
    def __init__(
        self,
        *,
        allocation_id: typing.Optional[builtins.str] = None,
        eip: typing.Optional[builtins.str] = None,
        instance_id: typing.Optional[builtins.str] = None,
        network_interface_id: typing.Optional[builtins.str] = None,
        private_ip_address: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnEIPAssociationPropsMixin.

        :param allocation_id: The allocation ID. This is required.
        :param eip: 
        :param instance_id: The ID of the instance. The instance must have exactly one attached network interface. You can specify either the instance ID or the network interface ID, but not both.
        :param network_interface_id: The ID of the network interface. If the instance has more than one network interface, you must specify a network interface ID. You can specify either the instance ID or the network interface ID, but not both.
        :param private_ip_address: The primary or secondary private IP address to associate with the Elastic IP address. If no private IP address is specified, the Elastic IP address is associated with the primary private IP address.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eipassociation.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_eIPAssociation_mixin_props = ec2_mixins.CfnEIPAssociationMixinProps(
                allocation_id="allocationId",
                eip="eip",
                instance_id="instanceId",
                network_interface_id="networkInterfaceId",
                private_ip_address="privateIpAddress"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6aaafba9cc377c70b61c7624e9ce04d1d4a9be19d0c47893d796db52f20bfb38)
            check_type(argname="argument allocation_id", value=allocation_id, expected_type=type_hints["allocation_id"])
            check_type(argname="argument eip", value=eip, expected_type=type_hints["eip"])
            check_type(argname="argument instance_id", value=instance_id, expected_type=type_hints["instance_id"])
            check_type(argname="argument network_interface_id", value=network_interface_id, expected_type=type_hints["network_interface_id"])
            check_type(argname="argument private_ip_address", value=private_ip_address, expected_type=type_hints["private_ip_address"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if allocation_id is not None:
            self._values["allocation_id"] = allocation_id
        if eip is not None:
            self._values["eip"] = eip
        if instance_id is not None:
            self._values["instance_id"] = instance_id
        if network_interface_id is not None:
            self._values["network_interface_id"] = network_interface_id
        if private_ip_address is not None:
            self._values["private_ip_address"] = private_ip_address

    @builtins.property
    def allocation_id(self) -> typing.Optional[builtins.str]:
        '''The allocation ID.

        This is required.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eipassociation.html#cfn-ec2-eipassociation-allocationid
        '''
        result = self._values.get("allocation_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def eip(self) -> typing.Optional[builtins.str]:
        '''
        :deprecated: this property has been deprecated

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eipassociation.html#cfn-ec2-eipassociation-eip
        :stability: deprecated
        '''
        result = self._values.get("eip")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def instance_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the instance.

        The instance must have exactly one attached network interface. You can specify either the instance ID or the network interface ID, but not both.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eipassociation.html#cfn-ec2-eipassociation-instanceid
        '''
        result = self._values.get("instance_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def network_interface_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the network interface.

        If the instance has more than one network interface, you must specify a network interface ID.

        You can specify either the instance ID or the network interface ID, but not both.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eipassociation.html#cfn-ec2-eipassociation-networkinterfaceid
        '''
        result = self._values.get("network_interface_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def private_ip_address(self) -> typing.Optional[builtins.str]:
        '''The primary or secondary private IP address to associate with the Elastic IP address.

        If no private IP address is specified, the Elastic IP address is associated with the primary private IP address.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eipassociation.html#cfn-ec2-eipassociation-privateipaddress
        '''
        result = self._values.get("private_ip_address")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnEIPAssociationMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnEIPAssociationPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnEIPAssociationPropsMixin",
):
    '''Associates an Elastic IP address with an instance or a network interface.

    Before you can use an Elastic IP address, you must allocate it to your account. For more information about working with Elastic IP addresses, see `Elastic IP address concepts and rules <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-eips.html#vpc-eip-overview>`_ .

    You must specify ``AllocationId`` and either ``InstanceId`` , ``NetworkInterfaceId`` , or ``PrivateIpAddress`` .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eipassociation.html
    :cloudformationResource: AWS::EC2::EIPAssociation
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_eIPAssociation_props_mixin = ec2_mixins.CfnEIPAssociationPropsMixin(ec2_mixins.CfnEIPAssociationMixinProps(
            allocation_id="allocationId",
            eip="eip",
            instance_id="instanceId",
            network_interface_id="networkInterfaceId",
            private_ip_address="privateIpAddress"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnEIPAssociationMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::EIPAssociation``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5f75a125fed46cf19f0aecae05c651563140f330ed414d206462b1909a1fd616)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__82d5d7b37fe86c1420a8e083ddceed0fd81e4299f7b9695cbcfffc4b987a9afb)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1c41b29e46fd82d97e3559b86479520e7161b068873e4f814987dec3bab5a8c9)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnEIPAssociationMixinProps":
        return typing.cast("CfnEIPAssociationMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnEIPMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "address": "address",
        "domain": "domain",
        "instance_id": "instanceId",
        "ipam_pool_id": "ipamPoolId",
        "network_border_group": "networkBorderGroup",
        "public_ipv4_pool": "publicIpv4Pool",
        "tags": "tags",
        "transfer_address": "transferAddress",
    },
)
class CfnEIPMixinProps:
    def __init__(
        self,
        *,
        address: typing.Optional[builtins.str] = None,
        domain: typing.Optional[builtins.str] = None,
        instance_id: typing.Optional[builtins.str] = None,
        ipam_pool_id: typing.Optional[builtins.str] = None,
        network_border_group: typing.Optional[builtins.str] = None,
        public_ipv4_pool: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        transfer_address: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnEIPPropsMixin.

        :param address: An Elastic IP address or a carrier IP address in a Wavelength Zone.
        :param domain: The network ( ``vpc`` ). If you define an Elastic IP address and associate it with a VPC that is defined in the same template, you must declare a dependency on the VPC-gateway attachment by using the `DependsOn Attribute <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html>`_ on this resource.
        :param instance_id: The ID of the instance. .. epigraph:: Updates to the ``InstanceId`` property may require *some interruptions* . Updates on an EIP reassociates the address on its associated resource.
        :param ipam_pool_id: The ID of an IPAM pool which has an Amazon-provided or BYOIP public IPv4 CIDR provisioned to it. For more information, see `Allocate sequential Elastic IP addresses from an IPAM pool <https://docs.aws.amazon.com/vpc/latest/ipam/tutorials-eip-pool.html>`_ in the *Amazon VPC IPAM User Guide* .
        :param network_border_group: A unique set of Availability Zones, Local Zones, or Wavelength Zones from which AWS advertises IP addresses. Use this parameter to limit the IP address to this location. IP addresses cannot move between network border groups. Use `DescribeAvailabilityZones <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeAvailabilityZones.html>`_ to view the network border groups.
        :param public_ipv4_pool: The ID of an address pool that you own. Use this parameter to let Amazon EC2 select an address from the address pool. .. epigraph:: Updates to the ``PublicIpv4Pool`` property may require *some interruptions* . Updates on an EIP reassociates the address on its associated resource.
        :param tags: Any tags assigned to the Elastic IP address. .. epigraph:: Updates to the ``Tags`` property may require *some interruptions* . Updates on an EIP reassociates the address on its associated resource.
        :param transfer_address: The Elastic IP address you are accepting for transfer. You can only accept one transferred address. For more information on Elastic IP address transfers, see `Transfer Elastic IP addresses <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-eips.html#transfer-EIPs-intro>`_ in the *Amazon Virtual Private Cloud User Guide* .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_eIPMixin_props = ec2_mixins.CfnEIPMixinProps(
                address="address",
                domain="domain",
                instance_id="instanceId",
                ipam_pool_id="ipamPoolId",
                network_border_group="networkBorderGroup",
                public_ipv4_pool="publicIpv4Pool",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                transfer_address="transferAddress"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7b4321961ee9578d9fcd8cc8e89efb811afa69d80f452514f7f10d5fd4236ae7)
            check_type(argname="argument address", value=address, expected_type=type_hints["address"])
            check_type(argname="argument domain", value=domain, expected_type=type_hints["domain"])
            check_type(argname="argument instance_id", value=instance_id, expected_type=type_hints["instance_id"])
            check_type(argname="argument ipam_pool_id", value=ipam_pool_id, expected_type=type_hints["ipam_pool_id"])
            check_type(argname="argument network_border_group", value=network_border_group, expected_type=type_hints["network_border_group"])
            check_type(argname="argument public_ipv4_pool", value=public_ipv4_pool, expected_type=type_hints["public_ipv4_pool"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument transfer_address", value=transfer_address, expected_type=type_hints["transfer_address"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if address is not None:
            self._values["address"] = address
        if domain is not None:
            self._values["domain"] = domain
        if instance_id is not None:
            self._values["instance_id"] = instance_id
        if ipam_pool_id is not None:
            self._values["ipam_pool_id"] = ipam_pool_id
        if network_border_group is not None:
            self._values["network_border_group"] = network_border_group
        if public_ipv4_pool is not None:
            self._values["public_ipv4_pool"] = public_ipv4_pool
        if tags is not None:
            self._values["tags"] = tags
        if transfer_address is not None:
            self._values["transfer_address"] = transfer_address

    @builtins.property
    def address(self) -> typing.Optional[builtins.str]:
        '''An Elastic IP address or a carrier IP address in a Wavelength Zone.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html#cfn-ec2-eip-address
        '''
        result = self._values.get("address")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def domain(self) -> typing.Optional[builtins.str]:
        '''The network ( ``vpc`` ).

        If you define an Elastic IP address and associate it with a VPC that is defined in the same template, you must declare a dependency on the VPC-gateway attachment by using the `DependsOn Attribute <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html>`_ on this resource.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html#cfn-ec2-eip-domain
        '''
        result = self._values.get("domain")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def instance_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the instance.

        .. epigraph::

           Updates to the ``InstanceId`` property may require *some interruptions* . Updates on an EIP reassociates the address on its associated resource.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html#cfn-ec2-eip-instanceid
        '''
        result = self._values.get("instance_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ipam_pool_id(self) -> typing.Optional[builtins.str]:
        '''The ID of an IPAM pool which has an Amazon-provided or BYOIP public IPv4 CIDR provisioned to it.

        For more information, see `Allocate sequential Elastic IP addresses from an IPAM pool <https://docs.aws.amazon.com/vpc/latest/ipam/tutorials-eip-pool.html>`_ in the *Amazon VPC IPAM User Guide* .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html#cfn-ec2-eip-ipampoolid
        '''
        result = self._values.get("ipam_pool_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def network_border_group(self) -> typing.Optional[builtins.str]:
        '''A unique set of Availability Zones, Local Zones, or Wavelength Zones from which AWS advertises IP addresses.

        Use this parameter to limit the IP address to this location. IP addresses cannot move between network border groups.

        Use `DescribeAvailabilityZones <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeAvailabilityZones.html>`_ to view the network border groups.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html#cfn-ec2-eip-networkbordergroup
        '''
        result = self._values.get("network_border_group")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def public_ipv4_pool(self) -> typing.Optional[builtins.str]:
        '''The ID of an address pool that you own.

        Use this parameter to let Amazon EC2 select an address from the address pool.
        .. epigraph::

           Updates to the ``PublicIpv4Pool`` property may require *some interruptions* . Updates on an EIP reassociates the address on its associated resource.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html#cfn-ec2-eip-publicipv4pool
        '''
        result = self._values.get("public_ipv4_pool")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''Any tags assigned to the Elastic IP address.

        .. epigraph::

           Updates to the ``Tags`` property may require *some interruptions* . Updates on an EIP reassociates the address on its associated resource.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html#cfn-ec2-eip-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def transfer_address(self) -> typing.Optional[builtins.str]:
        '''The Elastic IP address you are accepting for transfer.

        You can only accept one transferred address. For more information on Elastic IP address transfers, see `Transfer Elastic IP addresses <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-eips.html#transfer-EIPs-intro>`_ in the *Amazon Virtual Private Cloud User Guide* .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html#cfn-ec2-eip-transferaddress
        '''
        result = self._values.get("transfer_address")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnEIPMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnEIPPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnEIPPropsMixin",
):
    '''Specifies an Elastic IP (EIP) address and can, optionally, associate it with an Amazon EC2 instance.

    You can allocate an Elastic IP address from an address pool owned by AWS or from an address pool created from a public IPv4 address range that you have brought to AWS for use with your AWS resources using bring your own IP addresses (BYOIP). For more information, see `Bring Your Own IP Addresses (BYOIP) <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-byoip.html>`_ in the *Amazon EC2 User Guide* .

    For more information, see `Elastic IP Addresses <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html>`_ in the *Amazon EC2 User Guide* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html
    :cloudformationResource: AWS::EC2::EIP
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_eIPProps_mixin = ec2_mixins.CfnEIPPropsMixin(ec2_mixins.CfnEIPMixinProps(
            address="address",
            domain="domain",
            instance_id="instanceId",
            ipam_pool_id="ipamPoolId",
            network_border_group="networkBorderGroup",
            public_ipv4_pool="publicIpv4Pool",
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            transfer_address="transferAddress"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnEIPMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::EIP``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__af6d10912a62e85163c2029b7478781f0881b73183c96170ca49f3da535e1d65)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bf097a02687c5e5b23fc0ec3c06229b35eabc5cad3a79a146a3ceb93b251d5db)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e46afd6f46be79c7f8623a1c4dfbd6160cf8d24cefa1db52cf2e834669539468)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnEIPMixinProps":
        return typing.cast("CfnEIPMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnEgressOnlyInternetGatewayMixinProps",
    jsii_struct_bases=[],
    name_mapping={"tags": "tags", "vpc_id": "vpcId"},
)
class CfnEgressOnlyInternetGatewayMixinProps:
    def __init__(
        self,
        *,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        vpc_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnEgressOnlyInternetGatewayPropsMixin.

        :param tags: The tags assigned to the egress-only internet gateway.
        :param vpc_id: The ID of the VPC for which to create the egress-only internet gateway.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-egressonlyinternetgateway.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_egress_only_internet_gateway_mixin_props = ec2_mixins.CfnEgressOnlyInternetGatewayMixinProps(
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                vpc_id="vpcId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__292636e4119269553ac36bb94a807f4f88b73017215231098112f6090bf4c473)
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument vpc_id", value=vpc_id, expected_type=type_hints["vpc_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if tags is not None:
            self._values["tags"] = tags
        if vpc_id is not None:
            self._values["vpc_id"] = vpc_id

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags assigned to the egress-only internet gateway.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-egressonlyinternetgateway.html#cfn-ec2-egressonlyinternetgateway-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def vpc_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the VPC for which to create the egress-only internet gateway.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-egressonlyinternetgateway.html#cfn-ec2-egressonlyinternetgateway-vpcid
        '''
        result = self._values.get("vpc_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnEgressOnlyInternetGatewayMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnEgressOnlyInternetGatewayPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnEgressOnlyInternetGatewayPropsMixin",
):
    '''[IPv6 only] Specifies an egress-only internet gateway for your VPC.

    An egress-only internet gateway is used to enable outbound communication over IPv6 from instances in your VPC to the internet, and prevents hosts outside of your VPC from initiating an IPv6 connection with your instance.

    For more information, see `Egress-only internet gateway <https://docs.aws.amazon.com/vpc/latest/userguide/egress-only-internet-gateway.html>`_ in the *Amazon VPC User Guide* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-egressonlyinternetgateway.html
    :cloudformationResource: AWS::EC2::EgressOnlyInternetGateway
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_egress_only_internet_gateway_props_mixin = ec2_mixins.CfnEgressOnlyInternetGatewayPropsMixin(ec2_mixins.CfnEgressOnlyInternetGatewayMixinProps(
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            vpc_id="vpcId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnEgressOnlyInternetGatewayMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::EgressOnlyInternetGateway``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9d3725848eba9124e67c376045cf5cd5583f74845d93546c56182fda7c3357ea)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__40ccbf3a44dd3ffc513cfa80b78c38c2e66352e3436f894229f81f8e96b6720f)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3ac90168fa2fa28ec3908c87306fcb90a5c81c2fdb21985215c517e455ffa02f)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnEgressOnlyInternetGatewayMixinProps":
        return typing.cast("CfnEgressOnlyInternetGatewayMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnEnclaveCertificateIamRoleAssociationMixinProps",
    jsii_struct_bases=[],
    name_mapping={"certificate_arn": "certificateArn", "role_arn": "roleArn"},
)
class CfnEnclaveCertificateIamRoleAssociationMixinProps:
    def __init__(
        self,
        *,
        certificate_arn: typing.Optional[builtins.str] = None,
        role_arn: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnEnclaveCertificateIamRoleAssociationPropsMixin.

        :param certificate_arn: The ARN of the ACM certificate with which to associate the IAM role.
        :param role_arn: The ARN of the IAM role to associate with the ACM certificate. You can associate up to 16 IAM roles with an ACM certificate.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-enclavecertificateiamroleassociation.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_enclave_certificate_iam_role_association_mixin_props = ec2_mixins.CfnEnclaveCertificateIamRoleAssociationMixinProps(
                certificate_arn="certificateArn",
                role_arn="roleArn"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b92b07067d721a2538c6383c1e5eb88aa2635fe3cd054afd2fa554fd8e00f800)
            check_type(argname="argument certificate_arn", value=certificate_arn, expected_type=type_hints["certificate_arn"])
            check_type(argname="argument role_arn", value=role_arn, expected_type=type_hints["role_arn"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if certificate_arn is not None:
            self._values["certificate_arn"] = certificate_arn
        if role_arn is not None:
            self._values["role_arn"] = role_arn

    @builtins.property
    def certificate_arn(self) -> typing.Optional[builtins.str]:
        '''The ARN of the ACM certificate with which to associate the IAM role.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-enclavecertificateiamroleassociation.html#cfn-ec2-enclavecertificateiamroleassociation-certificatearn
        '''
        result = self._values.get("certificate_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def role_arn(self) -> typing.Optional[builtins.str]:
        '''The ARN of the IAM role to associate with the ACM certificate.

        You can associate up to 16 IAM roles with an ACM certificate.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-enclavecertificateiamroleassociation.html#cfn-ec2-enclavecertificateiamroleassociation-rolearn
        '''
        result = self._values.get("role_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnEnclaveCertificateIamRoleAssociationMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnEnclaveCertificateIamRoleAssociationPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnEnclaveCertificateIamRoleAssociationPropsMixin",
):
    '''Associates an AWS Identity and Access Management (IAM) role with an Certificate Manager (ACM) certificate.

    This enables the certificate to be used by the ACM for Nitro Enclaves application inside an enclave. For more information, see `Certificate Manager for Nitro Enclaves <https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave-refapp.html>`_ in the *AWS Nitro Enclaves User Guide* .

    When the IAM role is associated with the ACM certificate, the certificate, certificate chain, and encrypted private key are placed in an Amazon S3 location that only the associated IAM role can access. The private key of the certificate is encrypted with an AWS managed key that has an attached attestation-based key policy.

    To enable the IAM role to access the Amazon S3 object, you must grant it permission to call ``s3:GetObject`` on the Amazon S3 bucket returned by the command. To enable the IAM role to access the KMS key, you must grant it permission to call ``kms:Decrypt`` on the KMS key returned by the command. For more information, see `Grant the role permission to access the certificate and encryption key <https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave-refapp.html#add-policy>`_ in the *AWS Nitro Enclaves User Guide* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-enclavecertificateiamroleassociation.html
    :cloudformationResource: AWS::EC2::EnclaveCertificateIamRoleAssociation
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_enclave_certificate_iam_role_association_props_mixin = ec2_mixins.CfnEnclaveCertificateIamRoleAssociationPropsMixin(ec2_mixins.CfnEnclaveCertificateIamRoleAssociationMixinProps(
            certificate_arn="certificateArn",
            role_arn="roleArn"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnEnclaveCertificateIamRoleAssociationMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::EnclaveCertificateIamRoleAssociation``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__24ab8e9600cf8f37c54cc94518c30839628a371d5f2d2d4550fad5c8e95b2a90)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0bf396ae33f121a716ef2a611788ec55ae58b32b3ce8455a4b0f6116275894cb)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8d5eb2a80ea377b5b345e7516fe074e211f75cc5fdc84be8143e25160db3e8d0)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnEnclaveCertificateIamRoleAssociationMixinProps":
        return typing.cast("CfnEnclaveCertificateIamRoleAssociationMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnFlowLogMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "deliver_cross_account_role": "deliverCrossAccountRole",
        "deliver_logs_permission_arn": "deliverLogsPermissionArn",
        "destination_options": "destinationOptions",
        "log_destination": "logDestination",
        "log_destination_type": "logDestinationType",
        "log_format": "logFormat",
        "log_group_name": "logGroupName",
        "max_aggregation_interval": "maxAggregationInterval",
        "resource_id": "resourceId",
        "resource_type": "resourceType",
        "tags": "tags",
        "traffic_type": "trafficType",
    },
)
class CfnFlowLogMixinProps:
    def __init__(
        self,
        *,
        deliver_cross_account_role: typing.Optional[builtins.str] = None,
        deliver_logs_permission_arn: typing.Optional[builtins.str] = None,
        destination_options: typing.Any = None,
        log_destination: typing.Optional[builtins.str] = None,
        log_destination_type: typing.Optional[builtins.str] = None,
        log_format: typing.Optional[builtins.str] = None,
        log_group_name: typing.Optional[builtins.str] = None,
        max_aggregation_interval: typing.Optional[jsii.Number] = None,
        resource_id: typing.Optional[builtins.str] = None,
        resource_type: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        traffic_type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnFlowLogPropsMixin.

        :param deliver_cross_account_role: The ARN of the IAM role that allows the service to publish flow logs across accounts.
        :param deliver_logs_permission_arn: The ARN of the IAM role that allows Amazon EC2 to publish flow logs to the log destination. This parameter is required if the destination type is ``cloud-watch-logs`` , or if the destination type is ``kinesis-data-firehose`` and the delivery stream and the resources to monitor are in different accounts.
        :param destination_options: The destination options.
        :param log_destination: The destination for the flow log data. The meaning of this parameter depends on the destination type. - If the destination type is ``cloud-watch-logs`` , specify the ARN of a CloudWatch Logs log group. For example: arn:aws:logs: *region* : *account_id* :log-group: *my_group* Alternatively, use the ``LogGroupName`` parameter. - If the destination type is ``s3`` , specify the ARN of an S3 bucket. For example: arn:aws:s3::: *my_bucket* / *my_subfolder* / The subfolder is optional. Note that you can't use ``AWSLogs`` as a subfolder name. - If the destination type is ``kinesis-data-firehose`` , specify the ARN of a Kinesis Data Firehose delivery stream. For example: arn:aws:firehose: *region* : *account_id* :deliverystream: *my_stream*
        :param log_destination_type: The type of destination for the flow log data. Default: ``cloud-watch-logs``
        :param log_format: The fields to include in the flow log record, in the order in which they should appear. If you omit this parameter, the flow log is created using the default format. If you specify this parameter, you must include at least one field. For more information about the available fields, see `Flow log records <https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs.html#flow-log-records>`_ in the *Amazon VPC User Guide* or `Transit Gateway Flow Log records <https://docs.aws.amazon.com/vpc/latest/tgw/tgw-flow-logs.html#flow-log-records>`_ in the *AWS Transit Gateway Guide* . Specify the fields using the ``${field-id}`` format, separated by spaces.
        :param log_group_name: The name of a new or existing CloudWatch Logs log group where Amazon EC2 publishes your flow logs. This parameter is valid only if the destination type is ``cloud-watch-logs`` .
        :param max_aggregation_interval: The maximum interval of time during which a flow of packets is captured and aggregated into a flow log record. The possible values are 60 seconds (1 minute) or 600 seconds (10 minutes). This parameter must be 60 seconds for transit gateway resource types. When a network interface is attached to a `Nitro-based instance <https://docs.aws.amazon.com/ec2/latest/instancetypes/ec2-nitro-instances.html>`_ , the aggregation interval is always 60 seconds or less, regardless of the value that you specify. Default: 600
        :param resource_id: The ID of the resource to monitor. For example, if the resource type is ``VPC`` , specify the ID of the VPC.
        :param resource_type: The type of resource to monitor.
        :param tags: The tags to apply to the flow logs.
        :param traffic_type: The type of traffic to monitor (accepted traffic, rejected traffic, or all traffic). This parameter is not supported for transit gateway resource types. It is required for the other resource types.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            # destination_options: Any
            
            cfn_flow_log_mixin_props = ec2_mixins.CfnFlowLogMixinProps(
                deliver_cross_account_role="deliverCrossAccountRole",
                deliver_logs_permission_arn="deliverLogsPermissionArn",
                destination_options=destination_options,
                log_destination="logDestination",
                log_destination_type="logDestinationType",
                log_format="logFormat",
                log_group_name="logGroupName",
                max_aggregation_interval=123,
                resource_id="resourceId",
                resource_type="resourceType",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                traffic_type="trafficType"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__19a0e8f9fc3bbe335f1c91f25b15df9b9486c2187eee8982b8d5034f63b1e849)
            check_type(argname="argument deliver_cross_account_role", value=deliver_cross_account_role, expected_type=type_hints["deliver_cross_account_role"])
            check_type(argname="argument deliver_logs_permission_arn", value=deliver_logs_permission_arn, expected_type=type_hints["deliver_logs_permission_arn"])
            check_type(argname="argument destination_options", value=destination_options, expected_type=type_hints["destination_options"])
            check_type(argname="argument log_destination", value=log_destination, expected_type=type_hints["log_destination"])
            check_type(argname="argument log_destination_type", value=log_destination_type, expected_type=type_hints["log_destination_type"])
            check_type(argname="argument log_format", value=log_format, expected_type=type_hints["log_format"])
            check_type(argname="argument log_group_name", value=log_group_name, expected_type=type_hints["log_group_name"])
            check_type(argname="argument max_aggregation_interval", value=max_aggregation_interval, expected_type=type_hints["max_aggregation_interval"])
            check_type(argname="argument resource_id", value=resource_id, expected_type=type_hints["resource_id"])
            check_type(argname="argument resource_type", value=resource_type, expected_type=type_hints["resource_type"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument traffic_type", value=traffic_type, expected_type=type_hints["traffic_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if deliver_cross_account_role is not None:
            self._values["deliver_cross_account_role"] = deliver_cross_account_role
        if deliver_logs_permission_arn is not None:
            self._values["deliver_logs_permission_arn"] = deliver_logs_permission_arn
        if destination_options is not None:
            self._values["destination_options"] = destination_options
        if log_destination is not None:
            self._values["log_destination"] = log_destination
        if log_destination_type is not None:
            self._values["log_destination_type"] = log_destination_type
        if log_format is not None:
            self._values["log_format"] = log_format
        if log_group_name is not None:
            self._values["log_group_name"] = log_group_name
        if max_aggregation_interval is not None:
            self._values["max_aggregation_interval"] = max_aggregation_interval
        if resource_id is not None:
            self._values["resource_id"] = resource_id
        if resource_type is not None:
            self._values["resource_type"] = resource_type
        if tags is not None:
            self._values["tags"] = tags
        if traffic_type is not None:
            self._values["traffic_type"] = traffic_type

    @builtins.property
    def deliver_cross_account_role(self) -> typing.Optional[builtins.str]:
        '''The ARN of the IAM role that allows the service to publish flow logs across accounts.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-delivercrossaccountrole
        '''
        result = self._values.get("deliver_cross_account_role")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def deliver_logs_permission_arn(self) -> typing.Optional[builtins.str]:
        '''The ARN of the IAM role that allows Amazon EC2 to publish flow logs to the log destination.

        This parameter is required if the destination type is ``cloud-watch-logs`` , or if the destination type is ``kinesis-data-firehose`` and the delivery stream and the resources to monitor are in different accounts.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-deliverlogspermissionarn
        '''
        result = self._values.get("deliver_logs_permission_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def destination_options(self) -> typing.Any:
        '''The destination options.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-destinationoptions
        '''
        result = self._values.get("destination_options")
        return typing.cast(typing.Any, result)

    @builtins.property
    def log_destination(self) -> typing.Optional[builtins.str]:
        '''The destination for the flow log data. The meaning of this parameter depends on the destination type.

        - If the destination type is ``cloud-watch-logs`` , specify the ARN of a CloudWatch Logs log group. For example:

        arn:aws:logs: *region* : *account_id* :log-group: *my_group*

        Alternatively, use the ``LogGroupName`` parameter.

        - If the destination type is ``s3`` , specify the ARN of an S3 bucket. For example:

        arn:aws:s3::: *my_bucket* / *my_subfolder* /

        The subfolder is optional. Note that you can't use ``AWSLogs`` as a subfolder name.

        - If the destination type is ``kinesis-data-firehose`` , specify the ARN of a Kinesis Data Firehose delivery stream. For example:

        arn:aws:firehose: *region* : *account_id* :deliverystream: *my_stream*

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-logdestination
        '''
        result = self._values.get("log_destination")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def log_destination_type(self) -> typing.Optional[builtins.str]:
        '''The type of destination for the flow log data.

        Default: ``cloud-watch-logs``

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-logdestinationtype
        '''
        result = self._values.get("log_destination_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def log_format(self) -> typing.Optional[builtins.str]:
        '''The fields to include in the flow log record, in the order in which they should appear.

        If you omit this parameter, the flow log is created using the default format. If you specify this parameter, you must include at least one field. For more information about the available fields, see `Flow log records <https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs.html#flow-log-records>`_ in the *Amazon VPC User Guide* or `Transit Gateway Flow Log records <https://docs.aws.amazon.com/vpc/latest/tgw/tgw-flow-logs.html#flow-log-records>`_ in the *AWS Transit Gateway Guide* .

        Specify the fields using the ``${field-id}`` format, separated by spaces.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-logformat
        '''
        result = self._values.get("log_format")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def log_group_name(self) -> typing.Optional[builtins.str]:
        '''The name of a new or existing CloudWatch Logs log group where Amazon EC2 publishes your flow logs.

        This parameter is valid only if the destination type is ``cloud-watch-logs`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-loggroupname
        '''
        result = self._values.get("log_group_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def max_aggregation_interval(self) -> typing.Optional[jsii.Number]:
        '''The maximum interval of time during which a flow of packets is captured and aggregated into a flow log record.

        The possible values are 60 seconds (1 minute) or 600 seconds (10 minutes). This parameter must be 60 seconds for transit gateway resource types.

        When a network interface is attached to a `Nitro-based instance <https://docs.aws.amazon.com/ec2/latest/instancetypes/ec2-nitro-instances.html>`_ , the aggregation interval is always 60 seconds or less, regardless of the value that you specify.

        Default: 600

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-maxaggregationinterval
        '''
        result = self._values.get("max_aggregation_interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def resource_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the resource to monitor.

        For example, if the resource type is ``VPC`` , specify the ID of the VPC.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-resourceid
        '''
        result = self._values.get("resource_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def resource_type(self) -> typing.Optional[builtins.str]:
        '''The type of resource to monitor.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-resourcetype
        '''
        result = self._values.get("resource_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags to apply to the flow logs.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def traffic_type(self) -> typing.Optional[builtins.str]:
        '''The type of traffic to monitor (accepted traffic, rejected traffic, or all traffic).

        This parameter is not supported for transit gateway resource types. It is required for the other resource types.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-traffictype
        '''
        result = self._values.get("traffic_type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnFlowLogMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnFlowLogPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnFlowLogPropsMixin",
):
    '''Specifies a VPC flow log that captures IP traffic for a specified network interface, subnet, or VPC.

    To view the log data, use Amazon CloudWatch Logs (CloudWatch Logs) to help troubleshoot connection issues. For example, you can use a flow log to investigate why certain traffic isn't reaching an instance, which can help you diagnose overly restrictive security group rules. For more information, see `VPC Flow Logs <https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs.html>`_ in the *Amazon VPC User Guide* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html
    :cloudformationResource: AWS::EC2::FlowLog
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        # destination_options: Any
        
        cfn_flow_log_props_mixin = ec2_mixins.CfnFlowLogPropsMixin(ec2_mixins.CfnFlowLogMixinProps(
            deliver_cross_account_role="deliverCrossAccountRole",
            deliver_logs_permission_arn="deliverLogsPermissionArn",
            destination_options=destination_options,
            log_destination="logDestination",
            log_destination_type="logDestinationType",
            log_format="logFormat",
            log_group_name="logGroupName",
            max_aggregation_interval=123,
            resource_id="resourceId",
            resource_type="resourceType",
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            traffic_type="trafficType"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnFlowLogMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::FlowLog``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__954aa64ec8678d4fdee8a4744ad57b053d643c30c46d1fafa60ae0abf833c25f)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f7a046758cd8eb35b7ed603cf01eb4fb3d7da5e58e6e868af70cd2f34b4d6bc9)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4e4ae0278237c20623c958dce2d6766adeec2d0cdcbc256f5239b78d108ce63f)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnFlowLogMixinProps":
        return typing.cast("CfnFlowLogMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnFlowLogPropsMixin.DestinationOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "file_format": "fileFormat",
            "hive_compatible_partitions": "hiveCompatiblePartitions",
            "per_hour_partition": "perHourPartition",
        },
    )
    class DestinationOptionsProperty:
        def __init__(
            self,
            *,
            file_format: typing.Optional[builtins.str] = None,
            hive_compatible_partitions: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            per_hour_partition: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        ) -> None:
            '''Describes the destination options for a flow log.

            :param file_format: The format for the flow log. The default is ``plain-text`` .
            :param hive_compatible_partitions: Indicates whether to use Hive-compatible prefixes for flow logs stored in Amazon S3. The default is ``false`` .
            :param per_hour_partition: Indicates whether to partition the flow log per hour. This reduces the cost and response time for queries. The default is ``false`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-flowlog-destinationoptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                destination_options_property = ec2_mixins.CfnFlowLogPropsMixin.DestinationOptionsProperty(
                    file_format="fileFormat",
                    hive_compatible_partitions=False,
                    per_hour_partition=False
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__2bf0e0af524063edee90f30df57ebece61733883704939869fcc767ef735e66d)
                check_type(argname="argument file_format", value=file_format, expected_type=type_hints["file_format"])
                check_type(argname="argument hive_compatible_partitions", value=hive_compatible_partitions, expected_type=type_hints["hive_compatible_partitions"])
                check_type(argname="argument per_hour_partition", value=per_hour_partition, expected_type=type_hints["per_hour_partition"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if file_format is not None:
                self._values["file_format"] = file_format
            if hive_compatible_partitions is not None:
                self._values["hive_compatible_partitions"] = hive_compatible_partitions
            if per_hour_partition is not None:
                self._values["per_hour_partition"] = per_hour_partition

        @builtins.property
        def file_format(self) -> typing.Optional[builtins.str]:
            '''The format for the flow log.

            The default is ``plain-text`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-flowlog-destinationoptions.html#cfn-ec2-flowlog-destinationoptions-fileformat
            '''
            result = self._values.get("file_format")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def hive_compatible_partitions(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether to use Hive-compatible prefixes for flow logs stored in Amazon S3.

            The default is ``false`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-flowlog-destinationoptions.html#cfn-ec2-flowlog-destinationoptions-hivecompatiblepartitions
            '''
            result = self._values.get("hive_compatible_partitions")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def per_hour_partition(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether to partition the flow log per hour.

            This reduces the cost and response time for queries. The default is ``false`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-flowlog-destinationoptions.html#cfn-ec2-flowlog-destinationoptions-perhourpartition
            '''
            result = self._values.get("per_hour_partition")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "DestinationOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnGatewayRouteTableAssociationMixinProps",
    jsii_struct_bases=[],
    name_mapping={"gateway_id": "gatewayId", "route_table_id": "routeTableId"},
)
class CfnGatewayRouteTableAssociationMixinProps:
    def __init__(
        self,
        *,
        gateway_id: typing.Optional[builtins.str] = None,
        route_table_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnGatewayRouteTableAssociationPropsMixin.

        :param gateway_id: The ID of the gateway.
        :param route_table_id: The ID of the route table.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-gatewayroutetableassociation.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_gateway_route_table_association_mixin_props = ec2_mixins.CfnGatewayRouteTableAssociationMixinProps(
                gateway_id="gatewayId",
                route_table_id="routeTableId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c9c4f0724fc9828f3c4ab579ad4a8dfe82600528a5824faeaa60f4962b8bed05)
            check_type(argname="argument gateway_id", value=gateway_id, expected_type=type_hints["gateway_id"])
            check_type(argname="argument route_table_id", value=route_table_id, expected_type=type_hints["route_table_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if gateway_id is not None:
            self._values["gateway_id"] = gateway_id
        if route_table_id is not None:
            self._values["route_table_id"] = route_table_id

    @builtins.property
    def gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the gateway.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-gatewayroutetableassociation.html#cfn-ec2-gatewayroutetableassociation-gatewayid
        '''
        result = self._values.get("gateway_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def route_table_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the route table.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-gatewayroutetableassociation.html#cfn-ec2-gatewayroutetableassociation-routetableid
        '''
        result = self._values.get("route_table_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnGatewayRouteTableAssociationMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnGatewayRouteTableAssociationPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnGatewayRouteTableAssociationPropsMixin",
):
    '''Associates a virtual private gateway or internet gateway with a route table.

    The gateway and route table must be in the same VPC. This association causes the incoming traffic to the gateway to be routed according to the routes in the route table.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-gatewayroutetableassociation.html
    :cloudformationResource: AWS::EC2::GatewayRouteTableAssociation
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_gateway_route_table_association_props_mixin = ec2_mixins.CfnGatewayRouteTableAssociationPropsMixin(ec2_mixins.CfnGatewayRouteTableAssociationMixinProps(
            gateway_id="gatewayId",
            route_table_id="routeTableId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnGatewayRouteTableAssociationMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::GatewayRouteTableAssociation``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bc34f333cac962e0adcdbb652d3a5119c2c47b4b4ce7ea19f0e8edf03b57081b)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5dd6819168a34e66476bfac4bfeeee3cff9cf87c3a78f0b7cbe65741729a13e6)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e1180a86e05a0a14178bcdfbce14d941c1631a58af9006661c0127fbead6a076)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnGatewayRouteTableAssociationMixinProps":
        return typing.cast("CfnGatewayRouteTableAssociationMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnHostMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "asset_id": "assetId",
        "auto_placement": "autoPlacement",
        "availability_zone": "availabilityZone",
        "host_maintenance": "hostMaintenance",
        "host_recovery": "hostRecovery",
        "instance_family": "instanceFamily",
        "instance_type": "instanceType",
        "outpost_arn": "outpostArn",
        "tags": "tags",
    },
)
class CfnHostMixinProps:
    def __init__(
        self,
        *,
        asset_id: typing.Optional[builtins.str] = None,
        auto_placement: typing.Optional[builtins.str] = None,
        availability_zone: typing.Optional[builtins.str] = None,
        host_maintenance: typing.Optional[builtins.str] = None,
        host_recovery: typing.Optional[builtins.str] = None,
        instance_family: typing.Optional[builtins.str] = None,
        instance_type: typing.Optional[builtins.str] = None,
        outpost_arn: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnHostPropsMixin.

        :param asset_id: The ID of the Outpost hardware asset on which the Dedicated Host is allocated.
        :param auto_placement: Indicates whether the host accepts any untargeted instance launches that match its instance type configuration, or if it only accepts Host tenancy instance launches that specify its unique host ID. For more information, see `Understanding auto-placement and affinity <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/how-dedicated-hosts-work.html#dedicated-hosts-understanding>`_ in the *Amazon EC2 User Guide* . Default: ``off``
        :param availability_zone: The Availability Zone in which to allocate the Dedicated Host.
        :param host_maintenance: Indicates whether host maintenance is enabled or disabled for the Dedicated Host.
        :param host_recovery: Indicates whether to enable or disable host recovery for the Dedicated Host. Host recovery is disabled by default. For more information, see `Host recovery <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/dedicated-hosts-recovery.html>`_ in the *Amazon EC2 User Guide* . Default: ``off``
        :param instance_family: The instance family supported by the Dedicated Host. For example, ``m5`` .
        :param instance_type: Specifies the instance type to be supported by the Dedicated Hosts. If you specify an instance type, the Dedicated Hosts support instances of the specified instance type only.
        :param outpost_arn: The Amazon Resource Name (ARN) of the AWS Outpost on which the Dedicated Host is allocated.
        :param tags: Any tags assigned to the Dedicated Host.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_host_mixin_props = ec2_mixins.CfnHostMixinProps(
                asset_id="assetId",
                auto_placement="autoPlacement",
                availability_zone="availabilityZone",
                host_maintenance="hostMaintenance",
                host_recovery="hostRecovery",
                instance_family="instanceFamily",
                instance_type="instanceType",
                outpost_arn="outpostArn",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6dd0932246e90c83404013360eca298e680ac68b38e504feb536117c7934dd1a)
            check_type(argname="argument asset_id", value=asset_id, expected_type=type_hints["asset_id"])
            check_type(argname="argument auto_placement", value=auto_placement, expected_type=type_hints["auto_placement"])
            check_type(argname="argument availability_zone", value=availability_zone, expected_type=type_hints["availability_zone"])
            check_type(argname="argument host_maintenance", value=host_maintenance, expected_type=type_hints["host_maintenance"])
            check_type(argname="argument host_recovery", value=host_recovery, expected_type=type_hints["host_recovery"])
            check_type(argname="argument instance_family", value=instance_family, expected_type=type_hints["instance_family"])
            check_type(argname="argument instance_type", value=instance_type, expected_type=type_hints["instance_type"])
            check_type(argname="argument outpost_arn", value=outpost_arn, expected_type=type_hints["outpost_arn"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if asset_id is not None:
            self._values["asset_id"] = asset_id
        if auto_placement is not None:
            self._values["auto_placement"] = auto_placement
        if availability_zone is not None:
            self._values["availability_zone"] = availability_zone
        if host_maintenance is not None:
            self._values["host_maintenance"] = host_maintenance
        if host_recovery is not None:
            self._values["host_recovery"] = host_recovery
        if instance_family is not None:
            self._values["instance_family"] = instance_family
        if instance_type is not None:
            self._values["instance_type"] = instance_type
        if outpost_arn is not None:
            self._values["outpost_arn"] = outpost_arn
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def asset_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the Outpost hardware asset on which the Dedicated Host is allocated.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-assetid
        '''
        result = self._values.get("asset_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def auto_placement(self) -> typing.Optional[builtins.str]:
        '''Indicates whether the host accepts any untargeted instance launches that match its instance type configuration, or if it only accepts Host tenancy instance launches that specify its unique host ID.

        For more information, see `Understanding auto-placement and affinity <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/how-dedicated-hosts-work.html#dedicated-hosts-understanding>`_ in the *Amazon EC2 User Guide* .

        Default: ``off``

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-autoplacement
        '''
        result = self._values.get("auto_placement")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def availability_zone(self) -> typing.Optional[builtins.str]:
        '''The Availability Zone in which to allocate the Dedicated Host.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-availabilityzone
        '''
        result = self._values.get("availability_zone")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def host_maintenance(self) -> typing.Optional[builtins.str]:
        '''Indicates whether host maintenance is enabled or disabled for the Dedicated Host.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-hostmaintenance
        '''
        result = self._values.get("host_maintenance")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def host_recovery(self) -> typing.Optional[builtins.str]:
        '''Indicates whether to enable or disable host recovery for the Dedicated Host.

        Host recovery is disabled by default. For more information, see `Host recovery <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/dedicated-hosts-recovery.html>`_ in the *Amazon EC2 User Guide* .

        Default: ``off``

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-hostrecovery
        '''
        result = self._values.get("host_recovery")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def instance_family(self) -> typing.Optional[builtins.str]:
        '''The instance family supported by the Dedicated Host.

        For example, ``m5`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-instancefamily
        '''
        result = self._values.get("instance_family")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def instance_type(self) -> typing.Optional[builtins.str]:
        '''Specifies the instance type to be supported by the Dedicated Hosts.

        If you specify an instance type, the Dedicated Hosts support instances of the specified instance type only.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-instancetype
        '''
        result = self._values.get("instance_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def outpost_arn(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the AWS Outpost on which the Dedicated Host is allocated.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-outpostarn
        '''
        result = self._values.get("outpost_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''Any tags assigned to the Dedicated Host.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnHostMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnHostPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnHostPropsMixin",
):
    '''Allocates a fully dedicated physical server for launching EC2 instances.

    Because the host is fully dedicated for your use, it can help you address compliance requirements and reduce costs by allowing you to use your existing server-bound software licenses. For more information, see `Dedicated Hosts <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/dedicated-hosts-overview.html>`_ in the *Amazon EC2 User Guide* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html
    :cloudformationResource: AWS::EC2::Host
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_host_props_mixin = ec2_mixins.CfnHostPropsMixin(ec2_mixins.CfnHostMixinProps(
            asset_id="assetId",
            auto_placement="autoPlacement",
            availability_zone="availabilityZone",
            host_maintenance="hostMaintenance",
            host_recovery="hostRecovery",
            instance_family="instanceFamily",
            instance_type="instanceType",
            outpost_arn="outpostArn",
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnHostMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::Host``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eef94dd5ba073e13621755e3b764cbf685a90f5121c106ed9aec22f7a8044c7a)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3cf7b725c441a77fecad51fb9db240cde475a8be246373b73007dd441b82eb54)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9fe27a480fd4dc86940f607a4bfcde05f39e72bae982da1408771b9482710f24)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnHostMixinProps":
        return typing.cast("CfnHostMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnIPAMAllocationMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "cidr": "cidr",
        "description": "description",
        "ipam_pool_id": "ipamPoolId",
        "netmask_length": "netmaskLength",
    },
)
class CfnIPAMAllocationMixinProps:
    def __init__(
        self,
        *,
        cidr: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        ipam_pool_id: typing.Optional[builtins.str] = None,
        netmask_length: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Properties for CfnIPAMAllocationPropsMixin.

        :param cidr: The CIDR you would like to allocate from the IPAM pool. Note the following:. - If there is no DefaultNetmaskLength allocation rule set on the pool, you must specify either the NetmaskLength or the CIDR. - If the DefaultNetmaskLength allocation rule is set on the pool, you can specify either the NetmaskLength or the CIDR and the DefaultNetmaskLength allocation rule will be ignored. Possible values: Any available IPv4 or IPv6 CIDR.
        :param description: A description for the allocation.
        :param ipam_pool_id: The ID of the IPAM pool from which you would like to allocate a CIDR.
        :param netmask_length: The netmask length of the CIDR you would like to allocate from the IPAM pool. Note the following:. - If there is no DefaultNetmaskLength allocation rule set on the pool, you must specify either the NetmaskLength or the CIDR. - If the DefaultNetmaskLength allocation rule is set on the pool, you can specify either the NetmaskLength or the CIDR and the DefaultNetmaskLength allocation rule will be ignored. Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_iPAMAllocation_mixin_props = ec2_mixins.CfnIPAMAllocationMixinProps(
                cidr="cidr",
                description="description",
                ipam_pool_id="ipamPoolId",
                netmask_length=123
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__06b90d2128171e00fbc5aa2aa100382cf0322f625b67817d50d0089a60b0123b)
            check_type(argname="argument cidr", value=cidr, expected_type=type_hints["cidr"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument ipam_pool_id", value=ipam_pool_id, expected_type=type_hints["ipam_pool_id"])
            check_type(argname="argument netmask_length", value=netmask_length, expected_type=type_hints["netmask_length"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if cidr is not None:
            self._values["cidr"] = cidr
        if description is not None:
            self._values["description"] = description
        if ipam_pool_id is not None:
            self._values["ipam_pool_id"] = ipam_pool_id
        if netmask_length is not None:
            self._values["netmask_length"] = netmask_length

    @builtins.property
    def cidr(self) -> typing.Optional[builtins.str]:
        '''The CIDR you would like to allocate from the IPAM pool. Note the following:.

        - If there is no DefaultNetmaskLength allocation rule set on the pool, you must specify either the NetmaskLength or the CIDR.
        - If the DefaultNetmaskLength allocation rule is set on the pool, you can specify either the NetmaskLength or the CIDR and the DefaultNetmaskLength allocation rule will be ignored.

        Possible values: Any available IPv4 or IPv6 CIDR.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html#cfn-ec2-ipamallocation-cidr
        '''
        result = self._values.get("cidr")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''A description for the allocation.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html#cfn-ec2-ipamallocation-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ipam_pool_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the IPAM pool from which you would like to allocate a CIDR.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html#cfn-ec2-ipamallocation-ipampoolid
        '''
        result = self._values.get("ipam_pool_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def netmask_length(self) -> typing.Optional[jsii.Number]:
        '''The netmask length of the CIDR you would like to allocate from the IPAM pool. Note the following:.

        - If there is no DefaultNetmaskLength allocation rule set on the pool, you must specify either the NetmaskLength or the CIDR.
        - If the DefaultNetmaskLength allocation rule is set on the pool, you can specify either the NetmaskLength or the CIDR and the DefaultNetmaskLength allocation rule will be ignored.

        Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html#cfn-ec2-ipamallocation-netmasklength
        '''
        result = self._values.get("netmask_length")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnIPAMAllocationMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnIPAMAllocationPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnIPAMAllocationPropsMixin",
):
    '''In IPAM, an allocation is a CIDR assignment from an IPAM pool to another IPAM pool or to a resource.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html
    :cloudformationResource: AWS::EC2::IPAMAllocation
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_iPAMAllocation_props_mixin = ec2_mixins.CfnIPAMAllocationPropsMixin(ec2_mixins.CfnIPAMAllocationMixinProps(
            cidr="cidr",
            description="description",
            ipam_pool_id="ipamPoolId",
            netmask_length=123
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnIPAMAllocationMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::IPAMAllocation``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c627c0c057c8d4e1f2df9f8c82dfdcf82d5f59b77fae7cd132215a5048a34230)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1fe40de42037cb7fc208ee103de323bf1290c67b2989a68c8e08593980e0d8ee)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__10c9d8d418bc7e50153941602620f0cc1d5a931f01b10050def4b580dfbc92a2)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnIPAMAllocationMixinProps":
        return typing.cast("CfnIPAMAllocationMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnIPAMMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "default_resource_discovery_organizational_unit_exclusions": "defaultResourceDiscoveryOrganizationalUnitExclusions",
        "description": "description",
        "enable_private_gua": "enablePrivateGua",
        "metered_account": "meteredAccount",
        "operating_regions": "operatingRegions",
        "tags": "tags",
        "tier": "tier",
    },
)
class CfnIPAMMixinProps:
    def __init__(
        self,
        *,
        default_resource_discovery_organizational_unit_exclusions: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnIPAMPropsMixin.IpamOrganizationalUnitExclusionProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        description: typing.Optional[builtins.str] = None,
        enable_private_gua: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        metered_account: typing.Optional[builtins.str] = None,
        operating_regions: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnIPAMPropsMixin.IpamOperatingRegionProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        tier: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnIPAMPropsMixin.

        :param default_resource_discovery_organizational_unit_exclusions: If your IPAM is integrated with AWS Organizations, you can exclude an `organizational unit (OU) <https://docs.aws.amazon.com/organizations/latest/userguide/orgs_getting-started_concepts.html#organizationalunit>`_ from being managed by IPAM. When you exclude an OU, IPAM will not manage the IP addresses in accounts in that OU. For more information, see `Exclude organizational units from IPAM <https://docs.aws.amazon.com/vpc/latest/ipam/exclude-ous.html>`_ in the *Amazon Virtual Private Cloud IP Address Manager User Guide* .
        :param description: The description for the IPAM.
        :param enable_private_gua: Enable this option to use your own GUA ranges as private IPv6 addresses. This option is disabled by default.
        :param metered_account: A metered account is an AWS account that is charged for active IP addresses managed in IPAM. For more information, see `Enable cost distribution <https://docs.aws.amazon.com/vpc/latest/ipam/ipam-enable-cost-distro.html>`_ in the *Amazon VPC IPAM User Guide* . Possible values: - ``ipam-owner`` (default): The AWS account which owns the IPAM is charged for all active IP addresses managed in IPAM. - ``resource-owner`` : The AWS account that owns the IP address is charged for the active IP address.
        :param operating_regions: The operating Regions for an IPAM. Operating Regions are AWS Regions where the IPAM is allowed to manage IP address CIDRs. IPAM only discovers and monitors resources in the AWS Regions you select as operating Regions. For more information about operating Regions, see `Create an IPAM <https://docs.aws.amazon.com//vpc/latest/ipam/create-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .
        :param tags: The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key ``Owner`` and the value ``TeamA`` , specify ``tag:Owner`` for the filter name and ``TeamA`` for the filter value.
        :param tier: IPAM is offered in a Free Tier and an Advanced Tier. For more information about the features available in each tier and the costs associated with the tiers, see the `VPC IPAM product pricing page <https://docs.aws.amazon.com/vpc/pricing/>`_ .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_iPAMMixin_props = ec2_mixins.CfnIPAMMixinProps(
                default_resource_discovery_organizational_unit_exclusions=[ec2_mixins.CfnIPAMPropsMixin.IpamOrganizationalUnitExclusionProperty(
                    organizations_entity_path="organizationsEntityPath"
                )],
                description="description",
                enable_private_gua=False,
                metered_account="meteredAccount",
                operating_regions=[ec2_mixins.CfnIPAMPropsMixin.IpamOperatingRegionProperty(
                    region_name="regionName"
                )],
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                tier="tier"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__01f41952a31d241e80e2da300b963f27cc44b1c148b0357535722dc8425ab309)
            check_type(argname="argument default_resource_discovery_organizational_unit_exclusions", value=default_resource_discovery_organizational_unit_exclusions, expected_type=type_hints["default_resource_discovery_organizational_unit_exclusions"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument enable_private_gua", value=enable_private_gua, expected_type=type_hints["enable_private_gua"])
            check_type(argname="argument metered_account", value=metered_account, expected_type=type_hints["metered_account"])
            check_type(argname="argument operating_regions", value=operating_regions, expected_type=type_hints["operating_regions"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument tier", value=tier, expected_type=type_hints["tier"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if default_resource_discovery_organizational_unit_exclusions is not None:
            self._values["default_resource_discovery_organizational_unit_exclusions"] = default_resource_discovery_organizational_unit_exclusions
        if description is not None:
            self._values["description"] = description
        if enable_private_gua is not None:
            self._values["enable_private_gua"] = enable_private_gua
        if metered_account is not None:
            self._values["metered_account"] = metered_account
        if operating_regions is not None:
            self._values["operating_regions"] = operating_regions
        if tags is not None:
            self._values["tags"] = tags
        if tier is not None:
            self._values["tier"] = tier

    @builtins.property
    def default_resource_discovery_organizational_unit_exclusions(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnIPAMPropsMixin.IpamOrganizationalUnitExclusionProperty"]]]]:
        '''If your IPAM is integrated with AWS Organizations, you can exclude an `organizational unit (OU) <https://docs.aws.amazon.com/organizations/latest/userguide/orgs_getting-started_concepts.html#organizationalunit>`_ from being managed by IPAM. When you exclude an OU, IPAM will not manage the IP addresses in accounts in that OU. For more information, see `Exclude organizational units from IPAM <https://docs.aws.amazon.com/vpc/latest/ipam/exclude-ous.html>`_ in the *Amazon Virtual Private Cloud IP Address Manager User Guide* .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html#cfn-ec2-ipam-defaultresourcediscoveryorganizationalunitexclusions
        '''
        result = self._values.get("default_resource_discovery_organizational_unit_exclusions")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnIPAMPropsMixin.IpamOrganizationalUnitExclusionProperty"]]]], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''The description for the IPAM.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html#cfn-ec2-ipam-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_private_gua(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Enable this option to use your own GUA ranges as private IPv6 addresses.

        This option is disabled by default.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html#cfn-ec2-ipam-enableprivategua
        '''
        result = self._values.get("enable_private_gua")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def metered_account(self) -> typing.Optional[builtins.str]:
        '''A metered account is an AWS account that is charged for active IP addresses managed in IPAM.

        For more information, see `Enable cost distribution <https://docs.aws.amazon.com/vpc/latest/ipam/ipam-enable-cost-distro.html>`_ in the *Amazon VPC IPAM User Guide* .

        Possible values:

        - ``ipam-owner`` (default): The AWS account which owns the IPAM is charged for all active IP addresses managed in IPAM.
        - ``resource-owner`` : The AWS account that owns the IP address is charged for the active IP address.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html#cfn-ec2-ipam-meteredaccount
        '''
        result = self._values.get("metered_account")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def operating_regions(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnIPAMPropsMixin.IpamOperatingRegionProperty"]]]]:
        '''The operating Regions for an IPAM.

        Operating Regions are AWS Regions where the IPAM is allowed to manage IP address CIDRs. IPAM only discovers and monitors resources in the AWS Regions you select as operating Regions.

        For more information about operating Regions, see `Create an IPAM <https://docs.aws.amazon.com//vpc/latest/ipam/create-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html#cfn-ec2-ipam-operatingregions
        '''
        result = self._values.get("operating_regions")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnIPAMPropsMixin.IpamOperatingRegionProperty"]]]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The key/value combination of a tag assigned to the resource.

        Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key ``Owner`` and the value ``TeamA`` , specify ``tag:Owner`` for the filter name and ``TeamA`` for the filter value.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html#cfn-ec2-ipam-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def tier(self) -> typing.Optional[builtins.str]:
        '''IPAM is offered in a Free Tier and an Advanced Tier.

        For more information about the features available in each tier and the costs associated with the tiers, see the `VPC IPAM product pricing page <https://docs.aws.amazon.com/vpc/pricing/>`_ .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html#cfn-ec2-ipam-tier
        '''
        result = self._values.get("tier")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnIPAMMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnIPAMPoolCidrMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "cidr": "cidr",
        "ipam_pool_id": "ipamPoolId",
        "netmask_length": "netmaskLength",
    },
)
class CfnIPAMPoolCidrMixinProps:
    def __init__(
        self,
        *,
        cidr: typing.Optional[builtins.str] = None,
        ipam_pool_id: typing.Optional[builtins.str] = None,
        netmask_length: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Properties for CfnIPAMPoolCidrPropsMixin.

        :param cidr: The CIDR provisioned to the IPAM pool. A CIDR is a representation of an IP address and its associated network mask (or netmask) and refers to a range of IP addresses. An IPv4 CIDR example is ``10.24.34.0/23`` . An IPv6 CIDR example is ``2001:DB8::/32`` .
        :param ipam_pool_id: The ID of the IPAM pool.
        :param netmask_length: The netmask length of the CIDR you'd like to provision to a pool. Can be used for provisioning Amazon-provided IPv6 CIDRs to top-level pools and for provisioning CIDRs to pools with source pools. Cannot be used to provision BYOIP CIDRs to top-level pools. "NetmaskLength" or "Cidr" is required.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampoolcidr.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_iPAMPool_cidr_mixin_props = ec2_mixins.CfnIPAMPoolCidrMixinProps(
                cidr="cidr",
                ipam_pool_id="ipamPoolId",
                netmask_length=123
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a3d75353eb74e3467a06ce861c6edab9443bf9e380df5cacd86274ab75af3c79)
            check_type(argname="argument cidr", value=cidr, expected_type=type_hints["cidr"])
            check_type(argname="argument ipam_pool_id", value=ipam_pool_id, expected_type=type_hints["ipam_pool_id"])
            check_type(argname="argument netmask_length", value=netmask_length, expected_type=type_hints["netmask_length"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if cidr is not None:
            self._values["cidr"] = cidr
        if ipam_pool_id is not None:
            self._values["ipam_pool_id"] = ipam_pool_id
        if netmask_length is not None:
            self._values["netmask_length"] = netmask_length

    @builtins.property
    def cidr(self) -> typing.Optional[builtins.str]:
        '''The CIDR provisioned to the IPAM pool.

        A CIDR is a representation of an IP address and its associated network mask (or netmask) and refers to a range of IP addresses. An IPv4 CIDR example is ``10.24.34.0/23`` . An IPv6 CIDR example is ``2001:DB8::/32`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampoolcidr.html#cfn-ec2-ipampoolcidr-cidr
        '''
        result = self._values.get("cidr")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ipam_pool_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the IPAM pool.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampoolcidr.html#cfn-ec2-ipampoolcidr-ipampoolid
        '''
        result = self._values.get("ipam_pool_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def netmask_length(self) -> typing.Optional[jsii.Number]:
        '''The netmask length of the CIDR you'd like to provision to a pool.

        Can be used for provisioning Amazon-provided IPv6 CIDRs to top-level pools and for provisioning CIDRs to pools with source pools. Cannot be used to provision BYOIP CIDRs to top-level pools. "NetmaskLength" or "Cidr" is required.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampoolcidr.html#cfn-ec2-ipampoolcidr-netmasklength
        '''
        result = self._values.get("netmask_length")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnIPAMPoolCidrMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnIPAMPoolCidrPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnIPAMPoolCidrPropsMixin",
):
    '''A CIDR provisioned to an IPAM pool.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampoolcidr.html
    :cloudformationResource: AWS::EC2::IPAMPoolCidr
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_iPAMPool_cidr_props_mixin = ec2_mixins.CfnIPAMPoolCidrPropsMixin(ec2_mixins.CfnIPAMPoolCidrMixinProps(
            cidr="cidr",
            ipam_pool_id="ipamPoolId",
            netmask_length=123
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnIPAMPoolCidrMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::IPAMPoolCidr``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ea7e46fe1bf56a809cdf03767aec34e73ed2c3c413935d343e17bb75d91b3abd)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0c558b53a94c9f2dbccc3d49f68c46a89cc0cc1765245a69eec588019d752f8d)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__00f2de57870b786d4c90cccf153c79b2d7bd156d78ff675217314d6669b13fed)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnIPAMPoolCidrMixinProps":
        return typing.cast("CfnIPAMPoolCidrMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnIPAMPoolMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "address_family": "addressFamily",
        "allocation_default_netmask_length": "allocationDefaultNetmaskLength",
        "allocation_max_netmask_length": "allocationMaxNetmaskLength",
        "allocation_min_netmask_length": "allocationMinNetmaskLength",
        "allocation_resource_tags": "allocationResourceTags",
        "auto_import": "autoImport",
        "aws_service": "awsService",
        "description": "description",
        "ipam_scope_id": "ipamScopeId",
        "locale": "locale",
        "provisioned_cidrs": "provisionedCidrs",
        "public_ip_source": "publicIpSource",
        "publicly_advertisable": "publiclyAdvertisable",
        "source_ipam_pool_id": "sourceIpamPoolId",
        "source_resource": "sourceResource",
        "tags": "tags",
    },
)
class CfnIPAMPoolMixinProps:
    def __init__(
        self,
        *,
        address_family: typing.Optional[builtins.str] = None,
        allocation_default_netmask_length: typing.Optional[jsii.Number] = None,
        allocation_max_netmask_length: typing.Optional[jsii.Number] = None,
        allocation_min_netmask_length: typing.Optional[jsii.Number] = None,
        allocation_resource_tags: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        auto_import: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        aws_service: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        ipam_scope_id: typing.Optional[builtins.str] = None,
        locale: typing.Optional[builtins.str] = None,
        provisioned_cidrs: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnIPAMPoolPropsMixin.ProvisionedCidrProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        public_ip_source: typing.Optional[builtins.str] = None,
        publicly_advertisable: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        source_ipam_pool_id: typing.Optional[builtins.str] = None,
        source_resource: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnIPAMPoolPropsMixin.SourceResourceProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnIPAMPoolPropsMixin.

        :param address_family: The address family of the pool.
        :param allocation_default_netmask_length: The default netmask length for allocations added to this pool. If, for example, the CIDR assigned to this pool is 10.0.0.0/8 and you enter 16 here, new allocations will default to 10.0.0.0/16.
        :param allocation_max_netmask_length: The maximum netmask length possible for CIDR allocations in this IPAM pool to be compliant. The maximum netmask length must be greater than the minimum netmask length. Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.
        :param allocation_min_netmask_length: The minimum netmask length required for CIDR allocations in this IPAM pool to be compliant. The minimum netmask length must be less than the maximum netmask length. Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.
        :param allocation_resource_tags: Tags that are required for resources that use CIDRs from this IPAM pool. Resources that do not have these tags will not be allowed to allocate space from the pool. If the resources have their tags changed after they have allocated space or if the allocation tagging requirements are changed on the pool, the resource may be marked as noncompliant.
        :param auto_import: If selected, IPAM will continuously look for resources within the CIDR range of this pool and automatically import them as allocations into your IPAM. The CIDRs that will be allocated for these resources must not already be allocated to other resources in order for the import to succeed. IPAM will import a CIDR regardless of its compliance with the pool's allocation rules, so a resource might be imported and subsequently marked as noncompliant. If IPAM discovers multiple CIDRs that overlap, IPAM will import the largest CIDR only. If IPAM discovers multiple CIDRs with matching CIDRs, IPAM will randomly import one of them only. A locale must be set on the pool for this feature to work.
        :param aws_service: Limits which service in AWS that the pool can be used in. "ec2", for example, allows users to use space for Elastic IP addresses and VPCs.
        :param description: The description of the IPAM pool.
        :param ipam_scope_id: The ID of the scope in which you would like to create the IPAM pool.
        :param locale: The locale of the IPAM pool. The locale for the pool should be one of the following: - An AWS Region where you want this IPAM pool to be available for allocations. - The network border group for an AWS Local Zone where you want this IPAM pool to be available for allocations ( `supported Local Zones <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-byoip.html#byoip-zone-avail>`_ ). This option is only available for IPAM IPv4 pools in the public scope. If you choose an AWS Region for locale that has not been configured as an operating Region for the IPAM, you'll get an error.
        :param provisioned_cidrs: Information about the CIDRs provisioned to an IPAM pool.
        :param public_ip_source: The IP address source for pools in the public scope. Only used for provisioning IP address CIDRs to pools in the public scope. Default is ``BYOIP`` . For more information, see `Create IPv6 pools <https://docs.aws.amazon.com//vpc/latest/ipam/intro-create-ipv6-pools.html>`_ in the *Amazon VPC IPAM User Guide* . By default, you can add only one Amazon-provided IPv6 CIDR block to a top-level IPv6 pool. For information on increasing the default limit, see `Quotas for your IPAM <https://docs.aws.amazon.com//vpc/latest/ipam/quotas-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .
        :param publicly_advertisable: Determines if a pool is publicly advertisable. This option is not available for pools with AddressFamily set to ``ipv4`` .
        :param source_ipam_pool_id: The ID of the source IPAM pool. You can use this option to create an IPAM pool within an existing source pool.
        :param source_resource: The resource used to provision CIDRs to a resource planning pool.
        :param tags: The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key ``Owner`` and the value ``TeamA`` , specify ``tag:Owner`` for the filter name and ``TeamA`` for the filter value.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag, CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_iPAMPool_mixin_props = ec2_mixins.CfnIPAMPoolMixinProps(
                address_family="addressFamily",
                allocation_default_netmask_length=123,
                allocation_max_netmask_length=123,
                allocation_min_netmask_length=123,
                allocation_resource_tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                auto_import=False,
                aws_service="awsService",
                description="description",
                ipam_scope_id="ipamScopeId",
                locale="locale",
                provisioned_cidrs=[ec2_mixins.CfnIPAMPoolPropsMixin.ProvisionedCidrProperty(
                    cidr="cidr"
                )],
                public_ip_source="publicIpSource",
                publicly_advertisable=False,
                source_ipam_pool_id="sourceIpamPoolId",
                source_resource=ec2_mixins.CfnIPAMPoolPropsMixin.SourceResourceProperty(
                    resource_id="resourceId",
                    resource_owner="resourceOwner",
                    resource_region="resourceRegion",
                    resource_type="resourceType"
                ),
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9e263e5544d1c034065230b57a7f4cf03dfc7b1a98bc5b553a3316752e3f0766)
            check_type(argname="argument address_family", value=address_family, expected_type=type_hints["address_family"])
            check_type(argname="argument allocation_default_netmask_length", value=allocation_default_netmask_length, expected_type=type_hints["allocation_default_netmask_length"])
            check_type(argname="argument allocation_max_netmask_length", value=allocation_max_netmask_length, expected_type=type_hints["allocation_max_netmask_length"])
            check_type(argname="argument allocation_min_netmask_length", value=allocation_min_netmask_length, expected_type=type_hints["allocation_min_netmask_length"])
            check_type(argname="argument allocation_resource_tags", value=allocation_resource_tags, expected_type=type_hints["allocation_resource_tags"])
            check_type(argname="argument auto_import", value=auto_import, expected_type=type_hints["auto_import"])
            check_type(argname="argument aws_service", value=aws_service, expected_type=type_hints["aws_service"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument ipam_scope_id", value=ipam_scope_id, expected_type=type_hints["ipam_scope_id"])
            check_type(argname="argument locale", value=locale, expected_type=type_hints["locale"])
            check_type(argname="argument provisioned_cidrs", value=provisioned_cidrs, expected_type=type_hints["provisioned_cidrs"])
            check_type(argname="argument public_ip_source", value=public_ip_source, expected_type=type_hints["public_ip_source"])
            check_type(argname="argument publicly_advertisable", value=publicly_advertisable, expected_type=type_hints["publicly_advertisable"])
            check_type(argname="argument source_ipam_pool_id", value=source_ipam_pool_id, expected_type=type_hints["source_ipam_pool_id"])
            check_type(argname="argument source_resource", value=source_resource, expected_type=type_hints["source_resource"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if address_family is not None:
            self._values["address_family"] = address_family
        if allocation_default_netmask_length is not None:
            self._values["allocation_default_netmask_length"] = allocation_default_netmask_length
        if allocation_max_netmask_length is not None:
            self._values["allocation_max_netmask_length"] = allocation_max_netmask_length
        if allocation_min_netmask_length is not None:
            self._values["allocation_min_netmask_length"] = allocation_min_netmask_length
        if allocation_resource_tags is not None:
            self._values["allocation_resource_tags"] = allocation_resource_tags
        if auto_import is not None:
            self._values["auto_import"] = auto_import
        if aws_service is not None:
            self._values["aws_service"] = aws_service
        if description is not None:
            self._values["description"] = description
        if ipam_scope_id is not None:
            self._values["ipam_scope_id"] = ipam_scope_id
        if locale is not None:
            self._values["locale"] = locale
        if provisioned_cidrs is not None:
            self._values["provisioned_cidrs"] = provisioned_cidrs
        if public_ip_source is not None:
            self._values["public_ip_source"] = public_ip_source
        if publicly_advertisable is not None:
            self._values["publicly_advertisable"] = publicly_advertisable
        if source_ipam_pool_id is not None:
            self._values["source_ipam_pool_id"] = source_ipam_pool_id
        if source_resource is not None:
            self._values["source_resource"] = source_resource
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def address_family(self) -> typing.Optional[builtins.str]:
        '''The address family of the pool.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-addressfamily
        '''
        result = self._values.get("address_family")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def allocation_default_netmask_length(self) -> typing.Optional[jsii.Number]:
        '''The default netmask length for allocations added to this pool.

        If, for example, the CIDR assigned to this pool is 10.0.0.0/8 and you enter 16 here, new allocations will default to 10.0.0.0/16.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-allocationdefaultnetmasklength
        '''
        result = self._values.get("allocation_default_netmask_length")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def allocation_max_netmask_length(self) -> typing.Optional[jsii.Number]:
        '''The maximum netmask length possible for CIDR allocations in this IPAM pool to be compliant.

        The maximum netmask length must be greater than the minimum netmask length. Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-allocationmaxnetmasklength
        '''
        result = self._values.get("allocation_max_netmask_length")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def allocation_min_netmask_length(self) -> typing.Optional[jsii.Number]:
        '''The minimum netmask length required for CIDR allocations in this IPAM pool to be compliant.

        The minimum netmask length must be less than the maximum netmask length. Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-allocationminnetmasklength
        '''
        result = self._values.get("allocation_min_netmask_length")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def allocation_resource_tags(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "_aws_cdk_ceddda9d.CfnTag"]]]]:
        '''Tags that are required for resources that use CIDRs from this IPAM pool.

        Resources that do not have these tags will not be allowed to allocate space from the pool. If the resources have their tags changed after they have allocated space or if the allocation tagging requirements are changed on the pool, the resource may be marked as noncompliant.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-allocationresourcetags
        '''
        result = self._values.get("allocation_resource_tags")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "_aws_cdk_ceddda9d.CfnTag"]]]], result)

    @builtins.property
    def auto_import(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''If selected, IPAM will continuously look for resources within the CIDR range of this pool and automatically import them as allocations into your IPAM.

        The CIDRs that will be allocated for these resources must not already be allocated to other resources in order for the import to succeed. IPAM will import a CIDR regardless of its compliance with the pool's allocation rules, so a resource might be imported and subsequently marked as noncompliant. If IPAM discovers multiple CIDRs that overlap, IPAM will import the largest CIDR only. If IPAM discovers multiple CIDRs with matching CIDRs, IPAM will randomly import one of them only.

        A locale must be set on the pool for this feature to work.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-autoimport
        '''
        result = self._values.get("auto_import")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def aws_service(self) -> typing.Optional[builtins.str]:
        '''Limits which service in AWS that the pool can be used in.

        "ec2", for example, allows users to use space for Elastic IP addresses and VPCs.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-awsservice
        '''
        result = self._values.get("aws_service")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''The description of the IPAM pool.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ipam_scope_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the scope in which you would like to create the IPAM pool.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-ipamscopeid
        '''
        result = self._values.get("ipam_scope_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def locale(self) -> typing.Optional[builtins.str]:
        '''The locale of the IPAM pool.

        The locale for the pool should be one of the following:

        - An AWS Region where you want this IPAM pool to be available for allocations.
        - The network border group for an AWS Local Zone where you want this IPAM pool to be available for allocations ( `supported Local Zones <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-byoip.html#byoip-zone-avail>`_ ). This option is only available for IPAM IPv4 pools in the public scope.

        If you choose an AWS Region for locale that has not been configured as an operating Region for the IPAM, you'll get an error.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-locale
        '''
        result = self._values.get("locale")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def provisioned_cidrs(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnIPAMPoolPropsMixin.ProvisionedCidrProperty"]]]]:
        '''Information about the CIDRs provisioned to an IPAM pool.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-provisionedcidrs
        '''
        result = self._values.get("provisioned_cidrs")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnIPAMPoolPropsMixin.ProvisionedCidrProperty"]]]], result)

    @builtins.property
    def public_ip_source(self) -> typing.Optional[builtins.str]:
        '''The IP address source for pools in the public scope.

        Only used for provisioning IP address CIDRs to pools in the public scope. Default is ``BYOIP`` . For more information, see `Create IPv6 pools <https://docs.aws.amazon.com//vpc/latest/ipam/intro-create-ipv6-pools.html>`_ in the *Amazon VPC IPAM User Guide* . By default, you can add only one Amazon-provided IPv6 CIDR block to a top-level IPv6 pool. For information on increasing the default limit, see `Quotas for your IPAM <https://docs.aws.amazon.com//vpc/latest/ipam/quotas-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-publicipsource
        '''
        result = self._values.get("public_ip_source")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def publicly_advertisable(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Determines if a pool is publicly advertisable.

        This option is not available for pools with AddressFamily set to ``ipv4`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-publiclyadvertisable
        '''
        result = self._values.get("publicly_advertisable")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def source_ipam_pool_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the source IPAM pool.

        You can use this option to create an IPAM pool within an existing source pool.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-sourceipampoolid
        '''
        result = self._values.get("source_ipam_pool_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def source_resource(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnIPAMPoolPropsMixin.SourceResourceProperty"]]:
        '''The resource used to provision CIDRs to a resource planning pool.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-sourceresource
        '''
        result = self._values.get("source_resource")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnIPAMPoolPropsMixin.SourceResourceProperty"]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The key/value combination of a tag assigned to the resource.

        Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key ``Owner`` and the value ``TeamA`` , specify ``tag:Owner`` for the filter name and ``TeamA`` for the filter value.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnIPAMPoolMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnIPAMPoolPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnIPAMPoolPropsMixin",
):
    '''In IPAM, a pool is a collection of contiguous IP addresses CIDRs.

    Pools enable you to organize your IP addresses according to your routing and security needs. For example, if you have separate routing and security needs for development and production applications, you can create a pool for each.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html
    :cloudformationResource: AWS::EC2::IPAMPool
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag, CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_iPAMPool_props_mixin = ec2_mixins.CfnIPAMPoolPropsMixin(ec2_mixins.CfnIPAMPoolMixinProps(
            address_family="addressFamily",
            allocation_default_netmask_length=123,
            allocation_max_netmask_length=123,
            allocation_min_netmask_length=123,
            allocation_resource_tags=[CfnTag(
                key="key",
                value="value"
            )],
            auto_import=False,
            aws_service="awsService",
            description="description",
            ipam_scope_id="ipamScopeId",
            locale="locale",
            provisioned_cidrs=[ec2_mixins.CfnIPAMPoolPropsMixin.ProvisionedCidrProperty(
                cidr="cidr"
            )],
            public_ip_source="publicIpSource",
            publicly_advertisable=False,
            source_ipam_pool_id="sourceIpamPoolId",
            source_resource=ec2_mixins.CfnIPAMPoolPropsMixin.SourceResourceProperty(
                resource_id="resourceId",
                resource_owner="resourceOwner",
                resource_region="resourceRegion",
                resource_type="resourceType"
            ),
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnIPAMPoolMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::IPAMPool``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9a60d83b2a0abbc445b28f509ff9391299a25e2454349c3a7c1ba17e09556e15)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__81c0c7187436481d0c65def2ab021a9fd90991050bf8b88874491b0ec2134cf5)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8c98ac5405393fc2bb6fc1463949ecc0ceb28a5df592f074fa09ddeb15be0e4e)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnIPAMPoolMixinProps":
        return typing.cast("CfnIPAMPoolMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnIPAMPoolPropsMixin.ProvisionedCidrProperty",
        jsii_struct_bases=[],
        name_mapping={"cidr": "cidr"},
    )
    class ProvisionedCidrProperty:
        def __init__(self, *, cidr: typing.Optional[builtins.str] = None) -> None:
            '''The CIDR provisioned to the IPAM pool.

            A CIDR is a representation of an IP address and its associated network mask (or netmask) and refers to a range of IP addresses. An IPv4 CIDR example is ``10.24.34.0/23`` . An IPv6 CIDR example is ``2001:DB8::/32`` .
            .. epigraph::

               This resource type does not allow you to provision a CIDR using the netmask length. To provision a CIDR using netmask length, use `AWS::EC2::IPAMPoolCidr <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampoolcidr.html>`_ .

            :param cidr: The CIDR provisioned to the IPAM pool. A CIDR is a representation of an IP address and its associated network mask (or netmask) and refers to a range of IP addresses. An IPv4 CIDR example is ``10.24.34.0/23`` . An IPv6 CIDR example is ``2001:DB8::/32`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-provisionedcidr.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                provisioned_cidr_property = ec2_mixins.CfnIPAMPoolPropsMixin.ProvisionedCidrProperty(
                    cidr="cidr"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__e240d6cdece1d4e05e7eb46970366adbc3b7433442ffe40c1b1ef176b4918f4e)
                check_type(argname="argument cidr", value=cidr, expected_type=type_hints["cidr"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if cidr is not None:
                self._values["cidr"] = cidr

        @builtins.property
        def cidr(self) -> typing.Optional[builtins.str]:
            '''The CIDR provisioned to the IPAM pool.

            A CIDR is a representation of an IP address and its associated network mask (or netmask) and refers to a range of IP addresses. An IPv4 CIDR example is ``10.24.34.0/23`` . An IPv6 CIDR example is ``2001:DB8::/32`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-provisionedcidr.html#cfn-ec2-ipampool-provisionedcidr-cidr
            '''
            result = self._values.get("cidr")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ProvisionedCidrProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnIPAMPoolPropsMixin.SourceResourceProperty",
        jsii_struct_bases=[],
        name_mapping={
            "resource_id": "resourceId",
            "resource_owner": "resourceOwner",
            "resource_region": "resourceRegion",
            "resource_type": "resourceType",
        },
    )
    class SourceResourceProperty:
        def __init__(
            self,
            *,
            resource_id: typing.Optional[builtins.str] = None,
            resource_owner: typing.Optional[builtins.str] = None,
            resource_region: typing.Optional[builtins.str] = None,
            resource_type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The resource used to provision CIDRs to a resource planning pool.

            :param resource_id: The source resource ID.
            :param resource_owner: The source resource owner.
            :param resource_region: The source resource Region.
            :param resource_type: The source resource type.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-sourceresource.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                source_resource_property = ec2_mixins.CfnIPAMPoolPropsMixin.SourceResourceProperty(
                    resource_id="resourceId",
                    resource_owner="resourceOwner",
                    resource_region="resourceRegion",
                    resource_type="resourceType"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__864d9b72493c06c44b25b1a685ccafdf38e8b5eaf7887b11213493297b3828a0)
                check_type(argname="argument resource_id", value=resource_id, expected_type=type_hints["resource_id"])
                check_type(argname="argument resource_owner", value=resource_owner, expected_type=type_hints["resource_owner"])
                check_type(argname="argument resource_region", value=resource_region, expected_type=type_hints["resource_region"])
                check_type(argname="argument resource_type", value=resource_type, expected_type=type_hints["resource_type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if resource_id is not None:
                self._values["resource_id"] = resource_id
            if resource_owner is not None:
                self._values["resource_owner"] = resource_owner
            if resource_region is not None:
                self._values["resource_region"] = resource_region
            if resource_type is not None:
                self._values["resource_type"] = resource_type

        @builtins.property
        def resource_id(self) -> typing.Optional[builtins.str]:
            '''The source resource ID.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-sourceresource.html#cfn-ec2-ipampool-sourceresource-resourceid
            '''
            result = self._values.get("resource_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def resource_owner(self) -> typing.Optional[builtins.str]:
            '''The source resource owner.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-sourceresource.html#cfn-ec2-ipampool-sourceresource-resourceowner
            '''
            result = self._values.get("resource_owner")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def resource_region(self) -> typing.Optional[builtins.str]:
            '''The source resource Region.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-sourceresource.html#cfn-ec2-ipampool-sourceresource-resourceregion
            '''
            result = self._values.get("resource_region")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def resource_type(self) -> typing.Optional[builtins.str]:
            '''The source resource type.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-sourceresource.html#cfn-ec2-ipampool-sourceresource-resourcetype
            '''
            result = self._values.get("resource_type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SourceResourceProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.implements(_IMixin_11e4b965)
class CfnIPAMPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnIPAMPropsMixin",
):
    '''IPAM is a VPC feature that you can use to automate your IP address management workflows including assigning, tracking, troubleshooting, and auditing IP addresses across AWS Regions and accounts throughout your AWS Organization.

    For more information, see `What is IPAM? <https://docs.aws.amazon.com/vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .

    There are AWS Identity and Access Management (IAM) permissions required to fully manage an IPAM in CloudFormation. For more information, see `Example policy <https://docs.aws.amazon.com/vpc/latest/ipam/iam-ipam-policy-examples.html>`_ in the *Amazon VPC IPAM User Guide* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html
    :cloudformationResource: AWS::EC2::IPAM
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_iPAMProps_mixin = ec2_mixins.CfnIPAMPropsMixin(ec2_mixins.CfnIPAMMixinProps(
            default_resource_discovery_organizational_unit_exclusions=[ec2_mixins.CfnIPAMPropsMixin.IpamOrganizationalUnitExclusionProperty(
                organizations_entity_path="organizationsEntityPath"
            )],
            description="description",
            enable_private_gua=False,
            metered_account="meteredAccount",
            operating_regions=[ec2_mixins.CfnIPAMPropsMixin.IpamOperatingRegionProperty(
                region_name="regionName"
            )],
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            tier="tier"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnIPAMMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::IPAM``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2b7afb3d05d69ded687470d5229e9207613fd938157bb6da1af6c2f74295d544)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f13b261afddb081431a60f0cb3f373cc584e65b6b5801c29b1b3d9e7a0c5125d)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__60d56153df6fbcf9fb4131bfb8513f5eaee9128aca0359ef2ded8e1da388b23a)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnIPAMMixinProps":
        return typing.cast("CfnIPAMMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnIPAMPropsMixin.IpamOperatingRegionProperty",
        jsii_struct_bases=[],
        name_mapping={"region_name": "regionName"},
    )
    class IpamOperatingRegionProperty:
        def __init__(
            self,
            *,
            region_name: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The operating Regions for an IPAM.

            Operating Regions are AWS Regions where the IPAM is allowed to manage IP address CIDRs. IPAM only discovers and monitors resources in the AWS Regions you select as operating Regions.

            For more information about operating Regions, see `Create an IPAM <https://docs.aws.amazon.com//vpc/latest/ipam/create-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .

            :param region_name: The name of the operating Region.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipam-ipamoperatingregion.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                ipam_operating_region_property = ec2_mixins.CfnIPAMPropsMixin.IpamOperatingRegionProperty(
                    region_name="regionName"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__42b2e8711e052d5c0a2d64efbc9ee16c373c5be79085b52e220da0709df0609f)
                check_type(argname="argument region_name", value=region_name, expected_type=type_hints["region_name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if region_name is not None:
                self._values["region_name"] = region_name

        @builtins.property
        def region_name(self) -> typing.Optional[builtins.str]:
            '''The name of the operating Region.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipam-ipamoperatingregion.html#cfn-ec2-ipam-ipamoperatingregion-regionname
            '''
            result = self._values.get("region_name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "IpamOperatingRegionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnIPAMPropsMixin.IpamOrganizationalUnitExclusionProperty",
        jsii_struct_bases=[],
        name_mapping={"organizations_entity_path": "organizationsEntityPath"},
    )
    class IpamOrganizationalUnitExclusionProperty:
        def __init__(
            self,
            *,
            organizations_entity_path: typing.Optional[builtins.str] = None,
        ) -> None:
            '''If your IPAM is integrated with AWS Organizations, you can exclude an `organizational unit (OU) <https://docs.aws.amazon.com/organizations/latest/userguide/orgs_getting-started_concepts.html#organizationalunit>`_ from being managed by IPAM. When you exclude an OU, IPAM will not manage the IP addresses in accounts in that OU. For more information, see `Exclude organizational units from IPAM <https://docs.aws.amazon.com/vpc/latest/ipam/exclude-ous.html>`_ in the *Amazon Virtual Private Cloud IP Address Manager User Guide* .

            :param organizations_entity_path: An AWS Organizations entity path. For more information on the entity path, see `Understand the AWS Organizations entity path <https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_last-accessed-view-data-orgs.html#access_policies_access-advisor-viewing-orgs-entity-path>`_ in the *AWS Identity and Access Management User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipam-ipamorganizationalunitexclusion.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                ipam_organizational_unit_exclusion_property = ec2_mixins.CfnIPAMPropsMixin.IpamOrganizationalUnitExclusionProperty(
                    organizations_entity_path="organizationsEntityPath"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__556159646e2d57ee0c8eb5f8118b3b90df7ad7722b3a79433887a31ceb5f868b)
                check_type(argname="argument organizations_entity_path", value=organizations_entity_path, expected_type=type_hints["organizations_entity_path"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if organizations_entity_path is not None:
                self._values["organizations_entity_path"] = organizations_entity_path

        @builtins.property
        def organizations_entity_path(self) -> typing.Optional[builtins.str]:
            '''An AWS Organizations entity path.

            For more information on the entity path, see `Understand the AWS Organizations entity path <https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_last-accessed-view-data-orgs.html#access_policies_access-advisor-viewing-orgs-entity-path>`_ in the *AWS Identity and Access Management User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipam-ipamorganizationalunitexclusion.html#cfn-ec2-ipam-ipamorganizationalunitexclusion-organizationsentitypath
            '''
            result = self._values.get("organizations_entity_path")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "IpamOrganizationalUnitExclusionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnIPAMResourceDiscoveryAssociationMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "ipam_id": "ipamId",
        "ipam_resource_discovery_id": "ipamResourceDiscoveryId",
        "tags": "tags",
    },
)
class CfnIPAMResourceDiscoveryAssociationMixinProps:
    def __init__(
        self,
        *,
        ipam_id: typing.Optional[builtins.str] = None,
        ipam_resource_discovery_id: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnIPAMResourceDiscoveryAssociationPropsMixin.

        :param ipam_id: The IPAM ID.
        :param ipam_resource_discovery_id: The resource discovery ID.
        :param tags: A tag is a label that you assign to an AWS resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your AWS costs.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscoveryassociation.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_iPAMResource_discovery_association_mixin_props = ec2_mixins.CfnIPAMResourceDiscoveryAssociationMixinProps(
                ipam_id="ipamId",
                ipam_resource_discovery_id="ipamResourceDiscoveryId",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__492ae81ed0fe1741e1b9dc0928403c5ec6d8a34f7674b6c8ba69cfbd2f189080)
            check_type(argname="argument ipam_id", value=ipam_id, expected_type=type_hints["ipam_id"])
            check_type(argname="argument ipam_resource_discovery_id", value=ipam_resource_discovery_id, expected_type=type_hints["ipam_resource_discovery_id"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if ipam_id is not None:
            self._values["ipam_id"] = ipam_id
        if ipam_resource_discovery_id is not None:
            self._values["ipam_resource_discovery_id"] = ipam_resource_discovery_id
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def ipam_id(self) -> typing.Optional[builtins.str]:
        '''The IPAM ID.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscoveryassociation.html#cfn-ec2-ipamresourcediscoveryassociation-ipamid
        '''
        result = self._values.get("ipam_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ipam_resource_discovery_id(self) -> typing.Optional[builtins.str]:
        '''The resource discovery ID.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscoveryassociation.html#cfn-ec2-ipamresourcediscoveryassociation-ipamresourcediscoveryid
        '''
        result = self._values.get("ipam_resource_discovery_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''A tag is a label that you assign to an AWS resource.

        Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your AWS costs.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscoveryassociation.html#cfn-ec2-ipamresourcediscoveryassociation-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnIPAMResourceDiscoveryAssociationMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnIPAMResourceDiscoveryAssociationPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnIPAMResourceDiscoveryAssociationPropsMixin",
):
    '''An IPAM resource discovery association.

    An associated resource discovery is a resource discovery that has been associated with an IPAM. IPAM aggregates the resource CIDRs discovered by the associated resource discovery.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscoveryassociation.html
    :cloudformationResource: AWS::EC2::IPAMResourceDiscoveryAssociation
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_iPAMResource_discovery_association_props_mixin = ec2_mixins.CfnIPAMResourceDiscoveryAssociationPropsMixin(ec2_mixins.CfnIPAMResourceDiscoveryAssociationMixinProps(
            ipam_id="ipamId",
            ipam_resource_discovery_id="ipamResourceDiscoveryId",
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnIPAMResourceDiscoveryAssociationMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::IPAMResourceDiscoveryAssociation``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__867b01f83f2dce2d85dcc75d4b551f76ec42f54dd229443466f1f562e4912a21)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a362c4c2c31935fee732309e58db71da9a1127a41e39a1f50d0b3a34de25d6d2)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8998f8c4a4c8086ab821e67278b80cd688d9815ca5e9b5c71bd78e699af1d905)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnIPAMResourceDiscoveryAssociationMixinProps":
        return typing.cast("CfnIPAMResourceDiscoveryAssociationMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnIPAMResourceDiscoveryMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "description": "description",
        "operating_regions": "operatingRegions",
        "organizational_unit_exclusions": "organizationalUnitExclusions",
        "tags": "tags",
    },
)
class CfnIPAMResourceDiscoveryMixinProps:
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        operating_regions: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnIPAMResourceDiscoveryPropsMixin.IpamOperatingRegionProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        organizational_unit_exclusions: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnIPAMResourceDiscoveryPropsMixin.IpamResourceDiscoveryOrganizationalUnitExclusionProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnIPAMResourceDiscoveryPropsMixin.

        :param description: The resource discovery description.
        :param operating_regions: The operating Regions for the resource discovery. Operating Regions are AWS Regions where the IPAM is allowed to manage IP address CIDRs. IPAM only discovers and monitors resources in the AWS Regions you select as operating Regions.
        :param organizational_unit_exclusions: If your IPAM is integrated with AWS Organizations, you can exclude an `organizational unit (OU) <https://docs.aws.amazon.com/organizations/latest/userguide/orgs_getting-started_concepts.html#organizationalunit>`_ from being managed by IPAM. When you exclude an OU, IPAM will not manage the IP addresses in accounts in that OU. For more information, see `Exclude organizational units from IPAM <https://docs.aws.amazon.com/vpc/latest/ipam/exclude-ous.html>`_ in the *Amazon Virtual Private Cloud IP Address Manager User Guide* .
        :param tags: A tag is a label that you assign to an AWS resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your AWS costs.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscovery.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_iPAMResource_discovery_mixin_props = ec2_mixins.CfnIPAMResourceDiscoveryMixinProps(
                description="description",
                operating_regions=[ec2_mixins.CfnIPAMResourceDiscoveryPropsMixin.IpamOperatingRegionProperty(
                    region_name="regionName"
                )],
                organizational_unit_exclusions=[ec2_mixins.CfnIPAMResourceDiscoveryPropsMixin.IpamResourceDiscoveryOrganizationalUnitExclusionProperty(
                    organizations_entity_path="organizationsEntityPath"
                )],
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8913d840aefc1f2eeb5527b498859b38f8f6bee0eb75635f21fe7ee7a71cf71d)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument operating_regions", value=operating_regions, expected_type=type_hints["operating_regions"])
            check_type(argname="argument organizational_unit_exclusions", value=organizational_unit_exclusions, expected_type=type_hints["organizational_unit_exclusions"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if description is not None:
            self._values["description"] = description
        if operating_regions is not None:
            self._values["operating_regions"] = operating_regions
        if organizational_unit_exclusions is not None:
            self._values["organizational_unit_exclusions"] = organizational_unit_exclusions
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''The resource discovery description.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscovery.html#cfn-ec2-ipamresourcediscovery-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def operating_regions(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnIPAMResourceDiscoveryPropsMixin.IpamOperatingRegionProperty"]]]]:
        '''The operating Regions for the resource discovery.

        Operating Regions are AWS Regions where the IPAM is allowed to manage IP address CIDRs. IPAM only discovers and monitors resources in the AWS Regions you select as operating Regions.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscovery.html#cfn-ec2-ipamresourcediscovery-operatingregions
        '''
        result = self._values.get("operating_regions")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnIPAMResourceDiscoveryPropsMixin.IpamOperatingRegionProperty"]]]], result)

    @builtins.property
    def organizational_unit_exclusions(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnIPAMResourceDiscoveryPropsMixin.IpamResourceDiscoveryOrganizationalUnitExclusionProperty"]]]]:
        '''If your IPAM is integrated with AWS Organizations, you can exclude an `organizational unit (OU) <https://docs.aws.amazon.com/organizations/latest/userguide/orgs_getting-started_concepts.html#organizationalunit>`_ from being managed by IPAM. When you exclude an OU, IPAM will not manage the IP addresses in accounts in that OU. For more information, see `Exclude organizational units from IPAM <https://docs.aws.amazon.com/vpc/latest/ipam/exclude-ous.html>`_ in the *Amazon Virtual Private Cloud IP Address Manager User Guide* .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscovery.html#cfn-ec2-ipamresourcediscovery-organizationalunitexclusions
        '''
        result = self._values.get("organizational_unit_exclusions")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnIPAMResourceDiscoveryPropsMixin.IpamResourceDiscoveryOrganizationalUnitExclusionProperty"]]]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''A tag is a label that you assign to an AWS resource.

        Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your AWS costs.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscovery.html#cfn-ec2-ipamresourcediscovery-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnIPAMResourceDiscoveryMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnIPAMResourceDiscoveryPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnIPAMResourceDiscoveryPropsMixin",
):
    '''A resource discovery is an IPAM component that enables IPAM to manage and monitor resources that belong to the owning account.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscovery.html
    :cloudformationResource: AWS::EC2::IPAMResourceDiscovery
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_iPAMResource_discovery_props_mixin = ec2_mixins.CfnIPAMResourceDiscoveryPropsMixin(ec2_mixins.CfnIPAMResourceDiscoveryMixinProps(
            description="description",
            operating_regions=[ec2_mixins.CfnIPAMResourceDiscoveryPropsMixin.IpamOperatingRegionProperty(
                region_name="regionName"
            )],
            organizational_unit_exclusions=[ec2_mixins.CfnIPAMResourceDiscoveryPropsMixin.IpamResourceDiscoveryOrganizationalUnitExclusionProperty(
                organizations_entity_path="organizationsEntityPath"
            )],
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnIPAMResourceDiscoveryMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::IPAMResourceDiscovery``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3cb8ef35301df0baae72d784a27f8800a678ccc8fef4fe053ef3d5467b620680)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__541b2dcae956ea75d8893bf8c4c195b233e4e5dd3c1dd411892b168b03f88ffa)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3ed3bbe0e8ab697a88406144c1113306ac9a8c8beadd46e02e7eaeb89c91b995)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnIPAMResourceDiscoveryMixinProps":
        return typing.cast("CfnIPAMResourceDiscoveryMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnIPAMResourceDiscoveryPropsMixin.IpamOperatingRegionProperty",
        jsii_struct_bases=[],
        name_mapping={"region_name": "regionName"},
    )
    class IpamOperatingRegionProperty:
        def __init__(
            self,
            *,
            region_name: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The operating Regions for an IPAM.

            Operating Regions are AWS Regions where the IPAM is allowed to manage IP address CIDRs. IPAM only discovers and monitors resources in the AWS Regions you select as operating Regions.

            For more information about operating Regions, see `Create an IPAM <https://docs.aws.amazon.com//vpc/latest/ipam/create-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .

            :param region_name: The name of the operating Region.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipamresourcediscovery-ipamoperatingregion.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                ipam_operating_region_property = ec2_mixins.CfnIPAMResourceDiscoveryPropsMixin.IpamOperatingRegionProperty(
                    region_name="regionName"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__8da3d335f1e813588c4de562b86720e1516b0248a2cd7bed9e33df292f0ce89b)
                check_type(argname="argument region_name", value=region_name, expected_type=type_hints["region_name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if region_name is not None:
                self._values["region_name"] = region_name

        @builtins.property
        def region_name(self) -> typing.Optional[builtins.str]:
            '''The name of the operating Region.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipamresourcediscovery-ipamoperatingregion.html#cfn-ec2-ipamresourcediscovery-ipamoperatingregion-regionname
            '''
            result = self._values.get("region_name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "IpamOperatingRegionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnIPAMResourceDiscoveryPropsMixin.IpamResourceDiscoveryOrganizationalUnitExclusionProperty",
        jsii_struct_bases=[],
        name_mapping={"organizations_entity_path": "organizationsEntityPath"},
    )
    class IpamResourceDiscoveryOrganizationalUnitExclusionProperty:
        def __init__(
            self,
            *,
            organizations_entity_path: typing.Optional[builtins.str] = None,
        ) -> None:
            '''If your IPAM is integrated with AWS Organizations, you can exclude an `organizational unit (OU) <https://docs.aws.amazon.com/organizations/latest/userguide/orgs_getting-started_concepts.html#organizationalunit>`_ from being managed by IPAM. When you exclude an OU, IPAM will not manage the IP addresses in accounts in that OU. For more information, see `Exclude organizational units from IPAM <https://docs.aws.amazon.com/vpc/latest/ipam/exclude-ous.html>`_ in the *Amazon Virtual Private Cloud IP Address Manager User Guide* .

            :param organizations_entity_path: An AWS Organizations entity path. For more information on the entity path, see `Understand the AWS Organizations entity path <https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_last-accessed-view-data-orgs.html#access_policies_access-advisor-viewing-orgs-entity-path>`_ in the *AWS Identity and Access Management User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipamresourcediscovery-ipamresourcediscoveryorganizationalunitexclusion.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                ipam_resource_discovery_organizational_unit_exclusion_property = ec2_mixins.CfnIPAMResourceDiscoveryPropsMixin.IpamResourceDiscoveryOrganizationalUnitExclusionProperty(
                    organizations_entity_path="organizationsEntityPath"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__e938f9049fae6c7767364568d31d7b8be924004e957e7f7de022556e7cae4ac2)
                check_type(argname="argument organizations_entity_path", value=organizations_entity_path, expected_type=type_hints["organizations_entity_path"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if organizations_entity_path is not None:
                self._values["organizations_entity_path"] = organizations_entity_path

        @builtins.property
        def organizations_entity_path(self) -> typing.Optional[builtins.str]:
            '''An AWS Organizations entity path.

            For more information on the entity path, see `Understand the AWS Organizations entity path <https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_last-accessed-view-data-orgs.html#access_policies_access-advisor-viewing-orgs-entity-path>`_ in the *AWS Identity and Access Management User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipamresourcediscovery-ipamresourcediscoveryorganizationalunitexclusion.html#cfn-ec2-ipamresourcediscovery-ipamresourcediscoveryorganizationalunitexclusion-organizationsentitypath
            '''
            result = self._values.get("organizations_entity_path")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "IpamResourceDiscoveryOrganizationalUnitExclusionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnIPAMScopeMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "description": "description",
        "external_authority_configuration": "externalAuthorityConfiguration",
        "ipam_id": "ipamId",
        "tags": "tags",
    },
)
class CfnIPAMScopeMixinProps:
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        external_authority_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnIPAMScopePropsMixin.IpamScopeExternalAuthorityConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ipam_id: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnIPAMScopePropsMixin.

        :param description: The description of the scope.
        :param external_authority_configuration: The configuration that links an Amazon VPC IPAM scope to an external authority system. It specifies the type of external system and the external resource identifier that identifies your account or instance in that system. For more information, see `Integrate VPC IPAM with Infoblox infrastructure <https://docs.aws.amazon.com/vpc/latest/ipam/integrate-infoblox-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .
        :param ipam_id: The ID of the IPAM for which you're creating this scope.
        :param tags: The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key ``Owner`` and the value ``TeamA`` , specify ``tag:Owner`` for the filter name and ``TeamA`` for the filter value.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_iPAMScope_mixin_props = ec2_mixins.CfnIPAMScopeMixinProps(
                description="description",
                external_authority_configuration=ec2_mixins.CfnIPAMScopePropsMixin.IpamScopeExternalAuthorityConfigurationProperty(
                    external_resource_identifier="externalResourceIdentifier",
                    ipam_scope_external_authority_type="ipamScopeExternalAuthorityType"
                ),
                ipam_id="ipamId",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8178db85ece707e4c126ecb9e1e675b4db7ae2108584b6ea23e06352c70d60d6)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument external_authority_configuration", value=external_authority_configuration, expected_type=type_hints["external_authority_configuration"])
            check_type(argname="argument ipam_id", value=ipam_id, expected_type=type_hints["ipam_id"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if description is not None:
            self._values["description"] = description
        if external_authority_configuration is not None:
            self._values["external_authority_configuration"] = external_authority_configuration
        if ipam_id is not None:
            self._values["ipam_id"] = ipam_id
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''The description of the scope.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html#cfn-ec2-ipamscope-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def external_authority_configuration(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnIPAMScopePropsMixin.IpamScopeExternalAuthorityConfigurationProperty"]]:
        '''The configuration that links an Amazon VPC IPAM scope to an external authority system.

        It specifies the type of external system and the external resource identifier that identifies your account or instance in that system.

        For more information, see `Integrate VPC IPAM with Infoblox infrastructure <https://docs.aws.amazon.com/vpc/latest/ipam/integrate-infoblox-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html#cfn-ec2-ipamscope-externalauthorityconfiguration
        '''
        result = self._values.get("external_authority_configuration")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnIPAMScopePropsMixin.IpamScopeExternalAuthorityConfigurationProperty"]], result)

    @builtins.property
    def ipam_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the IPAM for which you're creating this scope.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html#cfn-ec2-ipamscope-ipamid
        '''
        result = self._values.get("ipam_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The key/value combination of a tag assigned to the resource.

        Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key ``Owner`` and the value ``TeamA`` , specify ``tag:Owner`` for the filter name and ``TeamA`` for the filter value.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html#cfn-ec2-ipamscope-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnIPAMScopeMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnIPAMScopePropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnIPAMScopePropsMixin",
):
    '''In IPAM, a scope is the highest-level container within IPAM.

    An IPAM contains two default scopes. Each scope represents the IP space for a single network. The private scope is intended for all private IP address space. The public scope is intended for all public IP address space. Scopes enable you to reuse IP addresses across multiple unconnected networks without causing IP address overlap or conflict.

    For more information, see `How IPAM works <https://docs.aws.amazon.com//vpc/latest/ipam/how-it-works-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html
    :cloudformationResource: AWS::EC2::IPAMScope
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_iPAMScope_props_mixin = ec2_mixins.CfnIPAMScopePropsMixin(ec2_mixins.CfnIPAMScopeMixinProps(
            description="description",
            external_authority_configuration=ec2_mixins.CfnIPAMScopePropsMixin.IpamScopeExternalAuthorityConfigurationProperty(
                external_resource_identifier="externalResourceIdentifier",
                ipam_scope_external_authority_type="ipamScopeExternalAuthorityType"
            ),
            ipam_id="ipamId",
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnIPAMScopeMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::IPAMScope``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__63f54f98c00c7d0c0fc1776f7279099ba492dc5c67d9e79b988a51f9c0048436)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6e62100f59ede4761b7773928085e75e7a80dd68acc421ce3ceac40a275bb9ec)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__480b82ed6ad2fd3f282034f4a6f122c69c52dfd2d4471d9e13462a9822aef363)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnIPAMScopeMixinProps":
        return typing.cast("CfnIPAMScopeMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnIPAMScopePropsMixin.IpamScopeExternalAuthorityConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "external_resource_identifier": "externalResourceIdentifier",
            "ipam_scope_external_authority_type": "ipamScopeExternalAuthorityType",
        },
    )
    class IpamScopeExternalAuthorityConfigurationProperty:
        def __init__(
            self,
            *,
            external_resource_identifier: typing.Optional[builtins.str] = None,
            ipam_scope_external_authority_type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The configuration that links an Amazon VPC IPAM scope to an external authority system.

            It specifies the type of external system and the external resource identifier that identifies your account or instance in that system.

            In IPAM, an external authority is a third-party IP address management system that provides CIDR blocks when you provision address space for top-level IPAM pools. This allows you to use your existing IP management system to control which address ranges are allocated to AWS while using Amazon VPC IPAM to manage subnets within those ranges.

            :param external_resource_identifier: The identifier for the external resource managing this scope. For Infoblox integrations, this is the Infoblox resource identifier in the format ``<version>.identity.account.<entity_realm>.<entity_id>`` .
            :param ipam_scope_external_authority_type: The type of external authority managing this scope. Currently supports ``Infoblox`` for integration with Infoblox Universal DDI.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipamscope-ipamscopeexternalauthorityconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                ipam_scope_external_authority_configuration_property = ec2_mixins.CfnIPAMScopePropsMixin.IpamScopeExternalAuthorityConfigurationProperty(
                    external_resource_identifier="externalResourceIdentifier",
                    ipam_scope_external_authority_type="ipamScopeExternalAuthorityType"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__314001993689940117cb4b021baaf1a82056262d8508916adf1b42274a88ca78)
                check_type(argname="argument external_resource_identifier", value=external_resource_identifier, expected_type=type_hints["external_resource_identifier"])
                check_type(argname="argument ipam_scope_external_authority_type", value=ipam_scope_external_authority_type, expected_type=type_hints["ipam_scope_external_authority_type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if external_resource_identifier is not None:
                self._values["external_resource_identifier"] = external_resource_identifier
            if ipam_scope_external_authority_type is not None:
                self._values["ipam_scope_external_authority_type"] = ipam_scope_external_authority_type

        @builtins.property
        def external_resource_identifier(self) -> typing.Optional[builtins.str]:
            '''The identifier for the external resource managing this scope.

            For Infoblox integrations, this is the Infoblox resource identifier in the format ``<version>.identity.account.<entity_realm>.<entity_id>`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipamscope-ipamscopeexternalauthorityconfiguration.html#cfn-ec2-ipamscope-ipamscopeexternalauthorityconfiguration-externalresourceidentifier
            '''
            result = self._values.get("external_resource_identifier")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def ipam_scope_external_authority_type(self) -> typing.Optional[builtins.str]:
            '''The type of external authority managing this scope.

            Currently supports ``Infoblox`` for integration with Infoblox Universal DDI.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipamscope-ipamscopeexternalauthorityconfiguration.html#cfn-ec2-ipamscope-ipamscopeexternalauthorityconfiguration-ipamscopeexternalauthoritytype
            '''
            result = self._values.get("ipam_scope_external_authority_type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "IpamScopeExternalAuthorityConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnInstanceConnectEndpointMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "client_token": "clientToken",
        "preserve_client_ip": "preserveClientIp",
        "security_group_ids": "securityGroupIds",
        "subnet_id": "subnetId",
        "tags": "tags",
    },
)
class CfnInstanceConnectEndpointMixinProps:
    def __init__(
        self,
        *,
        client_token: typing.Optional[builtins.str] = None,
        preserve_client_ip: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        security_group_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        subnet_id: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnInstanceConnectEndpointPropsMixin.

        :param client_token: Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        :param preserve_client_ip: Indicates whether the client IP address is preserved as the source. The following are the possible values. - ``true`` - Use the client IP address as the source. - ``false`` - Use the network interface IP address as the source. .. epigraph:: ``PreserveClientIp`` is only supported on IPv4 EC2 Instance Connect Endpoints. To use ``PreserveClientIp`` , the value for ``IpAddressType`` must be ``ipv4`` . Default: ``false``
        :param security_group_ids: One or more security groups to associate with the endpoint. If you don't specify a security group, the default security group for your VPC will be associated with the endpoint.
        :param subnet_id: The ID of the subnet in which to create the EC2 Instance Connect Endpoint.
        :param tags: The tags to apply to the EC2 Instance Connect Endpoint during creation.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instanceconnectendpoint.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_instance_connect_endpoint_mixin_props = ec2_mixins.CfnInstanceConnectEndpointMixinProps(
                client_token="clientToken",
                preserve_client_ip=False,
                security_group_ids=["securityGroupIds"],
                subnet_id="subnetId",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fc1001c39b6a4e34435bae1a0635d7fc2a6bc0142a5bc838d4c331e57df915ee)
            check_type(argname="argument client_token", value=client_token, expected_type=type_hints["client_token"])
            check_type(argname="argument preserve_client_ip", value=preserve_client_ip, expected_type=type_hints["preserve_client_ip"])
            check_type(argname="argument security_group_ids", value=security_group_ids, expected_type=type_hints["security_group_ids"])
            check_type(argname="argument subnet_id", value=subnet_id, expected_type=type_hints["subnet_id"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if client_token is not None:
            self._values["client_token"] = client_token
        if preserve_client_ip is not None:
            self._values["preserve_client_ip"] = preserve_client_ip
        if security_group_ids is not None:
            self._values["security_group_ids"] = security_group_ids
        if subnet_id is not None:
            self._values["subnet_id"] = subnet_id
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def client_token(self) -> typing.Optional[builtins.str]:
        '''Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instanceconnectendpoint.html#cfn-ec2-instanceconnectendpoint-clienttoken
        '''
        result = self._values.get("client_token")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def preserve_client_ip(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Indicates whether the client IP address is preserved as the source. The following are the possible values.

        - ``true`` - Use the client IP address as the source.
        - ``false`` - Use the network interface IP address as the source.

        .. epigraph::

           ``PreserveClientIp`` is only supported on IPv4 EC2 Instance Connect Endpoints. To use ``PreserveClientIp`` , the value for ``IpAddressType`` must be ``ipv4`` .

        Default: ``false``

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instanceconnectendpoint.html#cfn-ec2-instanceconnectendpoint-preserveclientip
        '''
        result = self._values.get("preserve_client_ip")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def security_group_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''One or more security groups to associate with the endpoint.

        If you don't specify a security group, the default security group for your VPC will be associated with the endpoint.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instanceconnectendpoint.html#cfn-ec2-instanceconnectendpoint-securitygroupids
        '''
        result = self._values.get("security_group_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def subnet_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the subnet in which to create the EC2 Instance Connect Endpoint.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instanceconnectendpoint.html#cfn-ec2-instanceconnectendpoint-subnetid
        '''
        result = self._values.get("subnet_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags to apply to the EC2 Instance Connect Endpoint during creation.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instanceconnectendpoint.html#cfn-ec2-instanceconnectendpoint-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnInstanceConnectEndpointMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnInstanceConnectEndpointPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnInstanceConnectEndpointPropsMixin",
):
    '''Creates an EC2 Instance Connect Endpoint.

    An EC2 Instance Connect Endpoint allows you to connect to an instance, without requiring the instance to have a public IPv4 address. For more information, see `Connect to your instances using EC2 Instance Connect Endpoint <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Connect-using-EC2-Instance-Connect-Endpoint.html>`_ in the *Amazon EC2 User Guide* .

    With the replacement update behavior, CloudFormation usually creates the new resource first, changes references to point to the new resource, and then deletes the old resource. However, you can create only one EC2 Instance Connect Endpoint per VPC, so the replacement process fails. If you need to modify an EC2 Instance Connect Endpoint, you must replace the resource manually.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instanceconnectendpoint.html
    :cloudformationResource: AWS::EC2::InstanceConnectEndpoint
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_instance_connect_endpoint_props_mixin = ec2_mixins.CfnInstanceConnectEndpointPropsMixin(ec2_mixins.CfnInstanceConnectEndpointMixinProps(
            client_token="clientToken",
            preserve_client_ip=False,
            security_group_ids=["securityGroupIds"],
            subnet_id="subnetId",
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnInstanceConnectEndpointMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::InstanceConnectEndpoint``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e43a6054f9133ba69da03a6e0044d745d56f467f6886f64858680c8038ca5357)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b6c366bcf5a94a0f4a290184f6674e6d4ffa8400f139f10c424d46dc4a3f7f64)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f9780da515b5f07ae21fb56a4f0ef391b0142e76e66b44a4ee9baa5f9147cdcc)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnInstanceConnectEndpointMixinProps":
        return typing.cast("CfnInstanceConnectEndpointMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnInstanceMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "additional_info": "additionalInfo",
        "affinity": "affinity",
        "availability_zone": "availabilityZone",
        "block_device_mappings": "blockDeviceMappings",
        "cpu_options": "cpuOptions",
        "credit_specification": "creditSpecification",
        "disable_api_termination": "disableApiTermination",
        "ebs_optimized": "ebsOptimized",
        "elastic_gpu_specifications": "elasticGpuSpecifications",
        "elastic_inference_accelerators": "elasticInferenceAccelerators",
        "enclave_options": "enclaveOptions",
        "hibernation_options": "hibernationOptions",
        "host_id": "hostId",
        "host_resource_group_arn": "hostResourceGroupArn",
        "iam_instance_profile": "iamInstanceProfile",
        "image_id": "imageId",
        "instance_initiated_shutdown_behavior": "instanceInitiatedShutdownBehavior",
        "instance_type": "instanceType",
        "ipv6_address_count": "ipv6AddressCount",
        "ipv6_addresses": "ipv6Addresses",
        "kernel_id": "kernelId",
        "key_name": "keyName",
        "launch_template": "launchTemplate",
        "license_specifications": "licenseSpecifications",
        "metadata_options": "metadataOptions",
        "monitoring": "monitoring",
        "network_interfaces": "networkInterfaces",
        "placement_group_name": "placementGroupName",
        "private_dns_name_options": "privateDnsNameOptions",
        "private_ip_address": "privateIpAddress",
        "propagate_tags_to_volume_on_creation": "propagateTagsToVolumeOnCreation",
        "ramdisk_id": "ramdiskId",
        "security_group_ids": "securityGroupIds",
        "security_groups": "securityGroups",
        "source_dest_check": "sourceDestCheck",
        "ssm_associations": "ssmAssociations",
        "subnet_id": "subnetId",
        "tags": "tags",
        "tenancy": "tenancy",
        "user_data": "userData",
        "volumes": "volumes",
    },
)
class CfnInstanceMixinProps:
    def __init__(
        self,
        *,
        additional_info: typing.Optional[builtins.str] = None,
        affinity: typing.Optional[builtins.str] = None,
        availability_zone: typing.Optional[builtins.str] = None,
        block_device_mappings: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnInstancePropsMixin.BlockDeviceMappingProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        cpu_options: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnInstancePropsMixin.CpuOptionsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        credit_specification: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnInstancePropsMixin.CreditSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        disable_api_termination: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        ebs_optimized: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        elastic_gpu_specifications: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnInstancePropsMixin.ElasticGpuSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        elastic_inference_accelerators: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnInstancePropsMixin.ElasticInferenceAcceleratorProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        enclave_options: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnInstancePropsMixin.EnclaveOptionsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        hibernation_options: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnInstancePropsMixin.HibernationOptionsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        host_id: typing.Optional[builtins.str] = None,
        host_resource_group_arn: typing.Optional[builtins.str] = None,
        iam_instance_profile: typing.Optional[builtins.str] = None,
        image_id: typing.Optional[builtins.str] = None,
        instance_initiated_shutdown_behavior: typing.Optional[builtins.str] = None,
        instance_type: typing.Optional[builtins.str] = None,
        ipv6_address_count: typing.Optional[jsii.Number] = None,
        ipv6_addresses: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnInstancePropsMixin.InstanceIpv6AddressProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        kernel_id: typing.Optional[builtins.str] = None,
        key_name: typing.Optional[builtins.str] = None,
        launch_template: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnInstancePropsMixin.LaunchTemplateSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        license_specifications: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnInstancePropsMixin.LicenseSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        metadata_options: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnInstancePropsMixin.MetadataOptionsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        monitoring: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        network_interfaces: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnInstancePropsMixin.NetworkInterfaceProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        placement_group_name: typing.Optional[builtins.str] = None,
        private_dns_name_options: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnInstancePropsMixin.PrivateDnsNameOptionsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        private_ip_address: typing.Optional[builtins.str] = None,
        propagate_tags_to_volume_on_creation: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        ramdisk_id: typing.Optional[builtins.str] = None,
        security_group_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        security_groups: typing.Optional[typing.Sequence[builtins.str]] = None,
        source_dest_check: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        ssm_associations: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnInstancePropsMixin.SsmAssociationProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        subnet_id: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        tenancy: typing.Optional[builtins.str] = None,
        user_data: typing.Optional[builtins.str] = None,
        volumes: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnInstancePropsMixin.VolumeProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
    ) -> None:
        '''Properties for CfnInstancePropsMixin.

        :param additional_info: This property is reserved for internal use. If you use it, the stack fails with this error: ``Bad property set: [Testing this property] (Service: AmazonEC2; Status Code: 400; Error Code: InvalidParameterCombination; Request ID: 0XXXXXX-49c7-4b40-8bcc-76885dcXXXXX)`` .
        :param affinity: Indicates whether the instance is associated with a dedicated host. If you want the instance to always restart on the same host on which it was launched, specify ``host`` . If you want the instance to restart on any available host, but try to launch onto the last host it ran on (on a best-effort basis), specify ``default`` .
        :param availability_zone: The Availability Zone of the instance. If not specified, an Availability Zone will be automatically chosen for you based on the load balancing criteria for the Region. This parameter is not supported by `DescribeImageAttribute <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImageAttribute.html>`_ .
        :param block_device_mappings: The block device mapping entries that defines the block devices to attach to the instance at launch. By default, the block devices specified in the block device mapping for the AMI are used. You can override the AMI block device mapping using the instance block device mapping. For the root volume, you can override only the volume size, volume type, volume encryption settings, and the ``DeleteOnTermination`` setting. .. epigraph:: After the instance is running, you can modify only the ``DeleteOnTermination`` parameter for the attached volumes without interrupting the instance. Modifying any other parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .
        :param cpu_options: The CPU options for the instance. For more information, see `Optimize CPU options <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .
        :param credit_specification: The credit option for CPU usage of the burstable performance instance. Valid values are ``standard`` and ``unlimited`` . To change this attribute after launch, use `ModifyInstanceCreditSpecification <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceCreditSpecification.html>`_ . For more information, see `Burstable performance instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html>`_ in the *Amazon EC2 User Guide* . Default: ``standard`` (T2 instances) or ``unlimited`` (T3/T3a/T4g instances) For T3 instances with ``host`` tenancy, only ``standard`` is supported.
        :param disable_api_termination: Indicates whether termination protection is enabled for the instance. The default is ``false`` , which means that you can terminate the instance using the Amazon EC2 console, command line tools, or API. You can enable termination protection when you launch an instance, while the instance is running, or while the instance is stopped.
        :param ebs_optimized: Indicates whether the instance is optimized for Amazon EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance. Default: ``false``
        :param elastic_gpu_specifications: An elastic GPU to associate with the instance. .. epigraph:: Amazon Elastic Graphics reached end of life on January 8, 2024.
        :param elastic_inference_accelerators: An elastic inference accelerator to associate with the instance. .. epigraph:: Amazon Elastic Inference is no longer available.
        :param enclave_options: Indicates whether the instance is enabled for AWS Nitro Enclaves.
        :param hibernation_options: Indicates whether an instance is enabled for hibernation. This parameter is valid only if the instance meets the `hibernation prerequisites <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/hibernating-prerequisites.html>`_ . For more information, see `Hibernate your Amazon EC2 instance <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html>`_ in the *Amazon EC2 User Guide* . You can't enable hibernation and AWS Nitro Enclaves on the same instance.
        :param host_id: If you specify host for the ``Affinity`` property, the ID of a dedicated host that the instance is associated with. If you don't specify an ID, Amazon EC2 launches the instance onto any available, compatible dedicated host in your account. This type of launch is called an untargeted launch. Note that for untargeted launches, you must have a compatible, dedicated host available to successfully launch instances.
        :param host_resource_group_arn: The ARN of the host resource group in which to launch the instances. If you specify a host resource group ARN, omit the *Tenancy* parameter or set it to ``host`` .
        :param iam_instance_profile: The name of an IAM instance profile. To create a new IAM instance profile, use the `AWS::IAM::InstanceProfile <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html>`_ resource.
        :param image_id: The ID of the AMI. An AMI ID is required to launch an instance and must be specified here or in a launch template.
        :param instance_initiated_shutdown_behavior: Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown). Default: ``stop``
        :param instance_type: The instance type. For more information, see `Instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html>`_ in the *Amazon EC2 User Guide* . When you change your EBS-backed instance type, instance restart or replacement behavior depends on the instance type compatibility between the old and new types. An instance with an instance store volume as the root volume is always replaced. For more information, see `Change the instance type <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-resize.html>`_ in the *Amazon EC2 User Guide* .
        :param ipv6_address_count: The number of IPv6 addresses to associate with the primary network interface. Amazon EC2 chooses the IPv6 addresses from the range of your subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch. You cannot specify this option and the network interfaces option in the same request.
        :param ipv6_addresses: The IPv6 addresses from the range of the subnet to associate with the primary network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch. You cannot specify this option and the network interfaces option in the same request.
        :param kernel_id: The ID of the kernel. .. epigraph:: We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see `PV-GRUB <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html>`_ in the *Amazon EC2 User Guide* .
        :param key_name: The name of the key pair. For more information, see `Create a key pair for your EC2 instance <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/create-key-pairs.html>`_ . .. epigraph:: If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.
        :param launch_template: The launch template. Any additional parameters that you specify for the new instance overwrite the corresponding parameters included in the launch template.
        :param license_specifications: The license configurations.
        :param metadata_options: The metadata options for the instance.
        :param monitoring: Specifies whether detailed monitoring is enabled for the instance. Specify ``true`` to enable detailed monitoring. Otherwise, basic monitoring is enabled. For more information about detailed monitoring, see `Enable or turn off detailed monitoring for your instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-cloudwatch-new.html>`_ in the *Amazon EC2 User Guide* .
        :param network_interfaces: The network interfaces to associate with the instance. .. epigraph:: If you use this property to point to a network interface, you must terminate the original interface before attaching a new one to allow the update of the instance to succeed. If this resource has a public IP address and is also in a VPC that is defined in the same template, you must use the `DependsOn Attribute <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html>`_ to declare a dependency on the VPC-gateway attachment.
        :param placement_group_name: The name of an existing placement group that you want to launch the instance into (cluster | partition | spread).
        :param private_dns_name_options: The options for the instance hostname.
        :param private_ip_address: The primary IPv4 address. You must specify a value from the IPv4 address range of the subnet. Only one private IP address can be designated as primary. You can't specify this option if you've specified the option to designate a private IP address as the primary IP address in a network interface specification. You cannot specify this option if you're launching more than one instance in the request. You cannot specify this option and the network interfaces option in the same request. If you make an update to an instance that requires replacement, you must assign a new private IP address. During a replacement, AWS CloudFormation creates a new instance but doesn't delete the old instance until the stack has successfully updated. If the stack update fails, AWS CloudFormation uses the old instance to roll back the stack to the previous working state. The old and new instances cannot have the same private IP address.
        :param propagate_tags_to_volume_on_creation: Indicates whether to assign the tags specified in the ``Tags`` property to the volumes specified in the ``BlockDeviceMappings`` property. Note that using this feature does not assign the tags to volumes that are created separately and then attached using ``AWS::EC2::VolumeAttachment`` .
        :param ramdisk_id: The ID of the RAM disk to select. Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, go to the AWS Resource Center and search for the kernel ID. .. epigraph:: We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see `PV-GRUB <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html>`_ in the *Amazon EC2 User Guide* .
        :param security_group_ids: The IDs of the security groups. You can specify the IDs of existing security groups and references to resources created by the stack template. If you specify a network interface, you must specify any security groups as part of the network interface.
        :param security_groups: [Default VPC] The names of the security groups. For a nondefault VPC, you must use security group IDs instead. You cannot specify this option and the network interfaces option in the same request. The list can contain both the name of existing Amazon EC2 security groups or references to AWS::EC2::SecurityGroup resources created in the template. Default: Amazon EC2 uses the default security group.
        :param source_dest_check: Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives. If the value is ``true`` , source/destination checks are enabled; otherwise, they are disabled. The default value is ``true`` . You must disable source/destination checks if the instance runs services such as network address translation, routing, or firewalls.
        :param ssm_associations: The SSM `document <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html>`_ and parameter values in AWS Systems Manager to associate with this instance. To use this property, you must specify an IAM instance profile role for the instance. For more information, see `Create an IAM instance profile for Systems Manager <https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-configuring-access-role.html>`_ in the *AWS Systems Manager User Guide* . .. epigraph:: You can associate only one document with an instance.
        :param subnet_id: The ID of the subnet to launch the instance into. If you specify a network interface, you must specify any subnets as part of the network interface instead of using this parameter.
        :param tags: The tags to add to the instance. These tags are not applied to the EBS volumes, such as the root volume, unless `PropagateTagsToVolumeOnCreation <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-propagatetagstovolumeoncreation>`_ is ``true`` .
        :param tenancy: The tenancy of the instance. An instance with a tenancy of ``dedicated`` runs on single-tenant hardware.
        :param user_data: The parameters or scripts to store as user data. Any scripts in user data are run when you launch the instance. User data is limited to 16 KB. You must provide base64-encoded text. For more information, see `Fn::Base64 <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-base64.html>`_ . If the root volume is an EBS volume and you update user data, CloudFormation restarts the instance. If the root volume is an instance store volume and you update user data, the instance is replaced.
        :param volumes: The volumes to attach to the instance.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_instance_mixin_props = ec2_mixins.CfnInstanceMixinProps(
                additional_info="additionalInfo",
                affinity="affinity",
                availability_zone="availabilityZone",
                block_device_mappings=[ec2_mixins.CfnInstancePropsMixin.BlockDeviceMappingProperty(
                    device_name="deviceName",
                    ebs=ec2_mixins.CfnInstancePropsMixin.EbsProperty(
                        delete_on_termination=False,
                        encrypted=False,
                        iops=123,
                        kms_key_id="kmsKeyId",
                        snapshot_id="snapshotId",
                        volume_size=123,
                        volume_type="volumeType"
                    ),
                    no_device=ec2_mixins.CfnInstancePropsMixin.NoDeviceProperty(),
                    virtual_name="virtualName"
                )],
                cpu_options=ec2_mixins.CfnInstancePropsMixin.CpuOptionsProperty(
                    core_count=123,
                    threads_per_core=123
                ),
                credit_specification=ec2_mixins.CfnInstancePropsMixin.CreditSpecificationProperty(
                    cpu_credits="cpuCredits"
                ),
                disable_api_termination=False,
                ebs_optimized=False,
                elastic_gpu_specifications=[ec2_mixins.CfnInstancePropsMixin.ElasticGpuSpecificationProperty(
                    type="type"
                )],
                elastic_inference_accelerators=[ec2_mixins.CfnInstancePropsMixin.ElasticInferenceAcceleratorProperty(
                    count=123,
                    type="type"
                )],
                enclave_options=ec2_mixins.CfnInstancePropsMixin.EnclaveOptionsProperty(
                    enabled=False
                ),
                hibernation_options=ec2_mixins.CfnInstancePropsMixin.HibernationOptionsProperty(
                    configured=False
                ),
                host_id="hostId",
                host_resource_group_arn="hostResourceGroupArn",
                iam_instance_profile="iamInstanceProfile",
                image_id="imageId",
                instance_initiated_shutdown_behavior="instanceInitiatedShutdownBehavior",
                instance_type="instanceType",
                ipv6_address_count=123,
                ipv6_addresses=[ec2_mixins.CfnInstancePropsMixin.InstanceIpv6AddressProperty(
                    ipv6_address="ipv6Address"
                )],
                kernel_id="kernelId",
                key_name="keyName",
                launch_template=ec2_mixins.CfnInstancePropsMixin.LaunchTemplateSpecificationProperty(
                    launch_template_id="launchTemplateId",
                    launch_template_name="launchTemplateName",
                    version="version"
                ),
                license_specifications=[ec2_mixins.CfnInstancePropsMixin.LicenseSpecificationProperty(
                    license_configuration_arn="licenseConfigurationArn"
                )],
                metadata_options=ec2_mixins.CfnInstancePropsMixin.MetadataOptionsProperty(
                    http_endpoint="httpEndpoint",
                    http_protocol_ipv6="httpProtocolIpv6",
                    http_put_response_hop_limit=123,
                    http_tokens="httpTokens",
                    instance_metadata_tags="instanceMetadataTags"
                ),
                monitoring=False,
                network_interfaces=[ec2_mixins.CfnInstancePropsMixin.NetworkInterfaceProperty(
                    associate_carrier_ip_address=False,
                    associate_public_ip_address=False,
                    delete_on_termination=False,
                    description="description",
                    device_index="deviceIndex",
                    ena_srd_specification=ec2_mixins.CfnInstancePropsMixin.EnaSrdSpecificationProperty(
                        ena_srd_enabled=False,
                        ena_srd_udp_specification=ec2_mixins.CfnInstancePropsMixin.EnaSrdUdpSpecificationProperty(
                            ena_srd_udp_enabled=False
                        )
                    ),
                    group_set=["groupSet"],
                    ipv6_address_count=123,
                    ipv6_addresses=[ec2_mixins.CfnInstancePropsMixin.InstanceIpv6AddressProperty(
                        ipv6_address="ipv6Address"
                    )],
                    network_interface_id="networkInterfaceId",
                    private_ip_address="privateIpAddress",
                    private_ip_addresses=[ec2_mixins.CfnInstancePropsMixin.PrivateIpAddressSpecificationProperty(
                        primary=False,
                        private_ip_address="privateIpAddress"
                    )],
                    secondary_private_ip_address_count=123,
                    subnet_id="subnetId"
                )],
                placement_group_name="placementGroupName",
                private_dns_name_options=ec2_mixins.CfnInstancePropsMixin.PrivateDnsNameOptionsProperty(
                    enable_resource_name_dns_aaaa_record=False,
                    enable_resource_name_dns_aRecord=False,
                    hostname_type="hostnameType"
                ),
                private_ip_address="privateIpAddress",
                propagate_tags_to_volume_on_creation=False,
                ramdisk_id="ramdiskId",
                security_group_ids=["securityGroupIds"],
                security_groups=["securityGroups"],
                source_dest_check=False,
                ssm_associations=[ec2_mixins.CfnInstancePropsMixin.SsmAssociationProperty(
                    association_parameters=[ec2_mixins.CfnInstancePropsMixin.AssociationParameterProperty(
                        key="key",
                        value=["value"]
                    )],
                    document_name="documentName"
                )],
                subnet_id="subnetId",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                tenancy="tenancy",
                user_data="userData",
                volumes=[ec2_mixins.CfnInstancePropsMixin.VolumeProperty(
                    device="device",
                    volume_id="volumeId"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1d226f35f2b7c4539dfaebf6f2f3099e717a2a51176d11fe7509fedd6c168acf)
            check_type(argname="argument additional_info", value=additional_info, expected_type=type_hints["additional_info"])
            check_type(argname="argument affinity", value=affinity, expected_type=type_hints["affinity"])
            check_type(argname="argument availability_zone", value=availability_zone, expected_type=type_hints["availability_zone"])
            check_type(argname="argument block_device_mappings", value=block_device_mappings, expected_type=type_hints["block_device_mappings"])
            check_type(argname="argument cpu_options", value=cpu_options, expected_type=type_hints["cpu_options"])
            check_type(argname="argument credit_specification", value=credit_specification, expected_type=type_hints["credit_specification"])
            check_type(argname="argument disable_api_termination", value=disable_api_termination, expected_type=type_hints["disable_api_termination"])
            check_type(argname="argument ebs_optimized", value=ebs_optimized, expected_type=type_hints["ebs_optimized"])
            check_type(argname="argument elastic_gpu_specifications", value=elastic_gpu_specifications, expected_type=type_hints["elastic_gpu_specifications"])
            check_type(argname="argument elastic_inference_accelerators", value=elastic_inference_accelerators, expected_type=type_hints["elastic_inference_accelerators"])
            check_type(argname="argument enclave_options", value=enclave_options, expected_type=type_hints["enclave_options"])
            check_type(argname="argument hibernation_options", value=hibernation_options, expected_type=type_hints["hibernation_options"])
            check_type(argname="argument host_id", value=host_id, expected_type=type_hints["host_id"])
            check_type(argname="argument host_resource_group_arn", value=host_resource_group_arn, expected_type=type_hints["host_resource_group_arn"])
            check_type(argname="argument iam_instance_profile", value=iam_instance_profile, expected_type=type_hints["iam_instance_profile"])
            check_type(argname="argument image_id", value=image_id, expected_type=type_hints["image_id"])
            check_type(argname="argument instance_initiated_shutdown_behavior", value=instance_initiated_shutdown_behavior, expected_type=type_hints["instance_initiated_shutdown_behavior"])
            check_type(argname="argument instance_type", value=instance_type, expected_type=type_hints["instance_type"])
            check_type(argname="argument ipv6_address_count", value=ipv6_address_count, expected_type=type_hints["ipv6_address_count"])
            check_type(argname="argument ipv6_addresses", value=ipv6_addresses, expected_type=type_hints["ipv6_addresses"])
            check_type(argname="argument kernel_id", value=kernel_id, expected_type=type_hints["kernel_id"])
            check_type(argname="argument key_name", value=key_name, expected_type=type_hints["key_name"])
            check_type(argname="argument launch_template", value=launch_template, expected_type=type_hints["launch_template"])
            check_type(argname="argument license_specifications", value=license_specifications, expected_type=type_hints["license_specifications"])
            check_type(argname="argument metadata_options", value=metadata_options, expected_type=type_hints["metadata_options"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument network_interfaces", value=network_interfaces, expected_type=type_hints["network_interfaces"])
            check_type(argname="argument placement_group_name", value=placement_group_name, expected_type=type_hints["placement_group_name"])
            check_type(argname="argument private_dns_name_options", value=private_dns_name_options, expected_type=type_hints["private_dns_name_options"])
            check_type(argname="argument private_ip_address", value=private_ip_address, expected_type=type_hints["private_ip_address"])
            check_type(argname="argument propagate_tags_to_volume_on_creation", value=propagate_tags_to_volume_on_creation, expected_type=type_hints["propagate_tags_to_volume_on_creation"])
            check_type(argname="argument ramdisk_id", value=ramdisk_id, expected_type=type_hints["ramdisk_id"])
            check_type(argname="argument security_group_ids", value=security_group_ids, expected_type=type_hints["security_group_ids"])
            check_type(argname="argument security_groups", value=security_groups, expected_type=type_hints["security_groups"])
            check_type(argname="argument source_dest_check", value=source_dest_check, expected_type=type_hints["source_dest_check"])
            check_type(argname="argument ssm_associations", value=ssm_associations, expected_type=type_hints["ssm_associations"])
            check_type(argname="argument subnet_id", value=subnet_id, expected_type=type_hints["subnet_id"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument tenancy", value=tenancy, expected_type=type_hints["tenancy"])
            check_type(argname="argument user_data", value=user_data, expected_type=type_hints["user_data"])
            check_type(argname="argument volumes", value=volumes, expected_type=type_hints["volumes"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if additional_info is not None:
            self._values["additional_info"] = additional_info
        if affinity is not None:
            self._values["affinity"] = affinity
        if availability_zone is not None:
            self._values["availability_zone"] = availability_zone
        if block_device_mappings is not None:
            self._values["block_device_mappings"] = block_device_mappings
        if cpu_options is not None:
            self._values["cpu_options"] = cpu_options
        if credit_specification is not None:
            self._values["credit_specification"] = credit_specification
        if disable_api_termination is not None:
            self._values["disable_api_termination"] = disable_api_termination
        if ebs_optimized is not None:
            self._values["ebs_optimized"] = ebs_optimized
        if elastic_gpu_specifications is not None:
            self._values["elastic_gpu_specifications"] = elastic_gpu_specifications
        if elastic_inference_accelerators is not None:
            self._values["elastic_inference_accelerators"] = elastic_inference_accelerators
        if enclave_options is not None:
            self._values["enclave_options"] = enclave_options
        if hibernation_options is not None:
            self._values["hibernation_options"] = hibernation_options
        if host_id is not None:
            self._values["host_id"] = host_id
        if host_resource_group_arn is not None:
            self._values["host_resource_group_arn"] = host_resource_group_arn
        if iam_instance_profile is not None:
            self._values["iam_instance_profile"] = iam_instance_profile
        if image_id is not None:
            self._values["image_id"] = image_id
        if instance_initiated_shutdown_behavior is not None:
            self._values["instance_initiated_shutdown_behavior"] = instance_initiated_shutdown_behavior
        if instance_type is not None:
            self._values["instance_type"] = instance_type
        if ipv6_address_count is not None:
            self._values["ipv6_address_count"] = ipv6_address_count
        if ipv6_addresses is not None:
            self._values["ipv6_addresses"] = ipv6_addresses
        if kernel_id is not None:
            self._values["kernel_id"] = kernel_id
        if key_name is not None:
            self._values["key_name"] = key_name
        if launch_template is not None:
            self._values["launch_template"] = launch_template
        if license_specifications is not None:
            self._values["license_specifications"] = license_specifications
        if metadata_options is not None:
            self._values["metadata_options"] = metadata_options
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if network_interfaces is not None:
            self._values["network_interfaces"] = network_interfaces
        if placement_group_name is not None:
            self._values["placement_group_name"] = placement_group_name
        if private_dns_name_options is not None:
            self._values["private_dns_name_options"] = private_dns_name_options
        if private_ip_address is not None:
            self._values["private_ip_address"] = private_ip_address
        if propagate_tags_to_volume_on_creation is not None:
            self._values["propagate_tags_to_volume_on_creation"] = propagate_tags_to_volume_on_creation
        if ramdisk_id is not None:
            self._values["ramdisk_id"] = ramdisk_id
        if security_group_ids is not None:
            self._values["security_group_ids"] = security_group_ids
        if security_groups is not None:
            self._values["security_groups"] = security_groups
        if source_dest_check is not None:
            self._values["source_dest_check"] = source_dest_check
        if ssm_associations is not None:
            self._values["ssm_associations"] = ssm_associations
        if subnet_id is not None:
            self._values["subnet_id"] = subnet_id
        if tags is not None:
            self._values["tags"] = tags
        if tenancy is not None:
            self._values["tenancy"] = tenancy
        if user_data is not None:
            self._values["user_data"] = user_data
        if volumes is not None:
            self._values["volumes"] = volumes

    @builtins.property
    def additional_info(self) -> typing.Optional[builtins.str]:
        '''This property is reserved for internal use.

        If you use it, the stack fails with this error: ``Bad property set: [Testing this property] (Service: AmazonEC2; Status Code: 400; Error Code: InvalidParameterCombination; Request ID: 0XXXXXX-49c7-4b40-8bcc-76885dcXXXXX)`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-additionalinfo
        '''
        result = self._values.get("additional_info")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def affinity(self) -> typing.Optional[builtins.str]:
        '''Indicates whether the instance is associated with a dedicated host.

        If you want the instance to always restart on the same host on which it was launched, specify ``host`` . If you want the instance to restart on any available host, but try to launch onto the last host it ran on (on a best-effort basis), specify ``default`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-affinity
        '''
        result = self._values.get("affinity")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def availability_zone(self) -> typing.Optional[builtins.str]:
        '''The Availability Zone of the instance.

        If not specified, an Availability Zone will be automatically chosen for you based on the load balancing criteria for the Region.

        This parameter is not supported by `DescribeImageAttribute <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImageAttribute.html>`_ .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-availabilityzone
        '''
        result = self._values.get("availability_zone")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def block_device_mappings(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.BlockDeviceMappingProperty"]]]]:
        '''The block device mapping entries that defines the block devices to attach to the instance at launch.

        By default, the block devices specified in the block device mapping for the AMI are used. You can override the AMI block device mapping using the instance block device mapping. For the root volume, you can override only the volume size, volume type, volume encryption settings, and the ``DeleteOnTermination`` setting.
        .. epigraph::

           After the instance is running, you can modify only the ``DeleteOnTermination`` parameter for the attached volumes without interrupting the instance. Modifying any other parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-blockdevicemappings
        '''
        result = self._values.get("block_device_mappings")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.BlockDeviceMappingProperty"]]]], result)

    @builtins.property
    def cpu_options(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.CpuOptionsProperty"]]:
        '''The CPU options for the instance.

        For more information, see `Optimize CPU options <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-cpuoptions
        '''
        result = self._values.get("cpu_options")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.CpuOptionsProperty"]], result)

    @builtins.property
    def credit_specification(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.CreditSpecificationProperty"]]:
        '''The credit option for CPU usage of the burstable performance instance.

        Valid values are ``standard`` and ``unlimited`` . To change this attribute after launch, use `ModifyInstanceCreditSpecification <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceCreditSpecification.html>`_ . For more information, see `Burstable performance instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html>`_ in the *Amazon EC2 User Guide* .

        Default: ``standard`` (T2 instances) or ``unlimited`` (T3/T3a/T4g instances)

        For T3 instances with ``host`` tenancy, only ``standard`` is supported.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-creditspecification
        '''
        result = self._values.get("credit_specification")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.CreditSpecificationProperty"]], result)

    @builtins.property
    def disable_api_termination(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Indicates whether termination protection is enabled for the instance.

        The default is ``false`` , which means that you can terminate the instance using the Amazon EC2 console, command line tools, or API. You can enable termination protection when you launch an instance, while the instance is running, or while the instance is stopped.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-disableapitermination
        '''
        result = self._values.get("disable_api_termination")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def ebs_optimized(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Indicates whether the instance is optimized for Amazon EBS I/O.

        This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.

        Default: ``false``

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-ebsoptimized
        '''
        result = self._values.get("ebs_optimized")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def elastic_gpu_specifications(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.ElasticGpuSpecificationProperty"]]]]:
        '''An elastic GPU to associate with the instance.

        .. epigraph::

           Amazon Elastic Graphics reached end of life on January 8, 2024.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-elasticgpuspecifications
        '''
        result = self._values.get("elastic_gpu_specifications")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.ElasticGpuSpecificationProperty"]]]], result)

    @builtins.property
    def elastic_inference_accelerators(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.ElasticInferenceAcceleratorProperty"]]]]:
        '''An elastic inference accelerator to associate with the instance.

        .. epigraph::

           Amazon Elastic Inference is no longer available.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-elasticinferenceaccelerators
        '''
        result = self._values.get("elastic_inference_accelerators")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.ElasticInferenceAcceleratorProperty"]]]], result)

    @builtins.property
    def enclave_options(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.EnclaveOptionsProperty"]]:
        '''Indicates whether the instance is enabled for AWS Nitro Enclaves.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-enclaveoptions
        '''
        result = self._values.get("enclave_options")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.EnclaveOptionsProperty"]], result)

    @builtins.property
    def hibernation_options(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.HibernationOptionsProperty"]]:
        '''Indicates whether an instance is enabled for hibernation.

        This parameter is valid only if the instance meets the `hibernation prerequisites <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/hibernating-prerequisites.html>`_ . For more information, see `Hibernate your Amazon EC2 instance <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html>`_ in the *Amazon EC2 User Guide* .

        You can't enable hibernation and AWS Nitro Enclaves on the same instance.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-hibernationoptions
        '''
        result = self._values.get("hibernation_options")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.HibernationOptionsProperty"]], result)

    @builtins.property
    def host_id(self) -> typing.Optional[builtins.str]:
        '''If you specify host for the ``Affinity`` property, the ID of a dedicated host that the instance is associated with.

        If you don't specify an ID, Amazon EC2 launches the instance onto any available, compatible dedicated host in your account. This type of launch is called an untargeted launch. Note that for untargeted launches, you must have a compatible, dedicated host available to successfully launch instances.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-hostid
        '''
        result = self._values.get("host_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def host_resource_group_arn(self) -> typing.Optional[builtins.str]:
        '''The ARN of the host resource group in which to launch the instances.

        If you specify a host resource group ARN, omit the *Tenancy* parameter or set it to ``host`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-hostresourcegrouparn
        '''
        result = self._values.get("host_resource_group_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def iam_instance_profile(self) -> typing.Optional[builtins.str]:
        '''The name of an IAM instance profile.

        To create a new IAM instance profile, use the `AWS::IAM::InstanceProfile <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html>`_ resource.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-iaminstanceprofile
        '''
        result = self._values.get("iam_instance_profile")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def image_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the AMI.

        An AMI ID is required to launch an instance and must be specified here or in a launch template.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-imageid
        '''
        result = self._values.get("image_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def instance_initiated_shutdown_behavior(self) -> typing.Optional[builtins.str]:
        '''Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).

        Default: ``stop``

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-instanceinitiatedshutdownbehavior
        '''
        result = self._values.get("instance_initiated_shutdown_behavior")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def instance_type(self) -> typing.Optional[builtins.str]:
        '''The instance type. For more information, see `Instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html>`_ in the *Amazon EC2 User Guide* .

        When you change your EBS-backed instance type, instance restart or replacement behavior depends on the instance type compatibility between the old and new types. An instance with an instance store volume as the root volume is always replaced. For more information, see `Change the instance type <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-resize.html>`_ in the *Amazon EC2 User Guide* .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-instancetype
        '''
        result = self._values.get("instance_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ipv6_address_count(self) -> typing.Optional[jsii.Number]:
        '''The number of IPv6 addresses to associate with the primary network interface.

        Amazon EC2 chooses the IPv6 addresses from the range of your subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.

        You cannot specify this option and the network interfaces option in the same request.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-ipv6addresscount
        '''
        result = self._values.get("ipv6_address_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def ipv6_addresses(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.InstanceIpv6AddressProperty"]]]]:
        '''The IPv6 addresses from the range of the subnet to associate with the primary network interface.

        You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.

        You cannot specify this option and the network interfaces option in the same request.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-ipv6addresses
        '''
        result = self._values.get("ipv6_addresses")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.InstanceIpv6AddressProperty"]]]], result)

    @builtins.property
    def kernel_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the kernel.

        .. epigraph::

           We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see `PV-GRUB <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html>`_ in the *Amazon EC2 User Guide* .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-kernelid
        '''
        result = self._values.get("kernel_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key_name(self) -> typing.Optional[builtins.str]:
        '''The name of the key pair. For more information, see `Create a key pair for your EC2 instance <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/create-key-pairs.html>`_ .

        .. epigraph::

           If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-keyname
        '''
        result = self._values.get("key_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def launch_template(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.LaunchTemplateSpecificationProperty"]]:
        '''The launch template.

        Any additional parameters that you specify for the new instance overwrite the corresponding parameters included in the launch template.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-launchtemplate
        '''
        result = self._values.get("launch_template")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.LaunchTemplateSpecificationProperty"]], result)

    @builtins.property
    def license_specifications(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.LicenseSpecificationProperty"]]]]:
        '''The license configurations.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-licensespecifications
        '''
        result = self._values.get("license_specifications")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.LicenseSpecificationProperty"]]]], result)

    @builtins.property
    def metadata_options(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.MetadataOptionsProperty"]]:
        '''The metadata options for the instance.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-metadataoptions
        '''
        result = self._values.get("metadata_options")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.MetadataOptionsProperty"]], result)

    @builtins.property
    def monitoring(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Specifies whether detailed monitoring is enabled for the instance.

        Specify ``true`` to enable detailed monitoring. Otherwise, basic monitoring is enabled. For more information about detailed monitoring, see `Enable or turn off detailed monitoring for your instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-cloudwatch-new.html>`_ in the *Amazon EC2 User Guide* .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-monitoring
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def network_interfaces(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.NetworkInterfaceProperty"]]]]:
        '''The network interfaces to associate with the instance.

        .. epigraph::

           If you use this property to point to a network interface, you must terminate the original interface before attaching a new one to allow the update of the instance to succeed.

           If this resource has a public IP address and is also in a VPC that is defined in the same template, you must use the `DependsOn Attribute <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html>`_ to declare a dependency on the VPC-gateway attachment.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-networkinterfaces
        '''
        result = self._values.get("network_interfaces")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.NetworkInterfaceProperty"]]]], result)

    @builtins.property
    def placement_group_name(self) -> typing.Optional[builtins.str]:
        '''The name of an existing placement group that you want to launch the instance into (cluster | partition | spread).

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-placementgroupname
        '''
        result = self._values.get("placement_group_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def private_dns_name_options(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.PrivateDnsNameOptionsProperty"]]:
        '''The options for the instance hostname.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-privatednsnameoptions
        '''
        result = self._values.get("private_dns_name_options")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.PrivateDnsNameOptionsProperty"]], result)

    @builtins.property
    def private_ip_address(self) -> typing.Optional[builtins.str]:
        '''The primary IPv4 address. You must specify a value from the IPv4 address range of the subnet.

        Only one private IP address can be designated as primary. You can't specify this option if you've specified the option to designate a private IP address as the primary IP address in a network interface specification. You cannot specify this option if you're launching more than one instance in the request.

        You cannot specify this option and the network interfaces option in the same request.

        If you make an update to an instance that requires replacement, you must assign a new private IP address. During a replacement, AWS CloudFormation creates a new instance but doesn't delete the old instance until the stack has successfully updated. If the stack update fails, AWS CloudFormation uses the old instance to roll back the stack to the previous working state. The old and new instances cannot have the same private IP address.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-privateipaddress
        '''
        result = self._values.get("private_ip_address")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def propagate_tags_to_volume_on_creation(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Indicates whether to assign the tags specified in the ``Tags`` property to the volumes specified in the ``BlockDeviceMappings`` property.

        Note that using this feature does not assign the tags to volumes that are created separately and then attached using ``AWS::EC2::VolumeAttachment`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-propagatetagstovolumeoncreation
        '''
        result = self._values.get("propagate_tags_to_volume_on_creation")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def ramdisk_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the RAM disk to select.

        Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, go to the AWS Resource Center and search for the kernel ID.
        .. epigraph::

           We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see `PV-GRUB <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html>`_ in the *Amazon EC2 User Guide* .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-ramdiskid
        '''
        result = self._values.get("ramdisk_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def security_group_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The IDs of the security groups.

        You can specify the IDs of existing security groups and references to resources created by the stack template.

        If you specify a network interface, you must specify any security groups as part of the network interface.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-securitygroupids
        '''
        result = self._values.get("security_group_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def security_groups(self) -> typing.Optional[typing.List[builtins.str]]:
        '''[Default VPC] The names of the security groups. For a nondefault VPC, you must use security group IDs instead.

        You cannot specify this option and the network interfaces option in the same request. The list can contain both the name of existing Amazon EC2 security groups or references to AWS::EC2::SecurityGroup resources created in the template.

        Default: Amazon EC2 uses the default security group.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-securitygroups
        '''
        result = self._values.get("security_groups")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def source_dest_check(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives.

        If the value is ``true`` , source/destination checks are enabled; otherwise, they are disabled. The default value is ``true`` . You must disable source/destination checks if the instance runs services such as network address translation, routing, or firewalls.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-sourcedestcheck
        '''
        result = self._values.get("source_dest_check")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def ssm_associations(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.SsmAssociationProperty"]]]]:
        '''The SSM `document <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html>`_ and parameter values in AWS Systems Manager to associate with this instance. To use this property, you must specify an IAM instance profile role for the instance. For more information, see `Create an IAM instance profile for Systems Manager <https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-configuring-access-role.html>`_ in the *AWS Systems Manager User Guide* .

        .. epigraph::

           You can associate only one document with an instance.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-ssmassociations
        '''
        result = self._values.get("ssm_associations")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.SsmAssociationProperty"]]]], result)

    @builtins.property
    def subnet_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the subnet to launch the instance into.

        If you specify a network interface, you must specify any subnets as part of the network interface instead of using this parameter.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-subnetid
        '''
        result = self._values.get("subnet_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags to add to the instance.

        These tags are not applied to the EBS volumes, such as the root volume, unless `PropagateTagsToVolumeOnCreation <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-propagatetagstovolumeoncreation>`_ is ``true`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def tenancy(self) -> typing.Optional[builtins.str]:
        '''The tenancy of the instance.

        An instance with a tenancy of ``dedicated`` runs on single-tenant hardware.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-tenancy
        '''
        result = self._values.get("tenancy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def user_data(self) -> typing.Optional[builtins.str]:
        '''The parameters or scripts to store as user data.

        Any scripts in user data are run when you launch the instance. User data is limited to 16 KB. You must provide base64-encoded text. For more information, see `Fn::Base64 <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-base64.html>`_ .

        If the root volume is an EBS volume and you update user data, CloudFormation restarts the instance. If the root volume is an instance store volume and you update user data, the instance is replaced.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-userdata
        '''
        result = self._values.get("user_data")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def volumes(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.VolumeProperty"]]]]:
        '''The volumes to attach to the instance.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html#cfn-ec2-instance-volumes
        '''
        result = self._values.get("volumes")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.VolumeProperty"]]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnInstanceMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnInstancePropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnInstancePropsMixin",
):
    '''Specifies an EC2 instance.

    If an Elastic IP address is attached to your instance, AWS CloudFormation reattaches the Elastic IP address after it updates the instance. For more information about updating stacks, see `AWS CloudFormation Stacks Updates <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks.html>`_ .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html
    :cloudformationResource: AWS::EC2::Instance
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_instance_props_mixin = ec2_mixins.CfnInstancePropsMixin(ec2_mixins.CfnInstanceMixinProps(
            additional_info="additionalInfo",
            affinity="affinity",
            availability_zone="availabilityZone",
            block_device_mappings=[ec2_mixins.CfnInstancePropsMixin.BlockDeviceMappingProperty(
                device_name="deviceName",
                ebs=ec2_mixins.CfnInstancePropsMixin.EbsProperty(
                    delete_on_termination=False,
                    encrypted=False,
                    iops=123,
                    kms_key_id="kmsKeyId",
                    snapshot_id="snapshotId",
                    volume_size=123,
                    volume_type="volumeType"
                ),
                no_device=ec2_mixins.CfnInstancePropsMixin.NoDeviceProperty(),
                virtual_name="virtualName"
            )],
            cpu_options=ec2_mixins.CfnInstancePropsMixin.CpuOptionsProperty(
                core_count=123,
                threads_per_core=123
            ),
            credit_specification=ec2_mixins.CfnInstancePropsMixin.CreditSpecificationProperty(
                cpu_credits="cpuCredits"
            ),
            disable_api_termination=False,
            ebs_optimized=False,
            elastic_gpu_specifications=[ec2_mixins.CfnInstancePropsMixin.ElasticGpuSpecificationProperty(
                type="type"
            )],
            elastic_inference_accelerators=[ec2_mixins.CfnInstancePropsMixin.ElasticInferenceAcceleratorProperty(
                count=123,
                type="type"
            )],
            enclave_options=ec2_mixins.CfnInstancePropsMixin.EnclaveOptionsProperty(
                enabled=False
            ),
            hibernation_options=ec2_mixins.CfnInstancePropsMixin.HibernationOptionsProperty(
                configured=False
            ),
            host_id="hostId",
            host_resource_group_arn="hostResourceGroupArn",
            iam_instance_profile="iamInstanceProfile",
            image_id="imageId",
            instance_initiated_shutdown_behavior="instanceInitiatedShutdownBehavior",
            instance_type="instanceType",
            ipv6_address_count=123,
            ipv6_addresses=[ec2_mixins.CfnInstancePropsMixin.InstanceIpv6AddressProperty(
                ipv6_address="ipv6Address"
            )],
            kernel_id="kernelId",
            key_name="keyName",
            launch_template=ec2_mixins.CfnInstancePropsMixin.LaunchTemplateSpecificationProperty(
                launch_template_id="launchTemplateId",
                launch_template_name="launchTemplateName",
                version="version"
            ),
            license_specifications=[ec2_mixins.CfnInstancePropsMixin.LicenseSpecificationProperty(
                license_configuration_arn="licenseConfigurationArn"
            )],
            metadata_options=ec2_mixins.CfnInstancePropsMixin.MetadataOptionsProperty(
                http_endpoint="httpEndpoint",
                http_protocol_ipv6="httpProtocolIpv6",
                http_put_response_hop_limit=123,
                http_tokens="httpTokens",
                instance_metadata_tags="instanceMetadataTags"
            ),
            monitoring=False,
            network_interfaces=[ec2_mixins.CfnInstancePropsMixin.NetworkInterfaceProperty(
                associate_carrier_ip_address=False,
                associate_public_ip_address=False,
                delete_on_termination=False,
                description="description",
                device_index="deviceIndex",
                ena_srd_specification=ec2_mixins.CfnInstancePropsMixin.EnaSrdSpecificationProperty(
                    ena_srd_enabled=False,
                    ena_srd_udp_specification=ec2_mixins.CfnInstancePropsMixin.EnaSrdUdpSpecificationProperty(
                        ena_srd_udp_enabled=False
                    )
                ),
                group_set=["groupSet"],
                ipv6_address_count=123,
                ipv6_addresses=[ec2_mixins.CfnInstancePropsMixin.InstanceIpv6AddressProperty(
                    ipv6_address="ipv6Address"
                )],
                network_interface_id="networkInterfaceId",
                private_ip_address="privateIpAddress",
                private_ip_addresses=[ec2_mixins.CfnInstancePropsMixin.PrivateIpAddressSpecificationProperty(
                    primary=False,
                    private_ip_address="privateIpAddress"
                )],
                secondary_private_ip_address_count=123,
                subnet_id="subnetId"
            )],
            placement_group_name="placementGroupName",
            private_dns_name_options=ec2_mixins.CfnInstancePropsMixin.PrivateDnsNameOptionsProperty(
                enable_resource_name_dns_aaaa_record=False,
                enable_resource_name_dns_aRecord=False,
                hostname_type="hostnameType"
            ),
            private_ip_address="privateIpAddress",
            propagate_tags_to_volume_on_creation=False,
            ramdisk_id="ramdiskId",
            security_group_ids=["securityGroupIds"],
            security_groups=["securityGroups"],
            source_dest_check=False,
            ssm_associations=[ec2_mixins.CfnInstancePropsMixin.SsmAssociationProperty(
                association_parameters=[ec2_mixins.CfnInstancePropsMixin.AssociationParameterProperty(
                    key="key",
                    value=["value"]
                )],
                document_name="documentName"
            )],
            subnet_id="subnetId",
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            tenancy="tenancy",
            user_data="userData",
            volumes=[ec2_mixins.CfnInstancePropsMixin.VolumeProperty(
                device="device",
                volume_id="volumeId"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnInstanceMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::Instance``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ccd6a03d6e58b786df704b81ccbc5069d73a5967a53979c83ab3da3762423a99)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1543feb92dc3b58fff0ac4c9c261a346ac0c6f966ba2839bfcdcea8b6e1991f3)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__71e330001e7618b0cd10b69bb31944ea2ce130c8ece062bf2a8030dc1ef73ea0)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnInstanceMixinProps":
        return typing.cast("CfnInstanceMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnInstancePropsMixin.AssociationParameterProperty",
        jsii_struct_bases=[],
        name_mapping={"key": "key", "value": "value"},
    )
    class AssociationParameterProperty:
        def __init__(
            self,
            *,
            key: typing.Optional[builtins.str] = None,
            value: typing.Optional[typing.Sequence[builtins.str]] = None,
        ) -> None:
            '''Specifies input parameter values for an SSM document in AWS Systems Manager .

            ``AssociationParameter`` is a property of the `SsmAssociation <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html>`_ property type.

            :param key: The name of an input parameter that is in the associated SSM document.
            :param value: The value of an input parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-associationparameter.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                association_parameter_property = ec2_mixins.CfnInstancePropsMixin.AssociationParameterProperty(
                    key="key",
                    value=["value"]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__337d93eeb93f34076aa933341fd3f4280b377e2a2d711469d211554b4dc62505)
                check_type(argname="argument key", value=key, expected_type=type_hints["key"])
                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if key is not None:
                self._values["key"] = key
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def key(self) -> typing.Optional[builtins.str]:
            '''The name of an input parameter that is in the associated SSM document.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-associationparameter.html#cfn-ec2-instance-associationparameter-key
            '''
            result = self._values.get("key")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def value(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The value of an input parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-associationparameter.html#cfn-ec2-instance-associationparameter-value
            '''
            result = self._values.get("value")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AssociationParameterProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnInstancePropsMixin.BlockDeviceMappingProperty",
        jsii_struct_bases=[],
        name_mapping={
            "device_name": "deviceName",
            "ebs": "ebs",
            "no_device": "noDevice",
            "virtual_name": "virtualName",
        },
    )
    class BlockDeviceMappingProperty:
        def __init__(
            self,
            *,
            device_name: typing.Optional[builtins.str] = None,
            ebs: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnInstancePropsMixin.EbsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            no_device: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnInstancePropsMixin.NoDeviceProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            virtual_name: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies a block device mapping for an instance.

            You must specify exactly one of the following properties: ``VirtualName`` , ``Ebs`` , or ``NoDevice`` .

            ``BlockDeviceMapping`` is a property of the `AWS::EC2::Instance <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html>`_ resource.
            .. epigraph::

               After the instance is running, you can modify only the ``DeleteOnTermination`` parameter for the attached volumes without interrupting the instance. Modifying any other parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .

            :param device_name: The device name. For available device names, see `Device names for volumes <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/device_naming.html>`_ . .. epigraph:: After the instance is running, this parameter is used to specify the device name of the block device mapping to update.
            :param ebs: Parameters used to automatically set up EBS volumes when the instance is launched. .. epigraph:: After the instance is running, you can modify only the ``DeleteOnTermination`` parameter for the attached volumes without interrupting the instance. Modifying any other parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-no-interrupt>`_ .
            :param no_device: To omit the device from the block device mapping, specify an empty string. .. epigraph:: After the instance is running, modifying this parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .
            :param virtual_name: The virtual device name ( ``ephemeral`` N). The name must be in the form ``ephemeral`` *X* where *X* is a number starting from zero (0). For example, an instance type with 2 available instance store volumes can specify mappings for ``ephemeral0`` and ``ephemeral1`` . The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume. NVMe instance store volumes are automatically enumerated and assigned a device name. Including them in your block device mapping has no effect. *Constraints* : For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI. .. epigraph:: After the instance is running, modifying this parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                block_device_mapping_property = ec2_mixins.CfnInstancePropsMixin.BlockDeviceMappingProperty(
                    device_name="deviceName",
                    ebs=ec2_mixins.CfnInstancePropsMixin.EbsProperty(
                        delete_on_termination=False,
                        encrypted=False,
                        iops=123,
                        kms_key_id="kmsKeyId",
                        snapshot_id="snapshotId",
                        volume_size=123,
                        volume_type="volumeType"
                    ),
                    no_device=ec2_mixins.CfnInstancePropsMixin.NoDeviceProperty(),
                    virtual_name="virtualName"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__8a1b1bcc682cbf98735a58395825d806f544d8921f586377b3ec680d1215af7e)
                check_type(argname="argument device_name", value=device_name, expected_type=type_hints["device_name"])
                check_type(argname="argument ebs", value=ebs, expected_type=type_hints["ebs"])
                check_type(argname="argument no_device", value=no_device, expected_type=type_hints["no_device"])
                check_type(argname="argument virtual_name", value=virtual_name, expected_type=type_hints["virtual_name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if device_name is not None:
                self._values["device_name"] = device_name
            if ebs is not None:
                self._values["ebs"] = ebs
            if no_device is not None:
                self._values["no_device"] = no_device
            if virtual_name is not None:
                self._values["virtual_name"] = virtual_name

        @builtins.property
        def device_name(self) -> typing.Optional[builtins.str]:
            '''The device name. For available device names, see `Device names for volumes <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/device_naming.html>`_ .

            .. epigraph::

               After the instance is running, this parameter is used to specify the device name of the block device mapping to update.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-devicename
            '''
            result = self._values.get("device_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def ebs(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.EbsProperty"]]:
            '''Parameters used to automatically set up EBS volumes when the instance is launched.

            .. epigraph::

               After the instance is running, you can modify only the ``DeleteOnTermination`` parameter for the attached volumes without interrupting the instance. Modifying any other parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-no-interrupt>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-ebs
            '''
            result = self._values.get("ebs")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.EbsProperty"]], result)

        @builtins.property
        def no_device(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.NoDeviceProperty"]]:
            '''To omit the device from the block device mapping, specify an empty string.

            .. epigraph::

               After the instance is running, modifying this parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-nodevice
            '''
            result = self._values.get("no_device")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.NoDeviceProperty"]], result)

        @builtins.property
        def virtual_name(self) -> typing.Optional[builtins.str]:
            '''The virtual device name ( ``ephemeral`` N).

            The name must be in the form ``ephemeral`` *X* where *X* is a number starting from zero (0). For example, an instance type with 2 available instance store volumes can specify mappings for ``ephemeral0`` and ``ephemeral1`` . The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.

            NVMe instance store volumes are automatically enumerated and assigned a device name. Including them in your block device mapping has no effect.

            *Constraints* : For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.
            .. epigraph::

               After the instance is running, modifying this parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html#cfn-ec2-instance-blockdevicemapping-virtualname
            '''
            result = self._values.get("virtual_name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "BlockDeviceMappingProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnInstancePropsMixin.CpuOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={"core_count": "coreCount", "threads_per_core": "threadsPerCore"},
    )
    class CpuOptionsProperty:
        def __init__(
            self,
            *,
            core_count: typing.Optional[jsii.Number] = None,
            threads_per_core: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Specifies the CPU options for the instance.

            When you specify CPU options, you must specify both the number of CPU cores and threads per core.

            Modifying the CPU options for an instance results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .

            For more information, see `Optimize CPU options <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .

            :param core_count: The number of CPU cores for the instance.
            :param threads_per_core: The number of threads per CPU core.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                cpu_options_property = ec2_mixins.CfnInstancePropsMixin.CpuOptionsProperty(
                    core_count=123,
                    threads_per_core=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__aa7e40fd6c5b55a4c86b287de9df0b0ae3f1e5fdce8679cf5fe1d5d8463b7bb3)
                check_type(argname="argument core_count", value=core_count, expected_type=type_hints["core_count"])
                check_type(argname="argument threads_per_core", value=threads_per_core, expected_type=type_hints["threads_per_core"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if core_count is not None:
                self._values["core_count"] = core_count
            if threads_per_core is not None:
                self._values["threads_per_core"] = threads_per_core

        @builtins.property
        def core_count(self) -> typing.Optional[jsii.Number]:
            '''The number of CPU cores for the instance.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-corecount
            '''
            result = self._values.get("core_count")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def threads_per_core(self) -> typing.Optional[jsii.Number]:
            '''The number of threads per CPU core.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-threadspercore
            '''
            result = self._values.get("threads_per_core")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "CpuOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnInstancePropsMixin.CreditSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={"cpu_credits": "cpuCredits"},
    )
    class CreditSpecificationProperty:
        def __init__(
            self,
            *,
            cpu_credits: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies the credit option for CPU usage of a T instance.

            ``CreditSpecification`` is a property of the `AWS::EC2::Instance <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html>`_ resource.

            For more information, see `Burstable performance instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html>`_ in the *Amazon EC2 User Guide* .

            :param cpu_credits: The credit option for CPU usage of the instance. Valid values: ``standard`` | ``unlimited`` T3 instances with ``host`` tenancy do not support the ``unlimited`` CPU credit option.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                credit_specification_property = ec2_mixins.CfnInstancePropsMixin.CreditSpecificationProperty(
                    cpu_credits="cpuCredits"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__4ca1bcb5f39d7df26147dcdcee273756762fd890b789b9108af04dcf99ff8c60)
                check_type(argname="argument cpu_credits", value=cpu_credits, expected_type=type_hints["cpu_credits"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if cpu_credits is not None:
                self._values["cpu_credits"] = cpu_credits

        @builtins.property
        def cpu_credits(self) -> typing.Optional[builtins.str]:
            '''The credit option for CPU usage of the instance.

            Valid values: ``standard`` | ``unlimited``

            T3 instances with ``host`` tenancy do not support the ``unlimited`` CPU credit option.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-cpucredits
            '''
            result = self._values.get("cpu_credits")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "CreditSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnInstancePropsMixin.EbsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "delete_on_termination": "deleteOnTermination",
            "encrypted": "encrypted",
            "iops": "iops",
            "kms_key_id": "kmsKeyId",
            "snapshot_id": "snapshotId",
            "volume_size": "volumeSize",
            "volume_type": "volumeType",
        },
    )
    class EbsProperty:
        def __init__(
            self,
            *,
            delete_on_termination: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            encrypted: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            iops: typing.Optional[jsii.Number] = None,
            kms_key_id: typing.Optional[builtins.str] = None,
            snapshot_id: typing.Optional[builtins.str] = None,
            volume_size: typing.Optional[jsii.Number] = None,
            volume_type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies a block device for an EBS volume.

            ``Ebs`` is a property of the `BlockDeviceMapping <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-blockdevicemapping.html>`_ property type.
            .. epigraph::

               After the instance is running, you can modify only the ``DeleteOnTermination`` parameters for the attached volumes without interrupting the instance. Modifying any other parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .

            :param delete_on_termination: Indicates whether the EBS volume is deleted on instance termination. For more information, see `Preserving Amazon EBS volumes on instance termination <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination>`_ in the *Amazon EC2 User Guide* .
            :param encrypted: Indicates whether the volume should be encrypted. The effect of setting the encryption state to ``true`` depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see `Encryption by default <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-by-default>`_ in the *Amazon Elastic Compute Cloud User Guide* . Encrypted Amazon EBS volumes must be attached to instances that support Amazon EBS encryption. For more information, see `Supported instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances>`_ . .. epigraph:: After the instance is running, modifying this parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .
            :param iops: The number of I/O operations per second (IOPS). For ``gp3`` , ``io1`` , and ``io2`` volumes, this represents the number of IOPS that are provisioned for the volume. For ``gp2`` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. The following are the supported values for each volume type: - ``gp3`` : 3,000-16,000 IOPS - ``io1`` : 100-64,000 IOPS - ``io2`` : 100-64,000 IOPS For ``io1`` and ``io2`` volumes, we guarantee 64,000 IOPS only for `Instances built on the Nitro System <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances>`_ . Other instance families guarantee performance up to 32,000 IOPS. This parameter is required for ``io1`` and ``io2`` volumes. The default for ``gp3`` volumes is 3,000 IOPS. This parameter is not supported for ``gp2`` , ``st1`` , ``sc1`` , or ``standard`` volumes. .. epigraph:: After the instance is running, modifying this parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .
            :param kms_key_id: The identifier of the AWS KMS key to use for Amazon EBS encryption. If ``KmsKeyId`` is specified, the encrypted state must be ``true`` . If the encrypted state is ``true`` but you do not specify ``KmsKeyId`` , your KMS key for EBS is used. You can specify the KMS key using any of the following: - Key ID. For example, 1234abcd-12ab-34cd-56ef-1234567890ab. - Key alias. For example, alias/ExampleAlias. - Key ARN. For example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab. - Alias ARN. For example, arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias. .. epigraph:: After the instance is running, modifying this parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .
            :param snapshot_id: The ID of the snapshot. If you specify both ``SnapshotId`` and ``VolumeSize`` , ``VolumeSize`` must be equal or greater than the size of the snapshot. .. epigraph:: After the instance is running, modifying this parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .
            :param volume_size: The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size. The following are the supported volumes sizes for each volume type: - ``gp2`` and ``gp3`` :1-16,384 - ``io1`` and ``io2`` : 4-16,384 - ``st1`` and ``sc1`` : 125-16,384 - ``standard`` : 1-1,024 .. epigraph:: After the instance is running, modifying this parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .
            :param volume_type: The volume type. For more information, see `Amazon EBS volume types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html>`_ in the *Amazon EC2 User Guide* . If the volume type is ``io1`` or ``io2`` , you must specify the IOPS that the volume supports. .. epigraph:: After the instance is running, modifying this parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ebs.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                ebs_property = ec2_mixins.CfnInstancePropsMixin.EbsProperty(
                    delete_on_termination=False,
                    encrypted=False,
                    iops=123,
                    kms_key_id="kmsKeyId",
                    snapshot_id="snapshotId",
                    volume_size=123,
                    volume_type="volumeType"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__fec51512cd7ea3aa3c4921cba32ae6ec0dcf42b1161ea73654714a37e9008268)
                check_type(argname="argument delete_on_termination", value=delete_on_termination, expected_type=type_hints["delete_on_termination"])
                check_type(argname="argument encrypted", value=encrypted, expected_type=type_hints["encrypted"])
                check_type(argname="argument iops", value=iops, expected_type=type_hints["iops"])
                check_type(argname="argument kms_key_id", value=kms_key_id, expected_type=type_hints["kms_key_id"])
                check_type(argname="argument snapshot_id", value=snapshot_id, expected_type=type_hints["snapshot_id"])
                check_type(argname="argument volume_size", value=volume_size, expected_type=type_hints["volume_size"])
                check_type(argname="argument volume_type", value=volume_type, expected_type=type_hints["volume_type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if delete_on_termination is not None:
                self._values["delete_on_termination"] = delete_on_termination
            if encrypted is not None:
                self._values["encrypted"] = encrypted
            if iops is not None:
                self._values["iops"] = iops
            if kms_key_id is not None:
                self._values["kms_key_id"] = kms_key_id
            if snapshot_id is not None:
                self._values["snapshot_id"] = snapshot_id
            if volume_size is not None:
                self._values["volume_size"] = volume_size
            if volume_type is not None:
                self._values["volume_type"] = volume_type

        @builtins.property
        def delete_on_termination(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether the EBS volume is deleted on instance termination.

            For more information, see `Preserving Amazon EBS volumes on instance termination <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination>`_ in the *Amazon EC2 User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ebs.html#cfn-ec2-instance-ebs-deleteontermination
            '''
            result = self._values.get("delete_on_termination")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def encrypted(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether the volume should be encrypted.

            The effect of setting the encryption state to ``true`` depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see `Encryption by default <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-by-default>`_ in the *Amazon Elastic Compute Cloud User Guide* .

            Encrypted Amazon EBS volumes must be attached to instances that support Amazon EBS encryption. For more information, see `Supported instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances>`_ .
            .. epigraph::

               After the instance is running, modifying this parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ebs.html#cfn-ec2-instance-ebs-encrypted
            '''
            result = self._values.get("encrypted")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def iops(self) -> typing.Optional[jsii.Number]:
            '''The number of I/O operations per second (IOPS).

            For ``gp3`` , ``io1`` , and ``io2`` volumes, this represents the number of IOPS that are provisioned for the volume. For ``gp2`` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.

            The following are the supported values for each volume type:

            - ``gp3`` : 3,000-16,000 IOPS
            - ``io1`` : 100-64,000 IOPS
            - ``io2`` : 100-64,000 IOPS

            For ``io1`` and ``io2`` volumes, we guarantee 64,000 IOPS only for `Instances built on the Nitro System <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances>`_ . Other instance families guarantee performance up to 32,000 IOPS.

            This parameter is required for ``io1`` and ``io2`` volumes. The default for ``gp3`` volumes is 3,000 IOPS. This parameter is not supported for ``gp2`` , ``st1`` , ``sc1`` , or ``standard`` volumes.
            .. epigraph::

               After the instance is running, modifying this parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ebs.html#cfn-ec2-instance-ebs-iops
            '''
            result = self._values.get("iops")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def kms_key_id(self) -> typing.Optional[builtins.str]:
            '''The identifier of the AWS KMS key to use for Amazon EBS encryption.

            If ``KmsKeyId`` is specified, the encrypted state must be ``true`` . If the encrypted state is ``true`` but you do not specify ``KmsKeyId`` , your KMS key for EBS is used.

            You can specify the KMS key using any of the following:

            - Key ID. For example, 1234abcd-12ab-34cd-56ef-1234567890ab.
            - Key alias. For example, alias/ExampleAlias.
            - Key ARN. For example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
            - Alias ARN. For example, arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias.

            .. epigraph::

               After the instance is running, modifying this parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ebs.html#cfn-ec2-instance-ebs-kmskeyid
            '''
            result = self._values.get("kms_key_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def snapshot_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the snapshot.

            If you specify both ``SnapshotId`` and ``VolumeSize`` , ``VolumeSize`` must be equal or greater than the size of the snapshot.
            .. epigraph::

               After the instance is running, modifying this parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ebs.html#cfn-ec2-instance-ebs-snapshotid
            '''
            result = self._values.get("snapshot_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def volume_size(self) -> typing.Optional[jsii.Number]:
            '''The size of the volume, in GiBs.

            You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size.

            The following are the supported volumes sizes for each volume type:

            - ``gp2`` and ``gp3`` :1-16,384
            - ``io1`` and ``io2`` : 4-16,384
            - ``st1`` and ``sc1`` : 125-16,384
            - ``standard`` : 1-1,024

            .. epigraph::

               After the instance is running, modifying this parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ebs.html#cfn-ec2-instance-ebs-volumesize
            '''
            result = self._values.get("volume_size")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def volume_type(self) -> typing.Optional[builtins.str]:
            '''The volume type.

            For more information, see `Amazon EBS volume types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html>`_ in the *Amazon EC2 User Guide* . If the volume type is ``io1`` or ``io2`` , you must specify the IOPS that the volume supports.
            .. epigraph::

               After the instance is running, modifying this parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ebs.html#cfn-ec2-instance-ebs-volumetype
            '''
            result = self._values.get("volume_type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "EbsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnInstancePropsMixin.ElasticGpuSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={"type": "type"},
    )
    class ElasticGpuSpecificationProperty:
        def __init__(self, *, type: typing.Optional[builtins.str] = None) -> None:
            '''.. epigraph::

   Amazon Elastic Graphics reached end of life on January 8, 2024.

            Specifies the type of Elastic GPU. An Elastic GPU is a GPU resource that you can attach to your Amazon EC2 instance to accelerate the graphics performance of your applications.

            ``ElasticGpuSpecification`` is a property of the `AWS::EC2::Instance <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html>`_ resource.

            :param type: The type of Elastic Graphics accelerator.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                elastic_gpu_specification_property = ec2_mixins.CfnInstancePropsMixin.ElasticGpuSpecificationProperty(
                    type="type"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__5030efb09121c8de356f9008376b22a2e1597bbf68f021e21791e21ded0750fe)
                check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if type is not None:
                self._values["type"] = type

        @builtins.property
        def type(self) -> typing.Optional[builtins.str]:
            '''The type of Elastic Graphics accelerator.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ElasticGpuSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnInstancePropsMixin.ElasticInferenceAcceleratorProperty",
        jsii_struct_bases=[],
        name_mapping={"count": "count", "type": "type"},
    )
    class ElasticInferenceAcceleratorProperty:
        def __init__(
            self,
            *,
            count: typing.Optional[jsii.Number] = None,
            type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''.. epigraph::

   Amazon Elastic Inference is no longer available.

            Specifies the Elastic Inference Accelerator for the instance.

            ``ElasticInferenceAccelerator`` is a property of the `AWS::EC2::Instance <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html>`_ resource.

            :param count: The number of elastic inference accelerators to attach to the instance.
            :param type: The type of elastic inference accelerator. The possible values are ``eia1.medium`` , ``eia1.large`` , ``eia1.xlarge`` , ``eia2.medium`` , ``eia2.large`` , and ``eia2.xlarge`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                elastic_inference_accelerator_property = ec2_mixins.CfnInstancePropsMixin.ElasticInferenceAcceleratorProperty(
                    count=123,
                    type="type"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__e815aa4a51d795bb85c88c54c6758f54a0293db404519aea3fd9295dd612bdca)
                check_type(argname="argument count", value=count, expected_type=type_hints["count"])
                check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if count is not None:
                self._values["count"] = count
            if type is not None:
                self._values["type"] = type

        @builtins.property
        def count(self) -> typing.Optional[jsii.Number]:
            '''The number of elastic inference accelerators to attach to the instance.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-count
            '''
            result = self._values.get("count")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def type(self) -> typing.Optional[builtins.str]:
            '''The type of elastic inference accelerator.

            The possible values are ``eia1.medium`` , ``eia1.large`` , ``eia1.xlarge`` , ``eia2.medium`` , ``eia2.large`` , and ``eia2.xlarge`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ElasticInferenceAcceleratorProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnInstancePropsMixin.EnaSrdSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "ena_srd_enabled": "enaSrdEnabled",
            "ena_srd_udp_specification": "enaSrdUdpSpecification",
        },
    )
    class EnaSrdSpecificationProperty:
        def __init__(
            self,
            *,
            ena_srd_enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            ena_srd_udp_specification: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnInstancePropsMixin.EnaSrdUdpSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''ENA Express uses AWS Scalable Reliable Datagram (SRD) technology to increase the maximum bandwidth used per stream and minimize tail latency of network traffic between EC2 instances.

            With ENA Express, you can communicate between two EC2 instances in the same subnet within the same account, or in different accounts. Both sending and receiving instances must have ENA Express enabled.

            To improve the reliability of network packet delivery, ENA Express reorders network packets on the receiving end by default. However, some UDP-based applications are designed to handle network packets that are out of order to reduce the overhead for packet delivery at the network layer. When ENA Express is enabled, you can specify whether UDP network traffic uses it.

            :param ena_srd_enabled: Indicates whether ENA Express is enabled for the network interface.
            :param ena_srd_udp_specification: Configures ENA Express for UDP network traffic.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enasrdspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                ena_srd_specification_property = ec2_mixins.CfnInstancePropsMixin.EnaSrdSpecificationProperty(
                    ena_srd_enabled=False,
                    ena_srd_udp_specification=ec2_mixins.CfnInstancePropsMixin.EnaSrdUdpSpecificationProperty(
                        ena_srd_udp_enabled=False
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__838bd0a78651b05bb0f3fd35b80d6f5b5a48ffa1e17e83ab4b4fc4cc8d511bef)
                check_type(argname="argument ena_srd_enabled", value=ena_srd_enabled, expected_type=type_hints["ena_srd_enabled"])
                check_type(argname="argument ena_srd_udp_specification", value=ena_srd_udp_specification, expected_type=type_hints["ena_srd_udp_specification"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if ena_srd_enabled is not None:
                self._values["ena_srd_enabled"] = ena_srd_enabled
            if ena_srd_udp_specification is not None:
                self._values["ena_srd_udp_specification"] = ena_srd_udp_specification

        @builtins.property
        def ena_srd_enabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether ENA Express is enabled for the network interface.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enasrdspecification.html#cfn-ec2-instance-enasrdspecification-enasrdenabled
            '''
            result = self._values.get("ena_srd_enabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def ena_srd_udp_specification(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.EnaSrdUdpSpecificationProperty"]]:
            '''Configures ENA Express for UDP network traffic.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enasrdspecification.html#cfn-ec2-instance-enasrdspecification-enasrdudpspecification
            '''
            result = self._values.get("ena_srd_udp_specification")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.EnaSrdUdpSpecificationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "EnaSrdSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnInstancePropsMixin.EnaSrdUdpSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={"ena_srd_udp_enabled": "enaSrdUdpEnabled"},
    )
    class EnaSrdUdpSpecificationProperty:
        def __init__(
            self,
            *,
            ena_srd_udp_enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        ) -> None:
            '''ENA Express is compatible with both TCP and UDP transport protocols.

            When it's enabled, TCP traffic automatically uses it. However, some UDP-based applications are designed to handle network packets that are out of order, without a need for retransmission, such as live video broadcasting or other near-real-time applications. For UDP traffic, you can specify whether to use ENA Express, based on your application environment needs.

            :param ena_srd_udp_enabled: Indicates whether UDP traffic to and from the instance uses ENA Express. To specify this setting, you must first enable ENA Express.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enasrdudpspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                ena_srd_udp_specification_property = ec2_mixins.CfnInstancePropsMixin.EnaSrdUdpSpecificationProperty(
                    ena_srd_udp_enabled=False
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__ec99fe7d3680efc105725767ffa4331a59e47a4b9f2f8c1467724074bfa01319)
                check_type(argname="argument ena_srd_udp_enabled", value=ena_srd_udp_enabled, expected_type=type_hints["ena_srd_udp_enabled"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if ena_srd_udp_enabled is not None:
                self._values["ena_srd_udp_enabled"] = ena_srd_udp_enabled

        @builtins.property
        def ena_srd_udp_enabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether UDP traffic to and from the instance uses ENA Express.

            To specify this setting, you must first enable ENA Express.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enasrdudpspecification.html#cfn-ec2-instance-enasrdudpspecification-enasrdudpenabled
            '''
            result = self._values.get("ena_srd_udp_enabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "EnaSrdUdpSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnInstancePropsMixin.EnclaveOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={"enabled": "enabled"},
    )
    class EnclaveOptionsProperty:
        def __init__(
            self,
            *,
            enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        ) -> None:
            '''Indicates whether the instance is enabled for AWS Nitro Enclaves.

            :param enabled: If this parameter is set to ``true`` , the instance is enabled for AWS Nitro Enclaves; otherwise, it is not enabled for AWS Nitro Enclaves.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                enclave_options_property = ec2_mixins.CfnInstancePropsMixin.EnclaveOptionsProperty(
                    enabled=False
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__ad132a665ba2b7ec4ebbf890f56add2bd083d35e412230e3a01d6aca2f277708)
                check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if enabled is not None:
                self._values["enabled"] = enabled

        @builtins.property
        def enabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''If this parameter is set to ``true`` , the instance is enabled for AWS Nitro Enclaves;

            otherwise, it is not enabled for AWS Nitro Enclaves.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-enabled
            '''
            result = self._values.get("enabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "EnclaveOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnInstancePropsMixin.HibernationOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={"configured": "configured"},
    )
    class HibernationOptionsProperty:
        def __init__(
            self,
            *,
            configured: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        ) -> None:
            '''Specifies the hibernation options for the instance.

            ``HibernationOptions`` is a property of the `AWS::EC2::Instance <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html>`_ resource.

            :param configured: Set to ``true`` to enable your instance for hibernation. For Spot Instances, if you set ``Configured`` to ``true`` , either omit the ``InstanceInterruptionBehavior`` parameter (for ```SpotMarketOptions`` <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SpotMarketOptions.html>`_ ), or set it to ``hibernate`` . When ``Configured`` is true: - If you omit ``InstanceInterruptionBehavior`` , it defaults to ``hibernate`` . - If you set ``InstanceInterruptionBehavior`` to a value other than ``hibernate`` , you'll get an error. Default: ``false`` Default: - false

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                hibernation_options_property = ec2_mixins.CfnInstancePropsMixin.HibernationOptionsProperty(
                    configured=False
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__40ed17182fc149cd22251d65e605c35a0e690a71ba99d34d7b4b79924ab1c2a3)
                check_type(argname="argument configured", value=configured, expected_type=type_hints["configured"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if configured is not None:
                self._values["configured"] = configured

        @builtins.property
        def configured(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Set to ``true`` to enable your instance for hibernation.

            For Spot Instances, if you set ``Configured`` to ``true`` , either omit the ``InstanceInterruptionBehavior`` parameter (for ```SpotMarketOptions`` <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SpotMarketOptions.html>`_ ), or set it to ``hibernate`` . When ``Configured`` is true:

            - If you omit ``InstanceInterruptionBehavior`` , it defaults to ``hibernate`` .
            - If you set ``InstanceInterruptionBehavior`` to a value other than ``hibernate`` , you'll get an error.

            Default: ``false``

            :default: - false

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-configured
            '''
            result = self._values.get("configured")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "HibernationOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnInstancePropsMixin.InstanceIpv6AddressProperty",
        jsii_struct_bases=[],
        name_mapping={"ipv6_address": "ipv6Address"},
    )
    class InstanceIpv6AddressProperty:
        def __init__(
            self,
            *,
            ipv6_address: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies the IPv6 address for the instance.

            ``InstanceIpv6Address`` is a property of the `AWS::EC2::Instance <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html>`_ resource.

            :param ipv6_address: The IPv6 address.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                instance_ipv6_address_property = ec2_mixins.CfnInstancePropsMixin.InstanceIpv6AddressProperty(
                    ipv6_address="ipv6Address"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__4a1a54cbe0962b9362670d8e410176938339a63f3fbb56d7ca12707eac86b26b)
                check_type(argname="argument ipv6_address", value=ipv6_address, expected_type=type_hints["ipv6_address"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if ipv6_address is not None:
                self._values["ipv6_address"] = ipv6_address

        @builtins.property
        def ipv6_address(self) -> typing.Optional[builtins.str]:
            '''The IPv6 address.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-ipv6address
            '''
            result = self._values.get("ipv6_address")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "InstanceIpv6AddressProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnInstancePropsMixin.LaunchTemplateSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "launch_template_id": "launchTemplateId",
            "launch_template_name": "launchTemplateName",
            "version": "version",
        },
    )
    class LaunchTemplateSpecificationProperty:
        def __init__(
            self,
            *,
            launch_template_id: typing.Optional[builtins.str] = None,
            launch_template_name: typing.Optional[builtins.str] = None,
            version: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies a launch template to use when launching an Amazon EC2 instance.

            You must specify the following:

            - The ID or the name of the launch template, but not both.
            - The version of the launch template.

            For information about creating a launch template, see `AWS::EC2::LaunchTemplate <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html>`_ and `Create a launch template <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#create-launch-template>`_ in the *Amazon EC2 User Guide* . For example launch templates, see the `Examples <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#aws-resource-ec2-launchtemplate--examples>`_ for ``AWS::EC2::LaunchTemplate`` .

            :param launch_template_id: The ID of the launch template. You must specify either the launch template ID or the launch template name, but not both.
            :param launch_template_name: The name of the launch template. You must specify either the launch template ID or the launch template name, but not both.
            :param version: The version number of the launch template. You must specify this property. To specify the default version of the template, use the ``Fn::GetAtt`` intrinsic function to retrieve the ``DefaultVersionNumber`` attribute of the launch template. To specify the latest version of the template, use ``Fn::GetAtt`` to retrieve the ``LatestVersionNumber`` attribute. For more information, see `AWS::EC2:LaunchTemplate return values for Fn::GetAtt <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#aws-resource-ec2-launchtemplate-return-values-fn--getatt>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                launch_template_specification_property = ec2_mixins.CfnInstancePropsMixin.LaunchTemplateSpecificationProperty(
                    launch_template_id="launchTemplateId",
                    launch_template_name="launchTemplateName",
                    version="version"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__14575557fc86b61b07c92e3995e721dee5767885314771e9c214471d1307af3a)
                check_type(argname="argument launch_template_id", value=launch_template_id, expected_type=type_hints["launch_template_id"])
                check_type(argname="argument launch_template_name", value=launch_template_name, expected_type=type_hints["launch_template_name"])
                check_type(argname="argument version", value=version, expected_type=type_hints["version"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if launch_template_id is not None:
                self._values["launch_template_id"] = launch_template_id
            if launch_template_name is not None:
                self._values["launch_template_name"] = launch_template_name
            if version is not None:
                self._values["version"] = version

        @builtins.property
        def launch_template_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the launch template.

            You must specify either the launch template ID or the launch template name, but not both.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-launchtemplateid
            '''
            result = self._values.get("launch_template_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def launch_template_name(self) -> typing.Optional[builtins.str]:
            '''The name of the launch template.

            You must specify either the launch template ID or the launch template name, but not both.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-launchtemplatename
            '''
            result = self._values.get("launch_template_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def version(self) -> typing.Optional[builtins.str]:
            '''The version number of the launch template. You must specify this property.

            To specify the default version of the template, use the ``Fn::GetAtt`` intrinsic function to retrieve the ``DefaultVersionNumber`` attribute of the launch template. To specify the latest version of the template, use ``Fn::GetAtt`` to retrieve the ``LatestVersionNumber`` attribute. For more information, see `AWS::EC2:LaunchTemplate return values for Fn::GetAtt <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#aws-resource-ec2-launchtemplate-return-values-fn--getatt>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-version
            '''
            result = self._values.get("version")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "LaunchTemplateSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnInstancePropsMixin.LicenseSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={"license_configuration_arn": "licenseConfigurationArn"},
    )
    class LicenseSpecificationProperty:
        def __init__(
            self,
            *,
            license_configuration_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies the license configuration to use.

            ``LicenseSpecification`` is a property of the `AWS::EC2::Instance <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html>`_ resource.

            :param license_configuration_arn: The Amazon Resource Name (ARN) of the license configuration.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                license_specification_property = ec2_mixins.CfnInstancePropsMixin.LicenseSpecificationProperty(
                    license_configuration_arn="licenseConfigurationArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__753dc090b54fa4e40f47c6d64e1866f790be3b00f09adc0d49f5788db952a052)
                check_type(argname="argument license_configuration_arn", value=license_configuration_arn, expected_type=type_hints["license_configuration_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if license_configuration_arn is not None:
                self._values["license_configuration_arn"] = license_configuration_arn

        @builtins.property
        def license_configuration_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the license configuration.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-licenseconfigurationarn
            '''
            result = self._values.get("license_configuration_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "LicenseSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnInstancePropsMixin.MetadataOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "http_endpoint": "httpEndpoint",
            "http_protocol_ipv6": "httpProtocolIpv6",
            "http_put_response_hop_limit": "httpPutResponseHopLimit",
            "http_tokens": "httpTokens",
            "instance_metadata_tags": "instanceMetadataTags",
        },
    )
    class MetadataOptionsProperty:
        def __init__(
            self,
            *,
            http_endpoint: typing.Optional[builtins.str] = None,
            http_protocol_ipv6: typing.Optional[builtins.str] = None,
            http_put_response_hop_limit: typing.Optional[jsii.Number] = None,
            http_tokens: typing.Optional[builtins.str] = None,
            instance_metadata_tags: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies the metadata options for the instance.

            :param http_endpoint: Enables or disables the HTTP metadata endpoint on your instances. If you specify a value of ``disabled`` , you cannot access your instance metadata. Default: ``enabled``
            :param http_protocol_ipv6: Enables or disables the IPv6 endpoint for the instance metadata service. Default: ``disabled``
            :param http_put_response_hop_limit: The maximum number of hops that the metadata token can travel. Possible values: Integers from 1 to 64 Default: - 1
            :param http_tokens: Indicates whether IMDSv2 is required. - ``optional`` - IMDSv2 is optional, which means that you can use either IMDSv2 or IMDSv1. - ``required`` - IMDSv2 is required, which means that IMDSv1 is disabled, and you must use IMDSv2. Default: - If the value of ``ImdsSupport`` for the Amazon Machine Image (AMI) for your instance is ``v2.0`` and the account level default is set to ``no-preference`` , the default is ``required`` . - If the value of ``ImdsSupport`` for the Amazon Machine Image (AMI) for your instance is ``v2.0`` , but the account level default is set to ``V1 or V2`` , the default is ``optional`` . The default value can also be affected by other combinations of parameters. For more information, see `Order of precedence for instance metadata options <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/configuring-instance-metadata-options.html#instance-metadata-options-order-of-precedence>`_ in the *Amazon EC2 User Guide* .
            :param instance_metadata_tags: Set to ``enabled`` to allow access to instance tags from the instance metadata. Set to ``disabled`` to turn off access to instance tags from the instance metadata. For more information, see `Work with instance tags using the instance metadata <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#work-with-tags-in-IMDS>`_ . Default: ``disabled``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-metadataoptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                metadata_options_property = ec2_mixins.CfnInstancePropsMixin.MetadataOptionsProperty(
                    http_endpoint="httpEndpoint",
                    http_protocol_ipv6="httpProtocolIpv6",
                    http_put_response_hop_limit=123,
                    http_tokens="httpTokens",
                    instance_metadata_tags="instanceMetadataTags"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__636b55fb2c25df671b20d48b136b9d31c75074dc6b55cbc3f597060d32e28ae2)
                check_type(argname="argument http_endpoint", value=http_endpoint, expected_type=type_hints["http_endpoint"])
                check_type(argname="argument http_protocol_ipv6", value=http_protocol_ipv6, expected_type=type_hints["http_protocol_ipv6"])
                check_type(argname="argument http_put_response_hop_limit", value=http_put_response_hop_limit, expected_type=type_hints["http_put_response_hop_limit"])
                check_type(argname="argument http_tokens", value=http_tokens, expected_type=type_hints["http_tokens"])
                check_type(argname="argument instance_metadata_tags", value=instance_metadata_tags, expected_type=type_hints["instance_metadata_tags"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if http_endpoint is not None:
                self._values["http_endpoint"] = http_endpoint
            if http_protocol_ipv6 is not None:
                self._values["http_protocol_ipv6"] = http_protocol_ipv6
            if http_put_response_hop_limit is not None:
                self._values["http_put_response_hop_limit"] = http_put_response_hop_limit
            if http_tokens is not None:
                self._values["http_tokens"] = http_tokens
            if instance_metadata_tags is not None:
                self._values["instance_metadata_tags"] = instance_metadata_tags

        @builtins.property
        def http_endpoint(self) -> typing.Optional[builtins.str]:
            '''Enables or disables the HTTP metadata endpoint on your instances.

            If you specify a value of ``disabled`` , you cannot access your instance metadata.

            Default: ``enabled``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-metadataoptions.html#cfn-ec2-instance-metadataoptions-httpendpoint
            '''
            result = self._values.get("http_endpoint")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def http_protocol_ipv6(self) -> typing.Optional[builtins.str]:
            '''Enables or disables the IPv6 endpoint for the instance metadata service.

            Default: ``disabled``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-metadataoptions.html#cfn-ec2-instance-metadataoptions-httpprotocolipv6
            '''
            result = self._values.get("http_protocol_ipv6")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def http_put_response_hop_limit(self) -> typing.Optional[jsii.Number]:
            '''The maximum number of hops that the metadata token can travel.

            Possible values: Integers from 1 to 64

            :default: - 1

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-metadataoptions.html#cfn-ec2-instance-metadataoptions-httpputresponsehoplimit
            '''
            result = self._values.get("http_put_response_hop_limit")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def http_tokens(self) -> typing.Optional[builtins.str]:
            '''Indicates whether IMDSv2 is required.

            - ``optional`` - IMDSv2 is optional, which means that you can use either IMDSv2 or IMDSv1.
            - ``required`` - IMDSv2 is required, which means that IMDSv1 is disabled, and you must use IMDSv2.

            Default:

            - If the value of ``ImdsSupport`` for the Amazon Machine Image (AMI) for your instance is ``v2.0`` and the account level default is set to ``no-preference`` , the default is ``required`` .
            - If the value of ``ImdsSupport`` for the Amazon Machine Image (AMI) for your instance is ``v2.0`` , but the account level default is set to ``V1 or V2`` , the default is ``optional`` .

            The default value can also be affected by other combinations of parameters. For more information, see `Order of precedence for instance metadata options <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/configuring-instance-metadata-options.html#instance-metadata-options-order-of-precedence>`_ in the *Amazon EC2 User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-metadataoptions.html#cfn-ec2-instance-metadataoptions-httptokens
            '''
            result = self._values.get("http_tokens")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def instance_metadata_tags(self) -> typing.Optional[builtins.str]:
            '''Set to ``enabled`` to allow access to instance tags from the instance metadata.

            Set to ``disabled`` to turn off access to instance tags from the instance metadata. For more information, see `Work with instance tags using the instance metadata <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#work-with-tags-in-IMDS>`_ .

            Default: ``disabled``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-metadataoptions.html#cfn-ec2-instance-metadataoptions-instancemetadatatags
            '''
            result = self._values.get("instance_metadata_tags")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "MetadataOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnInstancePropsMixin.NetworkInterfaceProperty",
        jsii_struct_bases=[],
        name_mapping={
            "associate_carrier_ip_address": "associateCarrierIpAddress",
            "associate_public_ip_address": "associatePublicIpAddress",
            "delete_on_termination": "deleteOnTermination",
            "description": "description",
            "device_index": "deviceIndex",
            "ena_srd_specification": "enaSrdSpecification",
            "group_set": "groupSet",
            "ipv6_address_count": "ipv6AddressCount",
            "ipv6_addresses": "ipv6Addresses",
            "network_interface_id": "networkInterfaceId",
            "private_ip_address": "privateIpAddress",
            "private_ip_addresses": "privateIpAddresses",
            "secondary_private_ip_address_count": "secondaryPrivateIpAddressCount",
            "subnet_id": "subnetId",
        },
    )
    class NetworkInterfaceProperty:
        def __init__(
            self,
            *,
            associate_carrier_ip_address: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            associate_public_ip_address: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            delete_on_termination: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            description: typing.Optional[builtins.str] = None,
            device_index: typing.Optional[builtins.str] = None,
            ena_srd_specification: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnInstancePropsMixin.EnaSrdSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            group_set: typing.Optional[typing.Sequence[builtins.str]] = None,
            ipv6_address_count: typing.Optional[jsii.Number] = None,
            ipv6_addresses: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnInstancePropsMixin.InstanceIpv6AddressProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            network_interface_id: typing.Optional[builtins.str] = None,
            private_ip_address: typing.Optional[builtins.str] = None,
            private_ip_addresses: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnInstancePropsMixin.PrivateIpAddressSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            secondary_private_ip_address_count: typing.Optional[jsii.Number] = None,
            subnet_id: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies a network interface that is to be attached to an instance.

            You can create a network interface when launching an instance. For an example, see the `AWS::EC2::Instance examples <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#aws-properties-ec2-instance--examples--Automatically_assign_a_public_IP_address>`_ .

            Alternatively, you can attach an existing network interface when launching an instance. For an example, see the `AWS::EC2:NetworkInterface examples <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#aws-resource-ec2-networkinterface--examples>`_ .

            :param associate_carrier_ip_address: Indicates whether to assign a carrier IP address to the network interface. You can only assign a carrier IP address to a network interface that is in a subnet in a Wavelength Zone. For more information about carrier IP addresses, see `Carrier IP address <https://docs.aws.amazon.com/wavelength/latest/developerguide/how-wavelengths-work.html#provider-owned-ip>`_ in the *AWS Wavelength Developer Guide* .
            :param associate_public_ip_address: Indicates whether to assign a public IPv4 address to an instance. Applies only if creating a network interface when launching an instance. The network interface must be the primary network interface. If launching into a default subnet, the default value is ``true`` . AWS charges for all public IPv4 addresses, including public IPv4 addresses associated with running instances and Elastic IP addresses. For more information, see the *Public IPv4 Address* tab on the `VPC pricing page <https://docs.aws.amazon.com/vpc/pricing/>`_ .
            :param delete_on_termination: Indicates whether the network interface is deleted when the instance is terminated. Applies only if creating a network interface when launching an instance.
            :param description: The description of the network interface. Applies only if creating a network interface when launching an instance.
            :param device_index: The position of the network interface in the attachment order. A primary network interface has a device index of 0. If you create a network interface when launching an instance, you must specify the device index.
            :param ena_srd_specification: Configures ENA Express for UDP network traffic.
            :param group_set: The IDs of the security groups for the network interface. Applies only if creating a network interface when launching an instance.
            :param ipv6_address_count: A number of IPv6 addresses to assign to the network interface. Amazon EC2 chooses the IPv6 addresses from the range of the subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.
            :param ipv6_addresses: The IPv6 addresses to assign to the network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.
            :param network_interface_id: The ID of the network interface, when attaching an existing network interface.
            :param private_ip_address: The private IPv4 address of the network interface. Applies only if creating a network interface when launching an instance.
            :param private_ip_addresses: One or more private IPv4 addresses to assign to the network interface. Only one private IPv4 address can be designated as primary.
            :param secondary_private_ip_address_count: The number of secondary private IPv4 addresses. You can't specify this option and specify more than one private IP address using the private IP addresses option.
            :param subnet_id: The ID of the subnet associated with the network interface.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                network_interface_property = ec2_mixins.CfnInstancePropsMixin.NetworkInterfaceProperty(
                    associate_carrier_ip_address=False,
                    associate_public_ip_address=False,
                    delete_on_termination=False,
                    description="description",
                    device_index="deviceIndex",
                    ena_srd_specification=ec2_mixins.CfnInstancePropsMixin.EnaSrdSpecificationProperty(
                        ena_srd_enabled=False,
                        ena_srd_udp_specification=ec2_mixins.CfnInstancePropsMixin.EnaSrdUdpSpecificationProperty(
                            ena_srd_udp_enabled=False
                        )
                    ),
                    group_set=["groupSet"],
                    ipv6_address_count=123,
                    ipv6_addresses=[ec2_mixins.CfnInstancePropsMixin.InstanceIpv6AddressProperty(
                        ipv6_address="ipv6Address"
                    )],
                    network_interface_id="networkInterfaceId",
                    private_ip_address="privateIpAddress",
                    private_ip_addresses=[ec2_mixins.CfnInstancePropsMixin.PrivateIpAddressSpecificationProperty(
                        primary=False,
                        private_ip_address="privateIpAddress"
                    )],
                    secondary_private_ip_address_count=123,
                    subnet_id="subnetId"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__752f7d14a986923339cf950611b025feabc674f8dd75f0e62fc75acf0631aea5)
                check_type(argname="argument associate_carrier_ip_address", value=associate_carrier_ip_address, expected_type=type_hints["associate_carrier_ip_address"])
                check_type(argname="argument associate_public_ip_address", value=associate_public_ip_address, expected_type=type_hints["associate_public_ip_address"])
                check_type(argname="argument delete_on_termination", value=delete_on_termination, expected_type=type_hints["delete_on_termination"])
                check_type(argname="argument description", value=description, expected_type=type_hints["description"])
                check_type(argname="argument device_index", value=device_index, expected_type=type_hints["device_index"])
                check_type(argname="argument ena_srd_specification", value=ena_srd_specification, expected_type=type_hints["ena_srd_specification"])
                check_type(argname="argument group_set", value=group_set, expected_type=type_hints["group_set"])
                check_type(argname="argument ipv6_address_count", value=ipv6_address_count, expected_type=type_hints["ipv6_address_count"])
                check_type(argname="argument ipv6_addresses", value=ipv6_addresses, expected_type=type_hints["ipv6_addresses"])
                check_type(argname="argument network_interface_id", value=network_interface_id, expected_type=type_hints["network_interface_id"])
                check_type(argname="argument private_ip_address", value=private_ip_address, expected_type=type_hints["private_ip_address"])
                check_type(argname="argument private_ip_addresses", value=private_ip_addresses, expected_type=type_hints["private_ip_addresses"])
                check_type(argname="argument secondary_private_ip_address_count", value=secondary_private_ip_address_count, expected_type=type_hints["secondary_private_ip_address_count"])
                check_type(argname="argument subnet_id", value=subnet_id, expected_type=type_hints["subnet_id"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if associate_carrier_ip_address is not None:
                self._values["associate_carrier_ip_address"] = associate_carrier_ip_address
            if associate_public_ip_address is not None:
                self._values["associate_public_ip_address"] = associate_public_ip_address
            if delete_on_termination is not None:
                self._values["delete_on_termination"] = delete_on_termination
            if description is not None:
                self._values["description"] = description
            if device_index is not None:
                self._values["device_index"] = device_index
            if ena_srd_specification is not None:
                self._values["ena_srd_specification"] = ena_srd_specification
            if group_set is not None:
                self._values["group_set"] = group_set
            if ipv6_address_count is not None:
                self._values["ipv6_address_count"] = ipv6_address_count
            if ipv6_addresses is not None:
                self._values["ipv6_addresses"] = ipv6_addresses
            if network_interface_id is not None:
                self._values["network_interface_id"] = network_interface_id
            if private_ip_address is not None:
                self._values["private_ip_address"] = private_ip_address
            if private_ip_addresses is not None:
                self._values["private_ip_addresses"] = private_ip_addresses
            if secondary_private_ip_address_count is not None:
                self._values["secondary_private_ip_address_count"] = secondary_private_ip_address_count
            if subnet_id is not None:
                self._values["subnet_id"] = subnet_id

        @builtins.property
        def associate_carrier_ip_address(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether to assign a carrier IP address to the network interface.

            You can only assign a carrier IP address to a network interface that is in a subnet in a Wavelength Zone. For more information about carrier IP addresses, see `Carrier IP address <https://docs.aws.amazon.com/wavelength/latest/developerguide/how-wavelengths-work.html#provider-owned-ip>`_ in the *AWS Wavelength Developer Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-associatecarrieripaddress
            '''
            result = self._values.get("associate_carrier_ip_address")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def associate_public_ip_address(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether to assign a public IPv4 address to an instance.

            Applies only if creating a network interface when launching an instance. The network interface must be the primary network interface. If launching into a default subnet, the default value is ``true`` .

            AWS charges for all public IPv4 addresses, including public IPv4 addresses associated with running instances and Elastic IP addresses. For more information, see the *Public IPv4 Address* tab on the `VPC pricing page <https://docs.aws.amazon.com/vpc/pricing/>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-associatepublicipaddress
            '''
            result = self._values.get("associate_public_ip_address")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def delete_on_termination(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether the network interface is deleted when the instance is terminated.

            Applies only if creating a network interface when launching an instance.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-deleteontermination
            '''
            result = self._values.get("delete_on_termination")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def description(self) -> typing.Optional[builtins.str]:
            '''The description of the network interface.

            Applies only if creating a network interface when launching an instance.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-description
            '''
            result = self._values.get("description")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def device_index(self) -> typing.Optional[builtins.str]:
            '''The position of the network interface in the attachment order.

            A primary network interface has a device index of 0.

            If you create a network interface when launching an instance, you must specify the device index.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-deviceindex
            '''
            result = self._values.get("device_index")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def ena_srd_specification(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.EnaSrdSpecificationProperty"]]:
            '''Configures ENA Express for UDP network traffic.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-enasrdspecification
            '''
            result = self._values.get("ena_srd_specification")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.EnaSrdSpecificationProperty"]], result)

        @builtins.property
        def group_set(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The IDs of the security groups for the network interface.

            Applies only if creating a network interface when launching an instance.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-groupset
            '''
            result = self._values.get("group_set")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def ipv6_address_count(self) -> typing.Optional[jsii.Number]:
            '''A number of IPv6 addresses to assign to the network interface.

            Amazon EC2 chooses the IPv6 addresses from the range of the subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-ipv6addresscount
            '''
            result = self._values.get("ipv6_address_count")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def ipv6_addresses(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.InstanceIpv6AddressProperty"]]]]:
            '''The IPv6 addresses to assign to the network interface.

            You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-ipv6addresses
            '''
            result = self._values.get("ipv6_addresses")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.InstanceIpv6AddressProperty"]]]], result)

        @builtins.property
        def network_interface_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the network interface, when attaching an existing network interface.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-networkinterfaceid
            '''
            result = self._values.get("network_interface_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def private_ip_address(self) -> typing.Optional[builtins.str]:
            '''The private IPv4 address of the network interface.

            Applies only if creating a network interface when launching an instance.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-privateipaddress
            '''
            result = self._values.get("private_ip_address")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def private_ip_addresses(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.PrivateIpAddressSpecificationProperty"]]]]:
            '''One or more private IPv4 addresses to assign to the network interface.

            Only one private IPv4 address can be designated as primary.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-privateipaddresses
            '''
            result = self._values.get("private_ip_addresses")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.PrivateIpAddressSpecificationProperty"]]]], result)

        @builtins.property
        def secondary_private_ip_address_count(self) -> typing.Optional[jsii.Number]:
            '''The number of secondary private IPv4 addresses.

            You can't specify this option and specify more than one private IP address using the private IP addresses option.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-secondaryprivateipaddresscount
            '''
            result = self._values.get("secondary_private_ip_address_count")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def subnet_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the subnet associated with the network interface.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-networkinterface.html#cfn-ec2-instance-networkinterface-subnetid
            '''
            result = self._values.get("subnet_id")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "NetworkInterfaceProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnInstancePropsMixin.NoDeviceProperty",
        jsii_struct_bases=[],
        name_mapping={},
    )
    class NoDeviceProperty:
        def __init__(self) -> None:
            '''
            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-nodevice.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                no_device_property = ec2_mixins.CfnInstancePropsMixin.NoDeviceProperty()
            '''
            self._values: typing.Dict[builtins.str, typing.Any] = {}

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "NoDeviceProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnInstancePropsMixin.PrivateDnsNameOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "enable_resource_name_dns_aaaa_record": "enableResourceNameDnsAaaaRecord",
            "enable_resource_name_dns_a_record": "enableResourceNameDnsARecord",
            "hostname_type": "hostnameType",
        },
    )
    class PrivateDnsNameOptionsProperty:
        def __init__(
            self,
            *,
            enable_resource_name_dns_aaaa_record: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            enable_resource_name_dns_a_record: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            hostname_type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The type of hostnames to assign to instances in the subnet at launch.

            For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. For more information, see `Amazon EC2 instance hostname types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .

            :param enable_resource_name_dns_aaaa_record: Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records. For more information, see `Amazon EC2 instance hostname types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .
            :param enable_resource_name_dns_a_record: Indicates whether to respond to DNS queries for instance hostnames with DNS A records. For more information, see `Amazon EC2 instance hostname types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .
            :param hostname_type: The type of hostnames to assign to instances in the subnet at launch. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. For more information, see `Amazon EC2 instance hostname types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                private_dns_name_options_property = ec2_mixins.CfnInstancePropsMixin.PrivateDnsNameOptionsProperty(
                    enable_resource_name_dns_aaaa_record=False,
                    enable_resource_name_dns_aRecord=False,
                    hostname_type="hostnameType"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__c963de002d1038e2a839e73de9ecaf1329e7793b399ce49a5c082daa09d18295)
                check_type(argname="argument enable_resource_name_dns_aaaa_record", value=enable_resource_name_dns_aaaa_record, expected_type=type_hints["enable_resource_name_dns_aaaa_record"])
                check_type(argname="argument enable_resource_name_dns_a_record", value=enable_resource_name_dns_a_record, expected_type=type_hints["enable_resource_name_dns_a_record"])
                check_type(argname="argument hostname_type", value=hostname_type, expected_type=type_hints["hostname_type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if enable_resource_name_dns_aaaa_record is not None:
                self._values["enable_resource_name_dns_aaaa_record"] = enable_resource_name_dns_aaaa_record
            if enable_resource_name_dns_a_record is not None:
                self._values["enable_resource_name_dns_a_record"] = enable_resource_name_dns_a_record
            if hostname_type is not None:
                self._values["hostname_type"] = hostname_type

        @builtins.property
        def enable_resource_name_dns_aaaa_record(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.

            For more information, see `Amazon EC2 instance hostname types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-enableresourcenamednsaaaarecord
            '''
            result = self._values.get("enable_resource_name_dns_aaaa_record")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def enable_resource_name_dns_a_record(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether to respond to DNS queries for instance hostnames with DNS A records.

            For more information, see `Amazon EC2 instance hostname types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-enableresourcenamednsarecord
            '''
            result = self._values.get("enable_resource_name_dns_a_record")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def hostname_type(self) -> typing.Optional[builtins.str]:
            '''The type of hostnames to assign to instances in the subnet at launch.

            For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. For more information, see `Amazon EC2 instance hostname types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-hostnametype
            '''
            result = self._values.get("hostname_type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PrivateDnsNameOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnInstancePropsMixin.PrivateIpAddressSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={"primary": "primary", "private_ip_address": "privateIpAddress"},
    )
    class PrivateIpAddressSpecificationProperty:
        def __init__(
            self,
            *,
            primary: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            private_ip_address: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies a secondary private IPv4 address for a network interface.

            :param primary: Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.
            :param private_ip_address: The private IPv4 address.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privateipaddressspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                private_ip_address_specification_property = ec2_mixins.CfnInstancePropsMixin.PrivateIpAddressSpecificationProperty(
                    primary=False,
                    private_ip_address="privateIpAddress"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__3950ffc687313fadddd795671e7dc59044e01cbbb4093f63761934294caf8fcc)
                check_type(argname="argument primary", value=primary, expected_type=type_hints["primary"])
                check_type(argname="argument private_ip_address", value=private_ip_address, expected_type=type_hints["private_ip_address"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if primary is not None:
                self._values["primary"] = primary
            if private_ip_address is not None:
                self._values["private_ip_address"] = private_ip_address

        @builtins.property
        def primary(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether the private IPv4 address is the primary private IPv4 address.

            Only one IPv4 address can be designated as primary.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privateipaddressspecification.html#cfn-ec2-instance-privateipaddressspecification-primary
            '''
            result = self._values.get("primary")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def private_ip_address(self) -> typing.Optional[builtins.str]:
            '''The private IPv4 address.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privateipaddressspecification.html#cfn-ec2-instance-privateipaddressspecification-privateipaddress
            '''
            result = self._values.get("private_ip_address")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PrivateIpAddressSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnInstancePropsMixin.SsmAssociationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "association_parameters": "associationParameters",
            "document_name": "documentName",
        },
    )
    class SsmAssociationProperty:
        def __init__(
            self,
            *,
            association_parameters: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnInstancePropsMixin.AssociationParameterProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            document_name: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies the SSM document and parameter values in AWS Systems Manager to associate with an instance.

            ``SsmAssociations`` is a property of the `AWS::EC2::Instance <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html>`_ resource.

            :param association_parameters: The input parameter values to use with the associated SSM document.
            :param document_name: The name of an SSM document to associate with the instance.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                ssm_association_property = ec2_mixins.CfnInstancePropsMixin.SsmAssociationProperty(
                    association_parameters=[ec2_mixins.CfnInstancePropsMixin.AssociationParameterProperty(
                        key="key",
                        value=["value"]
                    )],
                    document_name="documentName"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__230c4541f1a13df62bcf6a21332f91a2059b2e0d1e6f601ba61ed1900ac45378)
                check_type(argname="argument association_parameters", value=association_parameters, expected_type=type_hints["association_parameters"])
                check_type(argname="argument document_name", value=document_name, expected_type=type_hints["document_name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if association_parameters is not None:
                self._values["association_parameters"] = association_parameters
            if document_name is not None:
                self._values["document_name"] = document_name

        @builtins.property
        def association_parameters(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.AssociationParameterProperty"]]]]:
            '''The input parameter values to use with the associated SSM document.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-associationparameters
            '''
            result = self._values.get("association_parameters")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnInstancePropsMixin.AssociationParameterProperty"]]]], result)

        @builtins.property
        def document_name(self) -> typing.Optional[builtins.str]:
            '''The name of an SSM document to associate with the instance.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociation.html#cfn-ec2-instance-ssmassociation-documentname
            '''
            result = self._values.get("document_name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SsmAssociationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnInstancePropsMixin.StateProperty",
        jsii_struct_bases=[],
        name_mapping={"code": "code", "name": "name"},
    )
    class StateProperty:
        def __init__(
            self,
            *,
            code: typing.Optional[builtins.str] = None,
            name: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes the current state of an instance.

            :param code: The state of the instance as a 16-bit unsigned integer. The high byte is all of the bits between 2^8 and (2^16)-1, which equals decimal values between 256 and 65,535. These numerical values are used for internal purposes and should be ignored. The low byte is all of the bits between 2^0 and (2^8)-1, which equals decimal values between 0 and 255. The valid values for instance-state-code will all be in the range of the low byte and they are: - ``0`` : ``pending`` - ``16`` : ``running`` - ``32`` : ``shutting-down`` - ``48`` : ``terminated`` - ``64`` : ``stopping`` - ``80`` : ``stopped`` You can ignore the high byte value by zeroing out all of the bits above 2^8 or 256 in decimal.
            :param name: The current state of the instance.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-state.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                state_property = ec2_mixins.CfnInstancePropsMixin.StateProperty(
                    code="code",
                    name="name"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__7eee5d3fb54208b57ca466d4f022582b9a31b4d66b3a38fa3317f308e1495945)
                check_type(argname="argument code", value=code, expected_type=type_hints["code"])
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if code is not None:
                self._values["code"] = code
            if name is not None:
                self._values["name"] = name

        @builtins.property
        def code(self) -> typing.Optional[builtins.str]:
            '''The state of the instance as a 16-bit unsigned integer.

            The high byte is all of the bits between 2^8 and (2^16)-1, which equals decimal values between 256 and 65,535. These numerical values are used for internal purposes and should be ignored.

            The low byte is all of the bits between 2^0 and (2^8)-1, which equals decimal values between 0 and 255.

            The valid values for instance-state-code will all be in the range of the low byte and they are:

            - ``0`` : ``pending``
            - ``16`` : ``running``
            - ``32`` : ``shutting-down``
            - ``48`` : ``terminated``
            - ``64`` : ``stopping``
            - ``80`` : ``stopped``

            You can ignore the high byte value by zeroing out all of the bits above 2^8 or 256 in decimal.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-state.html#cfn-ec2-instance-state-code
            '''
            result = self._values.get("code")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def name(self) -> typing.Optional[builtins.str]:
            '''The current state of the instance.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-state.html#cfn-ec2-instance-state-name
            '''
            result = self._values.get("name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "StateProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnInstancePropsMixin.VolumeProperty",
        jsii_struct_bases=[],
        name_mapping={"device": "device", "volume_id": "volumeId"},
    )
    class VolumeProperty:
        def __init__(
            self,
            *,
            device: typing.Optional[builtins.str] = None,
            volume_id: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies a volume to attach to an instance.

            ``Volume`` is an embedded property of the `AWS::EC2::Instance <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html>`_ resource.

            :param device: The device name (for example, ``/dev/sdh`` or ``xvdh`` ).
            :param volume_id: The ID of the EBS volume. The volume and instance must be within the same Availability Zone.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                volume_property = ec2_mixins.CfnInstancePropsMixin.VolumeProperty(
                    device="device",
                    volume_id="volumeId"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__8a772932780cd0d2d231f5ea2e03d87078083905b254ff39c37eceeb79ce1d39)
                check_type(argname="argument device", value=device, expected_type=type_hints["device"])
                check_type(argname="argument volume_id", value=volume_id, expected_type=type_hints["volume_id"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if device is not None:
                self._values["device"] = device
            if volume_id is not None:
                self._values["volume_id"] = volume_id

        @builtins.property
        def device(self) -> typing.Optional[builtins.str]:
            '''The device name (for example, ``/dev/sdh`` or ``xvdh`` ).

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-device
            '''
            result = self._values.get("device")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def volume_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the EBS volume.

            The volume and instance must be within the same Availability Zone.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-volume.html#cfn-ec2-instance-volume-volumeid
            '''
            result = self._values.get("volume_id")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "VolumeProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnInternetGatewayMixinProps",
    jsii_struct_bases=[],
    name_mapping={"tags": "tags"},
)
class CfnInternetGatewayMixinProps:
    def __init__(
        self,
        *,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnInternetGatewayPropsMixin.

        :param tags: Any tags to assign to the internet gateway.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-internetgateway.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_internet_gateway_mixin_props = ec2_mixins.CfnInternetGatewayMixinProps(
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__47f9ff446e0773ea7c53167d151a4d36bb1cfdb19e08f49123cc45589bf243cc)
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''Any tags to assign to the internet gateway.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-internetgateway.html#cfn-ec2-internetgateway-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnInternetGatewayMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnInternetGatewayPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnInternetGatewayPropsMixin",
):
    '''Allocates an internet gateway for use with a VPC.

    After creating the Internet gateway, you then attach it to a VPC.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-internetgateway.html
    :cloudformationResource: AWS::EC2::InternetGateway
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_internet_gateway_props_mixin = ec2_mixins.CfnInternetGatewayPropsMixin(ec2_mixins.CfnInternetGatewayMixinProps(
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnInternetGatewayMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::InternetGateway``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3611eefc37dee1499ae28e8ef336e08855039f77a6d154eec76fb9863a871030)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__933a1291f4a4fb33d0effbc64a1adb042d1370970b4497c74419922d494a9ccd)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1e713ff4bd3369c3853144c15ca67ec92e2f4aa6c5b0b23fc85b7fe75e04af53)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnInternetGatewayMixinProps":
        return typing.cast("CfnInternetGatewayMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnIpPoolRouteTableAssociationMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "public_ipv4_pool": "publicIpv4Pool",
        "route_table_id": "routeTableId",
    },
)
class CfnIpPoolRouteTableAssociationMixinProps:
    def __init__(
        self,
        *,
        public_ipv4_pool: typing.Optional[builtins.str] = None,
        route_table_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnIpPoolRouteTableAssociationPropsMixin.

        :param public_ipv4_pool: The ID of a public IPv4 address pool.
        :param route_table_id: The ID of a route table.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ippoolroutetableassociation.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_ip_pool_route_table_association_mixin_props = ec2_mixins.CfnIpPoolRouteTableAssociationMixinProps(
                public_ipv4_pool="publicIpv4Pool",
                route_table_id="routeTableId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7e1d262cf73d57822efef9c2bb8ccb6a5c02ddc50bfb1fbe0c5579cfdd9658e9)
            check_type(argname="argument public_ipv4_pool", value=public_ipv4_pool, expected_type=type_hints["public_ipv4_pool"])
            check_type(argname="argument route_table_id", value=route_table_id, expected_type=type_hints["route_table_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if public_ipv4_pool is not None:
            self._values["public_ipv4_pool"] = public_ipv4_pool
        if route_table_id is not None:
            self._values["route_table_id"] = route_table_id

    @builtins.property
    def public_ipv4_pool(self) -> typing.Optional[builtins.str]:
        '''The ID of a public IPv4 address pool.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ippoolroutetableassociation.html#cfn-ec2-ippoolroutetableassociation-publicipv4pool
        '''
        result = self._values.get("public_ipv4_pool")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def route_table_id(self) -> typing.Optional[builtins.str]:
        '''The ID of a route table.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ippoolroutetableassociation.html#cfn-ec2-ippoolroutetableassociation-routetableid
        '''
        result = self._values.get("route_table_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnIpPoolRouteTableAssociationMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnIpPoolRouteTableAssociationPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnIpPoolRouteTableAssociationPropsMixin",
):
    '''A route server association is the connection established between a route server and a VPC.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ippoolroutetableassociation.html
    :cloudformationResource: AWS::EC2::IpPoolRouteTableAssociation
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_ip_pool_route_table_association_props_mixin = ec2_mixins.CfnIpPoolRouteTableAssociationPropsMixin(ec2_mixins.CfnIpPoolRouteTableAssociationMixinProps(
            public_ipv4_pool="publicIpv4Pool",
            route_table_id="routeTableId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnIpPoolRouteTableAssociationMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::IpPoolRouteTableAssociation``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5a3a6368152db411210d096a94f9866442b7f67b62e65e49ed57bfe4ce065920)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__08cc2716570dc103400f6b6a4be98eb8c5b77f42adae015ceff35006be0f3679)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d2c0c14826668618044ad571183705b73d633c7d3826741a2afac8927a19982f)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnIpPoolRouteTableAssociationMixinProps":
        return typing.cast("CfnIpPoolRouteTableAssociationMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnKeyPairMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "key_format": "keyFormat",
        "key_name": "keyName",
        "key_type": "keyType",
        "public_key_material": "publicKeyMaterial",
        "tags": "tags",
    },
)
class CfnKeyPairMixinProps:
    def __init__(
        self,
        *,
        key_format: typing.Optional[builtins.str] = None,
        key_name: typing.Optional[builtins.str] = None,
        key_type: typing.Optional[builtins.str] = None,
        public_key_material: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnKeyPairPropsMixin.

        :param key_format: The format of the key pair. Default: ``pem`` Default: - "pem"
        :param key_name: A unique name for the key pair. Constraints: Up to 255 ASCII characters
        :param key_type: The type of key pair. Note that ED25519 keys are not supported for Windows instances. If the ``PublicKeyMaterial`` property is specified, the ``KeyType`` property is ignored, and the key type is inferred from the ``PublicKeyMaterial`` value. Default: ``rsa`` Default: - "rsa"
        :param public_key_material: The public key material. The ``PublicKeyMaterial`` property is used to import a key pair. If this property is not specified, then a new key pair will be created.
        :param tags: The tags to apply to the key pair.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-keypair.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_key_pair_mixin_props = ec2_mixins.CfnKeyPairMixinProps(
                key_format="keyFormat",
                key_name="keyName",
                key_type="keyType",
                public_key_material="publicKeyMaterial",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__44084727a7afd984ac91c9a5f2ad1398930af5930bf0601afc04fa100e0c4db9)
            check_type(argname="argument key_format", value=key_format, expected_type=type_hints["key_format"])
            check_type(argname="argument key_name", value=key_name, expected_type=type_hints["key_name"])
            check_type(argname="argument key_type", value=key_type, expected_type=type_hints["key_type"])
            check_type(argname="argument public_key_material", value=public_key_material, expected_type=type_hints["public_key_material"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key_format is not None:
            self._values["key_format"] = key_format
        if key_name is not None:
            self._values["key_name"] = key_name
        if key_type is not None:
            self._values["key_type"] = key_type
        if public_key_material is not None:
            self._values["public_key_material"] = public_key_material
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def key_format(self) -> typing.Optional[builtins.str]:
        '''The format of the key pair.

        Default: ``pem``

        :default: - "pem"

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-keypair.html#cfn-ec2-keypair-keyformat
        '''
        result = self._values.get("key_format")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key_name(self) -> typing.Optional[builtins.str]:
        '''A unique name for the key pair.

        Constraints: Up to 255 ASCII characters

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-keypair.html#cfn-ec2-keypair-keyname
        '''
        result = self._values.get("key_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key_type(self) -> typing.Optional[builtins.str]:
        '''The type of key pair. Note that ED25519 keys are not supported for Windows instances.

        If the ``PublicKeyMaterial`` property is specified, the ``KeyType`` property is ignored, and the key type is inferred from the ``PublicKeyMaterial`` value.

        Default: ``rsa``

        :default: - "rsa"

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-keypair.html#cfn-ec2-keypair-keytype
        '''
        result = self._values.get("key_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def public_key_material(self) -> typing.Optional[builtins.str]:
        '''The public key material.

        The ``PublicKeyMaterial`` property is used to import a key pair. If this property is not specified, then a new key pair will be created.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-keypair.html#cfn-ec2-keypair-publickeymaterial
        '''
        result = self._values.get("public_key_material")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags to apply to the key pair.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-keypair.html#cfn-ec2-keypair-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnKeyPairMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnKeyPairPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnKeyPairPropsMixin",
):
    '''Specifies a key pair for use with an Amazon Elastic Compute Cloud instance as follows:.

    - To import an existing key pair, include the ``PublicKeyMaterial`` property.
    - To create a new key pair, omit the ``PublicKeyMaterial`` property.

    When you import an existing key pair, you specify the public key material for the key. We assume that you have the private key material for the key. AWS CloudFormation does not create or return the private key material when you import a key pair.

    When you create a new key pair, the private key is saved to AWS Systems Manager Parameter Store, using a parameter with the following name: ``/ec2/keypair/{key_pair_id}`` . For more information about retrieving private key, and the required permissions, see `Create a key pair using CloudFormation <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/create-key-pairs.html#create-key-pair-cloudformation>`_ in the *Amazon EC2 User Guide* .

    When CloudFormation deletes a key pair that was created or imported by a stack, it also deletes the parameter that was used to store the private key material in Parameter Store.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-keypair.html
    :cloudformationResource: AWS::EC2::KeyPair
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_key_pair_props_mixin = ec2_mixins.CfnKeyPairPropsMixin(ec2_mixins.CfnKeyPairMixinProps(
            key_format="keyFormat",
            key_name="keyName",
            key_type="keyType",
            public_key_material="publicKeyMaterial",
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnKeyPairMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::KeyPair``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b1075277d980fa20a4e5e5e15e4ba5615d28932842c45691b4348dcb4f5af566)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__358d345640a2ee47e0bcdb2510b1790c5b1293c97daa86ae1670a6cdcc5513c9)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__325448334e7b50ddf9ddf2a57c13e74d11ce7e528cca34de6ba84f7955d78320)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnKeyPairMixinProps":
        return typing.cast("CfnKeyPairMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplateMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "launch_template_data": "launchTemplateData",
        "launch_template_name": "launchTemplateName",
        "tag_specifications": "tagSpecifications",
        "version_description": "versionDescription",
    },
)
class CfnLaunchTemplateMixinProps:
    def __init__(
        self,
        *,
        launch_template_data: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.LaunchTemplateDataProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        launch_template_name: typing.Optional[builtins.str] = None,
        tag_specifications: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.LaunchTemplateTagSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        version_description: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnLaunchTemplatePropsMixin.

        :param launch_template_data: The information for the launch template.
        :param launch_template_name: A name for the launch template.
        :param tag_specifications: The tags to apply to the launch template on creation. To tag the launch template, the resource type must be ``launch-template`` . To specify the tags for resources that are created during instance launch, use `TagSpecifications <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-tagspecifications>`_ .
        :param version_description: A description for the first version of the launch template.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag, CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_launch_template_mixin_props = ec2_mixins.CfnLaunchTemplateMixinProps(
                launch_template_data=ec2_mixins.CfnLaunchTemplatePropsMixin.LaunchTemplateDataProperty(
                    block_device_mappings=[ec2_mixins.CfnLaunchTemplatePropsMixin.BlockDeviceMappingProperty(
                        device_name="deviceName",
                        ebs=ec2_mixins.CfnLaunchTemplatePropsMixin.EbsProperty(
                            delete_on_termination=False,
                            encrypted=False,
                            iops=123,
                            kms_key_id="kmsKeyId",
                            snapshot_id="snapshotId",
                            throughput=123,
                            volume_initialization_rate=123,
                            volume_size=123,
                            volume_type="volumeType"
                        ),
                        no_device="noDevice",
                        virtual_name="virtualName"
                    )],
                    capacity_reservation_specification=ec2_mixins.CfnLaunchTemplatePropsMixin.CapacityReservationSpecificationProperty(
                        capacity_reservation_preference="capacityReservationPreference",
                        capacity_reservation_target=ec2_mixins.CfnLaunchTemplatePropsMixin.CapacityReservationTargetProperty(
                            capacity_reservation_id="capacityReservationId",
                            capacity_reservation_resource_group_arn="capacityReservationResourceGroupArn"
                        )
                    ),
                    cpu_options=ec2_mixins.CfnLaunchTemplatePropsMixin.CpuOptionsProperty(
                        amd_sev_snp="amdSevSnp",
                        core_count=123,
                        threads_per_core=123
                    ),
                    credit_specification=ec2_mixins.CfnLaunchTemplatePropsMixin.CreditSpecificationProperty(
                        cpu_credits="cpuCredits"
                    ),
                    disable_api_stop=False,
                    disable_api_termination=False,
                    ebs_optimized=False,
                    elastic_gpu_specifications=[ec2_mixins.CfnLaunchTemplatePropsMixin.ElasticGpuSpecificationProperty(
                        type="type"
                    )],
                    elastic_inference_accelerators=[ec2_mixins.CfnLaunchTemplatePropsMixin.LaunchTemplateElasticInferenceAcceleratorProperty(
                        count=123,
                        type="type"
                    )],
                    enclave_options=ec2_mixins.CfnLaunchTemplatePropsMixin.EnclaveOptionsProperty(
                        enabled=False
                    ),
                    hibernation_options=ec2_mixins.CfnLaunchTemplatePropsMixin.HibernationOptionsProperty(
                        configured=False
                    ),
                    iam_instance_profile=ec2_mixins.CfnLaunchTemplatePropsMixin.IamInstanceProfileProperty(
                        arn="arn",
                        name="name"
                    ),
                    image_id="imageId",
                    instance_initiated_shutdown_behavior="instanceInitiatedShutdownBehavior",
                    instance_market_options=ec2_mixins.CfnLaunchTemplatePropsMixin.InstanceMarketOptionsProperty(
                        market_type="marketType",
                        spot_options=ec2_mixins.CfnLaunchTemplatePropsMixin.SpotOptionsProperty(
                            block_duration_minutes=123,
                            instance_interruption_behavior="instanceInterruptionBehavior",
                            max_price="maxPrice",
                            spot_instance_type="spotInstanceType",
                            valid_until="validUntil"
                        )
                    ),
                    instance_requirements=ec2_mixins.CfnLaunchTemplatePropsMixin.InstanceRequirementsProperty(
                        accelerator_count=ec2_mixins.CfnLaunchTemplatePropsMixin.AcceleratorCountProperty(
                            max=123,
                            min=123
                        ),
                        accelerator_manufacturers=["acceleratorManufacturers"],
                        accelerator_names=["acceleratorNames"],
                        accelerator_total_memory_mi_b=ec2_mixins.CfnLaunchTemplatePropsMixin.AcceleratorTotalMemoryMiBProperty(
                            max=123,
                            min=123
                        ),
                        accelerator_types=["acceleratorTypes"],
                        allowed_instance_types=["allowedInstanceTypes"],
                        bare_metal="bareMetal",
                        baseline_ebs_bandwidth_mbps=ec2_mixins.CfnLaunchTemplatePropsMixin.BaselineEbsBandwidthMbpsProperty(
                            max=123,
                            min=123
                        ),
                        baseline_performance_factors=ec2_mixins.CfnLaunchTemplatePropsMixin.BaselinePerformanceFactorsProperty(
                            cpu=ec2_mixins.CfnLaunchTemplatePropsMixin.CpuProperty(
                                references=[ec2_mixins.CfnLaunchTemplatePropsMixin.ReferenceProperty(
                                    instance_family="instanceFamily"
                                )]
                            )
                        ),
                        burstable_performance="burstablePerformance",
                        cpu_manufacturers=["cpuManufacturers"],
                        excluded_instance_types=["excludedInstanceTypes"],
                        instance_generations=["instanceGenerations"],
                        local_storage="localStorage",
                        local_storage_types=["localStorageTypes"],
                        max_spot_price_as_percentage_of_optimal_on_demand_price=123,
                        memory_gi_bPer_vCpu=ec2_mixins.CfnLaunchTemplatePropsMixin.MemoryGiBPerVCpuProperty(
                            max=123,
                            min=123
                        ),
                        memory_mi_b=ec2_mixins.CfnLaunchTemplatePropsMixin.MemoryMiBProperty(
                            max=123,
                            min=123
                        ),
                        network_bandwidth_gbps=ec2_mixins.CfnLaunchTemplatePropsMixin.NetworkBandwidthGbpsProperty(
                            max=123,
                            min=123
                        ),
                        network_interface_count=ec2_mixins.CfnLaunchTemplatePropsMixin.NetworkInterfaceCountProperty(
                            max=123,
                            min=123
                        ),
                        on_demand_max_price_percentage_over_lowest_price=123,
                        require_hibernate_support=False,
                        spot_max_price_percentage_over_lowest_price=123,
                        total_local_storage_gb=ec2_mixins.CfnLaunchTemplatePropsMixin.TotalLocalStorageGBProperty(
                            max=123,
                            min=123
                        ),
                        v_cpu_count=ec2_mixins.CfnLaunchTemplatePropsMixin.VCpuCountProperty(
                            max=123,
                            min=123
                        )
                    ),
                    instance_type="instanceType",
                    kernel_id="kernelId",
                    key_name="keyName",
                    license_specifications=[ec2_mixins.CfnLaunchTemplatePropsMixin.LicenseSpecificationProperty(
                        license_configuration_arn="licenseConfigurationArn"
                    )],
                    maintenance_options=ec2_mixins.CfnLaunchTemplatePropsMixin.MaintenanceOptionsProperty(
                        auto_recovery="autoRecovery"
                    ),
                    metadata_options=ec2_mixins.CfnLaunchTemplatePropsMixin.MetadataOptionsProperty(
                        http_endpoint="httpEndpoint",
                        http_protocol_ipv6="httpProtocolIpv6",
                        http_put_response_hop_limit=123,
                        http_tokens="httpTokens",
                        instance_metadata_tags="instanceMetadataTags"
                    ),
                    monitoring=ec2_mixins.CfnLaunchTemplatePropsMixin.MonitoringProperty(
                        enabled=False
                    ),
                    network_interfaces=[ec2_mixins.CfnLaunchTemplatePropsMixin.NetworkInterfaceProperty(
                        associate_carrier_ip_address=False,
                        associate_public_ip_address=False,
                        connection_tracking_specification=ec2_mixins.CfnLaunchTemplatePropsMixin.ConnectionTrackingSpecificationProperty(
                            tcp_established_timeout=123,
                            udp_stream_timeout=123,
                            udp_timeout=123
                        ),
                        delete_on_termination=False,
                        description="description",
                        device_index=123,
                        ena_queue_count=123,
                        ena_srd_specification=ec2_mixins.CfnLaunchTemplatePropsMixin.EnaSrdSpecificationProperty(
                            ena_srd_enabled=False,
                            ena_srd_udp_specification=ec2_mixins.CfnLaunchTemplatePropsMixin.EnaSrdUdpSpecificationProperty(
                                ena_srd_udp_enabled=False
                            )
                        ),
                        groups=["groups"],
                        interface_type="interfaceType",
                        ipv4_prefix_count=123,
                        ipv4_prefixes=[ec2_mixins.CfnLaunchTemplatePropsMixin.Ipv4PrefixSpecificationProperty(
                            ipv4_prefix="ipv4Prefix"
                        )],
                        ipv6_address_count=123,
                        ipv6_addresses=[ec2_mixins.CfnLaunchTemplatePropsMixin.Ipv6AddProperty(
                            ipv6_address="ipv6Address"
                        )],
                        ipv6_prefix_count=123,
                        ipv6_prefixes=[ec2_mixins.CfnLaunchTemplatePropsMixin.Ipv6PrefixSpecificationProperty(
                            ipv6_prefix="ipv6Prefix"
                        )],
                        network_card_index=123,
                        network_interface_id="networkInterfaceId",
                        primary_ipv6=False,
                        private_ip_address="privateIpAddress",
                        private_ip_addresses=[ec2_mixins.CfnLaunchTemplatePropsMixin.PrivateIpAddProperty(
                            primary=False,
                            private_ip_address="privateIpAddress"
                        )],
                        secondary_private_ip_address_count=123,
                        subnet_id="subnetId"
                    )],
                    network_performance_options=ec2_mixins.CfnLaunchTemplatePropsMixin.NetworkPerformanceOptionsProperty(
                        bandwidth_weighting="bandwidthWeighting"
                    ),
                    placement=ec2_mixins.CfnLaunchTemplatePropsMixin.PlacementProperty(
                        affinity="affinity",
                        availability_zone="availabilityZone",
                        group_id="groupId",
                        group_name="groupName",
                        host_id="hostId",
                        host_resource_group_arn="hostResourceGroupArn",
                        partition_number=123,
                        spread_domain="spreadDomain",
                        tenancy="tenancy"
                    ),
                    private_dns_name_options=ec2_mixins.CfnLaunchTemplatePropsMixin.PrivateDnsNameOptionsProperty(
                        enable_resource_name_dns_aaaa_record=False,
                        enable_resource_name_dns_aRecord=False,
                        hostname_type="hostnameType"
                    ),
                    ram_disk_id="ramDiskId",
                    security_group_ids=["securityGroupIds"],
                    security_groups=["securityGroups"],
                    tag_specifications=[ec2_mixins.CfnLaunchTemplatePropsMixin.TagSpecificationProperty(
                        resource_type="resourceType",
                        tags=[CfnTag(
                            key="key",
                            value="value"
                        )]
                    )],
                    user_data="userData"
                ),
                launch_template_name="launchTemplateName",
                tag_specifications=[ec2_mixins.CfnLaunchTemplatePropsMixin.LaunchTemplateTagSpecificationProperty(
                    resource_type="resourceType",
                    tags=[CfnTag(
                        key="key",
                        value="value"
                    )]
                )],
                version_description="versionDescription"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9d4e2ace3d1dda2cdb3eed9e998ebd7a384bf2841519b72ebd095f58ba69958c)
            check_type(argname="argument launch_template_data", value=launch_template_data, expected_type=type_hints["launch_template_data"])
            check_type(argname="argument launch_template_name", value=launch_template_name, expected_type=type_hints["launch_template_name"])
            check_type(argname="argument tag_specifications", value=tag_specifications, expected_type=type_hints["tag_specifications"])
            check_type(argname="argument version_description", value=version_description, expected_type=type_hints["version_description"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if launch_template_data is not None:
            self._values["launch_template_data"] = launch_template_data
        if launch_template_name is not None:
            self._values["launch_template_name"] = launch_template_name
        if tag_specifications is not None:
            self._values["tag_specifications"] = tag_specifications
        if version_description is not None:
            self._values["version_description"] = version_description

    @builtins.property
    def launch_template_data(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.LaunchTemplateDataProperty"]]:
        '''The information for the launch template.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#cfn-ec2-launchtemplate-launchtemplatedata
        '''
        result = self._values.get("launch_template_data")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.LaunchTemplateDataProperty"]], result)

    @builtins.property
    def launch_template_name(self) -> typing.Optional[builtins.str]:
        '''A name for the launch template.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#cfn-ec2-launchtemplate-launchtemplatename
        '''
        result = self._values.get("launch_template_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tag_specifications(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.LaunchTemplateTagSpecificationProperty"]]]]:
        '''The tags to apply to the launch template on creation.

        To tag the launch template, the resource type must be ``launch-template`` .

        To specify the tags for resources that are created during instance launch, use `TagSpecifications <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-tagspecifications>`_ .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#cfn-ec2-launchtemplate-tagspecifications
        '''
        result = self._values.get("tag_specifications")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.LaunchTemplateTagSpecificationProperty"]]]], result)

    @builtins.property
    def version_description(self) -> typing.Optional[builtins.str]:
        '''A description for the first version of the launch template.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#cfn-ec2-launchtemplate-versiondescription
        '''
        result = self._values.get("version_description")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnLaunchTemplateMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnLaunchTemplatePropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin",
):
    '''Specifies the properties for creating a launch template.

    The minimum required properties for specifying a launch template are as follows:

    - You must specify at least one property for the launch template data.
    - You can optionally specify a name for the launch template. If you do not specify a name, CloudFormation creates a name for you.

    A launch template can contain some or all of the configuration information to launch an instance. When you launch an instance using a launch template, instance properties that are not specified in the launch template use default values, except the ``ImageId`` property, which has no default value. If you do not specify an AMI ID for the launch template ``ImageId`` property, you must specify an AMI ID for the instance ``ImageId`` property.

    For more information, see `Launch an instance from a launch template <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html>`_ in the *Amazon EC2 User Guide* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html
    :cloudformationResource: AWS::EC2::LaunchTemplate
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag, CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_launch_template_props_mixin = ec2_mixins.CfnLaunchTemplatePropsMixin(ec2_mixins.CfnLaunchTemplateMixinProps(
            launch_template_data=ec2_mixins.CfnLaunchTemplatePropsMixin.LaunchTemplateDataProperty(
                block_device_mappings=[ec2_mixins.CfnLaunchTemplatePropsMixin.BlockDeviceMappingProperty(
                    device_name="deviceName",
                    ebs=ec2_mixins.CfnLaunchTemplatePropsMixin.EbsProperty(
                        delete_on_termination=False,
                        encrypted=False,
                        iops=123,
                        kms_key_id="kmsKeyId",
                        snapshot_id="snapshotId",
                        throughput=123,
                        volume_initialization_rate=123,
                        volume_size=123,
                        volume_type="volumeType"
                    ),
                    no_device="noDevice",
                    virtual_name="virtualName"
                )],
                capacity_reservation_specification=ec2_mixins.CfnLaunchTemplatePropsMixin.CapacityReservationSpecificationProperty(
                    capacity_reservation_preference="capacityReservationPreference",
                    capacity_reservation_target=ec2_mixins.CfnLaunchTemplatePropsMixin.CapacityReservationTargetProperty(
                        capacity_reservation_id="capacityReservationId",
                        capacity_reservation_resource_group_arn="capacityReservationResourceGroupArn"
                    )
                ),
                cpu_options=ec2_mixins.CfnLaunchTemplatePropsMixin.CpuOptionsProperty(
                    amd_sev_snp="amdSevSnp",
                    core_count=123,
                    threads_per_core=123
                ),
                credit_specification=ec2_mixins.CfnLaunchTemplatePropsMixin.CreditSpecificationProperty(
                    cpu_credits="cpuCredits"
                ),
                disable_api_stop=False,
                disable_api_termination=False,
                ebs_optimized=False,
                elastic_gpu_specifications=[ec2_mixins.CfnLaunchTemplatePropsMixin.ElasticGpuSpecificationProperty(
                    type="type"
                )],
                elastic_inference_accelerators=[ec2_mixins.CfnLaunchTemplatePropsMixin.LaunchTemplateElasticInferenceAcceleratorProperty(
                    count=123,
                    type="type"
                )],
                enclave_options=ec2_mixins.CfnLaunchTemplatePropsMixin.EnclaveOptionsProperty(
                    enabled=False
                ),
                hibernation_options=ec2_mixins.CfnLaunchTemplatePropsMixin.HibernationOptionsProperty(
                    configured=False
                ),
                iam_instance_profile=ec2_mixins.CfnLaunchTemplatePropsMixin.IamInstanceProfileProperty(
                    arn="arn",
                    name="name"
                ),
                image_id="imageId",
                instance_initiated_shutdown_behavior="instanceInitiatedShutdownBehavior",
                instance_market_options=ec2_mixins.CfnLaunchTemplatePropsMixin.InstanceMarketOptionsProperty(
                    market_type="marketType",
                    spot_options=ec2_mixins.CfnLaunchTemplatePropsMixin.SpotOptionsProperty(
                        block_duration_minutes=123,
                        instance_interruption_behavior="instanceInterruptionBehavior",
                        max_price="maxPrice",
                        spot_instance_type="spotInstanceType",
                        valid_until="validUntil"
                    )
                ),
                instance_requirements=ec2_mixins.CfnLaunchTemplatePropsMixin.InstanceRequirementsProperty(
                    accelerator_count=ec2_mixins.CfnLaunchTemplatePropsMixin.AcceleratorCountProperty(
                        max=123,
                        min=123
                    ),
                    accelerator_manufacturers=["acceleratorManufacturers"],
                    accelerator_names=["acceleratorNames"],
                    accelerator_total_memory_mi_b=ec2_mixins.CfnLaunchTemplatePropsMixin.AcceleratorTotalMemoryMiBProperty(
                        max=123,
                        min=123
                    ),
                    accelerator_types=["acceleratorTypes"],
                    allowed_instance_types=["allowedInstanceTypes"],
                    bare_metal="bareMetal",
                    baseline_ebs_bandwidth_mbps=ec2_mixins.CfnLaunchTemplatePropsMixin.BaselineEbsBandwidthMbpsProperty(
                        max=123,
                        min=123
                    ),
                    baseline_performance_factors=ec2_mixins.CfnLaunchTemplatePropsMixin.BaselinePerformanceFactorsProperty(
                        cpu=ec2_mixins.CfnLaunchTemplatePropsMixin.CpuProperty(
                            references=[ec2_mixins.CfnLaunchTemplatePropsMixin.ReferenceProperty(
                                instance_family="instanceFamily"
                            )]
                        )
                    ),
                    burstable_performance="burstablePerformance",
                    cpu_manufacturers=["cpuManufacturers"],
                    excluded_instance_types=["excludedInstanceTypes"],
                    instance_generations=["instanceGenerations"],
                    local_storage="localStorage",
                    local_storage_types=["localStorageTypes"],
                    max_spot_price_as_percentage_of_optimal_on_demand_price=123,
                    memory_gi_bPer_vCpu=ec2_mixins.CfnLaunchTemplatePropsMixin.MemoryGiBPerVCpuProperty(
                        max=123,
                        min=123
                    ),
                    memory_mi_b=ec2_mixins.CfnLaunchTemplatePropsMixin.MemoryMiBProperty(
                        max=123,
                        min=123
                    ),
                    network_bandwidth_gbps=ec2_mixins.CfnLaunchTemplatePropsMixin.NetworkBandwidthGbpsProperty(
                        max=123,
                        min=123
                    ),
                    network_interface_count=ec2_mixins.CfnLaunchTemplatePropsMixin.NetworkInterfaceCountProperty(
                        max=123,
                        min=123
                    ),
                    on_demand_max_price_percentage_over_lowest_price=123,
                    require_hibernate_support=False,
                    spot_max_price_percentage_over_lowest_price=123,
                    total_local_storage_gb=ec2_mixins.CfnLaunchTemplatePropsMixin.TotalLocalStorageGBProperty(
                        max=123,
                        min=123
                    ),
                    v_cpu_count=ec2_mixins.CfnLaunchTemplatePropsMixin.VCpuCountProperty(
                        max=123,
                        min=123
                    )
                ),
                instance_type="instanceType",
                kernel_id="kernelId",
                key_name="keyName",
                license_specifications=[ec2_mixins.CfnLaunchTemplatePropsMixin.LicenseSpecificationProperty(
                    license_configuration_arn="licenseConfigurationArn"
                )],
                maintenance_options=ec2_mixins.CfnLaunchTemplatePropsMixin.MaintenanceOptionsProperty(
                    auto_recovery="autoRecovery"
                ),
                metadata_options=ec2_mixins.CfnLaunchTemplatePropsMixin.MetadataOptionsProperty(
                    http_endpoint="httpEndpoint",
                    http_protocol_ipv6="httpProtocolIpv6",
                    http_put_response_hop_limit=123,
                    http_tokens="httpTokens",
                    instance_metadata_tags="instanceMetadataTags"
                ),
                monitoring=ec2_mixins.CfnLaunchTemplatePropsMixin.MonitoringProperty(
                    enabled=False
                ),
                network_interfaces=[ec2_mixins.CfnLaunchTemplatePropsMixin.NetworkInterfaceProperty(
                    associate_carrier_ip_address=False,
                    associate_public_ip_address=False,
                    connection_tracking_specification=ec2_mixins.CfnLaunchTemplatePropsMixin.ConnectionTrackingSpecificationProperty(
                        tcp_established_timeout=123,
                        udp_stream_timeout=123,
                        udp_timeout=123
                    ),
                    delete_on_termination=False,
                    description="description",
                    device_index=123,
                    ena_queue_count=123,
                    ena_srd_specification=ec2_mixins.CfnLaunchTemplatePropsMixin.EnaSrdSpecificationProperty(
                        ena_srd_enabled=False,
                        ena_srd_udp_specification=ec2_mixins.CfnLaunchTemplatePropsMixin.EnaSrdUdpSpecificationProperty(
                            ena_srd_udp_enabled=False
                        )
                    ),
                    groups=["groups"],
                    interface_type="interfaceType",
                    ipv4_prefix_count=123,
                    ipv4_prefixes=[ec2_mixins.CfnLaunchTemplatePropsMixin.Ipv4PrefixSpecificationProperty(
                        ipv4_prefix="ipv4Prefix"
                    )],
                    ipv6_address_count=123,
                    ipv6_addresses=[ec2_mixins.CfnLaunchTemplatePropsMixin.Ipv6AddProperty(
                        ipv6_address="ipv6Address"
                    )],
                    ipv6_prefix_count=123,
                    ipv6_prefixes=[ec2_mixins.CfnLaunchTemplatePropsMixin.Ipv6PrefixSpecificationProperty(
                        ipv6_prefix="ipv6Prefix"
                    )],
                    network_card_index=123,
                    network_interface_id="networkInterfaceId",
                    primary_ipv6=False,
                    private_ip_address="privateIpAddress",
                    private_ip_addresses=[ec2_mixins.CfnLaunchTemplatePropsMixin.PrivateIpAddProperty(
                        primary=False,
                        private_ip_address="privateIpAddress"
                    )],
                    secondary_private_ip_address_count=123,
                    subnet_id="subnetId"
                )],
                network_performance_options=ec2_mixins.CfnLaunchTemplatePropsMixin.NetworkPerformanceOptionsProperty(
                    bandwidth_weighting="bandwidthWeighting"
                ),
                placement=ec2_mixins.CfnLaunchTemplatePropsMixin.PlacementProperty(
                    affinity="affinity",
                    availability_zone="availabilityZone",
                    group_id="groupId",
                    group_name="groupName",
                    host_id="hostId",
                    host_resource_group_arn="hostResourceGroupArn",
                    partition_number=123,
                    spread_domain="spreadDomain",
                    tenancy="tenancy"
                ),
                private_dns_name_options=ec2_mixins.CfnLaunchTemplatePropsMixin.PrivateDnsNameOptionsProperty(
                    enable_resource_name_dns_aaaa_record=False,
                    enable_resource_name_dns_aRecord=False,
                    hostname_type="hostnameType"
                ),
                ram_disk_id="ramDiskId",
                security_group_ids=["securityGroupIds"],
                security_groups=["securityGroups"],
                tag_specifications=[ec2_mixins.CfnLaunchTemplatePropsMixin.TagSpecificationProperty(
                    resource_type="resourceType",
                    tags=[CfnTag(
                        key="key",
                        value="value"
                    )]
                )],
                user_data="userData"
            ),
            launch_template_name="launchTemplateName",
            tag_specifications=[ec2_mixins.CfnLaunchTemplatePropsMixin.LaunchTemplateTagSpecificationProperty(
                resource_type="resourceType",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )],
            version_description="versionDescription"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnLaunchTemplateMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::LaunchTemplate``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5474e3e38d5f66f863bb62d766fb9883d5e434fa14f4a2b036ca02673d09e36a)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1086efa572fb90b1e8a5371fec8bd3173ce5362dcd14d33e7ffcd2d86697a101)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dffebb7c111a6e62f8933a3e3dcb2e99128dbf060170594752a76f24441af7fa)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnLaunchTemplateMixinProps":
        return typing.cast("CfnLaunchTemplateMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.AcceleratorCountProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class AcceleratorCountProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.

            :param max: The maximum number of accelerators. To specify no maximum limit, omit this parameter. To exclude accelerator-enabled instance types, set ``Max`` to ``0`` .
            :param min: The minimum number of accelerators. To specify no minimum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-acceleratorcount.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                accelerator_count_property = ec2_mixins.CfnLaunchTemplatePropsMixin.AcceleratorCountProperty(
                    max=123,
                    min=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__a2fa1ae5527e42a0a47cd8ec4f4510dd1d1ad17901ebab4244df9b602b9716c0)
                check_type(argname="argument max", value=max, expected_type=type_hints["max"])
                check_type(argname="argument min", value=min, expected_type=type_hints["min"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum number of accelerators.

            To specify no maximum limit, omit this parameter. To exclude accelerator-enabled instance types, set ``Max`` to ``0`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-acceleratorcount.html#cfn-ec2-launchtemplate-acceleratorcount-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum number of accelerators.

            To specify no minimum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-acceleratorcount.html#cfn-ec2-launchtemplate-acceleratorcount-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AcceleratorCountProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.AcceleratorTotalMemoryMiBProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class AcceleratorTotalMemoryMiBProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum amount of total accelerator memory, in MiB.

            :param max: The maximum amount of accelerator memory, in MiB. To specify no maximum limit, omit this parameter.
            :param min: The minimum amount of accelerator memory, in MiB. To specify no minimum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-acceleratortotalmemorymib.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                accelerator_total_memory_mi_bProperty = ec2_mixins.CfnLaunchTemplatePropsMixin.AcceleratorTotalMemoryMiBProperty(
                    max=123,
                    min=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__b11c354bb962a95f0c98bed1b78237d9e7e1bf5109490a72e2278633468dc040)
                check_type(argname="argument max", value=max, expected_type=type_hints["max"])
                check_type(argname="argument min", value=min, expected_type=type_hints["min"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum amount of accelerator memory, in MiB.

            To specify no maximum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-acceleratortotalmemorymib.html#cfn-ec2-launchtemplate-acceleratortotalmemorymib-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum amount of accelerator memory, in MiB.

            To specify no minimum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-acceleratortotalmemorymib.html#cfn-ec2-launchtemplate-acceleratortotalmemorymib-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AcceleratorTotalMemoryMiBProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.BaselineEbsBandwidthMbpsProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class BaselineEbsBandwidthMbpsProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps.

            For more information, see `Amazon EBSoptimized instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html>`_ in the *Amazon EC2 User Guide* .

            :param max: The maximum baseline bandwidth, in Mbps. To specify no maximum limit, omit this parameter.
            :param min: The minimum baseline bandwidth, in Mbps. To specify no minimum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-baselineebsbandwidthmbps.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                baseline_ebs_bandwidth_mbps_property = ec2_mixins.CfnLaunchTemplatePropsMixin.BaselineEbsBandwidthMbpsProperty(
                    max=123,
                    min=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__f4bfc277d85c54d67239ebe4480a8a6c4f389281ecbb1a8af17d291d8dbfcf78)
                check_type(argname="argument max", value=max, expected_type=type_hints["max"])
                check_type(argname="argument min", value=min, expected_type=type_hints["min"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum baseline bandwidth, in Mbps.

            To specify no maximum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-baselineebsbandwidthmbps.html#cfn-ec2-launchtemplate-baselineebsbandwidthmbps-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum baseline bandwidth, in Mbps.

            To specify no minimum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-baselineebsbandwidthmbps.html#cfn-ec2-launchtemplate-baselineebsbandwidthmbps-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "BaselineEbsBandwidthMbpsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.BaselinePerformanceFactorsProperty",
        jsii_struct_bases=[],
        name_mapping={"cpu": "cpu"},
    )
    class BaselinePerformanceFactorsProperty:
        def __init__(
            self,
            *,
            cpu: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.CpuProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''The baseline performance to consider, using an instance family as a baseline reference.

            The instance family establishes the lowest acceptable level of performance. Amazon EC2 uses this baseline to guide instance type selection, but there is no guarantee that the selected instance types will always exceed the baseline for every application.

            Currently, this parameter only supports CPU performance as a baseline performance factor. For example, specifying ``c6i`` would use the CPU performance of the ``c6i`` family as the baseline reference.

            :param cpu: The CPU performance to consider, using an instance family as the baseline reference.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-baselineperformancefactors.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                baseline_performance_factors_property = ec2_mixins.CfnLaunchTemplatePropsMixin.BaselinePerformanceFactorsProperty(
                    cpu=ec2_mixins.CfnLaunchTemplatePropsMixin.CpuProperty(
                        references=[ec2_mixins.CfnLaunchTemplatePropsMixin.ReferenceProperty(
                            instance_family="instanceFamily"
                        )]
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__248e62961218a521f45cb7f596aa7c953f6df656044176ed63094b5f9f3515e0)
                check_type(argname="argument cpu", value=cpu, expected_type=type_hints["cpu"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if cpu is not None:
                self._values["cpu"] = cpu

        @builtins.property
        def cpu(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.CpuProperty"]]:
            '''The CPU performance to consider, using an instance family as the baseline reference.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-baselineperformancefactors.html#cfn-ec2-launchtemplate-baselineperformancefactors-cpu
            '''
            result = self._values.get("cpu")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.CpuProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "BaselinePerformanceFactorsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.BlockDeviceMappingProperty",
        jsii_struct_bases=[],
        name_mapping={
            "device_name": "deviceName",
            "ebs": "ebs",
            "no_device": "noDevice",
            "virtual_name": "virtualName",
        },
    )
    class BlockDeviceMappingProperty:
        def __init__(
            self,
            *,
            device_name: typing.Optional[builtins.str] = None,
            ebs: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.EbsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            no_device: typing.Optional[builtins.str] = None,
            virtual_name: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies a block device mapping for a launch template.

            You must specify ``DeviceName`` plus exactly one of the following properties: ``Ebs`` , ``NoDevice`` , or ``VirtualName`` .

            ``BlockDeviceMapping`` is a property of `AWS::EC2::LaunchTemplate LaunchTemplateData <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html>`_ .

            :param device_name: The device name (for example, /dev/sdh or xvdh).
            :param ebs: Parameters used to automatically set up EBS volumes when the instance is launched.
            :param no_device: To omit the device from the block device mapping, specify an empty string.
            :param virtual_name: The virtual device name (ephemeralN). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for ephemeral0 and ephemeral1. The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                block_device_mapping_property = ec2_mixins.CfnLaunchTemplatePropsMixin.BlockDeviceMappingProperty(
                    device_name="deviceName",
                    ebs=ec2_mixins.CfnLaunchTemplatePropsMixin.EbsProperty(
                        delete_on_termination=False,
                        encrypted=False,
                        iops=123,
                        kms_key_id="kmsKeyId",
                        snapshot_id="snapshotId",
                        throughput=123,
                        volume_initialization_rate=123,
                        volume_size=123,
                        volume_type="volumeType"
                    ),
                    no_device="noDevice",
                    virtual_name="virtualName"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__4db281a81e83e651fa6728ba6a9e2257e4e6fcb6334141386ea9d8661b98c3bb)
                check_type(argname="argument device_name", value=device_name, expected_type=type_hints["device_name"])
                check_type(argname="argument ebs", value=ebs, expected_type=type_hints["ebs"])
                check_type(argname="argument no_device", value=no_device, expected_type=type_hints["no_device"])
                check_type(argname="argument virtual_name", value=virtual_name, expected_type=type_hints["virtual_name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if device_name is not None:
                self._values["device_name"] = device_name
            if ebs is not None:
                self._values["ebs"] = ebs
            if no_device is not None:
                self._values["no_device"] = no_device
            if virtual_name is not None:
                self._values["virtual_name"] = virtual_name

        @builtins.property
        def device_name(self) -> typing.Optional[builtins.str]:
            '''The device name (for example, /dev/sdh or xvdh).

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping.html#cfn-ec2-launchtemplate-blockdevicemapping-devicename
            '''
            result = self._values.get("device_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def ebs(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.EbsProperty"]]:
            '''Parameters used to automatically set up EBS volumes when the instance is launched.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping.html#cfn-ec2-launchtemplate-blockdevicemapping-ebs
            '''
            result = self._values.get("ebs")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.EbsProperty"]], result)

        @builtins.property
        def no_device(self) -> typing.Optional[builtins.str]:
            '''To omit the device from the block device mapping, specify an empty string.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping.html#cfn-ec2-launchtemplate-blockdevicemapping-nodevice
            '''
            result = self._values.get("no_device")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def virtual_name(self) -> typing.Optional[builtins.str]:
            '''The virtual device name (ephemeralN).

            Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for ephemeral0 and ephemeral1. The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping.html#cfn-ec2-launchtemplate-blockdevicemapping-virtualname
            '''
            result = self._values.get("virtual_name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "BlockDeviceMappingProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.CapacityReservationSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "capacity_reservation_preference": "capacityReservationPreference",
            "capacity_reservation_target": "capacityReservationTarget",
        },
    )
    class CapacityReservationSpecificationProperty:
        def __init__(
            self,
            *,
            capacity_reservation_preference: typing.Optional[builtins.str] = None,
            capacity_reservation_target: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.CapacityReservationTargetProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Specifies an instance's Capacity Reservation targeting option. You can specify only one option at a time.

            ``CapacityReservationSpecification`` is a property of `AWS::EC2::LaunchTemplate LaunchTemplateData <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html>`_ .

            :param capacity_reservation_preference: Indicates the instance's Capacity Reservation preferences. Possible preferences include:. - ``capacity-reservations-only`` - The instance will only run in a Capacity Reservation or Capacity Reservation group. If capacity isn't available, the instance will fail to launch. - ``open`` - The instance can run in any ``open`` Capacity Reservation that has matching attributes (instance type, platform, Availability Zone, tenancy). - ``none`` - The instance avoids running in a Capacity Reservation even if one is available. The instance runs in On-Demand capacity.
            :param capacity_reservation_target: Information about the target Capacity Reservation or Capacity Reservation group.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-capacityreservationspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                capacity_reservation_specification_property = ec2_mixins.CfnLaunchTemplatePropsMixin.CapacityReservationSpecificationProperty(
                    capacity_reservation_preference="capacityReservationPreference",
                    capacity_reservation_target=ec2_mixins.CfnLaunchTemplatePropsMixin.CapacityReservationTargetProperty(
                        capacity_reservation_id="capacityReservationId",
                        capacity_reservation_resource_group_arn="capacityReservationResourceGroupArn"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__086f0dbd1a0663e9308eda116ef6793987b16b1663e1d8588514f2899e587961)
                check_type(argname="argument capacity_reservation_preference", value=capacity_reservation_preference, expected_type=type_hints["capacity_reservation_preference"])
                check_type(argname="argument capacity_reservation_target", value=capacity_reservation_target, expected_type=type_hints["capacity_reservation_target"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if capacity_reservation_preference is not None:
                self._values["capacity_reservation_preference"] = capacity_reservation_preference
            if capacity_reservation_target is not None:
                self._values["capacity_reservation_target"] = capacity_reservation_target

        @builtins.property
        def capacity_reservation_preference(self) -> typing.Optional[builtins.str]:
            '''Indicates the instance's Capacity Reservation preferences. Possible preferences include:.

            - ``capacity-reservations-only`` - The instance will only run in a Capacity Reservation or Capacity Reservation group. If capacity isn't available, the instance will fail to launch.
            - ``open`` - The instance can run in any ``open`` Capacity Reservation that has matching attributes (instance type, platform, Availability Zone, tenancy).
            - ``none`` - The instance avoids running in a Capacity Reservation even if one is available. The instance runs in On-Demand capacity.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-capacityreservationspecification.html#cfn-ec2-launchtemplate-capacityreservationspecification-capacityreservationpreference
            '''
            result = self._values.get("capacity_reservation_preference")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def capacity_reservation_target(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.CapacityReservationTargetProperty"]]:
            '''Information about the target Capacity Reservation or Capacity Reservation group.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-capacityreservationspecification.html#cfn-ec2-launchtemplate-capacityreservationspecification-capacityreservationtarget
            '''
            result = self._values.get("capacity_reservation_target")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.CapacityReservationTargetProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "CapacityReservationSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.CapacityReservationTargetProperty",
        jsii_struct_bases=[],
        name_mapping={
            "capacity_reservation_id": "capacityReservationId",
            "capacity_reservation_resource_group_arn": "capacityReservationResourceGroupArn",
        },
    )
    class CapacityReservationTargetProperty:
        def __init__(
            self,
            *,
            capacity_reservation_id: typing.Optional[builtins.str] = None,
            capacity_reservation_resource_group_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies a target Capacity Reservation.

            ``CapacityReservationTarget`` is a property of the `Amazon EC2 LaunchTemplate LaunchTemplateData <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html>`_ property type.

            :param capacity_reservation_id: The ID of the Capacity Reservation in which to run the instance.
            :param capacity_reservation_resource_group_arn: The ARN of the Capacity Reservation resource group in which to run the instance.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-capacityreservationtarget.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                capacity_reservation_target_property = ec2_mixins.CfnLaunchTemplatePropsMixin.CapacityReservationTargetProperty(
                    capacity_reservation_id="capacityReservationId",
                    capacity_reservation_resource_group_arn="capacityReservationResourceGroupArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__99c4927757284b4736bcabf44b4921dd3757e798eec3910cca1a4386c5fd73e6)
                check_type(argname="argument capacity_reservation_id", value=capacity_reservation_id, expected_type=type_hints["capacity_reservation_id"])
                check_type(argname="argument capacity_reservation_resource_group_arn", value=capacity_reservation_resource_group_arn, expected_type=type_hints["capacity_reservation_resource_group_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if capacity_reservation_id is not None:
                self._values["capacity_reservation_id"] = capacity_reservation_id
            if capacity_reservation_resource_group_arn is not None:
                self._values["capacity_reservation_resource_group_arn"] = capacity_reservation_resource_group_arn

        @builtins.property
        def capacity_reservation_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the Capacity Reservation in which to run the instance.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-capacityreservationtarget.html#cfn-ec2-launchtemplate-capacityreservationtarget-capacityreservationid
            '''
            result = self._values.get("capacity_reservation_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def capacity_reservation_resource_group_arn(
            self,
        ) -> typing.Optional[builtins.str]:
            '''The ARN of the Capacity Reservation resource group in which to run the instance.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-capacityreservationtarget.html#cfn-ec2-launchtemplate-capacityreservationtarget-capacityreservationresourcegrouparn
            '''
            result = self._values.get("capacity_reservation_resource_group_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "CapacityReservationTargetProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.ConnectionTrackingSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "tcp_established_timeout": "tcpEstablishedTimeout",
            "udp_stream_timeout": "udpStreamTimeout",
            "udp_timeout": "udpTimeout",
        },
    )
    class ConnectionTrackingSpecificationProperty:
        def __init__(
            self,
            *,
            tcp_established_timeout: typing.Optional[jsii.Number] = None,
            udp_stream_timeout: typing.Optional[jsii.Number] = None,
            udp_timeout: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''A security group connection tracking specification that enables you to set the idle timeout for connection tracking on an Elastic network interface.

            For more information, see `Connection tracking timeouts <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-connection-tracking.html#connection-tracking-timeouts>`_ in the *Amazon EC2 User Guide* .

            :param tcp_established_timeout: Timeout (in seconds) for idle TCP connections in an established state. Min: 60 seconds. Max: 432000 seconds (5 days). Default: 432000 seconds. Recommended: Less than 432000 seconds.
            :param udp_stream_timeout: Timeout (in seconds) for idle UDP flows classified as streams which have seen more than one request-response transaction. Min: 60 seconds. Max: 180 seconds (3 minutes). Default: 180 seconds.
            :param udp_timeout: Timeout (in seconds) for idle UDP flows that have seen traffic only in a single direction or a single request-response transaction. Min: 30 seconds. Max: 60 seconds. Default: 30 seconds.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-connectiontrackingspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                connection_tracking_specification_property = ec2_mixins.CfnLaunchTemplatePropsMixin.ConnectionTrackingSpecificationProperty(
                    tcp_established_timeout=123,
                    udp_stream_timeout=123,
                    udp_timeout=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__0b5a4cc80934fd891da9e61ebea8411b661ed3c45568387809edd2642ccdd31c)
                check_type(argname="argument tcp_established_timeout", value=tcp_established_timeout, expected_type=type_hints["tcp_established_timeout"])
                check_type(argname="argument udp_stream_timeout", value=udp_stream_timeout, expected_type=type_hints["udp_stream_timeout"])
                check_type(argname="argument udp_timeout", value=udp_timeout, expected_type=type_hints["udp_timeout"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if tcp_established_timeout is not None:
                self._values["tcp_established_timeout"] = tcp_established_timeout
            if udp_stream_timeout is not None:
                self._values["udp_stream_timeout"] = udp_stream_timeout
            if udp_timeout is not None:
                self._values["udp_timeout"] = udp_timeout

        @builtins.property
        def tcp_established_timeout(self) -> typing.Optional[jsii.Number]:
            '''Timeout (in seconds) for idle TCP connections in an established state.

            Min: 60 seconds. Max: 432000 seconds (5 days). Default: 432000 seconds. Recommended: Less than 432000 seconds.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-connectiontrackingspecification.html#cfn-ec2-launchtemplate-connectiontrackingspecification-tcpestablishedtimeout
            '''
            result = self._values.get("tcp_established_timeout")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def udp_stream_timeout(self) -> typing.Optional[jsii.Number]:
            '''Timeout (in seconds) for idle UDP flows classified as streams which have seen more than one request-response transaction.

            Min: 60 seconds. Max: 180 seconds (3 minutes). Default: 180 seconds.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-connectiontrackingspecification.html#cfn-ec2-launchtemplate-connectiontrackingspecification-udpstreamtimeout
            '''
            result = self._values.get("udp_stream_timeout")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def udp_timeout(self) -> typing.Optional[jsii.Number]:
            '''Timeout (in seconds) for idle UDP flows that have seen traffic only in a single direction or a single request-response transaction.

            Min: 30 seconds. Max: 60 seconds. Default: 30 seconds.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-connectiontrackingspecification.html#cfn-ec2-launchtemplate-connectiontrackingspecification-udptimeout
            '''
            result = self._values.get("udp_timeout")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ConnectionTrackingSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.CpuOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "amd_sev_snp": "amdSevSnp",
            "core_count": "coreCount",
            "threads_per_core": "threadsPerCore",
        },
    )
    class CpuOptionsProperty:
        def __init__(
            self,
            *,
            amd_sev_snp: typing.Optional[builtins.str] = None,
            core_count: typing.Optional[jsii.Number] = None,
            threads_per_core: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Specifies the CPU options for an instance.

            For more information, see `Optimize CPU options <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .

            ``CpuOptions`` is a property of `AWS::EC2::LaunchTemplate LaunchTemplateData <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html>`_ .

            :param amd_sev_snp: Indicates whether to enable the instance for AMD SEV-SNP. AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only. For more information, see `AMD SEV-SNP for Amazon EC2 instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/sev-snp.html>`_ .
            :param core_count: The number of CPU cores for the instance.
            :param threads_per_core: The number of threads per CPU core. To disable multithreading for the instance, specify a value of ``1`` . Otherwise, specify the default value of ``2`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-cpuoptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                cpu_options_property = ec2_mixins.CfnLaunchTemplatePropsMixin.CpuOptionsProperty(
                    amd_sev_snp="amdSevSnp",
                    core_count=123,
                    threads_per_core=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__1422df4de4f0370d929b27048d9f11f8e58455b01ed74d47d3d6240a34e5325d)
                check_type(argname="argument amd_sev_snp", value=amd_sev_snp, expected_type=type_hints["amd_sev_snp"])
                check_type(argname="argument core_count", value=core_count, expected_type=type_hints["core_count"])
                check_type(argname="argument threads_per_core", value=threads_per_core, expected_type=type_hints["threads_per_core"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if amd_sev_snp is not None:
                self._values["amd_sev_snp"] = amd_sev_snp
            if core_count is not None:
                self._values["core_count"] = core_count
            if threads_per_core is not None:
                self._values["threads_per_core"] = threads_per_core

        @builtins.property
        def amd_sev_snp(self) -> typing.Optional[builtins.str]:
            '''Indicates whether to enable the instance for AMD SEV-SNP.

            AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only. For more information, see `AMD SEV-SNP for Amazon EC2 instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/sev-snp.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-cpuoptions.html#cfn-ec2-launchtemplate-cpuoptions-amdsevsnp
            '''
            result = self._values.get("amd_sev_snp")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def core_count(self) -> typing.Optional[jsii.Number]:
            '''The number of CPU cores for the instance.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-cpuoptions.html#cfn-ec2-launchtemplate-cpuoptions-corecount
            '''
            result = self._values.get("core_count")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def threads_per_core(self) -> typing.Optional[jsii.Number]:
            '''The number of threads per CPU core.

            To disable multithreading for the instance, specify a value of ``1`` . Otherwise, specify the default value of ``2`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-cpuoptions.html#cfn-ec2-launchtemplate-cpuoptions-threadspercore
            '''
            result = self._values.get("threads_per_core")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "CpuOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.CpuProperty",
        jsii_struct_bases=[],
        name_mapping={"references": "references"},
    )
    class CpuProperty:
        def __init__(
            self,
            *,
            references: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.ReferenceProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ) -> None:
            '''Specifies the CPU performance to consider when using an instance family as the baseline reference.

            :param references: The instance family to use as the baseline reference for CPU performance. All instance types that match your specified attributes are compared against the CPU performance of the referenced instance family, regardless of CPU manufacturer or architecture differences.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-cpu.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                cpu_property = ec2_mixins.CfnLaunchTemplatePropsMixin.CpuProperty(
                    references=[ec2_mixins.CfnLaunchTemplatePropsMixin.ReferenceProperty(
                        instance_family="instanceFamily"
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__32ec87664b7ed4f991a21ebd53c2dfebb89928e31bd4db317578ec239a3effeb)
                check_type(argname="argument references", value=references, expected_type=type_hints["references"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if references is not None:
                self._values["references"] = references

        @builtins.property
        def references(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.ReferenceProperty"]]]]:
            '''The instance family to use as the baseline reference for CPU performance.

            All instance types that match your specified attributes are compared against the CPU performance of the referenced instance family, regardless of CPU manufacturer or architecture differences.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-cpu.html#cfn-ec2-launchtemplate-cpu-references
            '''
            result = self._values.get("references")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.ReferenceProperty"]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "CpuProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.CreditSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={"cpu_credits": "cpuCredits"},
    )
    class CreditSpecificationProperty:
        def __init__(
            self,
            *,
            cpu_credits: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies the credit option for CPU usage of a T2, T3, or T3a instance.

            ``CreditSpecification`` is a property of `AWS::EC2::LaunchTemplate LaunchTemplateData <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html>`_ .

            :param cpu_credits: The credit option for CPU usage of a T instance. Valid values: ``standard`` | ``unlimited``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-creditspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                credit_specification_property = ec2_mixins.CfnLaunchTemplatePropsMixin.CreditSpecificationProperty(
                    cpu_credits="cpuCredits"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__f0b0de1ddacac42e341cbb52058aaf87b56beaa2df785c8504fde58be5f499dc)
                check_type(argname="argument cpu_credits", value=cpu_credits, expected_type=type_hints["cpu_credits"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if cpu_credits is not None:
                self._values["cpu_credits"] = cpu_credits

        @builtins.property
        def cpu_credits(self) -> typing.Optional[builtins.str]:
            '''The credit option for CPU usage of a T instance.

            Valid values: ``standard`` | ``unlimited``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-creditspecification.html#cfn-ec2-launchtemplate-creditspecification-cpucredits
            '''
            result = self._values.get("cpu_credits")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "CreditSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.EbsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "delete_on_termination": "deleteOnTermination",
            "encrypted": "encrypted",
            "iops": "iops",
            "kms_key_id": "kmsKeyId",
            "snapshot_id": "snapshotId",
            "throughput": "throughput",
            "volume_initialization_rate": "volumeInitializationRate",
            "volume_size": "volumeSize",
            "volume_type": "volumeType",
        },
    )
    class EbsProperty:
        def __init__(
            self,
            *,
            delete_on_termination: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            encrypted: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            iops: typing.Optional[jsii.Number] = None,
            kms_key_id: typing.Optional[builtins.str] = None,
            snapshot_id: typing.Optional[builtins.str] = None,
            throughput: typing.Optional[jsii.Number] = None,
            volume_initialization_rate: typing.Optional[jsii.Number] = None,
            volume_size: typing.Optional[jsii.Number] = None,
            volume_type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Parameters for a block device for an EBS volume in an Amazon EC2 launch template.

            ``Ebs`` is a property of `AWS::EC2::LaunchTemplate BlockDeviceMapping <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping.html>`_ .

            :param delete_on_termination: Indicates whether the EBS volume is deleted on instance termination.
            :param encrypted: Indicates whether the EBS volume is encrypted. Encrypted volumes can only be attached to instances that support Amazon EBS encryption. If you are creating a volume from a snapshot, you can't specify an encryption value.
            :param iops: The number of I/O operations per second (IOPS). For ``gp3`` , ``io1`` , and ``io2`` volumes, this represents the number of IOPS that are provisioned for the volume. For ``gp2`` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. The following are the supported values for each volume type: - ``gp3`` : 3,000 - 80,000 IOPS - ``io1`` : 100 - 64,000 IOPS - ``io2`` : 100 - 256,000 IOPS For ``io2`` volumes, you can achieve up to 256,000 IOPS on `instances built on the Nitro System <https://docs.aws.amazon.com/ec2/latest/instancetypes/ec2-nitro-instances.html>`_ . On other instances, you can achieve performance up to 32,000 IOPS. This parameter is supported for ``io1`` , ``io2`` , and ``gp3`` volumes only.
            :param kms_key_id: Identifier (key ID, key alias, key ARN, or alias ARN) of the customer managed KMS key to use for EBS encryption.
            :param snapshot_id: The ID of the snapshot.
            :param throughput: The throughput to provision for a ``gp3`` volume, with a maximum of 2,000 MiB/s. Valid Range: Minimum value of 125. Maximum value of 2,000.
            :param volume_initialization_rate: Specifies the Amazon EBS Provisioned Rate for Volume Initialization (volume initialization rate), in MiB/s, at which to download the snapshot blocks from Amazon S3 to the volume. This is also known as *volume initialization* . Specifying a volume initialization rate ensures that the volume is initialized at a predictable and consistent rate after creation. This parameter is supported only for volumes created from snapshots. Omit this parameter if: - You want to create the volume using fast snapshot restore. You must specify a snapshot that is enabled for fast snapshot restore. In this case, the volume is fully initialized at creation. .. epigraph:: If you specify a snapshot that is enabled for fast snapshot restore and a volume initialization rate, the volume will be initialized at the specified rate instead of fast snapshot restore. - You want to create a volume that is initialized at the default rate. For more information, see `Initialize Amazon EBS volumes <https://docs.aws.amazon.com/ebs/latest/userguide/initalize-volume.html>`_ in the *Amazon EC2 User Guide* . Valid range: 100 - 300 MiB/s
            :param volume_size: The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. The following are the supported volumes sizes for each volume type: - ``gp2`` : 1 - 16,384 GiB - ``gp3`` : 1 - 65,536 GiB - ``io1`` : 4 - 16,384 GiB - ``io2`` : 4 - 65,536 GiB - ``st1`` and ``sc1`` : 125 - 16,384 GiB - ``standard`` : 1 - 1024 GiB
            :param volume_type: The volume type. For more information, see `Amazon EBS volume types <https://docs.aws.amazon.com/ebs/latest/userguide/ebs-volume-types.html>`_ in the *Amazon EBS User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ebs.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                ebs_property = ec2_mixins.CfnLaunchTemplatePropsMixin.EbsProperty(
                    delete_on_termination=False,
                    encrypted=False,
                    iops=123,
                    kms_key_id="kmsKeyId",
                    snapshot_id="snapshotId",
                    throughput=123,
                    volume_initialization_rate=123,
                    volume_size=123,
                    volume_type="volumeType"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__978f1216898dc69ad436e7182f0b0d1b897197040b185e4de3531d0d2665dd31)
                check_type(argname="argument delete_on_termination", value=delete_on_termination, expected_type=type_hints["delete_on_termination"])
                check_type(argname="argument encrypted", value=encrypted, expected_type=type_hints["encrypted"])
                check_type(argname="argument iops", value=iops, expected_type=type_hints["iops"])
                check_type(argname="argument kms_key_id", value=kms_key_id, expected_type=type_hints["kms_key_id"])
                check_type(argname="argument snapshot_id", value=snapshot_id, expected_type=type_hints["snapshot_id"])
                check_type(argname="argument throughput", value=throughput, expected_type=type_hints["throughput"])
                check_type(argname="argument volume_initialization_rate", value=volume_initialization_rate, expected_type=type_hints["volume_initialization_rate"])
                check_type(argname="argument volume_size", value=volume_size, expected_type=type_hints["volume_size"])
                check_type(argname="argument volume_type", value=volume_type, expected_type=type_hints["volume_type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if delete_on_termination is not None:
                self._values["delete_on_termination"] = delete_on_termination
            if encrypted is not None:
                self._values["encrypted"] = encrypted
            if iops is not None:
                self._values["iops"] = iops
            if kms_key_id is not None:
                self._values["kms_key_id"] = kms_key_id
            if snapshot_id is not None:
                self._values["snapshot_id"] = snapshot_id
            if throughput is not None:
                self._values["throughput"] = throughput
            if volume_initialization_rate is not None:
                self._values["volume_initialization_rate"] = volume_initialization_rate
            if volume_size is not None:
                self._values["volume_size"] = volume_size
            if volume_type is not None:
                self._values["volume_type"] = volume_type

        @builtins.property
        def delete_on_termination(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether the EBS volume is deleted on instance termination.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ebs.html#cfn-ec2-launchtemplate-ebs-deleteontermination
            '''
            result = self._values.get("delete_on_termination")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def encrypted(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether the EBS volume is encrypted.

            Encrypted volumes can only be attached to instances that support Amazon EBS encryption. If you are creating a volume from a snapshot, you can't specify an encryption value.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ebs.html#cfn-ec2-launchtemplate-ebs-encrypted
            '''
            result = self._values.get("encrypted")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def iops(self) -> typing.Optional[jsii.Number]:
            '''The number of I/O operations per second (IOPS).

            For ``gp3`` , ``io1`` , and ``io2`` volumes, this represents the number of IOPS that are provisioned for the volume. For ``gp2`` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.

            The following are the supported values for each volume type:

            - ``gp3`` : 3,000 - 80,000 IOPS
            - ``io1`` : 100 - 64,000 IOPS
            - ``io2`` : 100 - 256,000 IOPS

            For ``io2`` volumes, you can achieve up to 256,000 IOPS on `instances built on the Nitro System <https://docs.aws.amazon.com/ec2/latest/instancetypes/ec2-nitro-instances.html>`_ . On other instances, you can achieve performance up to 32,000 IOPS.

            This parameter is supported for ``io1`` , ``io2`` , and ``gp3`` volumes only.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ebs.html#cfn-ec2-launchtemplate-ebs-iops
            '''
            result = self._values.get("iops")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def kms_key_id(self) -> typing.Optional[builtins.str]:
            '''Identifier (key ID, key alias, key ARN, or alias ARN) of the customer managed KMS key to use for EBS encryption.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ebs.html#cfn-ec2-launchtemplate-ebs-kmskeyid
            '''
            result = self._values.get("kms_key_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def snapshot_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the snapshot.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ebs.html#cfn-ec2-launchtemplate-ebs-snapshotid
            '''
            result = self._values.get("snapshot_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def throughput(self) -> typing.Optional[jsii.Number]:
            '''The throughput to provision for a ``gp3`` volume, with a maximum of 2,000 MiB/s.

            Valid Range: Minimum value of 125. Maximum value of 2,000.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ebs.html#cfn-ec2-launchtemplate-ebs-throughput
            '''
            result = self._values.get("throughput")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def volume_initialization_rate(self) -> typing.Optional[jsii.Number]:
            '''Specifies the Amazon EBS Provisioned Rate for Volume Initialization (volume initialization rate), in MiB/s, at which to download the snapshot blocks from Amazon S3 to the volume.

            This is also known as *volume initialization* . Specifying a volume initialization rate ensures that the volume is initialized at a predictable and consistent rate after creation.

            This parameter is supported only for volumes created from snapshots. Omit this parameter if:

            - You want to create the volume using fast snapshot restore. You must specify a snapshot that is enabled for fast snapshot restore. In this case, the volume is fully initialized at creation.

            .. epigraph::

               If you specify a snapshot that is enabled for fast snapshot restore and a volume initialization rate, the volume will be initialized at the specified rate instead of fast snapshot restore.

            - You want to create a volume that is initialized at the default rate.

            For more information, see `Initialize Amazon EBS volumes <https://docs.aws.amazon.com/ebs/latest/userguide/initalize-volume.html>`_ in the *Amazon EC2 User Guide* .

            Valid range: 100 - 300 MiB/s

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ebs.html#cfn-ec2-launchtemplate-ebs-volumeinitializationrate
            '''
            result = self._values.get("volume_initialization_rate")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def volume_size(self) -> typing.Optional[jsii.Number]:
            '''The size of the volume, in GiBs.

            You must specify either a snapshot ID or a volume size. The following are the supported volumes sizes for each volume type:

            - ``gp2`` : 1 - 16,384 GiB
            - ``gp3`` : 1 - 65,536 GiB
            - ``io1`` : 4 - 16,384 GiB
            - ``io2`` : 4 - 65,536 GiB
            - ``st1`` and ``sc1`` : 125 - 16,384 GiB
            - ``standard`` : 1 - 1024 GiB

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ebs.html#cfn-ec2-launchtemplate-ebs-volumesize
            '''
            result = self._values.get("volume_size")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def volume_type(self) -> typing.Optional[builtins.str]:
            '''The volume type.

            For more information, see `Amazon EBS volume types <https://docs.aws.amazon.com/ebs/latest/userguide/ebs-volume-types.html>`_ in the *Amazon EBS User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ebs.html#cfn-ec2-launchtemplate-ebs-volumetype
            '''
            result = self._values.get("volume_type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "EbsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.ElasticGpuSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={"type": "type"},
    )
    class ElasticGpuSpecificationProperty:
        def __init__(self, *, type: typing.Optional[builtins.str] = None) -> None:
            '''
            :param type: 

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-elasticgpuspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                elastic_gpu_specification_property = ec2_mixins.CfnLaunchTemplatePropsMixin.ElasticGpuSpecificationProperty(
                    type="type"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__ca1939f1ff97145a3b958ea0c5a3f873834656f204b4ffab751afd0a1b5a7516)
                check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if type is not None:
                self._values["type"] = type

        @builtins.property
        def type(self) -> typing.Optional[builtins.str]:
            '''
            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-elasticgpuspecification.html#cfn-ec2-launchtemplate-elasticgpuspecification-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ElasticGpuSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.EnaSrdSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "ena_srd_enabled": "enaSrdEnabled",
            "ena_srd_udp_specification": "enaSrdUdpSpecification",
        },
    )
    class EnaSrdSpecificationProperty:
        def __init__(
            self,
            *,
            ena_srd_enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            ena_srd_udp_specification: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.EnaSrdUdpSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''ENA Express uses AWS Scalable Reliable Datagram (SRD) technology to increase the maximum bandwidth used per stream and minimize tail latency of network traffic between EC2 instances.

            With ENA Express, you can communicate between two EC2 instances in the same subnet within the same account, or in different accounts. Both sending and receiving instances must have ENA Express enabled.

            To improve the reliability of network packet delivery, ENA Express reorders network packets on the receiving end by default. However, some UDP-based applications are designed to handle network packets that are out of order to reduce the overhead for packet delivery at the network layer. When ENA Express is enabled, you can specify whether UDP network traffic uses it.

            :param ena_srd_enabled: Indicates whether ENA Express is enabled for the network interface.
            :param ena_srd_udp_specification: Configures ENA Express for UDP network traffic.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-enasrdspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                ena_srd_specification_property = ec2_mixins.CfnLaunchTemplatePropsMixin.EnaSrdSpecificationProperty(
                    ena_srd_enabled=False,
                    ena_srd_udp_specification=ec2_mixins.CfnLaunchTemplatePropsMixin.EnaSrdUdpSpecificationProperty(
                        ena_srd_udp_enabled=False
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__62998cc2f3e5769140ecc1f6d96bd837ff139d94b77afbd716290ac8ef57b772)
                check_type(argname="argument ena_srd_enabled", value=ena_srd_enabled, expected_type=type_hints["ena_srd_enabled"])
                check_type(argname="argument ena_srd_udp_specification", value=ena_srd_udp_specification, expected_type=type_hints["ena_srd_udp_specification"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if ena_srd_enabled is not None:
                self._values["ena_srd_enabled"] = ena_srd_enabled
            if ena_srd_udp_specification is not None:
                self._values["ena_srd_udp_specification"] = ena_srd_udp_specification

        @builtins.property
        def ena_srd_enabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether ENA Express is enabled for the network interface.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-enasrdspecification.html#cfn-ec2-launchtemplate-enasrdspecification-enasrdenabled
            '''
            result = self._values.get("ena_srd_enabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def ena_srd_udp_specification(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.EnaSrdUdpSpecificationProperty"]]:
            '''Configures ENA Express for UDP network traffic.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-enasrdspecification.html#cfn-ec2-launchtemplate-enasrdspecification-enasrdudpspecification
            '''
            result = self._values.get("ena_srd_udp_specification")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.EnaSrdUdpSpecificationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "EnaSrdSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.EnaSrdUdpSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={"ena_srd_udp_enabled": "enaSrdUdpEnabled"},
    )
    class EnaSrdUdpSpecificationProperty:
        def __init__(
            self,
            *,
            ena_srd_udp_enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        ) -> None:
            '''ENA Express is compatible with both TCP and UDP transport protocols.

            When it's enabled, TCP traffic automatically uses it. However, some UDP-based applications are designed to handle network packets that are out of order, without a need for retransmission, such as live video broadcasting or other near-real-time applications. For UDP traffic, you can specify whether to use ENA Express, based on your application environment needs.

            :param ena_srd_udp_enabled: Indicates whether UDP traffic to and from the instance uses ENA Express. To specify this setting, you must first enable ENA Express.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-enasrdudpspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                ena_srd_udp_specification_property = ec2_mixins.CfnLaunchTemplatePropsMixin.EnaSrdUdpSpecificationProperty(
                    ena_srd_udp_enabled=False
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__8743066a9329d8d3a26808290853cf58c6f9367c0527830c9b01570b1c39d8dd)
                check_type(argname="argument ena_srd_udp_enabled", value=ena_srd_udp_enabled, expected_type=type_hints["ena_srd_udp_enabled"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if ena_srd_udp_enabled is not None:
                self._values["ena_srd_udp_enabled"] = ena_srd_udp_enabled

        @builtins.property
        def ena_srd_udp_enabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether UDP traffic to and from the instance uses ENA Express.

            To specify this setting, you must first enable ENA Express.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-enasrdudpspecification.html#cfn-ec2-launchtemplate-enasrdudpspecification-enasrdudpenabled
            '''
            result = self._values.get("ena_srd_udp_enabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "EnaSrdUdpSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.EnclaveOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={"enabled": "enabled"},
    )
    class EnclaveOptionsProperty:
        def __init__(
            self,
            *,
            enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        ) -> None:
            '''Indicates whether the instance is enabled for AWS Nitro Enclaves.

            :param enabled: If this parameter is set to ``true`` , the instance is enabled for AWS Nitro Enclaves; otherwise, it is not enabled for AWS Nitro Enclaves.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-enclaveoptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                enclave_options_property = ec2_mixins.CfnLaunchTemplatePropsMixin.EnclaveOptionsProperty(
                    enabled=False
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__72ab36f592d546363b9798e76ab00c27a0f01fbfaf7b6a858003f1d8dc273d93)
                check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if enabled is not None:
                self._values["enabled"] = enabled

        @builtins.property
        def enabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''If this parameter is set to ``true`` , the instance is enabled for AWS Nitro Enclaves;

            otherwise, it is not enabled for AWS Nitro Enclaves.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-enclaveoptions.html#cfn-ec2-launchtemplate-enclaveoptions-enabled
            '''
            result = self._values.get("enabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "EnclaveOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.HibernationOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={"configured": "configured"},
    )
    class HibernationOptionsProperty:
        def __init__(
            self,
            *,
            configured: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        ) -> None:
            '''Specifies whether your instance is configured for hibernation.

            This parameter is valid only if the instance meets the `hibernation prerequisites <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html#hibernating-prerequisites>`_ . For more information, see `Hibernate Your Instance <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html>`_ in the *Amazon EC2 User Guide* .

            ``HibernationOptions`` is a property of `AWS::EC2::LaunchTemplate LaunchTemplateData <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html>`_ .

            :param configured: If you set this parameter to ``true`` , the instance is enabled for hibernation. Default: ``false``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-hibernationoptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                hibernation_options_property = ec2_mixins.CfnLaunchTemplatePropsMixin.HibernationOptionsProperty(
                    configured=False
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__01260a92e5722d9da3da46f90b610dbfa635e24540d4915cefbafa4862f67488)
                check_type(argname="argument configured", value=configured, expected_type=type_hints["configured"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if configured is not None:
                self._values["configured"] = configured

        @builtins.property
        def configured(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''If you set this parameter to ``true`` , the instance is enabled for hibernation.

            Default: ``false``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-hibernationoptions.html#cfn-ec2-launchtemplate-hibernationoptions-configured
            '''
            result = self._values.get("configured")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "HibernationOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.IamInstanceProfileProperty",
        jsii_struct_bases=[],
        name_mapping={"arn": "arn", "name": "name"},
    )
    class IamInstanceProfileProperty:
        def __init__(
            self,
            *,
            arn: typing.Optional[builtins.str] = None,
            name: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies an IAM instance profile, which is a container for an IAM role for your instance.

            You can use an IAM role to distribute your AWS credentials to your instances.

            If you are creating the launch template for use with an Amazon EC2 Auto Scaling group, you can specify either the name or the ARN of the instance profile, but not both.

            ``IamInstanceProfile`` is a property of `AWS::EC2::LaunchTemplate LaunchTemplateData <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html>`_ .

            :param arn: The Amazon Resource Name (ARN) of the instance profile.
            :param name: The name of the instance profile.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-iaminstanceprofile.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                iam_instance_profile_property = ec2_mixins.CfnLaunchTemplatePropsMixin.IamInstanceProfileProperty(
                    arn="arn",
                    name="name"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__6a15f1670c4df4370505b15c7147c32614f5bcda2db67d077e00d1e01eb65ad4)
                check_type(argname="argument arn", value=arn, expected_type=type_hints["arn"])
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if arn is not None:
                self._values["arn"] = arn
            if name is not None:
                self._values["name"] = name

        @builtins.property
        def arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the instance profile.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-iaminstanceprofile.html#cfn-ec2-launchtemplate-iaminstanceprofile-arn
            '''
            result = self._values.get("arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def name(self) -> typing.Optional[builtins.str]:
            '''The name of the instance profile.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-iaminstanceprofile.html#cfn-ec2-launchtemplate-iaminstanceprofile-name
            '''
            result = self._values.get("name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "IamInstanceProfileProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.InstanceMarketOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={"market_type": "marketType", "spot_options": "spotOptions"},
    )
    class InstanceMarketOptionsProperty:
        def __init__(
            self,
            *,
            market_type: typing.Optional[builtins.str] = None,
            spot_options: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.SpotOptionsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Specifies the market (purchasing) option for an instance.

            ``InstanceMarketOptions`` is a property of the `AWS::EC2::LaunchTemplate LaunchTemplateData <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html>`_ .

            :param market_type: The market type.
            :param spot_options: The options for Spot Instances.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancemarketoptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                instance_market_options_property = ec2_mixins.CfnLaunchTemplatePropsMixin.InstanceMarketOptionsProperty(
                    market_type="marketType",
                    spot_options=ec2_mixins.CfnLaunchTemplatePropsMixin.SpotOptionsProperty(
                        block_duration_minutes=123,
                        instance_interruption_behavior="instanceInterruptionBehavior",
                        max_price="maxPrice",
                        spot_instance_type="spotInstanceType",
                        valid_until="validUntil"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__8c1940850963348126c5dd1ae35626844c3a04026aa94a2a1b14df405cdbea86)
                check_type(argname="argument market_type", value=market_type, expected_type=type_hints["market_type"])
                check_type(argname="argument spot_options", value=spot_options, expected_type=type_hints["spot_options"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if market_type is not None:
                self._values["market_type"] = market_type
            if spot_options is not None:
                self._values["spot_options"] = spot_options

        @builtins.property
        def market_type(self) -> typing.Optional[builtins.str]:
            '''The market type.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancemarketoptions.html#cfn-ec2-launchtemplate-instancemarketoptions-markettype
            '''
            result = self._values.get("market_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def spot_options(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.SpotOptionsProperty"]]:
            '''The options for Spot Instances.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancemarketoptions.html#cfn-ec2-launchtemplate-instancemarketoptions-spotoptions
            '''
            result = self._values.get("spot_options")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.SpotOptionsProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "InstanceMarketOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.InstanceRequirementsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "accelerator_count": "acceleratorCount",
            "accelerator_manufacturers": "acceleratorManufacturers",
            "accelerator_names": "acceleratorNames",
            "accelerator_total_memory_mib": "acceleratorTotalMemoryMiB",
            "accelerator_types": "acceleratorTypes",
            "allowed_instance_types": "allowedInstanceTypes",
            "bare_metal": "bareMetal",
            "baseline_ebs_bandwidth_mbps": "baselineEbsBandwidthMbps",
            "baseline_performance_factors": "baselinePerformanceFactors",
            "burstable_performance": "burstablePerformance",
            "cpu_manufacturers": "cpuManufacturers",
            "excluded_instance_types": "excludedInstanceTypes",
            "instance_generations": "instanceGenerations",
            "local_storage": "localStorage",
            "local_storage_types": "localStorageTypes",
            "max_spot_price_as_percentage_of_optimal_on_demand_price": "maxSpotPriceAsPercentageOfOptimalOnDemandPrice",
            "memory_gib_per_v_cpu": "memoryGiBPerVCpu",
            "memory_mib": "memoryMiB",
            "network_bandwidth_gbps": "networkBandwidthGbps",
            "network_interface_count": "networkInterfaceCount",
            "on_demand_max_price_percentage_over_lowest_price": "onDemandMaxPricePercentageOverLowestPrice",
            "require_hibernate_support": "requireHibernateSupport",
            "spot_max_price_percentage_over_lowest_price": "spotMaxPricePercentageOverLowestPrice",
            "total_local_storage_gb": "totalLocalStorageGb",
            "v_cpu_count": "vCpuCount",
        },
    )
    class InstanceRequirementsProperty:
        def __init__(
            self,
            *,
            accelerator_count: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.AcceleratorCountProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            accelerator_manufacturers: typing.Optional[typing.Sequence[builtins.str]] = None,
            accelerator_names: typing.Optional[typing.Sequence[builtins.str]] = None,
            accelerator_total_memory_mib: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.AcceleratorTotalMemoryMiBProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            accelerator_types: typing.Optional[typing.Sequence[builtins.str]] = None,
            allowed_instance_types: typing.Optional[typing.Sequence[builtins.str]] = None,
            bare_metal: typing.Optional[builtins.str] = None,
            baseline_ebs_bandwidth_mbps: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.BaselineEbsBandwidthMbpsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            baseline_performance_factors: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.BaselinePerformanceFactorsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            burstable_performance: typing.Optional[builtins.str] = None,
            cpu_manufacturers: typing.Optional[typing.Sequence[builtins.str]] = None,
            excluded_instance_types: typing.Optional[typing.Sequence[builtins.str]] = None,
            instance_generations: typing.Optional[typing.Sequence[builtins.str]] = None,
            local_storage: typing.Optional[builtins.str] = None,
            local_storage_types: typing.Optional[typing.Sequence[builtins.str]] = None,
            max_spot_price_as_percentage_of_optimal_on_demand_price: typing.Optional[jsii.Number] = None,
            memory_gib_per_v_cpu: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.MemoryGiBPerVCpuProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            memory_mib: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.MemoryMiBProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            network_bandwidth_gbps: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.NetworkBandwidthGbpsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            network_interface_count: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.NetworkInterfaceCountProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            on_demand_max_price_percentage_over_lowest_price: typing.Optional[jsii.Number] = None,
            require_hibernate_support: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            spot_max_price_percentage_over_lowest_price: typing.Optional[jsii.Number] = None,
            total_local_storage_gb: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.TotalLocalStorageGBProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            v_cpu_count: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.VCpuCountProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''The attributes for the instance types.

            When you specify instance attributes, Amazon EC2 will identify instance types with these attributes.

            You must specify ``VCpuCount`` and ``MemoryMiB`` . All other attributes are optional. Any unspecified optional attribute is set to its default.

            When you specify multiple attributes, you get instance types that satisfy all of the specified attributes. If you specify multiple values for an attribute, you get instance types that satisfy any of the specified values.

            To limit the list of instance types from which Amazon EC2 can identify matching instance types, you can use one of the following parameters, but not both in the same request:

            - ``AllowedInstanceTypes`` - The instance types to include in the list. All other instance types are ignored, even if they match your specified attributes.
            - ``ExcludedInstanceTypes`` - The instance types to exclude from the list, even if they match your specified attributes.

            .. epigraph::

               If you specify ``InstanceRequirements`` , you can't specify ``InstanceType`` .

               Attribute-based instance type selection is only supported when using Auto Scaling groups, EC2 Fleet, and Spot Fleet to launch instances. If you plan to use the launch template in the `launch instance wizard <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-instance-wizard.html>`_ , or with the `RunInstances <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html>`_ API or `AWS::EC2::Instance <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html>`_ AWS CloudFormation resource, you can't specify ``InstanceRequirements`` .

            For more information, see `Specify attributes for instance type selection for EC2 Fleet or Spot Fleet <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html>`_ and `Spot placement score <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html>`_ in the *Amazon EC2 User Guide* .

            :param accelerator_count: The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance. To exclude accelerator-enabled instance types, set ``Max`` to ``0`` . Default: No minimum or maximum limits
            :param accelerator_manufacturers: Indicates whether instance types must have accelerators by specific manufacturers. - For instance types with AWS devices, specify ``amazon-web-services`` . - For instance types with AMD devices, specify ``amd`` . - For instance types with Habana devices, specify ``habana`` . - For instance types with NVIDIA devices, specify ``nvidia`` . - For instance types with Xilinx devices, specify ``xilinx`` . Default: Any manufacturer
            :param accelerator_names: The accelerators that must be on the instance type. - For instance types with NVIDIA A10G GPUs, specify ``a10g`` . - For instance types with NVIDIA A100 GPUs, specify ``a100`` . - For instance types with NVIDIA H100 GPUs, specify ``h100`` . - For instance types with AWS Inferentia chips, specify ``inferentia`` . - For instance types with AWS Inferentia2 chips, specify ``inferentia2`` . - For instance types with Habana Gaudi HL-205 GPUs, specify ``gaudi-hl-205`` . - For instance types with NVIDIA GRID K520 GPUs, specify ``k520`` . - For instance types with NVIDIA K80 GPUs, specify ``k80`` . - For instance types with NVIDIA L4 GPUs, specify ``l4`` . - For instance types with NVIDIA L40S GPUs, specify ``l40s`` . - For instance types with NVIDIA M60 GPUs, specify ``m60`` . - For instance types with AMD Radeon Pro V520 GPUs, specify ``radeon-pro-v520`` . - For instance types with AWS Trainium chips, specify ``trainium`` . - For instance types with AWS Trainium2 chips, specify ``trainium2`` . - For instance types with NVIDIA T4 GPUs, specify ``t4`` . - For instance types with NVIDIA T4G GPUs, specify ``t4g`` . - For instance types with Xilinx U30 cards, specify ``u30`` . - For instance types with Xilinx VU9P FPGAs, specify ``vu9p`` . - For instance types with NVIDIA V100 GPUs, specify ``v100`` . Default: Any accelerator
            :param accelerator_total_memory_mib: The minimum and maximum amount of total accelerator memory, in MiB. Default: No minimum or maximum limits
            :param accelerator_types: The accelerator types that must be on the instance type. - For instance types with FPGA accelerators, specify ``fpga`` . - For instance types with GPU accelerators, specify ``gpu`` . - For instance types with Inference accelerators, specify ``inference`` . - For instance types with Media accelerators, specify ``media`` . Default: Any accelerator type
            :param allowed_instance_types: The instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes. You can use strings with one or more wild cards, represented by an asterisk ( ``*`` ), to allow an instance type, size, or generation. The following are examples: ``m5.8xlarge`` , ``c5*.*`` , ``m5a.*`` , ``r*`` , ``*3*`` . For example, if you specify ``c5*`` ,Amazon EC2 will allow the entire C5 instance family, which includes all C5a and C5n instance types. If you specify ``m5a.*`` , Amazon EC2 will allow all the M5a instance types, but not the M5n instance types. .. epigraph:: If you specify ``AllowedInstanceTypes`` , you can't specify ``ExcludedInstanceTypes`` . Default: All instance types
            :param bare_metal: Indicates whether bare metal instance types must be included, excluded, or required. - To include bare metal instance types, specify ``included`` . - To require only bare metal instance types, specify ``required`` . - To exclude bare metal instance types, specify ``excluded`` . Default: ``excluded``
            :param baseline_ebs_bandwidth_mbps: The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see `Amazon EBSoptimized instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html>`_ in the *Amazon EC2 User Guide* . Default: No minimum or maximum limits
            :param baseline_performance_factors: The baseline performance to consider, using an instance family as a baseline reference. The instance family establishes the lowest acceptable level of performance. Amazon EC2 uses this baseline to guide instance type selection, but there is no guarantee that the selected instance types will always exceed the baseline for every application. Currently, this parameter only supports CPU performance as a baseline performance factor. For more information, see `Performance protection <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html#ec2fleet-abis-performance-protection>`_ in the *Amazon EC2 User Guide* .
            :param burstable_performance: Indicates whether burstable performance T instance types are included, excluded, or required. For more information, see `Burstable performance instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html>`_ . - To include burstable performance instance types, specify ``included`` . - To require only burstable performance instance types, specify ``required`` . - To exclude burstable performance instance types, specify ``excluded`` . Default: ``excluded``
            :param cpu_manufacturers: The CPU manufacturers to include. - For instance types with Intel CPUs, specify ``intel`` . - For instance types with AMD CPUs, specify ``amd`` . - For instance types with AWS CPUs, specify ``amazon-web-services`` . - For instance types with Apple CPUs, specify ``apple`` . .. epigraph:: Don't confuse the CPU manufacturer with the CPU architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template. Default: Any manufacturer
            :param excluded_instance_types: The instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk ( ``*`` ), to exclude an instance type, size, or generation. The following are examples: ``m5.8xlarge`` , ``c5*.*`` , ``m5a.*`` , ``r*`` , ``*3*`` . For example, if you specify ``c5*`` ,Amazon EC2 will exclude the entire C5 instance family, which includes all C5a and C5n instance types. If you specify ``m5a.*`` , Amazon EC2 will exclude all the M5a instance types, but not the M5n instance types. .. epigraph:: If you specify ``ExcludedInstanceTypes`` , you can't specify ``AllowedInstanceTypes`` . Default: No excluded instance types
            :param instance_generations: Indicates whether current or previous generation instance types are included. The current generation instance types are recommended for use. Current generation instance types are typically the latest two to three generations in each instance family. For more information, see `Instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html>`_ in the *Amazon EC2 User Guide* . For current generation instance types, specify ``current`` . For previous generation instance types, specify ``previous`` . Default: Current and previous generation instance types
            :param local_storage: Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, `Amazon EC2 instance store <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html>`_ in the *Amazon EC2 User Guide* . - To include instance types with instance store volumes, specify ``included`` . - To require only instance types with instance store volumes, specify ``required`` . - To exclude instance types with instance store volumes, specify ``excluded`` . Default: ``included``
            :param local_storage_types: The type of local storage that is required. - For instance types with hard disk drive (HDD) storage, specify ``hdd`` . - For instance types with solid state drive (SSD) storage, specify ``ssd`` . Default: ``hdd`` and ``ssd``
            :param max_spot_price_as_percentage_of_optimal_on_demand_price: [Price protection] The price protection threshold for Spot Instances, as a percentage of an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold. The parameter accepts an integer, which Amazon EC2 interprets as a percentage. If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib`` , the price protection threshold is based on the per vCPU or per memory price instead of the per instance price. .. epigraph:: Only one of ``SpotMaxPricePercentageOverLowestPrice`` or ``MaxSpotPriceAsPercentageOfOptimalOnDemandPrice`` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as ``999999`` .
            :param memory_gib_per_v_cpu: The minimum and maximum amount of memory per vCPU, in GiB. Default: No minimum or maximum limits
            :param memory_mib: The minimum and maximum amount of memory, in MiB.
            :param network_bandwidth_gbps: The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default: No minimum or maximum limits
            :param network_interface_count: The minimum and maximum number of network interfaces. Default: No minimum or maximum limits
            :param on_demand_max_price_percentage_over_lowest_price: [Price protection] The price protection threshold for On-Demand Instances, as a percentage higher than an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold. The parameter accepts an integer, which Amazon EC2 interprets as a percentage. To turn off price protection, specify a high value, such as ``999999`` . This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ and `GetInstanceTypesFromInstanceRequirements <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html>`_ . .. epigraph:: If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib`` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price. Default: ``20``
            :param require_hibernate_support: Indicates whether instance types must support hibernation for On-Demand Instances. This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ . Default: ``false``
            :param spot_max_price_percentage_over_lowest_price: [Price protection] The price protection threshold for Spot Instances, as a percentage higher than an identified Spot price. The identified Spot price is the Spot price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified Spot price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose Spot price exceeds your specified threshold. The parameter accepts an integer, which Amazon EC2 interprets as a percentage. If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib`` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price. This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ and `GetInstanceTypesFromInstanceRequirements <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html>`_ . .. epigraph:: Only one of ``SpotMaxPricePercentageOverLowestPrice`` or ``MaxSpotPriceAsPercentageOfOptimalOnDemandPrice`` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as ``999999`` . Default: ``100``
            :param total_local_storage_gb: The minimum and maximum amount of total local storage, in GB. Default: No minimum or maximum limits
            :param v_cpu_count: The minimum and maximum number of vCPUs.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                instance_requirements_property = ec2_mixins.CfnLaunchTemplatePropsMixin.InstanceRequirementsProperty(
                    accelerator_count=ec2_mixins.CfnLaunchTemplatePropsMixin.AcceleratorCountProperty(
                        max=123,
                        min=123
                    ),
                    accelerator_manufacturers=["acceleratorManufacturers"],
                    accelerator_names=["acceleratorNames"],
                    accelerator_total_memory_mi_b=ec2_mixins.CfnLaunchTemplatePropsMixin.AcceleratorTotalMemoryMiBProperty(
                        max=123,
                        min=123
                    ),
                    accelerator_types=["acceleratorTypes"],
                    allowed_instance_types=["allowedInstanceTypes"],
                    bare_metal="bareMetal",
                    baseline_ebs_bandwidth_mbps=ec2_mixins.CfnLaunchTemplatePropsMixin.BaselineEbsBandwidthMbpsProperty(
                        max=123,
                        min=123
                    ),
                    baseline_performance_factors=ec2_mixins.CfnLaunchTemplatePropsMixin.BaselinePerformanceFactorsProperty(
                        cpu=ec2_mixins.CfnLaunchTemplatePropsMixin.CpuProperty(
                            references=[ec2_mixins.CfnLaunchTemplatePropsMixin.ReferenceProperty(
                                instance_family="instanceFamily"
                            )]
                        )
                    ),
                    burstable_performance="burstablePerformance",
                    cpu_manufacturers=["cpuManufacturers"],
                    excluded_instance_types=["excludedInstanceTypes"],
                    instance_generations=["instanceGenerations"],
                    local_storage="localStorage",
                    local_storage_types=["localStorageTypes"],
                    max_spot_price_as_percentage_of_optimal_on_demand_price=123,
                    memory_gi_bPer_vCpu=ec2_mixins.CfnLaunchTemplatePropsMixin.MemoryGiBPerVCpuProperty(
                        max=123,
                        min=123
                    ),
                    memory_mi_b=ec2_mixins.CfnLaunchTemplatePropsMixin.MemoryMiBProperty(
                        max=123,
                        min=123
                    ),
                    network_bandwidth_gbps=ec2_mixins.CfnLaunchTemplatePropsMixin.NetworkBandwidthGbpsProperty(
                        max=123,
                        min=123
                    ),
                    network_interface_count=ec2_mixins.CfnLaunchTemplatePropsMixin.NetworkInterfaceCountProperty(
                        max=123,
                        min=123
                    ),
                    on_demand_max_price_percentage_over_lowest_price=123,
                    require_hibernate_support=False,
                    spot_max_price_percentage_over_lowest_price=123,
                    total_local_storage_gb=ec2_mixins.CfnLaunchTemplatePropsMixin.TotalLocalStorageGBProperty(
                        max=123,
                        min=123
                    ),
                    v_cpu_count=ec2_mixins.CfnLaunchTemplatePropsMixin.VCpuCountProperty(
                        max=123,
                        min=123
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__9a31aff9b7bdab15555051756b0cfdba6b03631e576909c57f154e9c8f03ba54)
                check_type(argname="argument accelerator_count", value=accelerator_count, expected_type=type_hints["accelerator_count"])
                check_type(argname="argument accelerator_manufacturers", value=accelerator_manufacturers, expected_type=type_hints["accelerator_manufacturers"])
                check_type(argname="argument accelerator_names", value=accelerator_names, expected_type=type_hints["accelerator_names"])
                check_type(argname="argument accelerator_total_memory_mib", value=accelerator_total_memory_mib, expected_type=type_hints["accelerator_total_memory_mib"])
                check_type(argname="argument accelerator_types", value=accelerator_types, expected_type=type_hints["accelerator_types"])
                check_type(argname="argument allowed_instance_types", value=allowed_instance_types, expected_type=type_hints["allowed_instance_types"])
                check_type(argname="argument bare_metal", value=bare_metal, expected_type=type_hints["bare_metal"])
                check_type(argname="argument baseline_ebs_bandwidth_mbps", value=baseline_ebs_bandwidth_mbps, expected_type=type_hints["baseline_ebs_bandwidth_mbps"])
                check_type(argname="argument baseline_performance_factors", value=baseline_performance_factors, expected_type=type_hints["baseline_performance_factors"])
                check_type(argname="argument burstable_performance", value=burstable_performance, expected_type=type_hints["burstable_performance"])
                check_type(argname="argument cpu_manufacturers", value=cpu_manufacturers, expected_type=type_hints["cpu_manufacturers"])
                check_type(argname="argument excluded_instance_types", value=excluded_instance_types, expected_type=type_hints["excluded_instance_types"])
                check_type(argname="argument instance_generations", value=instance_generations, expected_type=type_hints["instance_generations"])
                check_type(argname="argument local_storage", value=local_storage, expected_type=type_hints["local_storage"])
                check_type(argname="argument local_storage_types", value=local_storage_types, expected_type=type_hints["local_storage_types"])
                check_type(argname="argument max_spot_price_as_percentage_of_optimal_on_demand_price", value=max_spot_price_as_percentage_of_optimal_on_demand_price, expected_type=type_hints["max_spot_price_as_percentage_of_optimal_on_demand_price"])
                check_type(argname="argument memory_gib_per_v_cpu", value=memory_gib_per_v_cpu, expected_type=type_hints["memory_gib_per_v_cpu"])
                check_type(argname="argument memory_mib", value=memory_mib, expected_type=type_hints["memory_mib"])
                check_type(argname="argument network_bandwidth_gbps", value=network_bandwidth_gbps, expected_type=type_hints["network_bandwidth_gbps"])
                check_type(argname="argument network_interface_count", value=network_interface_count, expected_type=type_hints["network_interface_count"])
                check_type(argname="argument on_demand_max_price_percentage_over_lowest_price", value=on_demand_max_price_percentage_over_lowest_price, expected_type=type_hints["on_demand_max_price_percentage_over_lowest_price"])
                check_type(argname="argument require_hibernate_support", value=require_hibernate_support, expected_type=type_hints["require_hibernate_support"])
                check_type(argname="argument spot_max_price_percentage_over_lowest_price", value=spot_max_price_percentage_over_lowest_price, expected_type=type_hints["spot_max_price_percentage_over_lowest_price"])
                check_type(argname="argument total_local_storage_gb", value=total_local_storage_gb, expected_type=type_hints["total_local_storage_gb"])
                check_type(argname="argument v_cpu_count", value=v_cpu_count, expected_type=type_hints["v_cpu_count"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if accelerator_count is not None:
                self._values["accelerator_count"] = accelerator_count
            if accelerator_manufacturers is not None:
                self._values["accelerator_manufacturers"] = accelerator_manufacturers
            if accelerator_names is not None:
                self._values["accelerator_names"] = accelerator_names
            if accelerator_total_memory_mib is not None:
                self._values["accelerator_total_memory_mib"] = accelerator_total_memory_mib
            if accelerator_types is not None:
                self._values["accelerator_types"] = accelerator_types
            if allowed_instance_types is not None:
                self._values["allowed_instance_types"] = allowed_instance_types
            if bare_metal is not None:
                self._values["bare_metal"] = bare_metal
            if baseline_ebs_bandwidth_mbps is not None:
                self._values["baseline_ebs_bandwidth_mbps"] = baseline_ebs_bandwidth_mbps
            if baseline_performance_factors is not None:
                self._values["baseline_performance_factors"] = baseline_performance_factors
            if burstable_performance is not None:
                self._values["burstable_performance"] = burstable_performance
            if cpu_manufacturers is not None:
                self._values["cpu_manufacturers"] = cpu_manufacturers
            if excluded_instance_types is not None:
                self._values["excluded_instance_types"] = excluded_instance_types
            if instance_generations is not None:
                self._values["instance_generations"] = instance_generations
            if local_storage is not None:
                self._values["local_storage"] = local_storage
            if local_storage_types is not None:
                self._values["local_storage_types"] = local_storage_types
            if max_spot_price_as_percentage_of_optimal_on_demand_price is not None:
                self._values["max_spot_price_as_percentage_of_optimal_on_demand_price"] = max_spot_price_as_percentage_of_optimal_on_demand_price
            if memory_gib_per_v_cpu is not None:
                self._values["memory_gib_per_v_cpu"] = memory_gib_per_v_cpu
            if memory_mib is not None:
                self._values["memory_mib"] = memory_mib
            if network_bandwidth_gbps is not None:
                self._values["network_bandwidth_gbps"] = network_bandwidth_gbps
            if network_interface_count is not None:
                self._values["network_interface_count"] = network_interface_count
            if on_demand_max_price_percentage_over_lowest_price is not None:
                self._values["on_demand_max_price_percentage_over_lowest_price"] = on_demand_max_price_percentage_over_lowest_price
            if require_hibernate_support is not None:
                self._values["require_hibernate_support"] = require_hibernate_support
            if spot_max_price_percentage_over_lowest_price is not None:
                self._values["spot_max_price_percentage_over_lowest_price"] = spot_max_price_percentage_over_lowest_price
            if total_local_storage_gb is not None:
                self._values["total_local_storage_gb"] = total_local_storage_gb
            if v_cpu_count is not None:
                self._values["v_cpu_count"] = v_cpu_count

        @builtins.property
        def accelerator_count(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.AcceleratorCountProperty"]]:
            '''The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.

            To exclude accelerator-enabled instance types, set ``Max`` to ``0`` .

            Default: No minimum or maximum limits

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-acceleratorcount
            '''
            result = self._values.get("accelerator_count")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.AcceleratorCountProperty"]], result)

        @builtins.property
        def accelerator_manufacturers(
            self,
        ) -> typing.Optional[typing.List[builtins.str]]:
            '''Indicates whether instance types must have accelerators by specific manufacturers.

            - For instance types with AWS devices, specify ``amazon-web-services`` .
            - For instance types with AMD devices, specify ``amd`` .
            - For instance types with Habana devices, specify ``habana`` .
            - For instance types with NVIDIA devices, specify ``nvidia`` .
            - For instance types with Xilinx devices, specify ``xilinx`` .

            Default: Any manufacturer

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-acceleratormanufacturers
            '''
            result = self._values.get("accelerator_manufacturers")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def accelerator_names(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The accelerators that must be on the instance type.

            - For instance types with NVIDIA A10G GPUs, specify ``a10g`` .
            - For instance types with NVIDIA A100 GPUs, specify ``a100`` .
            - For instance types with NVIDIA H100 GPUs, specify ``h100`` .
            - For instance types with AWS Inferentia chips, specify ``inferentia`` .
            - For instance types with AWS Inferentia2 chips, specify ``inferentia2`` .
            - For instance types with Habana Gaudi HL-205 GPUs, specify ``gaudi-hl-205`` .
            - For instance types with NVIDIA GRID K520 GPUs, specify ``k520`` .
            - For instance types with NVIDIA K80 GPUs, specify ``k80`` .
            - For instance types with NVIDIA L4 GPUs, specify ``l4`` .
            - For instance types with NVIDIA L40S GPUs, specify ``l40s`` .
            - For instance types with NVIDIA M60 GPUs, specify ``m60`` .
            - For instance types with AMD Radeon Pro V520 GPUs, specify ``radeon-pro-v520`` .
            - For instance types with AWS Trainium chips, specify ``trainium`` .
            - For instance types with AWS Trainium2 chips, specify ``trainium2`` .
            - For instance types with NVIDIA T4 GPUs, specify ``t4`` .
            - For instance types with NVIDIA T4G GPUs, specify ``t4g`` .
            - For instance types with Xilinx U30 cards, specify ``u30`` .
            - For instance types with Xilinx VU9P FPGAs, specify ``vu9p`` .
            - For instance types with NVIDIA V100 GPUs, specify ``v100`` .

            Default: Any accelerator

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-acceleratornames
            '''
            result = self._values.get("accelerator_names")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def accelerator_total_memory_mib(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.AcceleratorTotalMemoryMiBProperty"]]:
            '''The minimum and maximum amount of total accelerator memory, in MiB.

            Default: No minimum or maximum limits

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-acceleratortotalmemorymib
            '''
            result = self._values.get("accelerator_total_memory_mib")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.AcceleratorTotalMemoryMiBProperty"]], result)

        @builtins.property
        def accelerator_types(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The accelerator types that must be on the instance type.

            - For instance types with FPGA accelerators, specify ``fpga`` .
            - For instance types with GPU accelerators, specify ``gpu`` .
            - For instance types with Inference accelerators, specify ``inference`` .
            - For instance types with Media accelerators, specify ``media`` .

            Default: Any accelerator type

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-acceleratortypes
            '''
            result = self._values.get("accelerator_types")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def allowed_instance_types(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The instance types to apply your specified attributes against.

            All other instance types are ignored, even if they match your specified attributes.

            You can use strings with one or more wild cards, represented by an asterisk ( ``*`` ), to allow an instance type, size, or generation. The following are examples: ``m5.8xlarge`` , ``c5*.*`` , ``m5a.*`` , ``r*`` , ``*3*`` .

            For example, if you specify ``c5*`` ,Amazon EC2 will allow the entire C5 instance family, which includes all C5a and C5n instance types. If you specify ``m5a.*`` , Amazon EC2 will allow all the M5a instance types, but not the M5n instance types.
            .. epigraph::

               If you specify ``AllowedInstanceTypes`` , you can't specify ``ExcludedInstanceTypes`` .

            Default: All instance types

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-allowedinstancetypes
            '''
            result = self._values.get("allowed_instance_types")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def bare_metal(self) -> typing.Optional[builtins.str]:
            '''Indicates whether bare metal instance types must be included, excluded, or required.

            - To include bare metal instance types, specify ``included`` .
            - To require only bare metal instance types, specify ``required`` .
            - To exclude bare metal instance types, specify ``excluded`` .

            Default: ``excluded``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-baremetal
            '''
            result = self._values.get("bare_metal")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def baseline_ebs_bandwidth_mbps(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.BaselineEbsBandwidthMbpsProperty"]]:
            '''The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps.

            For more information, see `Amazon EBSoptimized instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html>`_ in the *Amazon EC2 User Guide* .

            Default: No minimum or maximum limits

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-baselineebsbandwidthmbps
            '''
            result = self._values.get("baseline_ebs_bandwidth_mbps")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.BaselineEbsBandwidthMbpsProperty"]], result)

        @builtins.property
        def baseline_performance_factors(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.BaselinePerformanceFactorsProperty"]]:
            '''The baseline performance to consider, using an instance family as a baseline reference.

            The instance family establishes the lowest acceptable level of performance. Amazon EC2 uses this baseline to guide instance type selection, but there is no guarantee that the selected instance types will always exceed the baseline for every application. Currently, this parameter only supports CPU performance as a baseline performance factor. For more information, see `Performance protection <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html#ec2fleet-abis-performance-protection>`_ in the *Amazon EC2 User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-baselineperformancefactors
            '''
            result = self._values.get("baseline_performance_factors")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.BaselinePerformanceFactorsProperty"]], result)

        @builtins.property
        def burstable_performance(self) -> typing.Optional[builtins.str]:
            '''Indicates whether burstable performance T instance types are included, excluded, or required.

            For more information, see `Burstable performance instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html>`_ .

            - To include burstable performance instance types, specify ``included`` .
            - To require only burstable performance instance types, specify ``required`` .
            - To exclude burstable performance instance types, specify ``excluded`` .

            Default: ``excluded``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-burstableperformance
            '''
            result = self._values.get("burstable_performance")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def cpu_manufacturers(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The CPU manufacturers to include.

            - For instance types with Intel CPUs, specify ``intel`` .
            - For instance types with AMD CPUs, specify ``amd`` .
            - For instance types with AWS CPUs, specify ``amazon-web-services`` .
            - For instance types with Apple CPUs, specify ``apple`` .

            .. epigraph::

               Don't confuse the CPU manufacturer with the CPU architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.

            Default: Any manufacturer

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-cpumanufacturers
            '''
            result = self._values.get("cpu_manufacturers")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def excluded_instance_types(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The instance types to exclude.

            You can use strings with one or more wild cards, represented by an asterisk ( ``*`` ), to exclude an instance type, size, or generation. The following are examples: ``m5.8xlarge`` , ``c5*.*`` , ``m5a.*`` , ``r*`` , ``*3*`` .

            For example, if you specify ``c5*`` ,Amazon EC2 will exclude the entire C5 instance family, which includes all C5a and C5n instance types. If you specify ``m5a.*`` , Amazon EC2 will exclude all the M5a instance types, but not the M5n instance types.
            .. epigraph::

               If you specify ``ExcludedInstanceTypes`` , you can't specify ``AllowedInstanceTypes`` .

            Default: No excluded instance types

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-excludedinstancetypes
            '''
            result = self._values.get("excluded_instance_types")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def instance_generations(self) -> typing.Optional[typing.List[builtins.str]]:
            '''Indicates whether current or previous generation instance types are included.

            The current generation instance types are recommended for use. Current generation instance types are typically the latest two to three generations in each instance family. For more information, see `Instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html>`_ in the *Amazon EC2 User Guide* .

            For current generation instance types, specify ``current`` .

            For previous generation instance types, specify ``previous`` .

            Default: Current and previous generation instance types

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-instancegenerations
            '''
            result = self._values.get("instance_generations")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def local_storage(self) -> typing.Optional[builtins.str]:
            '''Indicates whether instance types with instance store volumes are included, excluded, or required.

            For more information, `Amazon EC2 instance store <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html>`_ in the *Amazon EC2 User Guide* .

            - To include instance types with instance store volumes, specify ``included`` .
            - To require only instance types with instance store volumes, specify ``required`` .
            - To exclude instance types with instance store volumes, specify ``excluded`` .

            Default: ``included``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-localstorage
            '''
            result = self._values.get("local_storage")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def local_storage_types(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The type of local storage that is required.

            - For instance types with hard disk drive (HDD) storage, specify ``hdd`` .
            - For instance types with solid state drive (SSD) storage, specify ``ssd`` .

            Default: ``hdd`` and ``ssd``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-localstoragetypes
            '''
            result = self._values.get("local_storage_types")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def max_spot_price_as_percentage_of_optimal_on_demand_price(
            self,
        ) -> typing.Optional[jsii.Number]:
            '''[Price protection] The price protection threshold for Spot Instances, as a percentage of an identified On-Demand price.

            The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.

            The parameter accepts an integer, which Amazon EC2 interprets as a percentage.

            If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib`` , the price protection threshold is based on the per vCPU or per memory price instead of the per instance price.
            .. epigraph::

               Only one of ``SpotMaxPricePercentageOverLowestPrice`` or ``MaxSpotPriceAsPercentageOfOptimalOnDemandPrice`` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as ``999999`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-maxspotpriceaspercentageofoptimalondemandprice
            '''
            result = self._values.get("max_spot_price_as_percentage_of_optimal_on_demand_price")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def memory_gib_per_v_cpu(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.MemoryGiBPerVCpuProperty"]]:
            '''The minimum and maximum amount of memory per vCPU, in GiB.

            Default: No minimum or maximum limits

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-memorygibpervcpu
            '''
            result = self._values.get("memory_gib_per_v_cpu")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.MemoryGiBPerVCpuProperty"]], result)

        @builtins.property
        def memory_mib(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.MemoryMiBProperty"]]:
            '''The minimum and maximum amount of memory, in MiB.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-memorymib
            '''
            result = self._values.get("memory_mib")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.MemoryMiBProperty"]], result)

        @builtins.property
        def network_bandwidth_gbps(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.NetworkBandwidthGbpsProperty"]]:
            '''The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps).

            Default: No minimum or maximum limits

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-networkbandwidthgbps
            '''
            result = self._values.get("network_bandwidth_gbps")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.NetworkBandwidthGbpsProperty"]], result)

        @builtins.property
        def network_interface_count(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.NetworkInterfaceCountProperty"]]:
            '''The minimum and maximum number of network interfaces.

            Default: No minimum or maximum limits

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-networkinterfacecount
            '''
            result = self._values.get("network_interface_count")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.NetworkInterfaceCountProperty"]], result)

        @builtins.property
        def on_demand_max_price_percentage_over_lowest_price(
            self,
        ) -> typing.Optional[jsii.Number]:
            '''[Price protection] The price protection threshold for On-Demand Instances, as a percentage higher than an identified On-Demand price.

            The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.

            The parameter accepts an integer, which Amazon EC2 interprets as a percentage.

            To turn off price protection, specify a high value, such as ``999999`` .

            This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ and `GetInstanceTypesFromInstanceRequirements <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html>`_ .
            .. epigraph::

               If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib`` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.

            Default: ``20``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-ondemandmaxpricepercentageoverlowestprice
            '''
            result = self._values.get("on_demand_max_price_percentage_over_lowest_price")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def require_hibernate_support(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether instance types must support hibernation for On-Demand Instances.

            This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ .

            Default: ``false``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-requirehibernatesupport
            '''
            result = self._values.get("require_hibernate_support")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def spot_max_price_percentage_over_lowest_price(
            self,
        ) -> typing.Optional[jsii.Number]:
            '''[Price protection] The price protection threshold for Spot Instances, as a percentage higher than an identified Spot price.

            The identified Spot price is the Spot price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified Spot price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose Spot price exceeds your specified threshold.

            The parameter accepts an integer, which Amazon EC2 interprets as a percentage.

            If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib`` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.

            This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ and `GetInstanceTypesFromInstanceRequirements <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html>`_ .
            .. epigraph::

               Only one of ``SpotMaxPricePercentageOverLowestPrice`` or ``MaxSpotPriceAsPercentageOfOptimalOnDemandPrice`` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as ``999999`` .

            Default: ``100``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-spotmaxpricepercentageoverlowestprice
            '''
            result = self._values.get("spot_max_price_percentage_over_lowest_price")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def total_local_storage_gb(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.TotalLocalStorageGBProperty"]]:
            '''The minimum and maximum amount of total local storage, in GB.

            Default: No minimum or maximum limits

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-totallocalstoragegb
            '''
            result = self._values.get("total_local_storage_gb")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.TotalLocalStorageGBProperty"]], result)

        @builtins.property
        def v_cpu_count(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.VCpuCountProperty"]]:
            '''The minimum and maximum number of vCPUs.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-vcpucount
            '''
            result = self._values.get("v_cpu_count")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.VCpuCountProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "InstanceRequirementsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.Ipv4PrefixSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={"ipv4_prefix": "ipv4Prefix"},
    )
    class Ipv4PrefixSpecificationProperty:
        def __init__(
            self,
            *,
            ipv4_prefix: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies an IPv4 prefix for a network interface.

            ``Ipv4PrefixSpecification`` is a property of `AWS::EC2::LaunchTemplate NetworkInterface <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html>`_ .

            :param ipv4_prefix: The IPv4 prefix. For information, see `Assigning prefixes to network interfaces <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-prefix-eni.html>`_ in the *Amazon EC2 User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ipv4prefixspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                ipv4_prefix_specification_property = ec2_mixins.CfnLaunchTemplatePropsMixin.Ipv4PrefixSpecificationProperty(
                    ipv4_prefix="ipv4Prefix"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__2a69c0e8eb18fd44b77bb8e79c12bf0df266e0e8762c48058dfeb06ddf645ce8)
                check_type(argname="argument ipv4_prefix", value=ipv4_prefix, expected_type=type_hints["ipv4_prefix"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if ipv4_prefix is not None:
                self._values["ipv4_prefix"] = ipv4_prefix

        @builtins.property
        def ipv4_prefix(self) -> typing.Optional[builtins.str]:
            '''The IPv4 prefix.

            For information, see `Assigning prefixes to network interfaces <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-prefix-eni.html>`_ in the *Amazon EC2 User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ipv4prefixspecification.html#cfn-ec2-launchtemplate-ipv4prefixspecification-ipv4prefix
            '''
            result = self._values.get("ipv4_prefix")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "Ipv4PrefixSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.Ipv6AddProperty",
        jsii_struct_bases=[],
        name_mapping={"ipv6_address": "ipv6Address"},
    )
    class Ipv6AddProperty:
        def __init__(
            self,
            *,
            ipv6_address: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies an IPv6 address in an Amazon EC2 launch template.

            ``Ipv6Add`` is a property of `AWS::EC2::LaunchTemplate NetworkInterface <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html>`_ .

            :param ipv6_address: One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. You can't use this option if you're specifying a number of IPv6 addresses.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ipv6add.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                ipv6_add_property = ec2_mixins.CfnLaunchTemplatePropsMixin.Ipv6AddProperty(
                    ipv6_address="ipv6Address"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__99e3fe4fcf40ea358b63611a484a7ec8412d694d24f87eaa14d5642a1a1af141)
                check_type(argname="argument ipv6_address", value=ipv6_address, expected_type=type_hints["ipv6_address"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if ipv6_address is not None:
                self._values["ipv6_address"] = ipv6_address

        @builtins.property
        def ipv6_address(self) -> typing.Optional[builtins.str]:
            '''One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet.

            You can't use this option if you're specifying a number of IPv6 addresses.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ipv6add.html#cfn-ec2-launchtemplate-ipv6add-ipv6address
            '''
            result = self._values.get("ipv6_address")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "Ipv6AddProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.Ipv6PrefixSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={"ipv6_prefix": "ipv6Prefix"},
    )
    class Ipv6PrefixSpecificationProperty:
        def __init__(
            self,
            *,
            ipv6_prefix: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies an IPv6 prefix for a network interface.

            ``Ipv6PrefixSpecification`` is a property of `AWS::EC2::LaunchTemplate NetworkInterface <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html>`_ .

            :param ipv6_prefix: The IPv6 prefix.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ipv6prefixspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                ipv6_prefix_specification_property = ec2_mixins.CfnLaunchTemplatePropsMixin.Ipv6PrefixSpecificationProperty(
                    ipv6_prefix="ipv6Prefix"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__b555e85994591eec38fee9a6e524f83cf30102040ceedf5d8c854d7f2db10764)
                check_type(argname="argument ipv6_prefix", value=ipv6_prefix, expected_type=type_hints["ipv6_prefix"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if ipv6_prefix is not None:
                self._values["ipv6_prefix"] = ipv6_prefix

        @builtins.property
        def ipv6_prefix(self) -> typing.Optional[builtins.str]:
            '''The IPv6 prefix.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ipv6prefixspecification.html#cfn-ec2-launchtemplate-ipv6prefixspecification-ipv6prefix
            '''
            result = self._values.get("ipv6_prefix")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "Ipv6PrefixSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.LaunchTemplateDataProperty",
        jsii_struct_bases=[],
        name_mapping={
            "block_device_mappings": "blockDeviceMappings",
            "capacity_reservation_specification": "capacityReservationSpecification",
            "cpu_options": "cpuOptions",
            "credit_specification": "creditSpecification",
            "disable_api_stop": "disableApiStop",
            "disable_api_termination": "disableApiTermination",
            "ebs_optimized": "ebsOptimized",
            "elastic_gpu_specifications": "elasticGpuSpecifications",
            "elastic_inference_accelerators": "elasticInferenceAccelerators",
            "enclave_options": "enclaveOptions",
            "hibernation_options": "hibernationOptions",
            "iam_instance_profile": "iamInstanceProfile",
            "image_id": "imageId",
            "instance_initiated_shutdown_behavior": "instanceInitiatedShutdownBehavior",
            "instance_market_options": "instanceMarketOptions",
            "instance_requirements": "instanceRequirements",
            "instance_type": "instanceType",
            "kernel_id": "kernelId",
            "key_name": "keyName",
            "license_specifications": "licenseSpecifications",
            "maintenance_options": "maintenanceOptions",
            "metadata_options": "metadataOptions",
            "monitoring": "monitoring",
            "network_interfaces": "networkInterfaces",
            "network_performance_options": "networkPerformanceOptions",
            "placement": "placement",
            "private_dns_name_options": "privateDnsNameOptions",
            "ram_disk_id": "ramDiskId",
            "security_group_ids": "securityGroupIds",
            "security_groups": "securityGroups",
            "tag_specifications": "tagSpecifications",
            "user_data": "userData",
        },
    )
    class LaunchTemplateDataProperty:
        def __init__(
            self,
            *,
            block_device_mappings: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.BlockDeviceMappingProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            capacity_reservation_specification: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.CapacityReservationSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            cpu_options: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.CpuOptionsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            credit_specification: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.CreditSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            disable_api_stop: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            disable_api_termination: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            ebs_optimized: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            elastic_gpu_specifications: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.ElasticGpuSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            elastic_inference_accelerators: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.LaunchTemplateElasticInferenceAcceleratorProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            enclave_options: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.EnclaveOptionsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            hibernation_options: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.HibernationOptionsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            iam_instance_profile: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.IamInstanceProfileProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            image_id: typing.Optional[builtins.str] = None,
            instance_initiated_shutdown_behavior: typing.Optional[builtins.str] = None,
            instance_market_options: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.InstanceMarketOptionsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            instance_requirements: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.InstanceRequirementsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            instance_type: typing.Optional[builtins.str] = None,
            kernel_id: typing.Optional[builtins.str] = None,
            key_name: typing.Optional[builtins.str] = None,
            license_specifications: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.LicenseSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            maintenance_options: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.MaintenanceOptionsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            metadata_options: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.MetadataOptionsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            monitoring: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.MonitoringProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            network_interfaces: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.NetworkInterfaceProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            network_performance_options: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.NetworkPerformanceOptionsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            placement: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.PlacementProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            private_dns_name_options: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.PrivateDnsNameOptionsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            ram_disk_id: typing.Optional[builtins.str] = None,
            security_group_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
            security_groups: typing.Optional[typing.Sequence[builtins.str]] = None,
            tag_specifications: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.TagSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            user_data: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The information to include in the launch template.

            .. epigraph::

               You must specify at least one parameter for the launch template data.

            :param block_device_mappings: The block device mapping.
            :param capacity_reservation_specification: The Capacity Reservation targeting option. If you do not specify this parameter, the instance's Capacity Reservation preference defaults to ``open`` , which enables it to run in any open Capacity Reservation that has matching attributes (instance type, platform, Availability Zone).
            :param cpu_options: The CPU options for the instance. For more information, see `CPU options for Amazon EC2 instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html>`_ in the *Amazon EC2 User Guide* .
            :param credit_specification: The credit option for CPU usage of the instance. Valid only for T instances.
            :param disable_api_stop: Indicates whether to enable the instance for stop protection. For more information, see `Enable stop protection for your EC2 instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-stop-protection.html>`_ in the *Amazon EC2 User Guide* .
            :param disable_api_termination: Indicates whether termination protection is enabled for the instance. The default is ``false`` , which means that you can terminate the instance using the Amazon EC2 console, command line tools, or API. You can enable termination protection when you launch an instance, while the instance is running, or while the instance is stopped.
            :param ebs_optimized: Indicates whether the instance is optimized for Amazon EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.
            :param elastic_gpu_specifications: 
            :param elastic_inference_accelerators: 
            :param enclave_options: Indicates whether the instance is enabled for AWS Nitro Enclaves. For more information, see `What is Nitro Enclaves? <https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html>`_ in the *AWS Nitro Enclaves User Guide* . You can't enable AWS Nitro Enclaves and hibernation on the same instance.
            :param hibernation_options: Indicates whether an instance is enabled for hibernation. This parameter is valid only if the instance meets the `hibernation prerequisites <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/hibernating-prerequisites.html>`_ . For more information, see `Hibernate your Amazon EC2 instance <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html>`_ in the *Amazon EC2 User Guide* .
            :param iam_instance_profile: The name or Amazon Resource Name (ARN) of an IAM instance profile.
            :param image_id: The ID of the AMI. Alternatively, you can specify a Systems Manager parameter, which will resolve to an AMI ID on launch. Valid formats: - ``ami-0ac394d6a3example`` - ``resolve:ssm:parameter-name`` - ``resolve:ssm:parameter-name:version-number`` - ``resolve:ssm:parameter-name:label`` For more information, see `Use a Systems Manager parameter to find an AMI <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/finding-an-ami.html#using-systems-manager-parameter-to-find-AMI>`_ in the *Amazon Elastic Compute Cloud User Guide* .
            :param instance_initiated_shutdown_behavior: Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown). Default: ``stop``
            :param instance_market_options: The market (purchasing) option for the instances.
            :param instance_requirements: The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with these attributes. You must specify ``VCpuCount`` and ``MemoryMiB`` . All other attributes are optional. Any unspecified optional attribute is set to its default. When you specify multiple attributes, you get instance types that satisfy all of the specified attributes. If you specify multiple values for an attribute, you get instance types that satisfy any of the specified values. To limit the list of instance types from which Amazon EC2 can identify matching instance types, you can use one of the following parameters, but not both in the same request: - ``AllowedInstanceTypes`` - The instance types to include in the list. All other instance types are ignored, even if they match your specified attributes. - ``ExcludedInstanceTypes`` - The instance types to exclude from the list, even if they match your specified attributes. .. epigraph:: If you specify ``InstanceRequirements`` , you can't specify ``InstanceType`` . Attribute-based instance type selection is only supported when using Auto Scaling groups, EC2 Fleet, and Spot Fleet to launch instances. If you plan to use the launch template in the `launch instance wizard <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-instance-wizard.html>`_ , or with the `RunInstances <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html>`_ API or `AWS::EC2::Instance <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html>`_ AWS CloudFormation resource, you can't specify ``InstanceRequirements`` . For more information, see `Specify attributes for instance type selection for EC2 Fleet or Spot Fleet <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html>`_ and `Spot placement score <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html>`_ in the *Amazon EC2 User Guide* .
            :param instance_type: The instance type. For more information, see `Amazon EC2 instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html>`_ in the *Amazon EC2 User Guide* . If you specify ``InstanceType`` , you can't specify ``InstanceRequirements`` .
            :param kernel_id: The ID of the kernel. We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see `User Provided Kernels <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html>`_ in the *Amazon EC2 User Guide* .
            :param key_name: The name of the key pair. You can create a key pair using `CreateKeyPair <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html>`_ or `ImportKeyPair <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html>`_ . .. epigraph:: If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.
            :param license_specifications: The license configurations.
            :param maintenance_options: The maintenance options of your instance.
            :param metadata_options: The metadata options for the instance. For more information, see `Configure the Instance Metadata Service options <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/configuring-instance-metadata-options.html>`_ in the *Amazon EC2 User Guide* .
            :param monitoring: The monitoring for the instance.
            :param network_interfaces: The network interfaces for the instance.
            :param network_performance_options: The settings for the network performance options for the instance. For more information, see `EC2 instance bandwidth weighting configuration <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/configure-bandwidth-weighting.html>`_ .
            :param placement: The placement for the instance.
            :param private_dns_name_options: The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries should be handled. For more information, see `Amazon EC2 instance hostname types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .
            :param ram_disk_id: The ID of the RAM disk. .. epigraph:: We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see `User provided kernels <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html>`_ in the *Amazon EC2 User Guide* .
            :param security_group_ids: The IDs of the security groups. You can specify the IDs of existing security groups and references to resources created by the stack template. If you specify a network interface, you must specify any security groups as part of the network interface instead.
            :param security_groups: The names of the security groups. For a nondefault VPC, you must use security group IDs instead. If you specify a network interface, you must specify any security groups as part of the network interface instead of using this parameter.
            :param tag_specifications: The tags to apply to resources that are created during instance launch. To tag the launch template itself, use `TagSpecifications <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#cfn-ec2-launchtemplate-tagspecifications>`_ .
            :param user_data: The user data to make available to the instance. You must provide base64-encoded text. User data is limited to 16 KB. For more information, see `Run commands when you launch an EC2 instance with user data input <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html>`_ in the *Amazon EC2 User Guide* . If you are creating the launch template for use with AWS Batch , the user data must be provided in the `MIME multi-part archive format <https://docs.aws.amazon.com/https://cloudinit.readthedocs.io/en/latest/topics/format.html#mime-multi-part-archive>`_ . For more information, see `Amazon EC2 user data in launch templates <https://docs.aws.amazon.com/batch/latest/userguide/launch-templates.html#lt-user-data>`_ in the *AWS Batch User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html
            :exampleMetadata: fixture=_generated

            Example::

                from aws_cdk import CfnTag
                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                launch_template_data_property = ec2_mixins.CfnLaunchTemplatePropsMixin.LaunchTemplateDataProperty(
                    block_device_mappings=[ec2_mixins.CfnLaunchTemplatePropsMixin.BlockDeviceMappingProperty(
                        device_name="deviceName",
                        ebs=ec2_mixins.CfnLaunchTemplatePropsMixin.EbsProperty(
                            delete_on_termination=False,
                            encrypted=False,
                            iops=123,
                            kms_key_id="kmsKeyId",
                            snapshot_id="snapshotId",
                            throughput=123,
                            volume_initialization_rate=123,
                            volume_size=123,
                            volume_type="volumeType"
                        ),
                        no_device="noDevice",
                        virtual_name="virtualName"
                    )],
                    capacity_reservation_specification=ec2_mixins.CfnLaunchTemplatePropsMixin.CapacityReservationSpecificationProperty(
                        capacity_reservation_preference="capacityReservationPreference",
                        capacity_reservation_target=ec2_mixins.CfnLaunchTemplatePropsMixin.CapacityReservationTargetProperty(
                            capacity_reservation_id="capacityReservationId",
                            capacity_reservation_resource_group_arn="capacityReservationResourceGroupArn"
                        )
                    ),
                    cpu_options=ec2_mixins.CfnLaunchTemplatePropsMixin.CpuOptionsProperty(
                        amd_sev_snp="amdSevSnp",
                        core_count=123,
                        threads_per_core=123
                    ),
                    credit_specification=ec2_mixins.CfnLaunchTemplatePropsMixin.CreditSpecificationProperty(
                        cpu_credits="cpuCredits"
                    ),
                    disable_api_stop=False,
                    disable_api_termination=False,
                    ebs_optimized=False,
                    elastic_gpu_specifications=[ec2_mixins.CfnLaunchTemplatePropsMixin.ElasticGpuSpecificationProperty(
                        type="type"
                    )],
                    elastic_inference_accelerators=[ec2_mixins.CfnLaunchTemplatePropsMixin.LaunchTemplateElasticInferenceAcceleratorProperty(
                        count=123,
                        type="type"
                    )],
                    enclave_options=ec2_mixins.CfnLaunchTemplatePropsMixin.EnclaveOptionsProperty(
                        enabled=False
                    ),
                    hibernation_options=ec2_mixins.CfnLaunchTemplatePropsMixin.HibernationOptionsProperty(
                        configured=False
                    ),
                    iam_instance_profile=ec2_mixins.CfnLaunchTemplatePropsMixin.IamInstanceProfileProperty(
                        arn="arn",
                        name="name"
                    ),
                    image_id="imageId",
                    instance_initiated_shutdown_behavior="instanceInitiatedShutdownBehavior",
                    instance_market_options=ec2_mixins.CfnLaunchTemplatePropsMixin.InstanceMarketOptionsProperty(
                        market_type="marketType",
                        spot_options=ec2_mixins.CfnLaunchTemplatePropsMixin.SpotOptionsProperty(
                            block_duration_minutes=123,
                            instance_interruption_behavior="instanceInterruptionBehavior",
                            max_price="maxPrice",
                            spot_instance_type="spotInstanceType",
                            valid_until="validUntil"
                        )
                    ),
                    instance_requirements=ec2_mixins.CfnLaunchTemplatePropsMixin.InstanceRequirementsProperty(
                        accelerator_count=ec2_mixins.CfnLaunchTemplatePropsMixin.AcceleratorCountProperty(
                            max=123,
                            min=123
                        ),
                        accelerator_manufacturers=["acceleratorManufacturers"],
                        accelerator_names=["acceleratorNames"],
                        accelerator_total_memory_mi_b=ec2_mixins.CfnLaunchTemplatePropsMixin.AcceleratorTotalMemoryMiBProperty(
                            max=123,
                            min=123
                        ),
                        accelerator_types=["acceleratorTypes"],
                        allowed_instance_types=["allowedInstanceTypes"],
                        bare_metal="bareMetal",
                        baseline_ebs_bandwidth_mbps=ec2_mixins.CfnLaunchTemplatePropsMixin.BaselineEbsBandwidthMbpsProperty(
                            max=123,
                            min=123
                        ),
                        baseline_performance_factors=ec2_mixins.CfnLaunchTemplatePropsMixin.BaselinePerformanceFactorsProperty(
                            cpu=ec2_mixins.CfnLaunchTemplatePropsMixin.CpuProperty(
                                references=[ec2_mixins.CfnLaunchTemplatePropsMixin.ReferenceProperty(
                                    instance_family="instanceFamily"
                                )]
                            )
                        ),
                        burstable_performance="burstablePerformance",
                        cpu_manufacturers=["cpuManufacturers"],
                        excluded_instance_types=["excludedInstanceTypes"],
                        instance_generations=["instanceGenerations"],
                        local_storage="localStorage",
                        local_storage_types=["localStorageTypes"],
                        max_spot_price_as_percentage_of_optimal_on_demand_price=123,
                        memory_gi_bPer_vCpu=ec2_mixins.CfnLaunchTemplatePropsMixin.MemoryGiBPerVCpuProperty(
                            max=123,
                            min=123
                        ),
                        memory_mi_b=ec2_mixins.CfnLaunchTemplatePropsMixin.MemoryMiBProperty(
                            max=123,
                            min=123
                        ),
                        network_bandwidth_gbps=ec2_mixins.CfnLaunchTemplatePropsMixin.NetworkBandwidthGbpsProperty(
                            max=123,
                            min=123
                        ),
                        network_interface_count=ec2_mixins.CfnLaunchTemplatePropsMixin.NetworkInterfaceCountProperty(
                            max=123,
                            min=123
                        ),
                        on_demand_max_price_percentage_over_lowest_price=123,
                        require_hibernate_support=False,
                        spot_max_price_percentage_over_lowest_price=123,
                        total_local_storage_gb=ec2_mixins.CfnLaunchTemplatePropsMixin.TotalLocalStorageGBProperty(
                            max=123,
                            min=123
                        ),
                        v_cpu_count=ec2_mixins.CfnLaunchTemplatePropsMixin.VCpuCountProperty(
                            max=123,
                            min=123
                        )
                    ),
                    instance_type="instanceType",
                    kernel_id="kernelId",
                    key_name="keyName",
                    license_specifications=[ec2_mixins.CfnLaunchTemplatePropsMixin.LicenseSpecificationProperty(
                        license_configuration_arn="licenseConfigurationArn"
                    )],
                    maintenance_options=ec2_mixins.CfnLaunchTemplatePropsMixin.MaintenanceOptionsProperty(
                        auto_recovery="autoRecovery"
                    ),
                    metadata_options=ec2_mixins.CfnLaunchTemplatePropsMixin.MetadataOptionsProperty(
                        http_endpoint="httpEndpoint",
                        http_protocol_ipv6="httpProtocolIpv6",
                        http_put_response_hop_limit=123,
                        http_tokens="httpTokens",
                        instance_metadata_tags="instanceMetadataTags"
                    ),
                    monitoring=ec2_mixins.CfnLaunchTemplatePropsMixin.MonitoringProperty(
                        enabled=False
                    ),
                    network_interfaces=[ec2_mixins.CfnLaunchTemplatePropsMixin.NetworkInterfaceProperty(
                        associate_carrier_ip_address=False,
                        associate_public_ip_address=False,
                        connection_tracking_specification=ec2_mixins.CfnLaunchTemplatePropsMixin.ConnectionTrackingSpecificationProperty(
                            tcp_established_timeout=123,
                            udp_stream_timeout=123,
                            udp_timeout=123
                        ),
                        delete_on_termination=False,
                        description="description",
                        device_index=123,
                        ena_queue_count=123,
                        ena_srd_specification=ec2_mixins.CfnLaunchTemplatePropsMixin.EnaSrdSpecificationProperty(
                            ena_srd_enabled=False,
                            ena_srd_udp_specification=ec2_mixins.CfnLaunchTemplatePropsMixin.EnaSrdUdpSpecificationProperty(
                                ena_srd_udp_enabled=False
                            )
                        ),
                        groups=["groups"],
                        interface_type="interfaceType",
                        ipv4_prefix_count=123,
                        ipv4_prefixes=[ec2_mixins.CfnLaunchTemplatePropsMixin.Ipv4PrefixSpecificationProperty(
                            ipv4_prefix="ipv4Prefix"
                        )],
                        ipv6_address_count=123,
                        ipv6_addresses=[ec2_mixins.CfnLaunchTemplatePropsMixin.Ipv6AddProperty(
                            ipv6_address="ipv6Address"
                        )],
                        ipv6_prefix_count=123,
                        ipv6_prefixes=[ec2_mixins.CfnLaunchTemplatePropsMixin.Ipv6PrefixSpecificationProperty(
                            ipv6_prefix="ipv6Prefix"
                        )],
                        network_card_index=123,
                        network_interface_id="networkInterfaceId",
                        primary_ipv6=False,
                        private_ip_address="privateIpAddress",
                        private_ip_addresses=[ec2_mixins.CfnLaunchTemplatePropsMixin.PrivateIpAddProperty(
                            primary=False,
                            private_ip_address="privateIpAddress"
                        )],
                        secondary_private_ip_address_count=123,
                        subnet_id="subnetId"
                    )],
                    network_performance_options=ec2_mixins.CfnLaunchTemplatePropsMixin.NetworkPerformanceOptionsProperty(
                        bandwidth_weighting="bandwidthWeighting"
                    ),
                    placement=ec2_mixins.CfnLaunchTemplatePropsMixin.PlacementProperty(
                        affinity="affinity",
                        availability_zone="availabilityZone",
                        group_id="groupId",
                        group_name="groupName",
                        host_id="hostId",
                        host_resource_group_arn="hostResourceGroupArn",
                        partition_number=123,
                        spread_domain="spreadDomain",
                        tenancy="tenancy"
                    ),
                    private_dns_name_options=ec2_mixins.CfnLaunchTemplatePropsMixin.PrivateDnsNameOptionsProperty(
                        enable_resource_name_dns_aaaa_record=False,
                        enable_resource_name_dns_aRecord=False,
                        hostname_type="hostnameType"
                    ),
                    ram_disk_id="ramDiskId",
                    security_group_ids=["securityGroupIds"],
                    security_groups=["securityGroups"],
                    tag_specifications=[ec2_mixins.CfnLaunchTemplatePropsMixin.TagSpecificationProperty(
                        resource_type="resourceType",
                        tags=[CfnTag(
                            key="key",
                            value="value"
                        )]
                    )],
                    user_data="userData"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__0bfc269af1eefdc1cdc9fb233a656e9e25b85b36db90447b3088bad27841bfcb)
                check_type(argname="argument block_device_mappings", value=block_device_mappings, expected_type=type_hints["block_device_mappings"])
                check_type(argname="argument capacity_reservation_specification", value=capacity_reservation_specification, expected_type=type_hints["capacity_reservation_specification"])
                check_type(argname="argument cpu_options", value=cpu_options, expected_type=type_hints["cpu_options"])
                check_type(argname="argument credit_specification", value=credit_specification, expected_type=type_hints["credit_specification"])
                check_type(argname="argument disable_api_stop", value=disable_api_stop, expected_type=type_hints["disable_api_stop"])
                check_type(argname="argument disable_api_termination", value=disable_api_termination, expected_type=type_hints["disable_api_termination"])
                check_type(argname="argument ebs_optimized", value=ebs_optimized, expected_type=type_hints["ebs_optimized"])
                check_type(argname="argument elastic_gpu_specifications", value=elastic_gpu_specifications, expected_type=type_hints["elastic_gpu_specifications"])
                check_type(argname="argument elastic_inference_accelerators", value=elastic_inference_accelerators, expected_type=type_hints["elastic_inference_accelerators"])
                check_type(argname="argument enclave_options", value=enclave_options, expected_type=type_hints["enclave_options"])
                check_type(argname="argument hibernation_options", value=hibernation_options, expected_type=type_hints["hibernation_options"])
                check_type(argname="argument iam_instance_profile", value=iam_instance_profile, expected_type=type_hints["iam_instance_profile"])
                check_type(argname="argument image_id", value=image_id, expected_type=type_hints["image_id"])
                check_type(argname="argument instance_initiated_shutdown_behavior", value=instance_initiated_shutdown_behavior, expected_type=type_hints["instance_initiated_shutdown_behavior"])
                check_type(argname="argument instance_market_options", value=instance_market_options, expected_type=type_hints["instance_market_options"])
                check_type(argname="argument instance_requirements", value=instance_requirements, expected_type=type_hints["instance_requirements"])
                check_type(argname="argument instance_type", value=instance_type, expected_type=type_hints["instance_type"])
                check_type(argname="argument kernel_id", value=kernel_id, expected_type=type_hints["kernel_id"])
                check_type(argname="argument key_name", value=key_name, expected_type=type_hints["key_name"])
                check_type(argname="argument license_specifications", value=license_specifications, expected_type=type_hints["license_specifications"])
                check_type(argname="argument maintenance_options", value=maintenance_options, expected_type=type_hints["maintenance_options"])
                check_type(argname="argument metadata_options", value=metadata_options, expected_type=type_hints["metadata_options"])
                check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
                check_type(argname="argument network_interfaces", value=network_interfaces, expected_type=type_hints["network_interfaces"])
                check_type(argname="argument network_performance_options", value=network_performance_options, expected_type=type_hints["network_performance_options"])
                check_type(argname="argument placement", value=placement, expected_type=type_hints["placement"])
                check_type(argname="argument private_dns_name_options", value=private_dns_name_options, expected_type=type_hints["private_dns_name_options"])
                check_type(argname="argument ram_disk_id", value=ram_disk_id, expected_type=type_hints["ram_disk_id"])
                check_type(argname="argument security_group_ids", value=security_group_ids, expected_type=type_hints["security_group_ids"])
                check_type(argname="argument security_groups", value=security_groups, expected_type=type_hints["security_groups"])
                check_type(argname="argument tag_specifications", value=tag_specifications, expected_type=type_hints["tag_specifications"])
                check_type(argname="argument user_data", value=user_data, expected_type=type_hints["user_data"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if block_device_mappings is not None:
                self._values["block_device_mappings"] = block_device_mappings
            if capacity_reservation_specification is not None:
                self._values["capacity_reservation_specification"] = capacity_reservation_specification
            if cpu_options is not None:
                self._values["cpu_options"] = cpu_options
            if credit_specification is not None:
                self._values["credit_specification"] = credit_specification
            if disable_api_stop is not None:
                self._values["disable_api_stop"] = disable_api_stop
            if disable_api_termination is not None:
                self._values["disable_api_termination"] = disable_api_termination
            if ebs_optimized is not None:
                self._values["ebs_optimized"] = ebs_optimized
            if elastic_gpu_specifications is not None:
                self._values["elastic_gpu_specifications"] = elastic_gpu_specifications
            if elastic_inference_accelerators is not None:
                self._values["elastic_inference_accelerators"] = elastic_inference_accelerators
            if enclave_options is not None:
                self._values["enclave_options"] = enclave_options
            if hibernation_options is not None:
                self._values["hibernation_options"] = hibernation_options
            if iam_instance_profile is not None:
                self._values["iam_instance_profile"] = iam_instance_profile
            if image_id is not None:
                self._values["image_id"] = image_id
            if instance_initiated_shutdown_behavior is not None:
                self._values["instance_initiated_shutdown_behavior"] = instance_initiated_shutdown_behavior
            if instance_market_options is not None:
                self._values["instance_market_options"] = instance_market_options
            if instance_requirements is not None:
                self._values["instance_requirements"] = instance_requirements
            if instance_type is not None:
                self._values["instance_type"] = instance_type
            if kernel_id is not None:
                self._values["kernel_id"] = kernel_id
            if key_name is not None:
                self._values["key_name"] = key_name
            if license_specifications is not None:
                self._values["license_specifications"] = license_specifications
            if maintenance_options is not None:
                self._values["maintenance_options"] = maintenance_options
            if metadata_options is not None:
                self._values["metadata_options"] = metadata_options
            if monitoring is not None:
                self._values["monitoring"] = monitoring
            if network_interfaces is not None:
                self._values["network_interfaces"] = network_interfaces
            if network_performance_options is not None:
                self._values["network_performance_options"] = network_performance_options
            if placement is not None:
                self._values["placement"] = placement
            if private_dns_name_options is not None:
                self._values["private_dns_name_options"] = private_dns_name_options
            if ram_disk_id is not None:
                self._values["ram_disk_id"] = ram_disk_id
            if security_group_ids is not None:
                self._values["security_group_ids"] = security_group_ids
            if security_groups is not None:
                self._values["security_groups"] = security_groups
            if tag_specifications is not None:
                self._values["tag_specifications"] = tag_specifications
            if user_data is not None:
                self._values["user_data"] = user_data

        @builtins.property
        def block_device_mappings(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.BlockDeviceMappingProperty"]]]]:
            '''The block device mapping.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-blockdevicemappings
            '''
            result = self._values.get("block_device_mappings")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.BlockDeviceMappingProperty"]]]], result)

        @builtins.property
        def capacity_reservation_specification(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.CapacityReservationSpecificationProperty"]]:
            '''The Capacity Reservation targeting option.

            If you do not specify this parameter, the instance's Capacity Reservation preference defaults to ``open`` , which enables it to run in any open Capacity Reservation that has matching attributes (instance type, platform, Availability Zone).

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-capacityreservationspecification
            '''
            result = self._values.get("capacity_reservation_specification")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.CapacityReservationSpecificationProperty"]], result)

        @builtins.property
        def cpu_options(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.CpuOptionsProperty"]]:
            '''The CPU options for the instance.

            For more information, see `CPU options for Amazon EC2 instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html>`_ in the *Amazon EC2 User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-cpuoptions
            '''
            result = self._values.get("cpu_options")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.CpuOptionsProperty"]], result)

        @builtins.property
        def credit_specification(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.CreditSpecificationProperty"]]:
            '''The credit option for CPU usage of the instance.

            Valid only for T instances.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-creditspecification
            '''
            result = self._values.get("credit_specification")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.CreditSpecificationProperty"]], result)

        @builtins.property
        def disable_api_stop(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether to enable the instance for stop protection.

            For more information, see `Enable stop protection for your EC2 instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-stop-protection.html>`_ in the *Amazon EC2 User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-disableapistop
            '''
            result = self._values.get("disable_api_stop")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def disable_api_termination(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether termination protection is enabled for the instance.

            The default is ``false`` , which means that you can terminate the instance using the Amazon EC2 console, command line tools, or API. You can enable termination protection when you launch an instance, while the instance is running, or while the instance is stopped.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-disableapitermination
            '''
            result = self._values.get("disable_api_termination")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def ebs_optimized(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether the instance is optimized for Amazon EBS I/O.

            This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-ebsoptimized
            '''
            result = self._values.get("ebs_optimized")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def elastic_gpu_specifications(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.ElasticGpuSpecificationProperty"]]]]:
            '''
            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-elasticgpuspecifications
            '''
            result = self._values.get("elastic_gpu_specifications")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.ElasticGpuSpecificationProperty"]]]], result)

        @builtins.property
        def elastic_inference_accelerators(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.LaunchTemplateElasticInferenceAcceleratorProperty"]]]]:
            '''
            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-elasticinferenceaccelerators
            '''
            result = self._values.get("elastic_inference_accelerators")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.LaunchTemplateElasticInferenceAcceleratorProperty"]]]], result)

        @builtins.property
        def enclave_options(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.EnclaveOptionsProperty"]]:
            '''Indicates whether the instance is enabled for AWS Nitro Enclaves.

            For more information, see `What is Nitro Enclaves? <https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html>`_ in the *AWS Nitro Enclaves User Guide* .

            You can't enable AWS Nitro Enclaves and hibernation on the same instance.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-enclaveoptions
            '''
            result = self._values.get("enclave_options")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.EnclaveOptionsProperty"]], result)

        @builtins.property
        def hibernation_options(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.HibernationOptionsProperty"]]:
            '''Indicates whether an instance is enabled for hibernation.

            This parameter is valid only if the instance meets the `hibernation prerequisites <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/hibernating-prerequisites.html>`_ . For more information, see `Hibernate your Amazon EC2 instance <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html>`_ in the *Amazon EC2 User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-hibernationoptions
            '''
            result = self._values.get("hibernation_options")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.HibernationOptionsProperty"]], result)

        @builtins.property
        def iam_instance_profile(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.IamInstanceProfileProperty"]]:
            '''The name or Amazon Resource Name (ARN) of an IAM instance profile.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-iaminstanceprofile
            '''
            result = self._values.get("iam_instance_profile")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.IamInstanceProfileProperty"]], result)

        @builtins.property
        def image_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the AMI.

            Alternatively, you can specify a Systems Manager parameter, which will resolve to an AMI ID on launch.

            Valid formats:

            - ``ami-0ac394d6a3example``
            - ``resolve:ssm:parameter-name``
            - ``resolve:ssm:parameter-name:version-number``
            - ``resolve:ssm:parameter-name:label``

            For more information, see `Use a Systems Manager parameter to find an AMI <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/finding-an-ami.html#using-systems-manager-parameter-to-find-AMI>`_ in the *Amazon Elastic Compute Cloud User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-imageid
            '''
            result = self._values.get("image_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def instance_initiated_shutdown_behavior(self) -> typing.Optional[builtins.str]:
            '''Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).

            Default: ``stop``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-instanceinitiatedshutdownbehavior
            '''
            result = self._values.get("instance_initiated_shutdown_behavior")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def instance_market_options(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.InstanceMarketOptionsProperty"]]:
            '''The market (purchasing) option for the instances.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-instancemarketoptions
            '''
            result = self._values.get("instance_market_options")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.InstanceMarketOptionsProperty"]], result)

        @builtins.property
        def instance_requirements(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.InstanceRequirementsProperty"]]:
            '''The attributes for the instance types.

            When you specify instance attributes, Amazon EC2 will identify instance types with these attributes.

            You must specify ``VCpuCount`` and ``MemoryMiB`` . All other attributes are optional. Any unspecified optional attribute is set to its default.

            When you specify multiple attributes, you get instance types that satisfy all of the specified attributes. If you specify multiple values for an attribute, you get instance types that satisfy any of the specified values.

            To limit the list of instance types from which Amazon EC2 can identify matching instance types, you can use one of the following parameters, but not both in the same request:

            - ``AllowedInstanceTypes`` - The instance types to include in the list. All other instance types are ignored, even if they match your specified attributes.
            - ``ExcludedInstanceTypes`` - The instance types to exclude from the list, even if they match your specified attributes.

            .. epigraph::

               If you specify ``InstanceRequirements`` , you can't specify ``InstanceType`` .

               Attribute-based instance type selection is only supported when using Auto Scaling groups, EC2 Fleet, and Spot Fleet to launch instances. If you plan to use the launch template in the `launch instance wizard <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-instance-wizard.html>`_ , or with the `RunInstances <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html>`_ API or `AWS::EC2::Instance <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html>`_ AWS CloudFormation resource, you can't specify ``InstanceRequirements`` .

            For more information, see `Specify attributes for instance type selection for EC2 Fleet or Spot Fleet <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html>`_ and `Spot placement score <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html>`_ in the *Amazon EC2 User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-instancerequirements
            '''
            result = self._values.get("instance_requirements")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.InstanceRequirementsProperty"]], result)

        @builtins.property
        def instance_type(self) -> typing.Optional[builtins.str]:
            '''The instance type. For more information, see `Amazon EC2 instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html>`_ in the *Amazon EC2 User Guide* .

            If you specify ``InstanceType`` , you can't specify ``InstanceRequirements`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-instancetype
            '''
            result = self._values.get("instance_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def kernel_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the kernel.

            We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see `User Provided Kernels <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html>`_ in the *Amazon EC2 User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-kernelid
            '''
            result = self._values.get("kernel_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def key_name(self) -> typing.Optional[builtins.str]:
            '''The name of the key pair. You can create a key pair using `CreateKeyPair <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html>`_ or `ImportKeyPair <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html>`_ .

            .. epigraph::

               If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-keyname
            '''
            result = self._values.get("key_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def license_specifications(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.LicenseSpecificationProperty"]]]]:
            '''The license configurations.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-licensespecifications
            '''
            result = self._values.get("license_specifications")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.LicenseSpecificationProperty"]]]], result)

        @builtins.property
        def maintenance_options(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.MaintenanceOptionsProperty"]]:
            '''The maintenance options of your instance.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-maintenanceoptions
            '''
            result = self._values.get("maintenance_options")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.MaintenanceOptionsProperty"]], result)

        @builtins.property
        def metadata_options(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.MetadataOptionsProperty"]]:
            '''The metadata options for the instance.

            For more information, see `Configure the Instance Metadata Service options <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/configuring-instance-metadata-options.html>`_ in the *Amazon EC2 User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-metadataoptions
            '''
            result = self._values.get("metadata_options")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.MetadataOptionsProperty"]], result)

        @builtins.property
        def monitoring(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.MonitoringProperty"]]:
            '''The monitoring for the instance.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-monitoring
            '''
            result = self._values.get("monitoring")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.MonitoringProperty"]], result)

        @builtins.property
        def network_interfaces(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.NetworkInterfaceProperty"]]]]:
            '''The network interfaces for the instance.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-networkinterfaces
            '''
            result = self._values.get("network_interfaces")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.NetworkInterfaceProperty"]]]], result)

        @builtins.property
        def network_performance_options(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.NetworkPerformanceOptionsProperty"]]:
            '''The settings for the network performance options for the instance.

            For more information, see `EC2 instance bandwidth weighting configuration <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/configure-bandwidth-weighting.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-networkperformanceoptions
            '''
            result = self._values.get("network_performance_options")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.NetworkPerformanceOptionsProperty"]], result)

        @builtins.property
        def placement(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.PlacementProperty"]]:
            '''The placement for the instance.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-placement
            '''
            result = self._values.get("placement")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.PlacementProperty"]], result)

        @builtins.property
        def private_dns_name_options(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.PrivateDnsNameOptionsProperty"]]:
            '''The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries should be handled.

            For more information, see `Amazon EC2 instance hostname types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-privatednsnameoptions
            '''
            result = self._values.get("private_dns_name_options")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.PrivateDnsNameOptionsProperty"]], result)

        @builtins.property
        def ram_disk_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the RAM disk.

            .. epigraph::

               We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see `User provided kernels <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html>`_ in the *Amazon EC2 User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-ramdiskid
            '''
            result = self._values.get("ram_disk_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def security_group_ids(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The IDs of the security groups.

            You can specify the IDs of existing security groups and references to resources created by the stack template.

            If you specify a network interface, you must specify any security groups as part of the network interface instead.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-securitygroupids
            '''
            result = self._values.get("security_group_ids")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def security_groups(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The names of the security groups. For a nondefault VPC, you must use security group IDs instead.

            If you specify a network interface, you must specify any security groups as part of the network interface instead of using this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-securitygroups
            '''
            result = self._values.get("security_groups")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def tag_specifications(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.TagSpecificationProperty"]]]]:
            '''The tags to apply to resources that are created during instance launch.

            To tag the launch template itself, use `TagSpecifications <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#cfn-ec2-launchtemplate-tagspecifications>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-tagspecifications
            '''
            result = self._values.get("tag_specifications")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.TagSpecificationProperty"]]]], result)

        @builtins.property
        def user_data(self) -> typing.Optional[builtins.str]:
            '''The user data to make available to the instance.

            You must provide base64-encoded text. User data is limited to 16 KB. For more information, see `Run commands when you launch an EC2 instance with user data input <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html>`_ in the *Amazon EC2 User Guide* .

            If you are creating the launch template for use with AWS Batch , the user data must be provided in the `MIME multi-part archive format <https://docs.aws.amazon.com/https://cloudinit.readthedocs.io/en/latest/topics/format.html#mime-multi-part-archive>`_ . For more information, see `Amazon EC2 user data in launch templates <https://docs.aws.amazon.com/batch/latest/userguide/launch-templates.html#lt-user-data>`_ in the *AWS Batch User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-userdata
            '''
            result = self._values.get("user_data")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "LaunchTemplateDataProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.LaunchTemplateElasticInferenceAcceleratorProperty",
        jsii_struct_bases=[],
        name_mapping={"count": "count", "type": "type"},
    )
    class LaunchTemplateElasticInferenceAcceleratorProperty:
        def __init__(
            self,
            *,
            count: typing.Optional[jsii.Number] = None,
            type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''
            :param count: 
            :param type: 

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplateelasticinferenceaccelerator.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                launch_template_elastic_inference_accelerator_property = ec2_mixins.CfnLaunchTemplatePropsMixin.LaunchTemplateElasticInferenceAcceleratorProperty(
                    count=123,
                    type="type"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__ef42cf24e5e695d25947fdcf54f22f0735b874b1e66b0f5c7b2164beedd69987)
                check_type(argname="argument count", value=count, expected_type=type_hints["count"])
                check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if count is not None:
                self._values["count"] = count
            if type is not None:
                self._values["type"] = type

        @builtins.property
        def count(self) -> typing.Optional[jsii.Number]:
            '''
            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplateelasticinferenceaccelerator.html#cfn-ec2-launchtemplate-launchtemplateelasticinferenceaccelerator-count
            '''
            result = self._values.get("count")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def type(self) -> typing.Optional[builtins.str]:
            '''
            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplateelasticinferenceaccelerator.html#cfn-ec2-launchtemplate-launchtemplateelasticinferenceaccelerator-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "LaunchTemplateElasticInferenceAcceleratorProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.LaunchTemplateTagSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={"resource_type": "resourceType", "tags": "tags"},
    )
    class LaunchTemplateTagSpecificationProperty:
        def __init__(
            self,
            *,
            resource_type: typing.Optional[builtins.str] = None,
            tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Specifies the tags to apply to the launch template during creation.

            To specify the tags for the resources that are created during instance launch, use `AWS::EC2::LaunchTemplate TagSpecification <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-tagspecification.html>`_ .

            ``LaunchTemplateTagSpecification`` is a property of `AWS::EC2::LaunchTemplate <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html>`_ .

            :param resource_type: The type of resource. To tag a launch template, ``ResourceType`` must be ``launch-template`` .
            :param tags: The tags for the resource.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatetagspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                from aws_cdk import CfnTag
                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                launch_template_tag_specification_property = ec2_mixins.CfnLaunchTemplatePropsMixin.LaunchTemplateTagSpecificationProperty(
                    resource_type="resourceType",
                    tags=[CfnTag(
                        key="key",
                        value="value"
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__ba722af32047e934c636844fb1cb7a233bbb4ca5dfd737e73e54af58edbaaeb3)
                check_type(argname="argument resource_type", value=resource_type, expected_type=type_hints["resource_type"])
                check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if resource_type is not None:
                self._values["resource_type"] = resource_type
            if tags is not None:
                self._values["tags"] = tags

        @builtins.property
        def resource_type(self) -> typing.Optional[builtins.str]:
            '''The type of resource.

            To tag a launch template, ``ResourceType`` must be ``launch-template`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatetagspecification.html#cfn-ec2-launchtemplate-launchtemplatetagspecification-resourcetype
            '''
            result = self._values.get("resource_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
            '''The tags for the resource.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatetagspecification.html#cfn-ec2-launchtemplate-launchtemplatetagspecification-tags
            '''
            result = self._values.get("tags")
            return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "LaunchTemplateTagSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.LicenseSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={"license_configuration_arn": "licenseConfigurationArn"},
    )
    class LicenseSpecificationProperty:
        def __init__(
            self,
            *,
            license_configuration_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies a license configuration for an instance.

            ``LicenseSpecification`` is a property of `AWS::EC2::LaunchTemplate LaunchTemplateData <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html>`_ .

            :param license_configuration_arn: The Amazon Resource Name (ARN) of the license configuration.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-licensespecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                license_specification_property = ec2_mixins.CfnLaunchTemplatePropsMixin.LicenseSpecificationProperty(
                    license_configuration_arn="licenseConfigurationArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__f33cf57d80fddde60e907a3ddfe637125f32e24d17180e902a7febbdcdf72b13)
                check_type(argname="argument license_configuration_arn", value=license_configuration_arn, expected_type=type_hints["license_configuration_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if license_configuration_arn is not None:
                self._values["license_configuration_arn"] = license_configuration_arn

        @builtins.property
        def license_configuration_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the license configuration.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-licensespecification.html#cfn-ec2-launchtemplate-licensespecification-licenseconfigurationarn
            '''
            result = self._values.get("license_configuration_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "LicenseSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.MaintenanceOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={"auto_recovery": "autoRecovery"},
    )
    class MaintenanceOptionsProperty:
        def __init__(
            self,
            *,
            auto_recovery: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The maintenance options of your instance.

            :param auto_recovery: Disables the automatic recovery behavior of your instance or sets it to default.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-maintenanceoptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                maintenance_options_property = ec2_mixins.CfnLaunchTemplatePropsMixin.MaintenanceOptionsProperty(
                    auto_recovery="autoRecovery"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__5654590e83d3e61560ceed84eb56e77f7817347b859a99aadb3cd04a2c82a501)
                check_type(argname="argument auto_recovery", value=auto_recovery, expected_type=type_hints["auto_recovery"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if auto_recovery is not None:
                self._values["auto_recovery"] = auto_recovery

        @builtins.property
        def auto_recovery(self) -> typing.Optional[builtins.str]:
            '''Disables the automatic recovery behavior of your instance or sets it to default.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-maintenanceoptions.html#cfn-ec2-launchtemplate-maintenanceoptions-autorecovery
            '''
            result = self._values.get("auto_recovery")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "MaintenanceOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.MemoryGiBPerVCpuProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class MemoryGiBPerVCpuProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum amount of memory per vCPU, in GiB.

            :param max: The maximum amount of memory per vCPU, in GiB. To specify no maximum limit, omit this parameter.
            :param min: The minimum amount of memory per vCPU, in GiB. To specify no minimum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-memorygibpervcpu.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                memory_gi_bPer_vCpu_property = ec2_mixins.CfnLaunchTemplatePropsMixin.MemoryGiBPerVCpuProperty(
                    max=123,
                    min=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__d7559d641b2c1163d8c661812952517982b292b2ad3e227d413c2dd3bdb4a603)
                check_type(argname="argument max", value=max, expected_type=type_hints["max"])
                check_type(argname="argument min", value=min, expected_type=type_hints["min"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum amount of memory per vCPU, in GiB.

            To specify no maximum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-memorygibpervcpu.html#cfn-ec2-launchtemplate-memorygibpervcpu-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum amount of memory per vCPU, in GiB.

            To specify no minimum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-memorygibpervcpu.html#cfn-ec2-launchtemplate-memorygibpervcpu-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "MemoryGiBPerVCpuProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.MemoryMiBProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class MemoryMiBProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum amount of memory, in MiB.

            :param max: The maximum amount of memory, in MiB. To specify no maximum limit, omit this parameter.
            :param min: The minimum amount of memory, in MiB. To specify no minimum limit, specify ``0`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-memorymib.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                memory_mi_bProperty = ec2_mixins.CfnLaunchTemplatePropsMixin.MemoryMiBProperty(
                    max=123,
                    min=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__ebc01c0d1c391f6b7979a47eec84dac262d9320c2dd94ea9ba4682d9f015cfb9)
                check_type(argname="argument max", value=max, expected_type=type_hints["max"])
                check_type(argname="argument min", value=min, expected_type=type_hints["min"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum amount of memory, in MiB.

            To specify no maximum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-memorymib.html#cfn-ec2-launchtemplate-memorymib-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum amount of memory, in MiB.

            To specify no minimum limit, specify ``0`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-memorymib.html#cfn-ec2-launchtemplate-memorymib-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "MemoryMiBProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.MetadataOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "http_endpoint": "httpEndpoint",
            "http_protocol_ipv6": "httpProtocolIpv6",
            "http_put_response_hop_limit": "httpPutResponseHopLimit",
            "http_tokens": "httpTokens",
            "instance_metadata_tags": "instanceMetadataTags",
        },
    )
    class MetadataOptionsProperty:
        def __init__(
            self,
            *,
            http_endpoint: typing.Optional[builtins.str] = None,
            http_protocol_ipv6: typing.Optional[builtins.str] = None,
            http_put_response_hop_limit: typing.Optional[jsii.Number] = None,
            http_tokens: typing.Optional[builtins.str] = None,
            instance_metadata_tags: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The metadata options for the instance.

            For more information, see `Instance metadata and user data <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html>`_ in the *Amazon EC2 User Guide* .

            ``MetadataOptions`` is a property of `AWS::EC2::LaunchTemplate LaunchTemplateData <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html>`_ .

            :param http_endpoint: Enables or disables the HTTP metadata endpoint on your instances. If the parameter is not specified, the default state is ``enabled`` . .. epigraph:: If you specify a value of ``disabled`` , you will not be able to access your instance metadata.
            :param http_protocol_ipv6: Enables or disables the IPv6 endpoint for the instance metadata service. Default: ``disabled``
            :param http_put_response_hop_limit: The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Default: ``1`` Possible values: Integers from 1 to 64
            :param http_tokens: Indicates whether IMDSv2 is required. - ``optional`` - IMDSv2 is optional. You can choose whether to send a session token in your instance metadata retrieval requests. If you retrieve IAM role credentials without a session token, you receive the IMDSv1 role credentials. If you retrieve IAM role credentials using a valid session token, you receive the IMDSv2 role credentials. - ``required`` - IMDSv2 is required. You must send a session token in your instance metadata retrieval requests. With this option, retrieving the IAM role credentials always returns IMDSv2 credentials; IMDSv1 credentials are not available. Default: If the value of ``ImdsSupport`` for the Amazon Machine Image (AMI) for your instance is ``v2.0`` , the default is ``required`` .
            :param instance_metadata_tags: Set to ``enabled`` to allow access to instance tags from the instance metadata. Set to ``disabled`` to turn off access to instance tags from the instance metadata. For more information, see `View tags for your EC2 instances using instance metadata <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/work-with-tags-in-IMDS.html>`_ . Default: ``disabled``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-metadataoptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                metadata_options_property = ec2_mixins.CfnLaunchTemplatePropsMixin.MetadataOptionsProperty(
                    http_endpoint="httpEndpoint",
                    http_protocol_ipv6="httpProtocolIpv6",
                    http_put_response_hop_limit=123,
                    http_tokens="httpTokens",
                    instance_metadata_tags="instanceMetadataTags"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__bf7bbc8c0ead237e2c30dbcf5f9a42c8cc58d7c353811c7685eb697b1b013489)
                check_type(argname="argument http_endpoint", value=http_endpoint, expected_type=type_hints["http_endpoint"])
                check_type(argname="argument http_protocol_ipv6", value=http_protocol_ipv6, expected_type=type_hints["http_protocol_ipv6"])
                check_type(argname="argument http_put_response_hop_limit", value=http_put_response_hop_limit, expected_type=type_hints["http_put_response_hop_limit"])
                check_type(argname="argument http_tokens", value=http_tokens, expected_type=type_hints["http_tokens"])
                check_type(argname="argument instance_metadata_tags", value=instance_metadata_tags, expected_type=type_hints["instance_metadata_tags"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if http_endpoint is not None:
                self._values["http_endpoint"] = http_endpoint
            if http_protocol_ipv6 is not None:
                self._values["http_protocol_ipv6"] = http_protocol_ipv6
            if http_put_response_hop_limit is not None:
                self._values["http_put_response_hop_limit"] = http_put_response_hop_limit
            if http_tokens is not None:
                self._values["http_tokens"] = http_tokens
            if instance_metadata_tags is not None:
                self._values["instance_metadata_tags"] = instance_metadata_tags

        @builtins.property
        def http_endpoint(self) -> typing.Optional[builtins.str]:
            '''Enables or disables the HTTP metadata endpoint on your instances.

            If the parameter is not specified, the default state is ``enabled`` .
            .. epigraph::

               If you specify a value of ``disabled`` , you will not be able to access your instance metadata.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-metadataoptions.html#cfn-ec2-launchtemplate-metadataoptions-httpendpoint
            '''
            result = self._values.get("http_endpoint")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def http_protocol_ipv6(self) -> typing.Optional[builtins.str]:
            '''Enables or disables the IPv6 endpoint for the instance metadata service.

            Default: ``disabled``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-metadataoptions.html#cfn-ec2-launchtemplate-metadataoptions-httpprotocolipv6
            '''
            result = self._values.get("http_protocol_ipv6")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def http_put_response_hop_limit(self) -> typing.Optional[jsii.Number]:
            '''The desired HTTP PUT response hop limit for instance metadata requests.

            The larger the number, the further instance metadata requests can travel.

            Default: ``1``

            Possible values: Integers from 1 to 64

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-metadataoptions.html#cfn-ec2-launchtemplate-metadataoptions-httpputresponsehoplimit
            '''
            result = self._values.get("http_put_response_hop_limit")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def http_tokens(self) -> typing.Optional[builtins.str]:
            '''Indicates whether IMDSv2 is required.

            - ``optional`` - IMDSv2 is optional. You can choose whether to send a session token in your instance metadata retrieval requests. If you retrieve IAM role credentials without a session token, you receive the IMDSv1 role credentials. If you retrieve IAM role credentials using a valid session token, you receive the IMDSv2 role credentials.
            - ``required`` - IMDSv2 is required. You must send a session token in your instance metadata retrieval requests. With this option, retrieving the IAM role credentials always returns IMDSv2 credentials; IMDSv1 credentials are not available.

            Default: If the value of ``ImdsSupport`` for the Amazon Machine Image (AMI) for your instance is ``v2.0`` , the default is ``required`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-metadataoptions.html#cfn-ec2-launchtemplate-metadataoptions-httptokens
            '''
            result = self._values.get("http_tokens")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def instance_metadata_tags(self) -> typing.Optional[builtins.str]:
            '''Set to ``enabled`` to allow access to instance tags from the instance metadata.

            Set to ``disabled`` to turn off access to instance tags from the instance metadata. For more information, see `View tags for your EC2 instances using instance metadata <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/work-with-tags-in-IMDS.html>`_ .

            Default: ``disabled``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-metadataoptions.html#cfn-ec2-launchtemplate-metadataoptions-instancemetadatatags
            '''
            result = self._values.get("instance_metadata_tags")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "MetadataOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.MonitoringProperty",
        jsii_struct_bases=[],
        name_mapping={"enabled": "enabled"},
    )
    class MonitoringProperty:
        def __init__(
            self,
            *,
            enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        ) -> None:
            '''Specifies whether detailed monitoring is enabled for an instance.

            For more information about detailed monitoring, see `Enable or turn off detailed monitoring for your instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-cloudwatch-new.html>`_ in the *Amazon EC2 User Guide* .

            ``Monitoring`` is a property of `AWS::EC2::LaunchTemplate LaunchTemplateData <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html>`_ .

            :param enabled: Specify ``true`` to enable detailed monitoring. Otherwise, basic monitoring is enabled.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-monitoring.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                monitoring_property = ec2_mixins.CfnLaunchTemplatePropsMixin.MonitoringProperty(
                    enabled=False
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__9c016b67f5324eb7ba6ce35420b05ff613cab4ef1445914ebaad958bc3ec1f36)
                check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if enabled is not None:
                self._values["enabled"] = enabled

        @builtins.property
        def enabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Specify ``true`` to enable detailed monitoring.

            Otherwise, basic monitoring is enabled.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-monitoring.html#cfn-ec2-launchtemplate-monitoring-enabled
            '''
            result = self._values.get("enabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "MonitoringProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.NetworkBandwidthGbpsProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class NetworkBandwidthGbpsProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps).

            .. epigraph::

               Setting the minimum bandwidth does not guarantee that your instance will achieve the minimum bandwidth. Amazon EC2 will identify instance types that support the specified minimum bandwidth, but the actual bandwidth of your instance might go below the specified minimum at times. For more information, see `Available instance bandwidth <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-network-bandwidth.html#available-instance-bandwidth>`_ in the *Amazon EC2 User Guide* .

            :param max: The maximum amount of network bandwidth, in Gbps. To specify no maximum limit, omit this parameter.
            :param min: The minimum amount of network bandwidth, in Gbps. If this parameter is not specified, there is no minimum limit.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkbandwidthgbps.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                network_bandwidth_gbps_property = ec2_mixins.CfnLaunchTemplatePropsMixin.NetworkBandwidthGbpsProperty(
                    max=123,
                    min=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__88a41404d2f1aa6ee39e2728178f70773d0784aee67d8a8efbf78e76e6a8be57)
                check_type(argname="argument max", value=max, expected_type=type_hints["max"])
                check_type(argname="argument min", value=min, expected_type=type_hints["min"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum amount of network bandwidth, in Gbps.

            To specify no maximum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkbandwidthgbps.html#cfn-ec2-launchtemplate-networkbandwidthgbps-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum amount of network bandwidth, in Gbps.

            If this parameter is not specified, there is no minimum limit.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkbandwidthgbps.html#cfn-ec2-launchtemplate-networkbandwidthgbps-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "NetworkBandwidthGbpsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.NetworkInterfaceCountProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class NetworkInterfaceCountProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum number of network interfaces.

            :param max: The maximum number of network interfaces. To specify no maximum limit, omit this parameter.
            :param min: The minimum number of network interfaces. To specify no minimum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterfacecount.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                network_interface_count_property = ec2_mixins.CfnLaunchTemplatePropsMixin.NetworkInterfaceCountProperty(
                    max=123,
                    min=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__d8bf076c2089938dac7eff484d33b571823eb10520abf2772d40505a0431e193)
                check_type(argname="argument max", value=max, expected_type=type_hints["max"])
                check_type(argname="argument min", value=min, expected_type=type_hints["min"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum number of network interfaces.

            To specify no maximum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterfacecount.html#cfn-ec2-launchtemplate-networkinterfacecount-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum number of network interfaces.

            To specify no minimum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterfacecount.html#cfn-ec2-launchtemplate-networkinterfacecount-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "NetworkInterfaceCountProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.NetworkInterfaceProperty",
        jsii_struct_bases=[],
        name_mapping={
            "associate_carrier_ip_address": "associateCarrierIpAddress",
            "associate_public_ip_address": "associatePublicIpAddress",
            "connection_tracking_specification": "connectionTrackingSpecification",
            "delete_on_termination": "deleteOnTermination",
            "description": "description",
            "device_index": "deviceIndex",
            "ena_queue_count": "enaQueueCount",
            "ena_srd_specification": "enaSrdSpecification",
            "groups": "groups",
            "interface_type": "interfaceType",
            "ipv4_prefix_count": "ipv4PrefixCount",
            "ipv4_prefixes": "ipv4Prefixes",
            "ipv6_address_count": "ipv6AddressCount",
            "ipv6_addresses": "ipv6Addresses",
            "ipv6_prefix_count": "ipv6PrefixCount",
            "ipv6_prefixes": "ipv6Prefixes",
            "network_card_index": "networkCardIndex",
            "network_interface_id": "networkInterfaceId",
            "primary_ipv6": "primaryIpv6",
            "private_ip_address": "privateIpAddress",
            "private_ip_addresses": "privateIpAddresses",
            "secondary_private_ip_address_count": "secondaryPrivateIpAddressCount",
            "subnet_id": "subnetId",
        },
    )
    class NetworkInterfaceProperty:
        def __init__(
            self,
            *,
            associate_carrier_ip_address: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            associate_public_ip_address: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            connection_tracking_specification: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.ConnectionTrackingSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            delete_on_termination: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            description: typing.Optional[builtins.str] = None,
            device_index: typing.Optional[jsii.Number] = None,
            ena_queue_count: typing.Optional[jsii.Number] = None,
            ena_srd_specification: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.EnaSrdSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            groups: typing.Optional[typing.Sequence[builtins.str]] = None,
            interface_type: typing.Optional[builtins.str] = None,
            ipv4_prefix_count: typing.Optional[jsii.Number] = None,
            ipv4_prefixes: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.Ipv4PrefixSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            ipv6_address_count: typing.Optional[jsii.Number] = None,
            ipv6_addresses: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.Ipv6AddProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            ipv6_prefix_count: typing.Optional[jsii.Number] = None,
            ipv6_prefixes: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.Ipv6PrefixSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            network_card_index: typing.Optional[jsii.Number] = None,
            network_interface_id: typing.Optional[builtins.str] = None,
            primary_ipv6: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            private_ip_address: typing.Optional[builtins.str] = None,
            private_ip_addresses: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnLaunchTemplatePropsMixin.PrivateIpAddProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            secondary_private_ip_address_count: typing.Optional[jsii.Number] = None,
            subnet_id: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies the parameters for a network interface.

            ``NetworkInterface`` is a property of `AWS::EC2::LaunchTemplate LaunchTemplateData <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html>`_ .

            :param associate_carrier_ip_address: Associates a Carrier IP address with eth0 for a new network interface. Use this option when you launch an instance in a Wavelength Zone and want to associate a Carrier IP address with the network interface. For more information about Carrier IP addresses, see `Carrier IP addresses <https://docs.aws.amazon.com/wavelength/latest/developerguide/how-wavelengths-work.html#provider-owned-ip>`_ in the *AWS Wavelength Developer Guide* .
            :param associate_public_ip_address: Associates a public IPv4 address with eth0 for a new network interface. AWS charges for all public IPv4 addresses, including public IPv4 addresses associated with running instances and Elastic IP addresses. For more information, see the *Public IPv4 Address* tab on the `Amazon VPC pricing page <https://docs.aws.amazon.com/vpc/pricing/>`_ .
            :param connection_tracking_specification: A connection tracking specification for the network interface.
            :param delete_on_termination: Indicates whether the network interface is deleted when the instance is terminated.
            :param description: A description for the network interface.
            :param device_index: The device index for the network interface attachment. The primary network interface has a device index of 0. If the network interface is of type ``interface`` , you must specify a device index. If you create a launch template that includes secondary network interfaces but no primary network interface, and you specify it using the ``LaunchTemplate`` property of ``AWS::EC2::Instance`` , then you must include a primary network interface using the ``NetworkInterfaces`` property of ``AWS::EC2::Instance`` .
            :param ena_queue_count: The number of ENA queues to be created with the instance.
            :param ena_srd_specification: The ENA Express configuration for the network interface.
            :param groups: The IDs of one or more security groups.
            :param interface_type: The type of network interface. To create an Elastic Fabric Adapter (EFA), specify ``efa`` or ``efa`` . For more information, see `Elastic Fabric Adapter for AI/ML and HPC workloads on Amazon EC2 <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/efa.html>`_ in the *Amazon EC2 User Guide* . If you are not creating an EFA, specify ``interface`` or omit this parameter. If you specify ``efa-only`` , do not assign any IP addresses to the network interface. EFA-only network interfaces do not support IP addresses. Valid values: ``interface`` | ``efa`` | ``efa-only``
            :param ipv4_prefix_count: The number of IPv4 prefixes to be automatically assigned to the network interface. You cannot use this option if you use the ``Ipv4Prefix`` option.
            :param ipv4_prefixes: One or more IPv4 prefixes to be assigned to the network interface. You cannot use this option if you use the ``Ipv4PrefixCount`` option.
            :param ipv6_address_count: The number of IPv6 addresses to assign to a network interface. Amazon EC2 automatically selects the IPv6 addresses from the subnet range. You can't use this option if specifying specific IPv6 addresses.
            :param ipv6_addresses: One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. You can't use this option if you're specifying a number of IPv6 addresses.
            :param ipv6_prefix_count: The number of IPv6 prefixes to be automatically assigned to the network interface. You cannot use this option if you use the ``Ipv6Prefix`` option.
            :param ipv6_prefixes: One or more IPv6 prefixes to be assigned to the network interface. You cannot use this option if you use the ``Ipv6PrefixCount`` option.
            :param network_card_index: The index of the network card. Some instance types support multiple network cards. The primary network interface must be assigned to network card index 0. The default is network card index 0.
            :param network_interface_id: The ID of the network interface.
            :param primary_ipv6: The primary IPv6 address of the network interface. When you enable an IPv6 GUA address to be a primary IPv6, the first IPv6 GUA will be made the primary IPv6 address until the instance is terminated or the network interface is detached. For more information about primary IPv6 addresses, see `RunInstances <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html>`_ .
            :param private_ip_address: The primary private IPv4 address of the network interface.
            :param private_ip_addresses: One or more private IPv4 addresses.
            :param secondary_private_ip_address_count: The number of secondary private IPv4 addresses to assign to a network interface.
            :param subnet_id: The ID of the subnet for the network interface.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                network_interface_property = ec2_mixins.CfnLaunchTemplatePropsMixin.NetworkInterfaceProperty(
                    associate_carrier_ip_address=False,
                    associate_public_ip_address=False,
                    connection_tracking_specification=ec2_mixins.CfnLaunchTemplatePropsMixin.ConnectionTrackingSpecificationProperty(
                        tcp_established_timeout=123,
                        udp_stream_timeout=123,
                        udp_timeout=123
                    ),
                    delete_on_termination=False,
                    description="description",
                    device_index=123,
                    ena_queue_count=123,
                    ena_srd_specification=ec2_mixins.CfnLaunchTemplatePropsMixin.EnaSrdSpecificationProperty(
                        ena_srd_enabled=False,
                        ena_srd_udp_specification=ec2_mixins.CfnLaunchTemplatePropsMixin.EnaSrdUdpSpecificationProperty(
                            ena_srd_udp_enabled=False
                        )
                    ),
                    groups=["groups"],
                    interface_type="interfaceType",
                    ipv4_prefix_count=123,
                    ipv4_prefixes=[ec2_mixins.CfnLaunchTemplatePropsMixin.Ipv4PrefixSpecificationProperty(
                        ipv4_prefix="ipv4Prefix"
                    )],
                    ipv6_address_count=123,
                    ipv6_addresses=[ec2_mixins.CfnLaunchTemplatePropsMixin.Ipv6AddProperty(
                        ipv6_address="ipv6Address"
                    )],
                    ipv6_prefix_count=123,
                    ipv6_prefixes=[ec2_mixins.CfnLaunchTemplatePropsMixin.Ipv6PrefixSpecificationProperty(
                        ipv6_prefix="ipv6Prefix"
                    )],
                    network_card_index=123,
                    network_interface_id="networkInterfaceId",
                    primary_ipv6=False,
                    private_ip_address="privateIpAddress",
                    private_ip_addresses=[ec2_mixins.CfnLaunchTemplatePropsMixin.PrivateIpAddProperty(
                        primary=False,
                        private_ip_address="privateIpAddress"
                    )],
                    secondary_private_ip_address_count=123,
                    subnet_id="subnetId"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__25892afe09b618557ddf2d2cb6962addbf937fc9ff3121d66b07da343c61a0fd)
                check_type(argname="argument associate_carrier_ip_address", value=associate_carrier_ip_address, expected_type=type_hints["associate_carrier_ip_address"])
                check_type(argname="argument associate_public_ip_address", value=associate_public_ip_address, expected_type=type_hints["associate_public_ip_address"])
                check_type(argname="argument connection_tracking_specification", value=connection_tracking_specification, expected_type=type_hints["connection_tracking_specification"])
                check_type(argname="argument delete_on_termination", value=delete_on_termination, expected_type=type_hints["delete_on_termination"])
                check_type(argname="argument description", value=description, expected_type=type_hints["description"])
                check_type(argname="argument device_index", value=device_index, expected_type=type_hints["device_index"])
                check_type(argname="argument ena_queue_count", value=ena_queue_count, expected_type=type_hints["ena_queue_count"])
                check_type(argname="argument ena_srd_specification", value=ena_srd_specification, expected_type=type_hints["ena_srd_specification"])
                check_type(argname="argument groups", value=groups, expected_type=type_hints["groups"])
                check_type(argname="argument interface_type", value=interface_type, expected_type=type_hints["interface_type"])
                check_type(argname="argument ipv4_prefix_count", value=ipv4_prefix_count, expected_type=type_hints["ipv4_prefix_count"])
                check_type(argname="argument ipv4_prefixes", value=ipv4_prefixes, expected_type=type_hints["ipv4_prefixes"])
                check_type(argname="argument ipv6_address_count", value=ipv6_address_count, expected_type=type_hints["ipv6_address_count"])
                check_type(argname="argument ipv6_addresses", value=ipv6_addresses, expected_type=type_hints["ipv6_addresses"])
                check_type(argname="argument ipv6_prefix_count", value=ipv6_prefix_count, expected_type=type_hints["ipv6_prefix_count"])
                check_type(argname="argument ipv6_prefixes", value=ipv6_prefixes, expected_type=type_hints["ipv6_prefixes"])
                check_type(argname="argument network_card_index", value=network_card_index, expected_type=type_hints["network_card_index"])
                check_type(argname="argument network_interface_id", value=network_interface_id, expected_type=type_hints["network_interface_id"])
                check_type(argname="argument primary_ipv6", value=primary_ipv6, expected_type=type_hints["primary_ipv6"])
                check_type(argname="argument private_ip_address", value=private_ip_address, expected_type=type_hints["private_ip_address"])
                check_type(argname="argument private_ip_addresses", value=private_ip_addresses, expected_type=type_hints["private_ip_addresses"])
                check_type(argname="argument secondary_private_ip_address_count", value=secondary_private_ip_address_count, expected_type=type_hints["secondary_private_ip_address_count"])
                check_type(argname="argument subnet_id", value=subnet_id, expected_type=type_hints["subnet_id"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if associate_carrier_ip_address is not None:
                self._values["associate_carrier_ip_address"] = associate_carrier_ip_address
            if associate_public_ip_address is not None:
                self._values["associate_public_ip_address"] = associate_public_ip_address
            if connection_tracking_specification is not None:
                self._values["connection_tracking_specification"] = connection_tracking_specification
            if delete_on_termination is not None:
                self._values["delete_on_termination"] = delete_on_termination
            if description is not None:
                self._values["description"] = description
            if device_index is not None:
                self._values["device_index"] = device_index
            if ena_queue_count is not None:
                self._values["ena_queue_count"] = ena_queue_count
            if ena_srd_specification is not None:
                self._values["ena_srd_specification"] = ena_srd_specification
            if groups is not None:
                self._values["groups"] = groups
            if interface_type is not None:
                self._values["interface_type"] = interface_type
            if ipv4_prefix_count is not None:
                self._values["ipv4_prefix_count"] = ipv4_prefix_count
            if ipv4_prefixes is not None:
                self._values["ipv4_prefixes"] = ipv4_prefixes
            if ipv6_address_count is not None:
                self._values["ipv6_address_count"] = ipv6_address_count
            if ipv6_addresses is not None:
                self._values["ipv6_addresses"] = ipv6_addresses
            if ipv6_prefix_count is not None:
                self._values["ipv6_prefix_count"] = ipv6_prefix_count
            if ipv6_prefixes is not None:
                self._values["ipv6_prefixes"] = ipv6_prefixes
            if network_card_index is not None:
                self._values["network_card_index"] = network_card_index
            if network_interface_id is not None:
                self._values["network_interface_id"] = network_interface_id
            if primary_ipv6 is not None:
                self._values["primary_ipv6"] = primary_ipv6
            if private_ip_address is not None:
                self._values["private_ip_address"] = private_ip_address
            if private_ip_addresses is not None:
                self._values["private_ip_addresses"] = private_ip_addresses
            if secondary_private_ip_address_count is not None:
                self._values["secondary_private_ip_address_count"] = secondary_private_ip_address_count
            if subnet_id is not None:
                self._values["subnet_id"] = subnet_id

        @builtins.property
        def associate_carrier_ip_address(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Associates a Carrier IP address with eth0 for a new network interface.

            Use this option when you launch an instance in a Wavelength Zone and want to associate a Carrier IP address with the network interface. For more information about Carrier IP addresses, see `Carrier IP addresses <https://docs.aws.amazon.com/wavelength/latest/developerguide/how-wavelengths-work.html#provider-owned-ip>`_ in the *AWS Wavelength Developer Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-associatecarrieripaddress
            '''
            result = self._values.get("associate_carrier_ip_address")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def associate_public_ip_address(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Associates a public IPv4 address with eth0 for a new network interface.

            AWS charges for all public IPv4 addresses, including public IPv4 addresses associated with running instances and Elastic IP addresses. For more information, see the *Public IPv4 Address* tab on the `Amazon VPC pricing page <https://docs.aws.amazon.com/vpc/pricing/>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-associatepublicipaddress
            '''
            result = self._values.get("associate_public_ip_address")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def connection_tracking_specification(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.ConnectionTrackingSpecificationProperty"]]:
            '''A connection tracking specification for the network interface.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-connectiontrackingspecification
            '''
            result = self._values.get("connection_tracking_specification")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.ConnectionTrackingSpecificationProperty"]], result)

        @builtins.property
        def delete_on_termination(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether the network interface is deleted when the instance is terminated.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-deleteontermination
            '''
            result = self._values.get("delete_on_termination")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def description(self) -> typing.Optional[builtins.str]:
            '''A description for the network interface.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-description
            '''
            result = self._values.get("description")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def device_index(self) -> typing.Optional[jsii.Number]:
            '''The device index for the network interface attachment.

            The primary network interface has a device index of 0. If the network interface is of type ``interface`` , you must specify a device index.

            If you create a launch template that includes secondary network interfaces but no primary network interface, and you specify it using the ``LaunchTemplate`` property of ``AWS::EC2::Instance`` , then you must include a primary network interface using the ``NetworkInterfaces`` property of ``AWS::EC2::Instance`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-deviceindex
            '''
            result = self._values.get("device_index")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def ena_queue_count(self) -> typing.Optional[jsii.Number]:
            '''The number of ENA queues to be created with the instance.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-enaqueuecount
            '''
            result = self._values.get("ena_queue_count")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def ena_srd_specification(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.EnaSrdSpecificationProperty"]]:
            '''The ENA Express configuration for the network interface.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-enasrdspecification
            '''
            result = self._values.get("ena_srd_specification")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.EnaSrdSpecificationProperty"]], result)

        @builtins.property
        def groups(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The IDs of one or more security groups.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-groups
            '''
            result = self._values.get("groups")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def interface_type(self) -> typing.Optional[builtins.str]:
            '''The type of network interface.

            To create an Elastic Fabric Adapter (EFA), specify ``efa`` or ``efa`` . For more information, see `Elastic Fabric Adapter for AI/ML and HPC workloads on Amazon EC2 <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/efa.html>`_ in the *Amazon EC2 User Guide* .

            If you are not creating an EFA, specify ``interface`` or omit this parameter.

            If you specify ``efa-only`` , do not assign any IP addresses to the network interface. EFA-only network interfaces do not support IP addresses.

            Valid values: ``interface`` | ``efa`` | ``efa-only``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-interfacetype
            '''
            result = self._values.get("interface_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def ipv4_prefix_count(self) -> typing.Optional[jsii.Number]:
            '''The number of IPv4 prefixes to be automatically assigned to the network interface.

            You cannot use this option if you use the ``Ipv4Prefix`` option.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-ipv4prefixcount
            '''
            result = self._values.get("ipv4_prefix_count")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def ipv4_prefixes(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.Ipv4PrefixSpecificationProperty"]]]]:
            '''One or more IPv4 prefixes to be assigned to the network interface.

            You cannot use this option if you use the ``Ipv4PrefixCount`` option.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-ipv4prefixes
            '''
            result = self._values.get("ipv4_prefixes")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.Ipv4PrefixSpecificationProperty"]]]], result)

        @builtins.property
        def ipv6_address_count(self) -> typing.Optional[jsii.Number]:
            '''The number of IPv6 addresses to assign to a network interface.

            Amazon EC2 automatically selects the IPv6 addresses from the subnet range. You can't use this option if specifying specific IPv6 addresses.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-ipv6addresscount
            '''
            result = self._values.get("ipv6_address_count")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def ipv6_addresses(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.Ipv6AddProperty"]]]]:
            '''One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet.

            You can't use this option if you're specifying a number of IPv6 addresses.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-ipv6addresses
            '''
            result = self._values.get("ipv6_addresses")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.Ipv6AddProperty"]]]], result)

        @builtins.property
        def ipv6_prefix_count(self) -> typing.Optional[jsii.Number]:
            '''The number of IPv6 prefixes to be automatically assigned to the network interface.

            You cannot use this option if you use the ``Ipv6Prefix`` option.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-ipv6prefixcount
            '''
            result = self._values.get("ipv6_prefix_count")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def ipv6_prefixes(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.Ipv6PrefixSpecificationProperty"]]]]:
            '''One or more IPv6 prefixes to be assigned to the network interface.

            You cannot use this option if you use the ``Ipv6PrefixCount`` option.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-ipv6prefixes
            '''
            result = self._values.get("ipv6_prefixes")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.Ipv6PrefixSpecificationProperty"]]]], result)

        @builtins.property
        def network_card_index(self) -> typing.Optional[jsii.Number]:
            '''The index of the network card.

            Some instance types support multiple network cards. The primary network interface must be assigned to network card index 0. The default is network card index 0.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-networkcardindex
            '''
            result = self._values.get("network_card_index")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def network_interface_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the network interface.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-networkinterfaceid
            '''
            result = self._values.get("network_interface_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def primary_ipv6(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''The primary IPv6 address of the network interface.

            When you enable an IPv6 GUA address to be a primary IPv6, the first IPv6 GUA will be made the primary IPv6 address until the instance is terminated or the network interface is detached. For more information about primary IPv6 addresses, see `RunInstances <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-primaryipv6
            '''
            result = self._values.get("primary_ipv6")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def private_ip_address(self) -> typing.Optional[builtins.str]:
            '''The primary private IPv4 address of the network interface.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-privateipaddress
            '''
            result = self._values.get("private_ip_address")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def private_ip_addresses(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.PrivateIpAddProperty"]]]]:
            '''One or more private IPv4 addresses.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-privateipaddresses
            '''
            result = self._values.get("private_ip_addresses")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnLaunchTemplatePropsMixin.PrivateIpAddProperty"]]]], result)

        @builtins.property
        def secondary_private_ip_address_count(self) -> typing.Optional[jsii.Number]:
            '''The number of secondary private IPv4 addresses to assign to a network interface.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-secondaryprivateipaddresscount
            '''
            result = self._values.get("secondary_private_ip_address_count")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def subnet_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the subnet for the network interface.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-subnetid
            '''
            result = self._values.get("subnet_id")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "NetworkInterfaceProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.NetworkPerformanceOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={"bandwidth_weighting": "bandwidthWeighting"},
    )
    class NetworkPerformanceOptionsProperty:
        def __init__(
            self,
            *,
            bandwidth_weighting: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains settings for the network performance options for the instance.

            :param bandwidth_weighting: Specify the bandwidth weighting option to boost the associated type of baseline bandwidth, as follows:. - **default** - This option uses the standard bandwidth configuration for your instance type. - **vpc-1** - This option boosts your networking baseline bandwidth and reduces your EBS baseline bandwidth. - **ebs-1** - This option boosts your EBS baseline bandwidth and reduces your networking baseline bandwidth.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkperformanceoptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                network_performance_options_property = ec2_mixins.CfnLaunchTemplatePropsMixin.NetworkPerformanceOptionsProperty(
                    bandwidth_weighting="bandwidthWeighting"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__7bf71324f6f1a2e0a7c4697808d704e3fe52ecf6d1030ea5345d590b4beea72c)
                check_type(argname="argument bandwidth_weighting", value=bandwidth_weighting, expected_type=type_hints["bandwidth_weighting"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if bandwidth_weighting is not None:
                self._values["bandwidth_weighting"] = bandwidth_weighting

        @builtins.property
        def bandwidth_weighting(self) -> typing.Optional[builtins.str]:
            '''Specify the bandwidth weighting option to boost the associated type of baseline bandwidth, as follows:.

            - **default** - This option uses the standard bandwidth configuration for your instance type.
            - **vpc-1** - This option boosts your networking baseline bandwidth and reduces your EBS baseline bandwidth.
            - **ebs-1** - This option boosts your EBS baseline bandwidth and reduces your networking baseline bandwidth.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkperformanceoptions.html#cfn-ec2-launchtemplate-networkperformanceoptions-bandwidthweighting
            '''
            result = self._values.get("bandwidth_weighting")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "NetworkPerformanceOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.PlacementProperty",
        jsii_struct_bases=[],
        name_mapping={
            "affinity": "affinity",
            "availability_zone": "availabilityZone",
            "group_id": "groupId",
            "group_name": "groupName",
            "host_id": "hostId",
            "host_resource_group_arn": "hostResourceGroupArn",
            "partition_number": "partitionNumber",
            "spread_domain": "spreadDomain",
            "tenancy": "tenancy",
        },
    )
    class PlacementProperty:
        def __init__(
            self,
            *,
            affinity: typing.Optional[builtins.str] = None,
            availability_zone: typing.Optional[builtins.str] = None,
            group_id: typing.Optional[builtins.str] = None,
            group_name: typing.Optional[builtins.str] = None,
            host_id: typing.Optional[builtins.str] = None,
            host_resource_group_arn: typing.Optional[builtins.str] = None,
            partition_number: typing.Optional[jsii.Number] = None,
            spread_domain: typing.Optional[builtins.str] = None,
            tenancy: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies the placement of an instance.

            ``Placement`` is a property of `AWS::EC2::LaunchTemplate LaunchTemplateData <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html>`_ .

            :param affinity: The affinity setting for an instance on a Dedicated Host.
            :param availability_zone: The Availability Zone for the instance. Either ``AvailabilityZone`` or ``AvailabilityZoneId`` can be specified, but not both
            :param group_id: The Group Id of a placement group. You must specify the Placement Group *Group Id* to launch an instance in a shared placement group.
            :param group_name: The name of the placement group for the instance.
            :param host_id: The ID of the Dedicated Host for the instance.
            :param host_resource_group_arn: The ARN of the host resource group in which to launch the instances. If you specify a host resource group ARN, omit the *Tenancy* parameter or set it to ``host`` .
            :param partition_number: The number of the partition the instance should launch in. Valid only if the placement group strategy is set to ``partition`` .
            :param spread_domain: Reserved for future use.
            :param tenancy: The tenancy of the instance. An instance with a tenancy of dedicated runs on single-tenant hardware.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-placement.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                placement_property = ec2_mixins.CfnLaunchTemplatePropsMixin.PlacementProperty(
                    affinity="affinity",
                    availability_zone="availabilityZone",
                    group_id="groupId",
                    group_name="groupName",
                    host_id="hostId",
                    host_resource_group_arn="hostResourceGroupArn",
                    partition_number=123,
                    spread_domain="spreadDomain",
                    tenancy="tenancy"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__035c5e3631d6b7a94af1c5ffe79699b99970560cb8c80a50e86972e033b85214)
                check_type(argname="argument affinity", value=affinity, expected_type=type_hints["affinity"])
                check_type(argname="argument availability_zone", value=availability_zone, expected_type=type_hints["availability_zone"])
                check_type(argname="argument group_id", value=group_id, expected_type=type_hints["group_id"])
                check_type(argname="argument group_name", value=group_name, expected_type=type_hints["group_name"])
                check_type(argname="argument host_id", value=host_id, expected_type=type_hints["host_id"])
                check_type(argname="argument host_resource_group_arn", value=host_resource_group_arn, expected_type=type_hints["host_resource_group_arn"])
                check_type(argname="argument partition_number", value=partition_number, expected_type=type_hints["partition_number"])
                check_type(argname="argument spread_domain", value=spread_domain, expected_type=type_hints["spread_domain"])
                check_type(argname="argument tenancy", value=tenancy, expected_type=type_hints["tenancy"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if affinity is not None:
                self._values["affinity"] = affinity
            if availability_zone is not None:
                self._values["availability_zone"] = availability_zone
            if group_id is not None:
                self._values["group_id"] = group_id
            if group_name is not None:
                self._values["group_name"] = group_name
            if host_id is not None:
                self._values["host_id"] = host_id
            if host_resource_group_arn is not None:
                self._values["host_resource_group_arn"] = host_resource_group_arn
            if partition_number is not None:
                self._values["partition_number"] = partition_number
            if spread_domain is not None:
                self._values["spread_domain"] = spread_domain
            if tenancy is not None:
                self._values["tenancy"] = tenancy

        @builtins.property
        def affinity(self) -> typing.Optional[builtins.str]:
            '''The affinity setting for an instance on a Dedicated Host.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-placement.html#cfn-ec2-launchtemplate-placement-affinity
            '''
            result = self._values.get("affinity")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def availability_zone(self) -> typing.Optional[builtins.str]:
            '''The Availability Zone for the instance.

            Either ``AvailabilityZone`` or ``AvailabilityZoneId`` can be specified, but not both

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-placement.html#cfn-ec2-launchtemplate-placement-availabilityzone
            '''
            result = self._values.get("availability_zone")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def group_id(self) -> typing.Optional[builtins.str]:
            '''The Group Id of a placement group.

            You must specify the Placement Group *Group Id* to launch an instance in a shared placement group.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-placement.html#cfn-ec2-launchtemplate-placement-groupid
            '''
            result = self._values.get("group_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def group_name(self) -> typing.Optional[builtins.str]:
            '''The name of the placement group for the instance.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-placement.html#cfn-ec2-launchtemplate-placement-groupname
            '''
            result = self._values.get("group_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def host_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the Dedicated Host for the instance.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-placement.html#cfn-ec2-launchtemplate-placement-hostid
            '''
            result = self._values.get("host_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def host_resource_group_arn(self) -> typing.Optional[builtins.str]:
            '''The ARN of the host resource group in which to launch the instances.

            If you specify a host resource group ARN, omit the *Tenancy* parameter or set it to ``host`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-placement.html#cfn-ec2-launchtemplate-placement-hostresourcegrouparn
            '''
            result = self._values.get("host_resource_group_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def partition_number(self) -> typing.Optional[jsii.Number]:
            '''The number of the partition the instance should launch in.

            Valid only if the placement group strategy is set to ``partition`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-placement.html#cfn-ec2-launchtemplate-placement-partitionnumber
            '''
            result = self._values.get("partition_number")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def spread_domain(self) -> typing.Optional[builtins.str]:
            '''Reserved for future use.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-placement.html#cfn-ec2-launchtemplate-placement-spreaddomain
            '''
            result = self._values.get("spread_domain")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def tenancy(self) -> typing.Optional[builtins.str]:
            '''The tenancy of the instance.

            An instance with a tenancy of dedicated runs on single-tenant hardware.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-placement.html#cfn-ec2-launchtemplate-placement-tenancy
            '''
            result = self._values.get("tenancy")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PlacementProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.PrivateDnsNameOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "enable_resource_name_dns_aaaa_record": "enableResourceNameDnsAaaaRecord",
            "enable_resource_name_dns_a_record": "enableResourceNameDnsARecord",
            "hostname_type": "hostnameType",
        },
    )
    class PrivateDnsNameOptionsProperty:
        def __init__(
            self,
            *,
            enable_resource_name_dns_aaaa_record: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            enable_resource_name_dns_a_record: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            hostname_type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries should be handled.

            For more information, see `Amazon EC2 instance hostname types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .

            :param enable_resource_name_dns_aaaa_record: Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
            :param enable_resource_name_dns_a_record: Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
            :param hostname_type: The type of hostname for EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. For more information, see `Amazon EC2 instance hostname types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-privatednsnameoptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                private_dns_name_options_property = ec2_mixins.CfnLaunchTemplatePropsMixin.PrivateDnsNameOptionsProperty(
                    enable_resource_name_dns_aaaa_record=False,
                    enable_resource_name_dns_aRecord=False,
                    hostname_type="hostnameType"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__2ae9f701f4ffbdc23e0c8dddbd7f11734212cdbf86746dd770056493767a5168)
                check_type(argname="argument enable_resource_name_dns_aaaa_record", value=enable_resource_name_dns_aaaa_record, expected_type=type_hints["enable_resource_name_dns_aaaa_record"])
                check_type(argname="argument enable_resource_name_dns_a_record", value=enable_resource_name_dns_a_record, expected_type=type_hints["enable_resource_name_dns_a_record"])
                check_type(argname="argument hostname_type", value=hostname_type, expected_type=type_hints["hostname_type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if enable_resource_name_dns_aaaa_record is not None:
                self._values["enable_resource_name_dns_aaaa_record"] = enable_resource_name_dns_aaaa_record
            if enable_resource_name_dns_a_record is not None:
                self._values["enable_resource_name_dns_a_record"] = enable_resource_name_dns_a_record
            if hostname_type is not None:
                self._values["hostname_type"] = hostname_type

        @builtins.property
        def enable_resource_name_dns_aaaa_record(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-privatednsnameoptions.html#cfn-ec2-launchtemplate-privatednsnameoptions-enableresourcenamednsaaaarecord
            '''
            result = self._values.get("enable_resource_name_dns_aaaa_record")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def enable_resource_name_dns_a_record(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether to respond to DNS queries for instance hostnames with DNS A records.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-privatednsnameoptions.html#cfn-ec2-launchtemplate-privatednsnameoptions-enableresourcenamednsarecord
            '''
            result = self._values.get("enable_resource_name_dns_a_record")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def hostname_type(self) -> typing.Optional[builtins.str]:
            '''The type of hostname for EC2 instances.

            For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. For more information, see `Amazon EC2 instance hostname types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-privatednsnameoptions.html#cfn-ec2-launchtemplate-privatednsnameoptions-hostnametype
            '''
            result = self._values.get("hostname_type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PrivateDnsNameOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.PrivateIpAddProperty",
        jsii_struct_bases=[],
        name_mapping={"primary": "primary", "private_ip_address": "privateIpAddress"},
    )
    class PrivateIpAddProperty:
        def __init__(
            self,
            *,
            primary: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            private_ip_address: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies a secondary private IPv4 address for a network interface.

            ``PrivateIpAdd`` is a property of `AWS::EC2::LaunchTemplate NetworkInterface <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html>`_ .

            :param primary: Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.
            :param private_ip_address: The private IPv4 address.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-privateipadd.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                private_ip_add_property = ec2_mixins.CfnLaunchTemplatePropsMixin.PrivateIpAddProperty(
                    primary=False,
                    private_ip_address="privateIpAddress"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__1eb6665f049efa8dceab238cfdedb625b3c83f4000b3b1a3afe278c1b0b0965c)
                check_type(argname="argument primary", value=primary, expected_type=type_hints["primary"])
                check_type(argname="argument private_ip_address", value=private_ip_address, expected_type=type_hints["private_ip_address"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if primary is not None:
                self._values["primary"] = primary
            if private_ip_address is not None:
                self._values["private_ip_address"] = private_ip_address

        @builtins.property
        def primary(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether the private IPv4 address is the primary private IPv4 address.

            Only one IPv4 address can be designated as primary.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-privateipadd.html#cfn-ec2-launchtemplate-privateipadd-primary
            '''
            result = self._values.get("primary")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def private_ip_address(self) -> typing.Optional[builtins.str]:
            '''The private IPv4 address.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-privateipadd.html#cfn-ec2-launchtemplate-privateipadd-privateipaddress
            '''
            result = self._values.get("private_ip_address")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PrivateIpAddProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.ReferenceProperty",
        jsii_struct_bases=[],
        name_mapping={"instance_family": "instanceFamily"},
    )
    class ReferenceProperty:
        def __init__(
            self,
            *,
            instance_family: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies an instance family to use as the baseline reference for CPU performance.

            :param instance_family: The instance family to use as a baseline reference. .. epigraph:: Ensure that you specify the correct value for the instance family. The instance family is everything before the period ( ``.`` ) in the instance type name. For example, in the instance type ``c6i.large`` , the instance family is ``c6i`` , not ``c6`` . For more information, see `Amazon EC2 instance type naming conventions <https://docs.aws.amazon.com/ec2/latest/instancetypes/instance-type-names.html>`_ in *Amazon EC2 Instance Types* . The following instance families are *not supported* for performance protection: - ``c1`` - ``g3`` | ``g3s`` - ``hpc7g`` - ``m1`` | ``m2`` - ``mac1`` | ``mac2`` | ``mac2-m1ultra`` | ``mac2-m2`` | ``mac2-m2pro`` - ``p3dn`` | ``p4d`` | ``p5`` - ``t1`` - ``u-12tb1`` | ``u-18tb1`` | ``u-24tb1`` | ``u-3tb1`` | ``u-6tb1`` | ``u-9tb1`` | ``u7i-12tb`` | ``u7in-16tb`` | ``u7in-24tb`` | ``u7in-32tb`` If you enable performance protection by specifying a supported instance family, the returned instance types will exclude the above unsupported instance families.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-reference.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                reference_property = ec2_mixins.CfnLaunchTemplatePropsMixin.ReferenceProperty(
                    instance_family="instanceFamily"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__bfcff78ab73b0d214d15dbaa843aecb1669b0d02dd501ec35a0ee2b39fadc4d8)
                check_type(argname="argument instance_family", value=instance_family, expected_type=type_hints["instance_family"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if instance_family is not None:
                self._values["instance_family"] = instance_family

        @builtins.property
        def instance_family(self) -> typing.Optional[builtins.str]:
            '''The instance family to use as a baseline reference.

            .. epigraph::

               Ensure that you specify the correct value for the instance family. The instance family is everything before the period ( ``.`` ) in the instance type name. For example, in the instance type ``c6i.large`` , the instance family is ``c6i`` , not ``c6`` . For more information, see `Amazon EC2 instance type naming conventions <https://docs.aws.amazon.com/ec2/latest/instancetypes/instance-type-names.html>`_ in *Amazon EC2 Instance Types* .

            The following instance families are *not supported* for performance protection:

            - ``c1``
            - ``g3`` | ``g3s``
            - ``hpc7g``
            - ``m1`` | ``m2``
            - ``mac1`` | ``mac2`` | ``mac2-m1ultra`` | ``mac2-m2`` | ``mac2-m2pro``
            - ``p3dn`` | ``p4d`` | ``p5``
            - ``t1``
            - ``u-12tb1`` | ``u-18tb1`` | ``u-24tb1`` | ``u-3tb1`` | ``u-6tb1`` | ``u-9tb1`` | ``u7i-12tb`` | ``u7in-16tb`` | ``u7in-24tb`` | ``u7in-32tb``

            If you enable performance protection by specifying a supported instance family, the returned instance types will exclude the above unsupported instance families.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-reference.html#cfn-ec2-launchtemplate-reference-instancefamily
            '''
            result = self._values.get("instance_family")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ReferenceProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.SpotOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "block_duration_minutes": "blockDurationMinutes",
            "instance_interruption_behavior": "instanceInterruptionBehavior",
            "max_price": "maxPrice",
            "spot_instance_type": "spotInstanceType",
            "valid_until": "validUntil",
        },
    )
    class SpotOptionsProperty:
        def __init__(
            self,
            *,
            block_duration_minutes: typing.Optional[jsii.Number] = None,
            instance_interruption_behavior: typing.Optional[builtins.str] = None,
            max_price: typing.Optional[builtins.str] = None,
            spot_instance_type: typing.Optional[builtins.str] = None,
            valid_until: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies options for Spot Instances.

            ``SpotOptions`` is a property of `AWS::EC2::LaunchTemplate InstanceMarketOptions <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancemarketoptions.html>`_ .

            :param block_duration_minutes: Deprecated.
            :param instance_interruption_behavior: The behavior when a Spot Instance is interrupted. The default is ``terminate`` .
            :param max_price: The maximum hourly price you're willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price. If you do specify this parameter, it must be more than USD $0.001. Specifying a value below USD $0.001 will result in an ``InvalidParameterValue`` error message when the launch template is used to launch an instance. .. epigraph:: If you specify a maximum price, your Spot Instances will be interrupted more frequently than if you do not specify this parameter.
            :param spot_instance_type: The Spot Instance request type. If you are using Spot Instances with an Auto Scaling group, use ``one-time`` requests, as the Amazon EC2 Auto Scaling service handles requesting new Spot Instances whenever the group is below its desired capacity.
            :param valid_until: The end date of the request, in UTC format ( *YYYY-MM-DD* T *HH:MM:SS* Z). Supported only for persistent requests. - For a persistent request, the request remains active until the ``ValidUntil`` date and time is reached. Otherwise, the request remains active until you cancel it. - For a one-time request, ``ValidUntil`` is not supported. The request remains active until all instances launch or you cancel the request. Default: 7 days from the current date

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-spotoptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                spot_options_property = ec2_mixins.CfnLaunchTemplatePropsMixin.SpotOptionsProperty(
                    block_duration_minutes=123,
                    instance_interruption_behavior="instanceInterruptionBehavior",
                    max_price="maxPrice",
                    spot_instance_type="spotInstanceType",
                    valid_until="validUntil"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__84ff837f46b86cb2cfe052302218c451d5a9c1c8c484f2a9d175dc4ded6cb87d)
                check_type(argname="argument block_duration_minutes", value=block_duration_minutes, expected_type=type_hints["block_duration_minutes"])
                check_type(argname="argument instance_interruption_behavior", value=instance_interruption_behavior, expected_type=type_hints["instance_interruption_behavior"])
                check_type(argname="argument max_price", value=max_price, expected_type=type_hints["max_price"])
                check_type(argname="argument spot_instance_type", value=spot_instance_type, expected_type=type_hints["spot_instance_type"])
                check_type(argname="argument valid_until", value=valid_until, expected_type=type_hints["valid_until"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if block_duration_minutes is not None:
                self._values["block_duration_minutes"] = block_duration_minutes
            if instance_interruption_behavior is not None:
                self._values["instance_interruption_behavior"] = instance_interruption_behavior
            if max_price is not None:
                self._values["max_price"] = max_price
            if spot_instance_type is not None:
                self._values["spot_instance_type"] = spot_instance_type
            if valid_until is not None:
                self._values["valid_until"] = valid_until

        @builtins.property
        def block_duration_minutes(self) -> typing.Optional[jsii.Number]:
            '''Deprecated.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-spotoptions.html#cfn-ec2-launchtemplate-spotoptions-blockdurationminutes
            '''
            result = self._values.get("block_duration_minutes")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def instance_interruption_behavior(self) -> typing.Optional[builtins.str]:
            '''The behavior when a Spot Instance is interrupted.

            The default is ``terminate`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-spotoptions.html#cfn-ec2-launchtemplate-spotoptions-instanceinterruptionbehavior
            '''
            result = self._values.get("instance_interruption_behavior")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def max_price(self) -> typing.Optional[builtins.str]:
            '''The maximum hourly price you're willing to pay for a Spot Instance.

            We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price. If you do specify this parameter, it must be more than USD $0.001. Specifying a value below USD $0.001 will result in an ``InvalidParameterValue`` error message when the launch template is used to launch an instance.
            .. epigraph::

               If you specify a maximum price, your Spot Instances will be interrupted more frequently than if you do not specify this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-spotoptions.html#cfn-ec2-launchtemplate-spotoptions-maxprice
            '''
            result = self._values.get("max_price")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def spot_instance_type(self) -> typing.Optional[builtins.str]:
            '''The Spot Instance request type.

            If you are using Spot Instances with an Auto Scaling group, use ``one-time`` requests, as the Amazon EC2 Auto Scaling service handles requesting new Spot Instances whenever the group is below its desired capacity.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-spotoptions.html#cfn-ec2-launchtemplate-spotoptions-spotinstancetype
            '''
            result = self._values.get("spot_instance_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def valid_until(self) -> typing.Optional[builtins.str]:
            '''The end date of the request, in UTC format ( *YYYY-MM-DD* T *HH:MM:SS* Z). Supported only for persistent requests.

            - For a persistent request, the request remains active until the ``ValidUntil`` date and time is reached. Otherwise, the request remains active until you cancel it.
            - For a one-time request, ``ValidUntil`` is not supported. The request remains active until all instances launch or you cancel the request.

            Default: 7 days from the current date

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-spotoptions.html#cfn-ec2-launchtemplate-spotoptions-validuntil
            '''
            result = self._values.get("valid_until")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SpotOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.TagSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={"resource_type": "resourceType", "tags": "tags"},
    )
    class TagSpecificationProperty:
        def __init__(
            self,
            *,
            resource_type: typing.Optional[builtins.str] = None,
            tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Specifies the tags to apply to resources that are created during instance launch.

            ``TagSpecification`` is a property type of ```TagSpecifications`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-tagspecifications>`_ . ```TagSpecifications`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-tagspecifications>`_ is a property of `AWS::EC2::LaunchTemplate LaunchTemplateData <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html>`_ .

            :param resource_type: The type of resource to tag. You can specify tags for the following resource types only: ``instance`` | ``volume`` | ``network-interface`` | ``spot-instances-request`` . If the instance does not include the resource type that you specify, the instance launch fails. For example, not all instance types include a volume. To tag a resource after it has been created, see `CreateTags <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html>`_ .
            :param tags: The tags to apply to the resource.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-tagspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                from aws_cdk import CfnTag
                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                tag_specification_property = ec2_mixins.CfnLaunchTemplatePropsMixin.TagSpecificationProperty(
                    resource_type="resourceType",
                    tags=[CfnTag(
                        key="key",
                        value="value"
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__17ec4eafee121a7c99bc49c0663d085d1b3510a8be2b941435ba0dbb2e310d02)
                check_type(argname="argument resource_type", value=resource_type, expected_type=type_hints["resource_type"])
                check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if resource_type is not None:
                self._values["resource_type"] = resource_type
            if tags is not None:
                self._values["tags"] = tags

        @builtins.property
        def resource_type(self) -> typing.Optional[builtins.str]:
            '''The type of resource to tag.

            You can specify tags for the following resource types only: ``instance`` | ``volume`` | ``network-interface`` | ``spot-instances-request`` . If the instance does not include the resource type that you specify, the instance launch fails. For example, not all instance types include a volume.

            To tag a resource after it has been created, see `CreateTags <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-tagspecification.html#cfn-ec2-launchtemplate-tagspecification-resourcetype
            '''
            result = self._values.get("resource_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
            '''The tags to apply to the resource.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-tagspecification.html#cfn-ec2-launchtemplate-tagspecification-tags
            '''
            result = self._values.get("tags")
            return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TagSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.TotalLocalStorageGBProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class TotalLocalStorageGBProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum amount of total local storage, in GB.

            :param max: The maximum amount of total local storage, in GB. To specify no maximum limit, omit this parameter.
            :param min: The minimum amount of total local storage, in GB. To specify no minimum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-totallocalstoragegb.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                total_local_storage_gBProperty = ec2_mixins.CfnLaunchTemplatePropsMixin.TotalLocalStorageGBProperty(
                    max=123,
                    min=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__a5a10183f239509135b72a456a98a498c9f7f62932f403e14641e40efb407378)
                check_type(argname="argument max", value=max, expected_type=type_hints["max"])
                check_type(argname="argument min", value=min, expected_type=type_hints["min"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum amount of total local storage, in GB.

            To specify no maximum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-totallocalstoragegb.html#cfn-ec2-launchtemplate-totallocalstoragegb-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum amount of total local storage, in GB.

            To specify no minimum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-totallocalstoragegb.html#cfn-ec2-launchtemplate-totallocalstoragegb-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TotalLocalStorageGBProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLaunchTemplatePropsMixin.VCpuCountProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class VCpuCountProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum number of vCPUs.

            :param max: The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
            :param min: The minimum number of vCPUs. To specify no minimum limit, specify ``0`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-vcpucount.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                v_cpu_count_property = ec2_mixins.CfnLaunchTemplatePropsMixin.VCpuCountProperty(
                    max=123,
                    min=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__ef48843da0c45113e35a37208a973c41aaec357bfe06eb0d19af9e41c84aca0b)
                check_type(argname="argument max", value=max, expected_type=type_hints["max"])
                check_type(argname="argument min", value=min, expected_type=type_hints["min"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum number of vCPUs.

            To specify no maximum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-vcpucount.html#cfn-ec2-launchtemplate-vcpucount-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum number of vCPUs.

            To specify no minimum limit, specify ``0`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-vcpucount.html#cfn-ec2-launchtemplate-vcpucount-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "VCpuCountProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLocalGatewayRouteMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "destination_cidr_block": "destinationCidrBlock",
        "local_gateway_route_table_id": "localGatewayRouteTableId",
        "local_gateway_virtual_interface_group_id": "localGatewayVirtualInterfaceGroupId",
        "network_interface_id": "networkInterfaceId",
    },
)
class CfnLocalGatewayRouteMixinProps:
    def __init__(
        self,
        *,
        destination_cidr_block: typing.Optional[builtins.str] = None,
        local_gateway_route_table_id: typing.Optional[builtins.str] = None,
        local_gateway_virtual_interface_group_id: typing.Optional[builtins.str] = None,
        network_interface_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnLocalGatewayRoutePropsMixin.

        :param destination_cidr_block: The CIDR block used for destination matches.
        :param local_gateway_route_table_id: The ID of the local gateway route table.
        :param local_gateway_virtual_interface_group_id: The ID of the virtual interface group.
        :param network_interface_id: The ID of the network interface.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroute.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_local_gateway_route_mixin_props = ec2_mixins.CfnLocalGatewayRouteMixinProps(
                destination_cidr_block="destinationCidrBlock",
                local_gateway_route_table_id="localGatewayRouteTableId",
                local_gateway_virtual_interface_group_id="localGatewayVirtualInterfaceGroupId",
                network_interface_id="networkInterfaceId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c0c3a1e5c5e3473847a829c2e20a14b44e0d0a9d867658478a83c5559259ea8e)
            check_type(argname="argument destination_cidr_block", value=destination_cidr_block, expected_type=type_hints["destination_cidr_block"])
            check_type(argname="argument local_gateway_route_table_id", value=local_gateway_route_table_id, expected_type=type_hints["local_gateway_route_table_id"])
            check_type(argname="argument local_gateway_virtual_interface_group_id", value=local_gateway_virtual_interface_group_id, expected_type=type_hints["local_gateway_virtual_interface_group_id"])
            check_type(argname="argument network_interface_id", value=network_interface_id, expected_type=type_hints["network_interface_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if destination_cidr_block is not None:
            self._values["destination_cidr_block"] = destination_cidr_block
        if local_gateway_route_table_id is not None:
            self._values["local_gateway_route_table_id"] = local_gateway_route_table_id
        if local_gateway_virtual_interface_group_id is not None:
            self._values["local_gateway_virtual_interface_group_id"] = local_gateway_virtual_interface_group_id
        if network_interface_id is not None:
            self._values["network_interface_id"] = network_interface_id

    @builtins.property
    def destination_cidr_block(self) -> typing.Optional[builtins.str]:
        '''The CIDR block used for destination matches.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroute.html#cfn-ec2-localgatewayroute-destinationcidrblock
        '''
        result = self._values.get("destination_cidr_block")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_gateway_route_table_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the local gateway route table.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroute.html#cfn-ec2-localgatewayroute-localgatewayroutetableid
        '''
        result = self._values.get("local_gateway_route_table_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_gateway_virtual_interface_group_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the virtual interface group.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroute.html#cfn-ec2-localgatewayroute-localgatewayvirtualinterfacegroupid
        '''
        result = self._values.get("local_gateway_virtual_interface_group_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def network_interface_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the network interface.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroute.html#cfn-ec2-localgatewayroute-networkinterfaceid
        '''
        result = self._values.get("network_interface_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnLocalGatewayRouteMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnLocalGatewayRoutePropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLocalGatewayRoutePropsMixin",
):
    '''Creates a static route for the specified local gateway route table. You must specify one of the following targets:.

    - ``LocalGatewayVirtualInterfaceGroupId``
    - ``NetworkInterfaceId``

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroute.html
    :cloudformationResource: AWS::EC2::LocalGatewayRoute
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_local_gateway_route_props_mixin = ec2_mixins.CfnLocalGatewayRoutePropsMixin(ec2_mixins.CfnLocalGatewayRouteMixinProps(
            destination_cidr_block="destinationCidrBlock",
            local_gateway_route_table_id="localGatewayRouteTableId",
            local_gateway_virtual_interface_group_id="localGatewayVirtualInterfaceGroupId",
            network_interface_id="networkInterfaceId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnLocalGatewayRouteMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::LocalGatewayRoute``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b2598c027dab78ba8fab8bf6e619a47c9e25ca5acccb38b2839b6dc32e546b41)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b17e6dba46b50749e355663cb74c4117c56e5009bb84d7e21840b38e8cbc27b3)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b6c0b9abde7358886a452d1687579592bd3b4e3e8c419d00af948be06ca64d8d)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnLocalGatewayRouteMixinProps":
        return typing.cast("CfnLocalGatewayRouteMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLocalGatewayRouteTableMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "local_gateway_id": "localGatewayId",
        "mode": "mode",
        "tags": "tags",
    },
)
class CfnLocalGatewayRouteTableMixinProps:
    def __init__(
        self,
        *,
        local_gateway_id: typing.Optional[builtins.str] = None,
        mode: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnLocalGatewayRouteTablePropsMixin.

        :param local_gateway_id: The ID of the local gateway.
        :param mode: The mode of the local gateway route table.
        :param tags: The tags assigned to the local gateway route table.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetable.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_local_gateway_route_table_mixin_props = ec2_mixins.CfnLocalGatewayRouteTableMixinProps(
                local_gateway_id="localGatewayId",
                mode="mode",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8734861774b3253f97d6bf71cdc1f97cee754bc7a771f0a3d2771b5db95e643a)
            check_type(argname="argument local_gateway_id", value=local_gateway_id, expected_type=type_hints["local_gateway_id"])
            check_type(argname="argument mode", value=mode, expected_type=type_hints["mode"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if local_gateway_id is not None:
            self._values["local_gateway_id"] = local_gateway_id
        if mode is not None:
            self._values["mode"] = mode
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def local_gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the local gateway.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetable.html#cfn-ec2-localgatewayroutetable-localgatewayid
        '''
        result = self._values.get("local_gateway_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def mode(self) -> typing.Optional[builtins.str]:
        '''The mode of the local gateway route table.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetable.html#cfn-ec2-localgatewayroutetable-mode
        '''
        result = self._values.get("mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags assigned to the local gateway route table.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetable.html#cfn-ec2-localgatewayroutetable-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnLocalGatewayRouteTableMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnLocalGatewayRouteTablePropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLocalGatewayRouteTablePropsMixin",
):
    '''Describes a local gateway route table.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetable.html
    :cloudformationResource: AWS::EC2::LocalGatewayRouteTable
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_local_gateway_route_table_props_mixin = ec2_mixins.CfnLocalGatewayRouteTablePropsMixin(ec2_mixins.CfnLocalGatewayRouteTableMixinProps(
            local_gateway_id="localGatewayId",
            mode="mode",
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnLocalGatewayRouteTableMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::LocalGatewayRouteTable``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7f09510fd3300c6727059961cd6d37aa008ee264b6ff275c50aa8f71c878c3e8)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ff2b1758952e3b9c89fc1b16aba1d4a0de798330ed82e075a4f579050aa26ac0)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__374e9a34a3f4e4a74eede5a899f369bd2a945f0cf1b74de4cc7d028913af5b37)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnLocalGatewayRouteTableMixinProps":
        return typing.cast("CfnLocalGatewayRouteTableMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLocalGatewayRouteTableVPCAssociationMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "local_gateway_route_table_id": "localGatewayRouteTableId",
        "tags": "tags",
        "vpc_id": "vpcId",
    },
)
class CfnLocalGatewayRouteTableVPCAssociationMixinProps:
    def __init__(
        self,
        *,
        local_gateway_route_table_id: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        vpc_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnLocalGatewayRouteTableVPCAssociationPropsMixin.

        :param local_gateway_route_table_id: The ID of the local gateway route table.
        :param tags: The tags assigned to the association.
        :param vpc_id: The ID of the VPC.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevpcassociation.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_local_gateway_route_table_vPCAssociation_mixin_props = ec2_mixins.CfnLocalGatewayRouteTableVPCAssociationMixinProps(
                local_gateway_route_table_id="localGatewayRouteTableId",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                vpc_id="vpcId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0239962953c4482123e542643090af5b1f116caa0e0cd0b7e9be493ff52fe0f9)
            check_type(argname="argument local_gateway_route_table_id", value=local_gateway_route_table_id, expected_type=type_hints["local_gateway_route_table_id"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument vpc_id", value=vpc_id, expected_type=type_hints["vpc_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if local_gateway_route_table_id is not None:
            self._values["local_gateway_route_table_id"] = local_gateway_route_table_id
        if tags is not None:
            self._values["tags"] = tags
        if vpc_id is not None:
            self._values["vpc_id"] = vpc_id

    @builtins.property
    def local_gateway_route_table_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the local gateway route table.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevpcassociation.html#cfn-ec2-localgatewayroutetablevpcassociation-localgatewayroutetableid
        '''
        result = self._values.get("local_gateway_route_table_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags assigned to the association.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevpcassociation.html#cfn-ec2-localgatewayroutetablevpcassociation-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def vpc_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the VPC.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevpcassociation.html#cfn-ec2-localgatewayroutetablevpcassociation-vpcid
        '''
        result = self._values.get("vpc_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnLocalGatewayRouteTableVPCAssociationMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnLocalGatewayRouteTableVPCAssociationPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLocalGatewayRouteTableVPCAssociationPropsMixin",
):
    '''Associates the specified VPC with the specified local gateway route table.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevpcassociation.html
    :cloudformationResource: AWS::EC2::LocalGatewayRouteTableVPCAssociation
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_local_gateway_route_table_vPCAssociation_props_mixin = ec2_mixins.CfnLocalGatewayRouteTableVPCAssociationPropsMixin(ec2_mixins.CfnLocalGatewayRouteTableVPCAssociationMixinProps(
            local_gateway_route_table_id="localGatewayRouteTableId",
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            vpc_id="vpcId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnLocalGatewayRouteTableVPCAssociationMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::LocalGatewayRouteTableVPCAssociation``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__08799c82eeec4e1d747ec35b16945005f9caa79faeed21aa2d4998f4d40d75e7)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9dbdd41f10646e89e13b364632cc2a0f369c3f1769fc741e467d8ef9ee4d3ba7)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__44c95db2b81600f20ff77aa15c88b58b7d610746c86da3b6df4c07f89b2131ff)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnLocalGatewayRouteTableVPCAssociationMixinProps":
        return typing.cast("CfnLocalGatewayRouteTableVPCAssociationMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "local_gateway_route_table_id": "localGatewayRouteTableId",
        "local_gateway_virtual_interface_group_id": "localGatewayVirtualInterfaceGroupId",
        "tags": "tags",
    },
)
class CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationMixinProps:
    def __init__(
        self,
        *,
        local_gateway_route_table_id: typing.Optional[builtins.str] = None,
        local_gateway_virtual_interface_group_id: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationPropsMixin.

        :param local_gateway_route_table_id: The ID of the local gateway route table.
        :param local_gateway_virtual_interface_group_id: The ID of the virtual interface group.
        :param tags: The tags assigned to the association.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevirtualinterfacegroupassociation.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_local_gateway_route_table_virtual_interface_group_association_mixin_props = ec2_mixins.CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationMixinProps(
                local_gateway_route_table_id="localGatewayRouteTableId",
                local_gateway_virtual_interface_group_id="localGatewayVirtualInterfaceGroupId",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6ea439fe7f52962dbe4094ae948f32d27c0ac6c9a0688819eb6df3255c46df55)
            check_type(argname="argument local_gateway_route_table_id", value=local_gateway_route_table_id, expected_type=type_hints["local_gateway_route_table_id"])
            check_type(argname="argument local_gateway_virtual_interface_group_id", value=local_gateway_virtual_interface_group_id, expected_type=type_hints["local_gateway_virtual_interface_group_id"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if local_gateway_route_table_id is not None:
            self._values["local_gateway_route_table_id"] = local_gateway_route_table_id
        if local_gateway_virtual_interface_group_id is not None:
            self._values["local_gateway_virtual_interface_group_id"] = local_gateway_virtual_interface_group_id
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def local_gateway_route_table_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the local gateway route table.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevirtualinterfacegroupassociation.html#cfn-ec2-localgatewayroutetablevirtualinterfacegroupassociation-localgatewayroutetableid
        '''
        result = self._values.get("local_gateway_route_table_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_gateway_virtual_interface_group_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the virtual interface group.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevirtualinterfacegroupassociation.html#cfn-ec2-localgatewayroutetablevirtualinterfacegroupassociation-localgatewayvirtualinterfacegroupid
        '''
        result = self._values.get("local_gateway_virtual_interface_group_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags assigned to the association.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevirtualinterfacegroupassociation.html#cfn-ec2-localgatewayroutetablevirtualinterfacegroupassociation-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationPropsMixin",
):
    '''Describes an association between a local gateway route table and a virtual interface group.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevirtualinterfacegroupassociation.html
    :cloudformationResource: AWS::EC2::LocalGatewayRouteTableVirtualInterfaceGroupAssociation
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_local_gateway_route_table_virtual_interface_group_association_props_mixin = ec2_mixins.CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationPropsMixin(ec2_mixins.CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationMixinProps(
            local_gateway_route_table_id="localGatewayRouteTableId",
            local_gateway_virtual_interface_group_id="localGatewayVirtualInterfaceGroupId",
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::LocalGatewayRouteTableVirtualInterfaceGroupAssociation``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4a1125b2c181e00bea2cbd8066baa6b3369697761c3726b25a9b9da2f6560f02)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f8b008fc550ef2d344ec98b66dc4c82198bf0fcdf7c0ee02cf71a818086a6835)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bd65b945dbe2d9121b15055ed1ca0c071bace51e82a276a8c26f01b37e6d91ec)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(
        self,
    ) -> "CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationMixinProps":
        return typing.cast("CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLocalGatewayVirtualInterfaceGroupMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "local_bgp_asn": "localBgpAsn",
        "local_bgp_asn_extended": "localBgpAsnExtended",
        "local_gateway_id": "localGatewayId",
        "tags": "tags",
    },
)
class CfnLocalGatewayVirtualInterfaceGroupMixinProps:
    def __init__(
        self,
        *,
        local_bgp_asn: typing.Optional[jsii.Number] = None,
        local_bgp_asn_extended: typing.Optional[jsii.Number] = None,
        local_gateway_id: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnLocalGatewayVirtualInterfaceGroupPropsMixin.

        :param local_bgp_asn: The Autonomous System Number(ASN) for the local Border Gateway Protocol (BGP).
        :param local_bgp_asn_extended: The extended 32-bit ASN for the local BGP configuration.
        :param local_gateway_id: The ID of the local gateway.
        :param tags: The tags assigned to the virtual interface group.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayvirtualinterfacegroup.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_local_gateway_virtual_interface_group_mixin_props = ec2_mixins.CfnLocalGatewayVirtualInterfaceGroupMixinProps(
                local_bgp_asn=123,
                local_bgp_asn_extended=123,
                local_gateway_id="localGatewayId",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__452d0ccfbbd8a3aa9152637a38c1d60b1d5e673ec6049ba347afc733ca59188f)
            check_type(argname="argument local_bgp_asn", value=local_bgp_asn, expected_type=type_hints["local_bgp_asn"])
            check_type(argname="argument local_bgp_asn_extended", value=local_bgp_asn_extended, expected_type=type_hints["local_bgp_asn_extended"])
            check_type(argname="argument local_gateway_id", value=local_gateway_id, expected_type=type_hints["local_gateway_id"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if local_bgp_asn is not None:
            self._values["local_bgp_asn"] = local_bgp_asn
        if local_bgp_asn_extended is not None:
            self._values["local_bgp_asn_extended"] = local_bgp_asn_extended
        if local_gateway_id is not None:
            self._values["local_gateway_id"] = local_gateway_id
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def local_bgp_asn(self) -> typing.Optional[jsii.Number]:
        '''The Autonomous System Number(ASN) for the local Border Gateway Protocol (BGP).

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayvirtualinterfacegroup.html#cfn-ec2-localgatewayvirtualinterfacegroup-localbgpasn
        '''
        result = self._values.get("local_bgp_asn")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def local_bgp_asn_extended(self) -> typing.Optional[jsii.Number]:
        '''The extended 32-bit ASN for the local BGP configuration.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayvirtualinterfacegroup.html#cfn-ec2-localgatewayvirtualinterfacegroup-localbgpasnextended
        '''
        result = self._values.get("local_bgp_asn_extended")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def local_gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the local gateway.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayvirtualinterfacegroup.html#cfn-ec2-localgatewayvirtualinterfacegroup-localgatewayid
        '''
        result = self._values.get("local_gateway_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags assigned to the virtual interface group.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayvirtualinterfacegroup.html#cfn-ec2-localgatewayvirtualinterfacegroup-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnLocalGatewayVirtualInterfaceGroupMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnLocalGatewayVirtualInterfaceGroupPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLocalGatewayVirtualInterfaceGroupPropsMixin",
):
    '''Describes a local gateway virtual interface group.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayvirtualinterfacegroup.html
    :cloudformationResource: AWS::EC2::LocalGatewayVirtualInterfaceGroup
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_local_gateway_virtual_interface_group_props_mixin = ec2_mixins.CfnLocalGatewayVirtualInterfaceGroupPropsMixin(ec2_mixins.CfnLocalGatewayVirtualInterfaceGroupMixinProps(
            local_bgp_asn=123,
            local_bgp_asn_extended=123,
            local_gateway_id="localGatewayId",
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnLocalGatewayVirtualInterfaceGroupMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::LocalGatewayVirtualInterfaceGroup``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fa536b650b17ac381c9cec830a0489cb4a47dd32d6d054f609ed8200f858ab5c)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d4826e36048e0d5adfe1a40f8577bed98e84deeb3aa1f23ea01871026a36457c)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b4a902e543aad4d1a3db8eea9b75bda7425ebac42968920cfcf1ee6d61829c60)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnLocalGatewayVirtualInterfaceGroupMixinProps":
        return typing.cast("CfnLocalGatewayVirtualInterfaceGroupMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLocalGatewayVirtualInterfaceMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "local_address": "localAddress",
        "local_gateway_virtual_interface_group_id": "localGatewayVirtualInterfaceGroupId",
        "outpost_lag_id": "outpostLagId",
        "peer_address": "peerAddress",
        "peer_bgp_asn": "peerBgpAsn",
        "peer_bgp_asn_extended": "peerBgpAsnExtended",
        "tags": "tags",
        "vlan": "vlan",
    },
)
class CfnLocalGatewayVirtualInterfaceMixinProps:
    def __init__(
        self,
        *,
        local_address: typing.Optional[builtins.str] = None,
        local_gateway_virtual_interface_group_id: typing.Optional[builtins.str] = None,
        outpost_lag_id: typing.Optional[builtins.str] = None,
        peer_address: typing.Optional[builtins.str] = None,
        peer_bgp_asn: typing.Optional[jsii.Number] = None,
        peer_bgp_asn_extended: typing.Optional[jsii.Number] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        vlan: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Properties for CfnLocalGatewayVirtualInterfacePropsMixin.

        :param local_address: The local address.
        :param local_gateway_virtual_interface_group_id: The ID of the local gateway virtual interface group.
        :param outpost_lag_id: The Outpost LAG ID.
        :param peer_address: The peer address.
        :param peer_bgp_asn: The peer BGP ASN.
        :param peer_bgp_asn_extended: The extended 32-bit ASN of the BGP peer for use with larger ASN values.
        :param tags: The tags assigned to the virtual interface.
        :param vlan: The ID of the VLAN.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayvirtualinterface.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_local_gateway_virtual_interface_mixin_props = ec2_mixins.CfnLocalGatewayVirtualInterfaceMixinProps(
                local_address="localAddress",
                local_gateway_virtual_interface_group_id="localGatewayVirtualInterfaceGroupId",
                outpost_lag_id="outpostLagId",
                peer_address="peerAddress",
                peer_bgp_asn=123,
                peer_bgp_asn_extended=123,
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                vlan=123
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__124bd5fee7fdbd43875b3a24fdbd91459eaddedddaeafbcd930e86e08d9be180)
            check_type(argname="argument local_address", value=local_address, expected_type=type_hints["local_address"])
            check_type(argname="argument local_gateway_virtual_interface_group_id", value=local_gateway_virtual_interface_group_id, expected_type=type_hints["local_gateway_virtual_interface_group_id"])
            check_type(argname="argument outpost_lag_id", value=outpost_lag_id, expected_type=type_hints["outpost_lag_id"])
            check_type(argname="argument peer_address", value=peer_address, expected_type=type_hints["peer_address"])
            check_type(argname="argument peer_bgp_asn", value=peer_bgp_asn, expected_type=type_hints["peer_bgp_asn"])
            check_type(argname="argument peer_bgp_asn_extended", value=peer_bgp_asn_extended, expected_type=type_hints["peer_bgp_asn_extended"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument vlan", value=vlan, expected_type=type_hints["vlan"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if local_address is not None:
            self._values["local_address"] = local_address
        if local_gateway_virtual_interface_group_id is not None:
            self._values["local_gateway_virtual_interface_group_id"] = local_gateway_virtual_interface_group_id
        if outpost_lag_id is not None:
            self._values["outpost_lag_id"] = outpost_lag_id
        if peer_address is not None:
            self._values["peer_address"] = peer_address
        if peer_bgp_asn is not None:
            self._values["peer_bgp_asn"] = peer_bgp_asn
        if peer_bgp_asn_extended is not None:
            self._values["peer_bgp_asn_extended"] = peer_bgp_asn_extended
        if tags is not None:
            self._values["tags"] = tags
        if vlan is not None:
            self._values["vlan"] = vlan

    @builtins.property
    def local_address(self) -> typing.Optional[builtins.str]:
        '''The local address.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayvirtualinterface.html#cfn-ec2-localgatewayvirtualinterface-localaddress
        '''
        result = self._values.get("local_address")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_gateway_virtual_interface_group_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the local gateway virtual interface group.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayvirtualinterface.html#cfn-ec2-localgatewayvirtualinterface-localgatewayvirtualinterfacegroupid
        '''
        result = self._values.get("local_gateway_virtual_interface_group_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def outpost_lag_id(self) -> typing.Optional[builtins.str]:
        '''The Outpost LAG ID.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayvirtualinterface.html#cfn-ec2-localgatewayvirtualinterface-outpostlagid
        '''
        result = self._values.get("outpost_lag_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def peer_address(self) -> typing.Optional[builtins.str]:
        '''The peer address.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayvirtualinterface.html#cfn-ec2-localgatewayvirtualinterface-peeraddress
        '''
        result = self._values.get("peer_address")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def peer_bgp_asn(self) -> typing.Optional[jsii.Number]:
        '''The peer BGP ASN.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayvirtualinterface.html#cfn-ec2-localgatewayvirtualinterface-peerbgpasn
        '''
        result = self._values.get("peer_bgp_asn")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def peer_bgp_asn_extended(self) -> typing.Optional[jsii.Number]:
        '''The extended 32-bit ASN of the BGP peer for use with larger ASN values.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayvirtualinterface.html#cfn-ec2-localgatewayvirtualinterface-peerbgpasnextended
        '''
        result = self._values.get("peer_bgp_asn_extended")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags assigned to the virtual interface.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayvirtualinterface.html#cfn-ec2-localgatewayvirtualinterface-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def vlan(self) -> typing.Optional[jsii.Number]:
        '''The ID of the VLAN.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayvirtualinterface.html#cfn-ec2-localgatewayvirtualinterface-vlan
        '''
        result = self._values.get("vlan")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnLocalGatewayVirtualInterfaceMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnLocalGatewayVirtualInterfacePropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnLocalGatewayVirtualInterfacePropsMixin",
):
    '''Describes a local gateway virtual interface.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayvirtualinterface.html
    :cloudformationResource: AWS::EC2::LocalGatewayVirtualInterface
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_local_gateway_virtual_interface_props_mixin = ec2_mixins.CfnLocalGatewayVirtualInterfacePropsMixin(ec2_mixins.CfnLocalGatewayVirtualInterfaceMixinProps(
            local_address="localAddress",
            local_gateway_virtual_interface_group_id="localGatewayVirtualInterfaceGroupId",
            outpost_lag_id="outpostLagId",
            peer_address="peerAddress",
            peer_bgp_asn=123,
            peer_bgp_asn_extended=123,
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            vlan=123
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnLocalGatewayVirtualInterfaceMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::LocalGatewayVirtualInterface``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__37546942174763d6fc7fbabf4101c34eb7da4dc156e7e6a9bcf9fdc1ff0d269d)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6ee3d8a11d5c9a98e6d30f9a096b7e4b2af8b03168bd679e39004e6c7f10f3fc)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__41e8af99ec302a9922777ea3881a74da346c2b61dbc456d10b2e843d6d46330f)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnLocalGatewayVirtualInterfaceMixinProps":
        return typing.cast("CfnLocalGatewayVirtualInterfaceMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNatGatewayMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "allocation_id": "allocationId",
        "availability_mode": "availabilityMode",
        "availability_zone_addresses": "availabilityZoneAddresses",
        "connectivity_type": "connectivityType",
        "max_drain_duration_seconds": "maxDrainDurationSeconds",
        "private_ip_address": "privateIpAddress",
        "secondary_allocation_ids": "secondaryAllocationIds",
        "secondary_private_ip_address_count": "secondaryPrivateIpAddressCount",
        "secondary_private_ip_addresses": "secondaryPrivateIpAddresses",
        "subnet_id": "subnetId",
        "tags": "tags",
        "vpc_id": "vpcId",
    },
)
class CfnNatGatewayMixinProps:
    def __init__(
        self,
        *,
        allocation_id: typing.Optional[builtins.str] = None,
        availability_mode: typing.Optional[builtins.str] = None,
        availability_zone_addresses: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNatGatewayPropsMixin.AvailabilityZoneAddressProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        connectivity_type: typing.Optional[builtins.str] = None,
        max_drain_duration_seconds: typing.Optional[jsii.Number] = None,
        private_ip_address: typing.Optional[builtins.str] = None,
        secondary_allocation_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        secondary_private_ip_address_count: typing.Optional[jsii.Number] = None,
        secondary_private_ip_addresses: typing.Optional[typing.Sequence[builtins.str]] = None,
        subnet_id: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        vpc_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnNatGatewayPropsMixin.

        :param allocation_id: [Public NAT gateway only] The allocation ID of the Elastic IP address that's associated with the NAT gateway. This property is required for a public NAT gateway and cannot be specified with a private NAT gateway.
        :param availability_mode: Indicates whether this is a zonal (single-AZ) or regional (multi-AZ) NAT gateway. A zonal NAT gateway is a NAT Gateway that provides redundancy and scalability within a single availability zone. A regional NAT gateway is a single NAT Gateway that works across multiple availability zones (AZs) in your VPC, providing redundancy, scalability and availability across all the AZs in a Region. For more information, see `Regional NAT gateways for automatic multi-AZ expansion <https://docs.aws.amazon.com/vpc/latest/userguide/nat-gateways-regional.html>`_ in the *Amazon VPC User Guide* .
        :param availability_zone_addresses: For regional NAT gateways only: Specifies which Availability Zones you want the NAT gateway to support and the Elastic IP addresses (EIPs) to use in each AZ. The regional NAT gateway uses these EIPs to handle outbound NAT traffic from their respective AZs. If not specified, the NAT gateway will automatically expand to new AZs and associate EIPs upon detection of an elastic network interface. If you specify this parameter, auto-expansion is disabled and you must manually manage AZ coverage. A regional NAT gateway is a single NAT Gateway that works across multiple availability zones (AZs) in your VPC, providing redundancy, scalability and availability across all the AZs in a Region. For more information, see `Regional NAT gateways for automatic multi-AZ expansion <https://docs.aws.amazon.com/vpc/latest/userguide/nat-gateways-regional.html>`_ in the *Amazon VPC User Guide* .
        :param connectivity_type: Indicates whether the NAT gateway supports public or private connectivity. The default is public connectivity.
        :param max_drain_duration_seconds: The maximum amount of time to wait (in seconds) before forcibly releasing the IP addresses if connections are still in progress. Default value is 350 seconds.
        :param private_ip_address: The private IPv4 address to assign to the NAT gateway. If you don't provide an address, a private IPv4 address will be automatically assigned.
        :param secondary_allocation_ids: Secondary EIP allocation IDs. For more information, see `Create a NAT gateway <https://docs.aws.amazon.com/vpc/latest/userguide/nat-gateway-working-with.html>`_ in the *Amazon VPC User Guide* .
        :param secondary_private_ip_address_count: [Private NAT gateway only] The number of secondary private IPv4 addresses you want to assign to the NAT gateway. For more information about secondary addresses, see `Create a NAT gateway <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html#nat-gateway-creating>`_ in the *Amazon Virtual Private Cloud User Guide* . ``SecondaryPrivateIpAddressCount`` and ``SecondaryPrivateIpAddresses`` cannot be set at the same time.
        :param secondary_private_ip_addresses: Secondary private IPv4 addresses. For more information about secondary addresses, see `Create a NAT gateway <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html#nat-gateway-creating>`_ in the *Amazon Virtual Private Cloud User Guide* . ``SecondaryPrivateIpAddressCount`` and ``SecondaryPrivateIpAddresses`` cannot be set at the same time.
        :param subnet_id: The ID of the subnet in which the NAT gateway is located.
        :param tags: The tags for the NAT gateway.
        :param vpc_id: The ID of the VPC in which the NAT gateway is located.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_nat_gateway_mixin_props = ec2_mixins.CfnNatGatewayMixinProps(
                allocation_id="allocationId",
                availability_mode="availabilityMode",
                availability_zone_addresses=[ec2_mixins.CfnNatGatewayPropsMixin.AvailabilityZoneAddressProperty(
                    allocation_ids=["allocationIds"],
                    availability_zone="availabilityZone",
                    availability_zone_id="availabilityZoneId"
                )],
                connectivity_type="connectivityType",
                max_drain_duration_seconds=123,
                private_ip_address="privateIpAddress",
                secondary_allocation_ids=["secondaryAllocationIds"],
                secondary_private_ip_address_count=123,
                secondary_private_ip_addresses=["secondaryPrivateIpAddresses"],
                subnet_id="subnetId",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                vpc_id="vpcId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__68167a0b3f33310ab398389f86c8681b33d82127d2ee165ef334c9b1166b424a)
            check_type(argname="argument allocation_id", value=allocation_id, expected_type=type_hints["allocation_id"])
            check_type(argname="argument availability_mode", value=availability_mode, expected_type=type_hints["availability_mode"])
            check_type(argname="argument availability_zone_addresses", value=availability_zone_addresses, expected_type=type_hints["availability_zone_addresses"])
            check_type(argname="argument connectivity_type", value=connectivity_type, expected_type=type_hints["connectivity_type"])
            check_type(argname="argument max_drain_duration_seconds", value=max_drain_duration_seconds, expected_type=type_hints["max_drain_duration_seconds"])
            check_type(argname="argument private_ip_address", value=private_ip_address, expected_type=type_hints["private_ip_address"])
            check_type(argname="argument secondary_allocation_ids", value=secondary_allocation_ids, expected_type=type_hints["secondary_allocation_ids"])
            check_type(argname="argument secondary_private_ip_address_count", value=secondary_private_ip_address_count, expected_type=type_hints["secondary_private_ip_address_count"])
            check_type(argname="argument secondary_private_ip_addresses", value=secondary_private_ip_addresses, expected_type=type_hints["secondary_private_ip_addresses"])
            check_type(argname="argument subnet_id", value=subnet_id, expected_type=type_hints["subnet_id"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument vpc_id", value=vpc_id, expected_type=type_hints["vpc_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if allocation_id is not None:
            self._values["allocation_id"] = allocation_id
        if availability_mode is not None:
            self._values["availability_mode"] = availability_mode
        if availability_zone_addresses is not None:
            self._values["availability_zone_addresses"] = availability_zone_addresses
        if connectivity_type is not None:
            self._values["connectivity_type"] = connectivity_type
        if max_drain_duration_seconds is not None:
            self._values["max_drain_duration_seconds"] = max_drain_duration_seconds
        if private_ip_address is not None:
            self._values["private_ip_address"] = private_ip_address
        if secondary_allocation_ids is not None:
            self._values["secondary_allocation_ids"] = secondary_allocation_ids
        if secondary_private_ip_address_count is not None:
            self._values["secondary_private_ip_address_count"] = secondary_private_ip_address_count
        if secondary_private_ip_addresses is not None:
            self._values["secondary_private_ip_addresses"] = secondary_private_ip_addresses
        if subnet_id is not None:
            self._values["subnet_id"] = subnet_id
        if tags is not None:
            self._values["tags"] = tags
        if vpc_id is not None:
            self._values["vpc_id"] = vpc_id

    @builtins.property
    def allocation_id(self) -> typing.Optional[builtins.str]:
        '''[Public NAT gateway only] The allocation ID of the Elastic IP address that's associated with the NAT gateway.

        This property is required for a public NAT gateway and cannot be specified with a private NAT gateway.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-allocationid
        '''
        result = self._values.get("allocation_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def availability_mode(self) -> typing.Optional[builtins.str]:
        '''Indicates whether this is a zonal (single-AZ) or regional (multi-AZ) NAT gateway.

        A zonal NAT gateway is a NAT Gateway that provides redundancy and scalability within a single availability zone. A regional NAT gateway is a single NAT Gateway that works across multiple availability zones (AZs) in your VPC, providing redundancy, scalability and availability across all the AZs in a Region.

        For more information, see `Regional NAT gateways for automatic multi-AZ expansion <https://docs.aws.amazon.com/vpc/latest/userguide/nat-gateways-regional.html>`_ in the *Amazon VPC User Guide* .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-availabilitymode
        '''
        result = self._values.get("availability_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def availability_zone_addresses(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNatGatewayPropsMixin.AvailabilityZoneAddressProperty"]]]]:
        '''For regional NAT gateways only: Specifies which Availability Zones you want the NAT gateway to support and the Elastic IP addresses (EIPs) to use in each AZ.

        The regional NAT gateway uses these EIPs to handle outbound NAT traffic from their respective AZs. If not specified, the NAT gateway will automatically expand to new AZs and associate EIPs upon detection of an elastic network interface. If you specify this parameter, auto-expansion is disabled and you must manually manage AZ coverage.

        A regional NAT gateway is a single NAT Gateway that works across multiple availability zones (AZs) in your VPC, providing redundancy, scalability and availability across all the AZs in a Region.

        For more information, see `Regional NAT gateways for automatic multi-AZ expansion <https://docs.aws.amazon.com/vpc/latest/userguide/nat-gateways-regional.html>`_ in the *Amazon VPC User Guide* .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-availabilityzoneaddresses
        '''
        result = self._values.get("availability_zone_addresses")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNatGatewayPropsMixin.AvailabilityZoneAddressProperty"]]]], result)

    @builtins.property
    def connectivity_type(self) -> typing.Optional[builtins.str]:
        '''Indicates whether the NAT gateway supports public or private connectivity.

        The default is public connectivity.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-connectivitytype
        '''
        result = self._values.get("connectivity_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def max_drain_duration_seconds(self) -> typing.Optional[jsii.Number]:
        '''The maximum amount of time to wait (in seconds) before forcibly releasing the IP addresses if connections are still in progress.

        Default value is 350 seconds.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-maxdraindurationseconds
        '''
        result = self._values.get("max_drain_duration_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def private_ip_address(self) -> typing.Optional[builtins.str]:
        '''The private IPv4 address to assign to the NAT gateway.

        If you don't provide an address, a private IPv4 address will be automatically assigned.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-privateipaddress
        '''
        result = self._values.get("private_ip_address")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secondary_allocation_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Secondary EIP allocation IDs.

        For more information, see `Create a NAT gateway <https://docs.aws.amazon.com/vpc/latest/userguide/nat-gateway-working-with.html>`_ in the *Amazon VPC User Guide* .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-secondaryallocationids
        '''
        result = self._values.get("secondary_allocation_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def secondary_private_ip_address_count(self) -> typing.Optional[jsii.Number]:
        '''[Private NAT gateway only] The number of secondary private IPv4 addresses you want to assign to the NAT gateway.

        For more information about secondary addresses, see `Create a NAT gateway <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html#nat-gateway-creating>`_ in the *Amazon Virtual Private Cloud User Guide* .

        ``SecondaryPrivateIpAddressCount`` and ``SecondaryPrivateIpAddresses`` cannot be set at the same time.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-secondaryprivateipaddresscount
        '''
        result = self._values.get("secondary_private_ip_address_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def secondary_private_ip_addresses(
        self,
    ) -> typing.Optional[typing.List[builtins.str]]:
        '''Secondary private IPv4 addresses.

        For more information about secondary addresses, see `Create a NAT gateway <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html#nat-gateway-creating>`_ in the *Amazon Virtual Private Cloud User Guide* .

        ``SecondaryPrivateIpAddressCount`` and ``SecondaryPrivateIpAddresses`` cannot be set at the same time.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-secondaryprivateipaddresses
        '''
        result = self._values.get("secondary_private_ip_addresses")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def subnet_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the subnet in which the NAT gateway is located.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-subnetid
        '''
        result = self._values.get("subnet_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags for the NAT gateway.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def vpc_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the VPC in which the NAT gateway is located.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-vpcid
        '''
        result = self._values.get("vpc_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnNatGatewayMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnNatGatewayPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNatGatewayPropsMixin",
):
    '''Specifies a network address translation (NAT) gateway in the specified subnet.

    You can create either a public NAT gateway or a private NAT gateway. The default is a public NAT gateway. If you create a public NAT gateway, you must specify an elastic IP address.

    With a NAT gateway, instances in a private subnet can connect to the internet, other AWS services, or an on-premises network using the IP address of the NAT gateway. For more information, see `NAT gateways <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html>`_ in the *Amazon VPC User Guide* .

    If you add a default route ( ``AWS::EC2::Route`` resource) that points to a NAT gateway, specify the NAT gateway ID for the route's ``NatGatewayId`` property.
    .. epigraph::

       When you associate an Elastic IP address or secondary Elastic IP address with a public NAT gateway, the network border group of the Elastic IP address must match the network border group of the Availability Zone (AZ) that the public NAT gateway is in. Otherwise, the NAT gateway fails to launch. You can see the network border group for the AZ by viewing the details of the subnet. Similarly, you can view the network border group for the Elastic IP address by viewing its details. For more information, see `Allocate an Elastic IP address <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-eips.html#allocate-eip>`_ in the *Amazon VPC User Guide* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html
    :cloudformationResource: AWS::EC2::NatGateway
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_nat_gateway_props_mixin = ec2_mixins.CfnNatGatewayPropsMixin(ec2_mixins.CfnNatGatewayMixinProps(
            allocation_id="allocationId",
            availability_mode="availabilityMode",
            availability_zone_addresses=[ec2_mixins.CfnNatGatewayPropsMixin.AvailabilityZoneAddressProperty(
                allocation_ids=["allocationIds"],
                availability_zone="availabilityZone",
                availability_zone_id="availabilityZoneId"
            )],
            connectivity_type="connectivityType",
            max_drain_duration_seconds=123,
            private_ip_address="privateIpAddress",
            secondary_allocation_ids=["secondaryAllocationIds"],
            secondary_private_ip_address_count=123,
            secondary_private_ip_addresses=["secondaryPrivateIpAddresses"],
            subnet_id="subnetId",
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            vpc_id="vpcId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnNatGatewayMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::NatGateway``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__264394afd1351433c06a428cd4302f3957e584af18bf49cd7aac4dc1d8511ff9)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__087cf570400487e8e8450a88f7f03ecb776537cf37bf0af4709284a248e8ac60)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a3cf8137a4c1ced1d6d1f2ee9c6b29069a44a0aa0903331b10a9a8c94e99e013)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnNatGatewayMixinProps":
        return typing.cast("CfnNatGatewayMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNatGatewayPropsMixin.AvailabilityZoneAddressProperty",
        jsii_struct_bases=[],
        name_mapping={
            "allocation_ids": "allocationIds",
            "availability_zone": "availabilityZone",
            "availability_zone_id": "availabilityZoneId",
        },
    )
    class AvailabilityZoneAddressProperty:
        def __init__(
            self,
            *,
            allocation_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
            availability_zone: typing.Optional[builtins.str] = None,
            availability_zone_id: typing.Optional[builtins.str] = None,
        ) -> None:
            '''For regional NAT gateways only: The configuration specifying which Elastic IP address (EIP) to use for handling outbound NAT traffic from a specific Availability Zone.

            A regional NAT gateway is a single NAT Gateway that works across multiple availability zones (AZs) in your VPC, providing redundancy, scalability and availability across all the AZs in a Region.

            For more information, see `Regional NAT gateways for automatic multi-AZ expansion <https://docs.aws.amazon.com/vpc/latest/userguide/nat-gateways-regional.html>`_ in the *Amazon VPC User Guide* .

            :param allocation_ids: The allocation IDs of the Elastic IP addresses (EIPs) to be used for handling outbound NAT traffic in this specific Availability Zone.
            :param availability_zone: For regional NAT gateways only: The Availability Zone where this specific NAT gateway configuration will be active. Each AZ in a regional NAT gateway has its own configuration to handle outbound NAT traffic from that AZ. A regional NAT gateway is a single NAT Gateway that works across multiple availability zones (AZs) in your VPC, providing redundancy, scalability and availability across all the AZs in a Region.
            :param availability_zone_id: For regional NAT gateways only: The ID of the Availability Zone where this specific NAT gateway configuration will be active. Each AZ in a regional NAT gateway has its own configuration to handle outbound NAT traffic from that AZ. Use this instead of AvailabilityZone for consistent identification of AZs across AWS Regions. A regional NAT gateway is a single NAT Gateway that works across multiple availability zones (AZs) in your VPC, providing redundancy, scalability and availability across all the AZs in a Region.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-natgateway-availabilityzoneaddress.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                availability_zone_address_property = ec2_mixins.CfnNatGatewayPropsMixin.AvailabilityZoneAddressProperty(
                    allocation_ids=["allocationIds"],
                    availability_zone="availabilityZone",
                    availability_zone_id="availabilityZoneId"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__29b46d6944b9b565e55738423e36fa390617f435cefc03476f8daec0e83536cf)
                check_type(argname="argument allocation_ids", value=allocation_ids, expected_type=type_hints["allocation_ids"])
                check_type(argname="argument availability_zone", value=availability_zone, expected_type=type_hints["availability_zone"])
                check_type(argname="argument availability_zone_id", value=availability_zone_id, expected_type=type_hints["availability_zone_id"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if allocation_ids is not None:
                self._values["allocation_ids"] = allocation_ids
            if availability_zone is not None:
                self._values["availability_zone"] = availability_zone
            if availability_zone_id is not None:
                self._values["availability_zone_id"] = availability_zone_id

        @builtins.property
        def allocation_ids(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The allocation IDs of the Elastic IP addresses (EIPs) to be used for handling outbound NAT traffic in this specific Availability Zone.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-natgateway-availabilityzoneaddress.html#cfn-ec2-natgateway-availabilityzoneaddress-allocationids
            '''
            result = self._values.get("allocation_ids")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def availability_zone(self) -> typing.Optional[builtins.str]:
            '''For regional NAT gateways only: The Availability Zone where this specific NAT gateway configuration will be active.

            Each AZ in a regional NAT gateway has its own configuration to handle outbound NAT traffic from that AZ.

            A regional NAT gateway is a single NAT Gateway that works across multiple availability zones (AZs) in your VPC, providing redundancy, scalability and availability across all the AZs in a Region.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-natgateway-availabilityzoneaddress.html#cfn-ec2-natgateway-availabilityzoneaddress-availabilityzone
            '''
            result = self._values.get("availability_zone")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def availability_zone_id(self) -> typing.Optional[builtins.str]:
            '''For regional NAT gateways only: The ID of the Availability Zone where this specific NAT gateway configuration will be active.

            Each AZ in a regional NAT gateway has its own configuration to handle outbound NAT traffic from that AZ. Use this instead of AvailabilityZone for consistent identification of AZs across AWS Regions.

            A regional NAT gateway is a single NAT Gateway that works across multiple availability zones (AZs) in your VPC, providing redundancy, scalability and availability across all the AZs in a Region.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-natgateway-availabilityzoneaddress.html#cfn-ec2-natgateway-availabilityzoneaddress-availabilityzoneid
            '''
            result = self._values.get("availability_zone_id")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AvailabilityZoneAddressProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkAclEntryMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "cidr_block": "cidrBlock",
        "egress": "egress",
        "icmp": "icmp",
        "ipv6_cidr_block": "ipv6CidrBlock",
        "network_acl_id": "networkAclId",
        "port_range": "portRange",
        "protocol": "protocol",
        "rule_action": "ruleAction",
        "rule_number": "ruleNumber",
    },
)
class CfnNetworkAclEntryMixinProps:
    def __init__(
        self,
        *,
        cidr_block: typing.Optional[builtins.str] = None,
        egress: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        icmp: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkAclEntryPropsMixin.IcmpProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ipv6_cidr_block: typing.Optional[builtins.str] = None,
        network_acl_id: typing.Optional[builtins.str] = None,
        port_range: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkAclEntryPropsMixin.PortRangeProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        protocol: typing.Optional[jsii.Number] = None,
        rule_action: typing.Optional[builtins.str] = None,
        rule_number: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Properties for CfnNetworkAclEntryPropsMixin.

        :param cidr_block: The IPv4 CIDR range to allow or deny, in CIDR notation (for example, 172.16.0.0/24). You must specify an IPv4 CIDR block or an IPv6 CIDR block.
        :param egress: Whether this rule applies to egress traffic from the subnet ( ``true`` ) or ingress traffic to the subnet ( ``false`` ). By default, AWS CloudFormation specifies ``false`` .
        :param icmp: The Internet Control Message Protocol (ICMP) code and type. Required if specifying 1 (ICMP) for the protocol parameter.
        :param ipv6_cidr_block: The IPv6 network range to allow or deny, in CIDR notation. You must specify an IPv4 CIDR block or an IPv6 CIDR block.
        :param network_acl_id: The ID of the ACL for the entry.
        :param port_range: The range of port numbers for the UDP/TCP protocol. Required if specifying 6 (TCP) or 17 (UDP) for the protocol parameter.
        :param protocol: The IP protocol that the rule applies to. You must specify -1 or a protocol number. You can specify -1 for all protocols. .. epigraph:: If you specify -1, all ports are opened and the ``PortRange`` property is ignored.
        :param rule_action: Whether to allow or deny traffic that matches the rule; valid values are "allow" or "deny".
        :param rule_number: Rule number to assign to the entry, such as 100. ACL entries are processed in ascending order by rule number. Entries can't use the same rule number unless one is an egress rule and the other is an ingress rule.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_network_acl_entry_mixin_props = ec2_mixins.CfnNetworkAclEntryMixinProps(
                cidr_block="cidrBlock",
                egress=False,
                icmp=ec2_mixins.CfnNetworkAclEntryPropsMixin.IcmpProperty(
                    code=123,
                    type=123
                ),
                ipv6_cidr_block="ipv6CidrBlock",
                network_acl_id="networkAclId",
                port_range=ec2_mixins.CfnNetworkAclEntryPropsMixin.PortRangeProperty(
                    from=123,
                    to=123
                ),
                protocol=123,
                rule_action="ruleAction",
                rule_number=123
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__00a3ef97b127d59a3d5af6792b484b15c48e12c8b5aae800ac0aff1ecd1b5be7)
            check_type(argname="argument cidr_block", value=cidr_block, expected_type=type_hints["cidr_block"])
            check_type(argname="argument egress", value=egress, expected_type=type_hints["egress"])
            check_type(argname="argument icmp", value=icmp, expected_type=type_hints["icmp"])
            check_type(argname="argument ipv6_cidr_block", value=ipv6_cidr_block, expected_type=type_hints["ipv6_cidr_block"])
            check_type(argname="argument network_acl_id", value=network_acl_id, expected_type=type_hints["network_acl_id"])
            check_type(argname="argument port_range", value=port_range, expected_type=type_hints["port_range"])
            check_type(argname="argument protocol", value=protocol, expected_type=type_hints["protocol"])
            check_type(argname="argument rule_action", value=rule_action, expected_type=type_hints["rule_action"])
            check_type(argname="argument rule_number", value=rule_number, expected_type=type_hints["rule_number"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if cidr_block is not None:
            self._values["cidr_block"] = cidr_block
        if egress is not None:
            self._values["egress"] = egress
        if icmp is not None:
            self._values["icmp"] = icmp
        if ipv6_cidr_block is not None:
            self._values["ipv6_cidr_block"] = ipv6_cidr_block
        if network_acl_id is not None:
            self._values["network_acl_id"] = network_acl_id
        if port_range is not None:
            self._values["port_range"] = port_range
        if protocol is not None:
            self._values["protocol"] = protocol
        if rule_action is not None:
            self._values["rule_action"] = rule_action
        if rule_number is not None:
            self._values["rule_number"] = rule_number

    @builtins.property
    def cidr_block(self) -> typing.Optional[builtins.str]:
        '''The IPv4 CIDR range to allow or deny, in CIDR notation (for example, 172.16.0.0/24). You must specify an IPv4 CIDR block or an IPv6 CIDR block.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-cidrblock
        '''
        result = self._values.get("cidr_block")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def egress(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Whether this rule applies to egress traffic from the subnet ( ``true`` ) or ingress traffic to the subnet ( ``false`` ).

        By default, AWS CloudFormation specifies ``false`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-egress
        '''
        result = self._values.get("egress")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def icmp(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkAclEntryPropsMixin.IcmpProperty"]]:
        '''The Internet Control Message Protocol (ICMP) code and type.

        Required if specifying 1 (ICMP) for the protocol parameter.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-icmp
        '''
        result = self._values.get("icmp")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkAclEntryPropsMixin.IcmpProperty"]], result)

    @builtins.property
    def ipv6_cidr_block(self) -> typing.Optional[builtins.str]:
        '''The IPv6 network range to allow or deny, in CIDR notation.

        You must specify an IPv4 CIDR block or an IPv6 CIDR block.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-ipv6cidrblock
        '''
        result = self._values.get("ipv6_cidr_block")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def network_acl_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the ACL for the entry.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-networkaclid
        '''
        result = self._values.get("network_acl_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def port_range(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkAclEntryPropsMixin.PortRangeProperty"]]:
        '''The range of port numbers for the UDP/TCP protocol.

        Required if specifying 6 (TCP) or 17 (UDP) for the protocol parameter.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-portrange
        '''
        result = self._values.get("port_range")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkAclEntryPropsMixin.PortRangeProperty"]], result)

    @builtins.property
    def protocol(self) -> typing.Optional[jsii.Number]:
        '''The IP protocol that the rule applies to.

        You must specify -1 or a protocol number. You can specify -1 for all protocols.
        .. epigraph::

           If you specify -1, all ports are opened and the ``PortRange`` property is ignored.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-protocol
        '''
        result = self._values.get("protocol")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def rule_action(self) -> typing.Optional[builtins.str]:
        '''Whether to allow or deny traffic that matches the rule;

        valid values are "allow" or "deny".

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-ruleaction
        '''
        result = self._values.get("rule_action")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def rule_number(self) -> typing.Optional[jsii.Number]:
        '''Rule number to assign to the entry, such as 100.

        ACL entries are processed in ascending order by rule number. Entries can't use the same rule number unless one is an egress rule and the other is an ingress rule.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-rulenumber
        '''
        result = self._values.get("rule_number")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnNetworkAclEntryMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnNetworkAclEntryPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkAclEntryPropsMixin",
):
    '''Specifies an entry, known as a rule, in a network ACL with a rule number you specify.

    Each network ACL has a set of numbered ingress rules and a separate set of numbered egress rules.

    To create the network ACL, see `AWS::EC2::NetworkAcl <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkacl.html>`_ .

    For information about the protocol value, see `Protocol Numbers <https://docs.aws.amazon.com/https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml>`_ on the Internet Assigned Numbers Authority (IANA) website.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html
    :cloudformationResource: AWS::EC2::NetworkAclEntry
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_network_acl_entry_props_mixin = ec2_mixins.CfnNetworkAclEntryPropsMixin(ec2_mixins.CfnNetworkAclEntryMixinProps(
            cidr_block="cidrBlock",
            egress=False,
            icmp=ec2_mixins.CfnNetworkAclEntryPropsMixin.IcmpProperty(
                code=123,
                type=123
            ),
            ipv6_cidr_block="ipv6CidrBlock",
            network_acl_id="networkAclId",
            port_range=ec2_mixins.CfnNetworkAclEntryPropsMixin.PortRangeProperty(
                from=123,
                to=123
            ),
            protocol=123,
            rule_action="ruleAction",
            rule_number=123
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnNetworkAclEntryMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::NetworkAclEntry``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9372ef7465912e96618bb6277ba56d42b3d6bf1efbb8782bb850a37f54e3ebb5)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c3867578fc9e5e637c67e27732a87683f5db24de48049eb43d60281b8612bece)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a7e9ae28d4c75b46a3cd862879b73c44ddd47847be1204985b8bdccc6d314d55)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnNetworkAclEntryMixinProps":
        return typing.cast("CfnNetworkAclEntryMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkAclEntryPropsMixin.IcmpProperty",
        jsii_struct_bases=[],
        name_mapping={"code": "code", "type": "type"},
    )
    class IcmpProperty:
        def __init__(
            self,
            *,
            code: typing.Optional[jsii.Number] = None,
            type: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Describes the ICMP type and code.

            :param code: The Internet Control Message Protocol (ICMP) code. You can use -1 to specify all ICMP codes for the given ICMP type. Required if you specify 1 (ICMP) for the protocol parameter.
            :param type: The Internet Control Message Protocol (ICMP) type. You can use -1 to specify all ICMP types. Conditional requirement: Required if you specify 1 (ICMP) for the ``CreateNetworkAclEntry`` protocol parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-icmp.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                icmp_property = ec2_mixins.CfnNetworkAclEntryPropsMixin.IcmpProperty(
                    code=123,
                    type=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__b2044fbfd5d7552224d8dffb083b14eec0061cef63c1293cab0df32975a31144)
                check_type(argname="argument code", value=code, expected_type=type_hints["code"])
                check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if code is not None:
                self._values["code"] = code
            if type is not None:
                self._values["type"] = type

        @builtins.property
        def code(self) -> typing.Optional[jsii.Number]:
            '''The Internet Control Message Protocol (ICMP) code.

            You can use -1 to specify all ICMP codes for the given ICMP type. Required if you specify 1 (ICMP) for the protocol parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-icmp.html#cfn-ec2-networkaclentry-icmp-code
            '''
            result = self._values.get("code")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def type(self) -> typing.Optional[jsii.Number]:
            '''The Internet Control Message Protocol (ICMP) type.

            You can use -1 to specify all ICMP types. Conditional requirement: Required if you specify 1 (ICMP) for the ``CreateNetworkAclEntry`` protocol parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-icmp.html#cfn-ec2-networkaclentry-icmp-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "IcmpProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkAclEntryPropsMixin.PortRangeProperty",
        jsii_struct_bases=[],
        name_mapping={"from_": "from", "to": "to"},
    )
    class PortRangeProperty:
        def __init__(
            self,
            *,
            from_: typing.Optional[jsii.Number] = None,
            to: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Describes a range of ports.

            :param from_: The first port in the range. Required if you specify 6 (TCP) or 17 (UDP) for the protocol parameter.
            :param to: The last port in the range. Required if you specify 6 (TCP) or 17 (UDP) for the protocol parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-portrange.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                port_range_property = ec2_mixins.CfnNetworkAclEntryPropsMixin.PortRangeProperty(
                    from=123,
                    to=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__5142c24e90fb1580de1ac88b04e14ce4cb0abf88be740f0a740a8b9f3b67d01a)
                check_type(argname="argument from_", value=from_, expected_type=type_hints["from_"])
                check_type(argname="argument to", value=to, expected_type=type_hints["to"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if from_ is not None:
                self._values["from_"] = from_
            if to is not None:
                self._values["to"] = to

        @builtins.property
        def from_(self) -> typing.Optional[jsii.Number]:
            '''The first port in the range.

            Required if you specify 6 (TCP) or 17 (UDP) for the protocol parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-portrange.html#cfn-ec2-networkaclentry-portrange-from
            '''
            result = self._values.get("from_")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def to(self) -> typing.Optional[jsii.Number]:
            '''The last port in the range.

            Required if you specify 6 (TCP) or 17 (UDP) for the protocol parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-portrange.html#cfn-ec2-networkaclentry-portrange-to
            '''
            result = self._values.get("to")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PortRangeProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkAclMixinProps",
    jsii_struct_bases=[],
    name_mapping={"tags": "tags", "vpc_id": "vpcId"},
)
class CfnNetworkAclMixinProps:
    def __init__(
        self,
        *,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        vpc_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnNetworkAclPropsMixin.

        :param tags: The tags for the network ACL.
        :param vpc_id: The ID of the VPC for the network ACL.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkacl.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_network_acl_mixin_props = ec2_mixins.CfnNetworkAclMixinProps(
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                vpc_id="vpcId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__aa70990cdb9b7ff762664f95ec8f4a84df2f2e339c1100c3efc8746a886e4e3d)
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument vpc_id", value=vpc_id, expected_type=type_hints["vpc_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if tags is not None:
            self._values["tags"] = tags
        if vpc_id is not None:
            self._values["vpc_id"] = vpc_id

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags for the network ACL.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkacl.html#cfn-ec2-networkacl-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def vpc_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the VPC for the network ACL.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkacl.html#cfn-ec2-networkacl-vpcid
        '''
        result = self._values.get("vpc_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnNetworkAclMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnNetworkAclPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkAclPropsMixin",
):
    '''Specifies a network ACL for your VPC.

    To add a network ACL entry, see `AWS::EC2::NetworkAclEntry <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html>`_ .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkacl.html
    :cloudformationResource: AWS::EC2::NetworkAcl
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_network_acl_props_mixin = ec2_mixins.CfnNetworkAclPropsMixin(ec2_mixins.CfnNetworkAclMixinProps(
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            vpc_id="vpcId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnNetworkAclMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::NetworkAcl``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6f02ce9eb899190dbcac35d8640840091820dc5c88eb8c757afbe0916615eb43)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3e87f76490d846fd2b13bd090dd0980da986fd3807302d93f784d3d3569106f4)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7303daf30e8763b88cdd1b7ffdc5da41e5f4d98600c24c55781935a85da0d9d9)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnNetworkAclMixinProps":
        return typing.cast("CfnNetworkAclMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkInsightsAccessScopeAnalysisMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "network_insights_access_scope_id": "networkInsightsAccessScopeId",
        "tags": "tags",
    },
)
class CfnNetworkInsightsAccessScopeAnalysisMixinProps:
    def __init__(
        self,
        *,
        network_insights_access_scope_id: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnNetworkInsightsAccessScopeAnalysisPropsMixin.

        :param network_insights_access_scope_id: The ID of the Network Access Scope.
        :param tags: The tags.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscopeanalysis.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_network_insights_access_scope_analysis_mixin_props = ec2_mixins.CfnNetworkInsightsAccessScopeAnalysisMixinProps(
                network_insights_access_scope_id="networkInsightsAccessScopeId",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__493418819f6a818081c498e41bfd501ae10acc98f1a1b52c7cc82cbdf2196393)
            check_type(argname="argument network_insights_access_scope_id", value=network_insights_access_scope_id, expected_type=type_hints["network_insights_access_scope_id"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if network_insights_access_scope_id is not None:
            self._values["network_insights_access_scope_id"] = network_insights_access_scope_id
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def network_insights_access_scope_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the Network Access Scope.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscopeanalysis.html#cfn-ec2-networkinsightsaccessscopeanalysis-networkinsightsaccessscopeid
        '''
        result = self._values.get("network_insights_access_scope_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscopeanalysis.html#cfn-ec2-networkinsightsaccessscopeanalysis-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnNetworkInsightsAccessScopeAnalysisMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnNetworkInsightsAccessScopeAnalysisPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkInsightsAccessScopeAnalysisPropsMixin",
):
    '''Describes a Network Access Scope analysis.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscopeanalysis.html
    :cloudformationResource: AWS::EC2::NetworkInsightsAccessScopeAnalysis
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_network_insights_access_scope_analysis_props_mixin = ec2_mixins.CfnNetworkInsightsAccessScopeAnalysisPropsMixin(ec2_mixins.CfnNetworkInsightsAccessScopeAnalysisMixinProps(
            network_insights_access_scope_id="networkInsightsAccessScopeId",
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnNetworkInsightsAccessScopeAnalysisMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::NetworkInsightsAccessScopeAnalysis``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a8031baccbbf243f27d14be162fabe68e5d676a4de3a001aad6c9d00a0d25b91)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f211a4baf4dbf6fb34bb1c1607d914b4e83a27080255dbd3569e625020f7beda)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7e9f11dbf86eddb759cadd19414494f0ea6f05330b16dc5fa3481542f34a2020)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnNetworkInsightsAccessScopeAnalysisMixinProps":
        return typing.cast("CfnNetworkInsightsAccessScopeAnalysisMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkInsightsAccessScopeMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "exclude_paths": "excludePaths",
        "match_paths": "matchPaths",
        "tags": "tags",
    },
)
class CfnNetworkInsightsAccessScopeMixinProps:
    def __init__(
        self,
        *,
        exclude_paths: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAccessScopePropsMixin.AccessScopePathRequestProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        match_paths: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAccessScopePropsMixin.AccessScopePathRequestProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnNetworkInsightsAccessScopePropsMixin.

        :param exclude_paths: The paths to exclude.
        :param match_paths: The paths to match.
        :param tags: The tags.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscope.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_network_insights_access_scope_mixin_props = ec2_mixins.CfnNetworkInsightsAccessScopeMixinProps(
                exclude_paths=[ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.AccessScopePathRequestProperty(
                    destination=ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.PathStatementRequestProperty(
                        packet_header_statement=ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.PacketHeaderStatementRequestProperty(
                            destination_addresses=["destinationAddresses"],
                            destination_ports=["destinationPorts"],
                            destination_prefix_lists=["destinationPrefixLists"],
                            protocols=["protocols"],
                            source_addresses=["sourceAddresses"],
                            source_ports=["sourcePorts"],
                            source_prefix_lists=["sourcePrefixLists"]
                        ),
                        resource_statement=ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.ResourceStatementRequestProperty(
                            resources=["resources"],
                            resource_types=["resourceTypes"]
                        )
                    ),
                    source=ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.PathStatementRequestProperty(
                        packet_header_statement=ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.PacketHeaderStatementRequestProperty(
                            destination_addresses=["destinationAddresses"],
                            destination_ports=["destinationPorts"],
                            destination_prefix_lists=["destinationPrefixLists"],
                            protocols=["protocols"],
                            source_addresses=["sourceAddresses"],
                            source_ports=["sourcePorts"],
                            source_prefix_lists=["sourcePrefixLists"]
                        ),
                        resource_statement=ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.ResourceStatementRequestProperty(
                            resources=["resources"],
                            resource_types=["resourceTypes"]
                        )
                    ),
                    through_resources=[ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.ThroughResourcesStatementRequestProperty(
                        resource_statement=ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.ResourceStatementRequestProperty(
                            resources=["resources"],
                            resource_types=["resourceTypes"]
                        )
                    )]
                )],
                match_paths=[ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.AccessScopePathRequestProperty(
                    destination=ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.PathStatementRequestProperty(
                        packet_header_statement=ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.PacketHeaderStatementRequestProperty(
                            destination_addresses=["destinationAddresses"],
                            destination_ports=["destinationPorts"],
                            destination_prefix_lists=["destinationPrefixLists"],
                            protocols=["protocols"],
                            source_addresses=["sourceAddresses"],
                            source_ports=["sourcePorts"],
                            source_prefix_lists=["sourcePrefixLists"]
                        ),
                        resource_statement=ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.ResourceStatementRequestProperty(
                            resources=["resources"],
                            resource_types=["resourceTypes"]
                        )
                    ),
                    source=ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.PathStatementRequestProperty(
                        packet_header_statement=ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.PacketHeaderStatementRequestProperty(
                            destination_addresses=["destinationAddresses"],
                            destination_ports=["destinationPorts"],
                            destination_prefix_lists=["destinationPrefixLists"],
                            protocols=["protocols"],
                            source_addresses=["sourceAddresses"],
                            source_ports=["sourcePorts"],
                            source_prefix_lists=["sourcePrefixLists"]
                        ),
                        resource_statement=ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.ResourceStatementRequestProperty(
                            resources=["resources"],
                            resource_types=["resourceTypes"]
                        )
                    ),
                    through_resources=[ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.ThroughResourcesStatementRequestProperty(
                        resource_statement=ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.ResourceStatementRequestProperty(
                            resources=["resources"],
                            resource_types=["resourceTypes"]
                        )
                    )]
                )],
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a4739b2175c51f0265d9931e723847828c42851de7f26e07023dae6c06b35c6b)
            check_type(argname="argument exclude_paths", value=exclude_paths, expected_type=type_hints["exclude_paths"])
            check_type(argname="argument match_paths", value=match_paths, expected_type=type_hints["match_paths"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if exclude_paths is not None:
            self._values["exclude_paths"] = exclude_paths
        if match_paths is not None:
            self._values["match_paths"] = match_paths
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def exclude_paths(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAccessScopePropsMixin.AccessScopePathRequestProperty"]]]]:
        '''The paths to exclude.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscope.html#cfn-ec2-networkinsightsaccessscope-excludepaths
        '''
        result = self._values.get("exclude_paths")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAccessScopePropsMixin.AccessScopePathRequestProperty"]]]], result)

    @builtins.property
    def match_paths(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAccessScopePropsMixin.AccessScopePathRequestProperty"]]]]:
        '''The paths to match.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscope.html#cfn-ec2-networkinsightsaccessscope-matchpaths
        '''
        result = self._values.get("match_paths")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAccessScopePropsMixin.AccessScopePathRequestProperty"]]]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscope.html#cfn-ec2-networkinsightsaccessscope-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnNetworkInsightsAccessScopeMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnNetworkInsightsAccessScopePropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkInsightsAccessScopePropsMixin",
):
    '''Describes a Network Access Scope.

    A Network Access Scope defines outbound (egress) and inbound (ingress) traffic patterns, including sources, destinations, paths, and traffic types.

    Network Access Analyzer identifies unintended network access to your resources on AWS . When you start an analysis on a Network Access Scope, Network Access Analyzer produces findings. For more information, see the `Network Access Analyzer User Guide <https://docs.aws.amazon.com/vpc/latest/network-access-analyzer/>`_ .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscope.html
    :cloudformationResource: AWS::EC2::NetworkInsightsAccessScope
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_network_insights_access_scope_props_mixin = ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin(ec2_mixins.CfnNetworkInsightsAccessScopeMixinProps(
            exclude_paths=[ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.AccessScopePathRequestProperty(
                destination=ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.PathStatementRequestProperty(
                    packet_header_statement=ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.PacketHeaderStatementRequestProperty(
                        destination_addresses=["destinationAddresses"],
                        destination_ports=["destinationPorts"],
                        destination_prefix_lists=["destinationPrefixLists"],
                        protocols=["protocols"],
                        source_addresses=["sourceAddresses"],
                        source_ports=["sourcePorts"],
                        source_prefix_lists=["sourcePrefixLists"]
                    ),
                    resource_statement=ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.ResourceStatementRequestProperty(
                        resources=["resources"],
                        resource_types=["resourceTypes"]
                    )
                ),
                source=ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.PathStatementRequestProperty(
                    packet_header_statement=ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.PacketHeaderStatementRequestProperty(
                        destination_addresses=["destinationAddresses"],
                        destination_ports=["destinationPorts"],
                        destination_prefix_lists=["destinationPrefixLists"],
                        protocols=["protocols"],
                        source_addresses=["sourceAddresses"],
                        source_ports=["sourcePorts"],
                        source_prefix_lists=["sourcePrefixLists"]
                    ),
                    resource_statement=ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.ResourceStatementRequestProperty(
                        resources=["resources"],
                        resource_types=["resourceTypes"]
                    )
                ),
                through_resources=[ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.ThroughResourcesStatementRequestProperty(
                    resource_statement=ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.ResourceStatementRequestProperty(
                        resources=["resources"],
                        resource_types=["resourceTypes"]
                    )
                )]
            )],
            match_paths=[ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.AccessScopePathRequestProperty(
                destination=ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.PathStatementRequestProperty(
                    packet_header_statement=ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.PacketHeaderStatementRequestProperty(
                        destination_addresses=["destinationAddresses"],
                        destination_ports=["destinationPorts"],
                        destination_prefix_lists=["destinationPrefixLists"],
                        protocols=["protocols"],
                        source_addresses=["sourceAddresses"],
                        source_ports=["sourcePorts"],
                        source_prefix_lists=["sourcePrefixLists"]
                    ),
                    resource_statement=ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.ResourceStatementRequestProperty(
                        resources=["resources"],
                        resource_types=["resourceTypes"]
                    )
                ),
                source=ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.PathStatementRequestProperty(
                    packet_header_statement=ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.PacketHeaderStatementRequestProperty(
                        destination_addresses=["destinationAddresses"],
                        destination_ports=["destinationPorts"],
                        destination_prefix_lists=["destinationPrefixLists"],
                        protocols=["protocols"],
                        source_addresses=["sourceAddresses"],
                        source_ports=["sourcePorts"],
                        source_prefix_lists=["sourcePrefixLists"]
                    ),
                    resource_statement=ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.ResourceStatementRequestProperty(
                        resources=["resources"],
                        resource_types=["resourceTypes"]
                    )
                ),
                through_resources=[ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.ThroughResourcesStatementRequestProperty(
                    resource_statement=ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.ResourceStatementRequestProperty(
                        resources=["resources"],
                        resource_types=["resourceTypes"]
                    )
                )]
            )],
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnNetworkInsightsAccessScopeMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::NetworkInsightsAccessScope``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cb261b2f71341c8c78bfbeb4e3cf15fdd79e584563a06fa6b6bd10790d7d82da)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__34ccb83a7ae268b901d84ca393ef1d6dac73c7539d50bfe0b253d8642da83c6c)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3148816a61df0bbdfc7653b075995799cdfc3223a6b54423b16e9992b40ebb50)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnNetworkInsightsAccessScopeMixinProps":
        return typing.cast("CfnNetworkInsightsAccessScopeMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkInsightsAccessScopePropsMixin.AccessScopePathRequestProperty",
        jsii_struct_bases=[],
        name_mapping={
            "destination": "destination",
            "source": "source",
            "through_resources": "throughResources",
        },
    )
    class AccessScopePathRequestProperty:
        def __init__(
            self,
            *,
            destination: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAccessScopePropsMixin.PathStatementRequestProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            source: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAccessScopePropsMixin.PathStatementRequestProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            through_resources: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAccessScopePropsMixin.ThroughResourcesStatementRequestProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ) -> None:
            '''Describes a path.

            :param destination: The destination.
            :param source: The source.
            :param through_resources: The through resources.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-accessscopepathrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                access_scope_path_request_property = ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.AccessScopePathRequestProperty(
                    destination=ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.PathStatementRequestProperty(
                        packet_header_statement=ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.PacketHeaderStatementRequestProperty(
                            destination_addresses=["destinationAddresses"],
                            destination_ports=["destinationPorts"],
                            destination_prefix_lists=["destinationPrefixLists"],
                            protocols=["protocols"],
                            source_addresses=["sourceAddresses"],
                            source_ports=["sourcePorts"],
                            source_prefix_lists=["sourcePrefixLists"]
                        ),
                        resource_statement=ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.ResourceStatementRequestProperty(
                            resources=["resources"],
                            resource_types=["resourceTypes"]
                        )
                    ),
                    source=ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.PathStatementRequestProperty(
                        packet_header_statement=ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.PacketHeaderStatementRequestProperty(
                            destination_addresses=["destinationAddresses"],
                            destination_ports=["destinationPorts"],
                            destination_prefix_lists=["destinationPrefixLists"],
                            protocols=["protocols"],
                            source_addresses=["sourceAddresses"],
                            source_ports=["sourcePorts"],
                            source_prefix_lists=["sourcePrefixLists"]
                        ),
                        resource_statement=ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.ResourceStatementRequestProperty(
                            resources=["resources"],
                            resource_types=["resourceTypes"]
                        )
                    ),
                    through_resources=[ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.ThroughResourcesStatementRequestProperty(
                        resource_statement=ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.ResourceStatementRequestProperty(
                            resources=["resources"],
                            resource_types=["resourceTypes"]
                        )
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__aeaa89a252e4e740ee48ea49d0e05e72f6211c219b83af9053a2874e2b695310)
                check_type(argname="argument destination", value=destination, expected_type=type_hints["destination"])
                check_type(argname="argument source", value=source, expected_type=type_hints["source"])
                check_type(argname="argument through_resources", value=through_resources, expected_type=type_hints["through_resources"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if destination is not None:
                self._values["destination"] = destination
            if source is not None:
                self._values["source"] = source
            if through_resources is not None:
                self._values["through_resources"] = through_resources

        @builtins.property
        def destination(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAccessScopePropsMixin.PathStatementRequestProperty"]]:
            '''The destination.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-accessscopepathrequest.html#cfn-ec2-networkinsightsaccessscope-accessscopepathrequest-destination
            '''
            result = self._values.get("destination")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAccessScopePropsMixin.PathStatementRequestProperty"]], result)

        @builtins.property
        def source(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAccessScopePropsMixin.PathStatementRequestProperty"]]:
            '''The source.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-accessscopepathrequest.html#cfn-ec2-networkinsightsaccessscope-accessscopepathrequest-source
            '''
            result = self._values.get("source")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAccessScopePropsMixin.PathStatementRequestProperty"]], result)

        @builtins.property
        def through_resources(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAccessScopePropsMixin.ThroughResourcesStatementRequestProperty"]]]]:
            '''The through resources.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-accessscopepathrequest.html#cfn-ec2-networkinsightsaccessscope-accessscopepathrequest-throughresources
            '''
            result = self._values.get("through_resources")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAccessScopePropsMixin.ThroughResourcesStatementRequestProperty"]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AccessScopePathRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkInsightsAccessScopePropsMixin.PacketHeaderStatementRequestProperty",
        jsii_struct_bases=[],
        name_mapping={
            "destination_addresses": "destinationAddresses",
            "destination_ports": "destinationPorts",
            "destination_prefix_lists": "destinationPrefixLists",
            "protocols": "protocols",
            "source_addresses": "sourceAddresses",
            "source_ports": "sourcePorts",
            "source_prefix_lists": "sourcePrefixLists",
        },
    )
    class PacketHeaderStatementRequestProperty:
        def __init__(
            self,
            *,
            destination_addresses: typing.Optional[typing.Sequence[builtins.str]] = None,
            destination_ports: typing.Optional[typing.Sequence[builtins.str]] = None,
            destination_prefix_lists: typing.Optional[typing.Sequence[builtins.str]] = None,
            protocols: typing.Optional[typing.Sequence[builtins.str]] = None,
            source_addresses: typing.Optional[typing.Sequence[builtins.str]] = None,
            source_ports: typing.Optional[typing.Sequence[builtins.str]] = None,
            source_prefix_lists: typing.Optional[typing.Sequence[builtins.str]] = None,
        ) -> None:
            '''Describes a packet header statement.

            :param destination_addresses: The destination addresses.
            :param destination_ports: The destination ports.
            :param destination_prefix_lists: The destination prefix lists.
            :param protocols: The protocols.
            :param source_addresses: The source addresses.
            :param source_ports: The source ports.
            :param source_prefix_lists: The source prefix lists.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-packetheaderstatementrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                packet_header_statement_request_property = ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.PacketHeaderStatementRequestProperty(
                    destination_addresses=["destinationAddresses"],
                    destination_ports=["destinationPorts"],
                    destination_prefix_lists=["destinationPrefixLists"],
                    protocols=["protocols"],
                    source_addresses=["sourceAddresses"],
                    source_ports=["sourcePorts"],
                    source_prefix_lists=["sourcePrefixLists"]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__092e98a73392b6a41a2f6d1e1e15bcb73d3c52b203640b7767c8af503a37a5a8)
                check_type(argname="argument destination_addresses", value=destination_addresses, expected_type=type_hints["destination_addresses"])
                check_type(argname="argument destination_ports", value=destination_ports, expected_type=type_hints["destination_ports"])
                check_type(argname="argument destination_prefix_lists", value=destination_prefix_lists, expected_type=type_hints["destination_prefix_lists"])
                check_type(argname="argument protocols", value=protocols, expected_type=type_hints["protocols"])
                check_type(argname="argument source_addresses", value=source_addresses, expected_type=type_hints["source_addresses"])
                check_type(argname="argument source_ports", value=source_ports, expected_type=type_hints["source_ports"])
                check_type(argname="argument source_prefix_lists", value=source_prefix_lists, expected_type=type_hints["source_prefix_lists"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if destination_addresses is not None:
                self._values["destination_addresses"] = destination_addresses
            if destination_ports is not None:
                self._values["destination_ports"] = destination_ports
            if destination_prefix_lists is not None:
                self._values["destination_prefix_lists"] = destination_prefix_lists
            if protocols is not None:
                self._values["protocols"] = protocols
            if source_addresses is not None:
                self._values["source_addresses"] = source_addresses
            if source_ports is not None:
                self._values["source_ports"] = source_ports
            if source_prefix_lists is not None:
                self._values["source_prefix_lists"] = source_prefix_lists

        @builtins.property
        def destination_addresses(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The destination addresses.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-packetheaderstatementrequest.html#cfn-ec2-networkinsightsaccessscope-packetheaderstatementrequest-destinationaddresses
            '''
            result = self._values.get("destination_addresses")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def destination_ports(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The destination ports.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-packetheaderstatementrequest.html#cfn-ec2-networkinsightsaccessscope-packetheaderstatementrequest-destinationports
            '''
            result = self._values.get("destination_ports")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def destination_prefix_lists(
            self,
        ) -> typing.Optional[typing.List[builtins.str]]:
            '''The destination prefix lists.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-packetheaderstatementrequest.html#cfn-ec2-networkinsightsaccessscope-packetheaderstatementrequest-destinationprefixlists
            '''
            result = self._values.get("destination_prefix_lists")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def protocols(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The protocols.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-packetheaderstatementrequest.html#cfn-ec2-networkinsightsaccessscope-packetheaderstatementrequest-protocols
            '''
            result = self._values.get("protocols")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def source_addresses(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The source addresses.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-packetheaderstatementrequest.html#cfn-ec2-networkinsightsaccessscope-packetheaderstatementrequest-sourceaddresses
            '''
            result = self._values.get("source_addresses")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def source_ports(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The source ports.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-packetheaderstatementrequest.html#cfn-ec2-networkinsightsaccessscope-packetheaderstatementrequest-sourceports
            '''
            result = self._values.get("source_ports")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def source_prefix_lists(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The source prefix lists.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-packetheaderstatementrequest.html#cfn-ec2-networkinsightsaccessscope-packetheaderstatementrequest-sourceprefixlists
            '''
            result = self._values.get("source_prefix_lists")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PacketHeaderStatementRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkInsightsAccessScopePropsMixin.PathStatementRequestProperty",
        jsii_struct_bases=[],
        name_mapping={
            "packet_header_statement": "packetHeaderStatement",
            "resource_statement": "resourceStatement",
        },
    )
    class PathStatementRequestProperty:
        def __init__(
            self,
            *,
            packet_header_statement: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAccessScopePropsMixin.PacketHeaderStatementRequestProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            resource_statement: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAccessScopePropsMixin.ResourceStatementRequestProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Describes a path statement.

            :param packet_header_statement: The packet header statement.
            :param resource_statement: The resource statement.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-pathstatementrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                path_statement_request_property = ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.PathStatementRequestProperty(
                    packet_header_statement=ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.PacketHeaderStatementRequestProperty(
                        destination_addresses=["destinationAddresses"],
                        destination_ports=["destinationPorts"],
                        destination_prefix_lists=["destinationPrefixLists"],
                        protocols=["protocols"],
                        source_addresses=["sourceAddresses"],
                        source_ports=["sourcePorts"],
                        source_prefix_lists=["sourcePrefixLists"]
                    ),
                    resource_statement=ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.ResourceStatementRequestProperty(
                        resources=["resources"],
                        resource_types=["resourceTypes"]
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__3aa5e7dee02452bc28c4db5b9e2ea005ba166978e0a96ed6c10bd0b85e2be32d)
                check_type(argname="argument packet_header_statement", value=packet_header_statement, expected_type=type_hints["packet_header_statement"])
                check_type(argname="argument resource_statement", value=resource_statement, expected_type=type_hints["resource_statement"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if packet_header_statement is not None:
                self._values["packet_header_statement"] = packet_header_statement
            if resource_statement is not None:
                self._values["resource_statement"] = resource_statement

        @builtins.property
        def packet_header_statement(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAccessScopePropsMixin.PacketHeaderStatementRequestProperty"]]:
            '''The packet header statement.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-pathstatementrequest.html#cfn-ec2-networkinsightsaccessscope-pathstatementrequest-packetheaderstatement
            '''
            result = self._values.get("packet_header_statement")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAccessScopePropsMixin.PacketHeaderStatementRequestProperty"]], result)

        @builtins.property
        def resource_statement(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAccessScopePropsMixin.ResourceStatementRequestProperty"]]:
            '''The resource statement.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-pathstatementrequest.html#cfn-ec2-networkinsightsaccessscope-pathstatementrequest-resourcestatement
            '''
            result = self._values.get("resource_statement")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAccessScopePropsMixin.ResourceStatementRequestProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PathStatementRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkInsightsAccessScopePropsMixin.ResourceStatementRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"resources": "resources", "resource_types": "resourceTypes"},
    )
    class ResourceStatementRequestProperty:
        def __init__(
            self,
            *,
            resources: typing.Optional[typing.Sequence[builtins.str]] = None,
            resource_types: typing.Optional[typing.Sequence[builtins.str]] = None,
        ) -> None:
            '''Describes a resource statement.

            :param resources: The resources.
            :param resource_types: The resource types.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-resourcestatementrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                resource_statement_request_property = ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.ResourceStatementRequestProperty(
                    resources=["resources"],
                    resource_types=["resourceTypes"]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__760f070c3bfcd69ae08fd5c145f4d6b8e2a0cbe402f37d165e6bb8584e63d3ae)
                check_type(argname="argument resources", value=resources, expected_type=type_hints["resources"])
                check_type(argname="argument resource_types", value=resource_types, expected_type=type_hints["resource_types"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if resources is not None:
                self._values["resources"] = resources
            if resource_types is not None:
                self._values["resource_types"] = resource_types

        @builtins.property
        def resources(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The resources.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-resourcestatementrequest.html#cfn-ec2-networkinsightsaccessscope-resourcestatementrequest-resources
            '''
            result = self._values.get("resources")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def resource_types(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The resource types.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-resourcestatementrequest.html#cfn-ec2-networkinsightsaccessscope-resourcestatementrequest-resourcetypes
            '''
            result = self._values.get("resource_types")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ResourceStatementRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkInsightsAccessScopePropsMixin.ThroughResourcesStatementRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"resource_statement": "resourceStatement"},
    )
    class ThroughResourcesStatementRequestProperty:
        def __init__(
            self,
            *,
            resource_statement: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAccessScopePropsMixin.ResourceStatementRequestProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Describes a through resource statement.

            :param resource_statement: The resource statement.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-throughresourcesstatementrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                through_resources_statement_request_property = ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.ThroughResourcesStatementRequestProperty(
                    resource_statement=ec2_mixins.CfnNetworkInsightsAccessScopePropsMixin.ResourceStatementRequestProperty(
                        resources=["resources"],
                        resource_types=["resourceTypes"]
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__7555ca7b173d036fc4fdd99c2b6bc4c9d1b222b2f99593480046f0f7e8544b18)
                check_type(argname="argument resource_statement", value=resource_statement, expected_type=type_hints["resource_statement"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if resource_statement is not None:
                self._values["resource_statement"] = resource_statement

        @builtins.property
        def resource_statement(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAccessScopePropsMixin.ResourceStatementRequestProperty"]]:
            '''The resource statement.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-throughresourcesstatementrequest.html#cfn-ec2-networkinsightsaccessscope-throughresourcesstatementrequest-resourcestatement
            '''
            result = self._values.get("resource_statement")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAccessScopePropsMixin.ResourceStatementRequestProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ThroughResourcesStatementRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkInsightsAnalysisMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "additional_accounts": "additionalAccounts",
        "filter_in_arns": "filterInArns",
        "filter_out_arns": "filterOutArns",
        "network_insights_path_id": "networkInsightsPathId",
        "tags": "tags",
    },
)
class CfnNetworkInsightsAnalysisMixinProps:
    def __init__(
        self,
        *,
        additional_accounts: typing.Optional[typing.Sequence[builtins.str]] = None,
        filter_in_arns: typing.Optional[typing.Sequence[builtins.str]] = None,
        filter_out_arns: typing.Optional[typing.Sequence[builtins.str]] = None,
        network_insights_path_id: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnNetworkInsightsAnalysisPropsMixin.

        :param additional_accounts: The member accounts that contain resources that the path can traverse.
        :param filter_in_arns: The Amazon Resource Names (ARN) of the resources that the path must traverse.
        :param filter_out_arns: The Amazon Resource Names (ARN) of the resources that the path must ignore.
        :param network_insights_path_id: The ID of the path.
        :param tags: The tags to apply.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_network_insights_analysis_mixin_props = ec2_mixins.CfnNetworkInsightsAnalysisMixinProps(
                additional_accounts=["additionalAccounts"],
                filter_in_arns=["filterInArns"],
                filter_out_arns=["filterOutArns"],
                network_insights_path_id="networkInsightsPathId",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ea8301d508fcbeb5bd5c3edd25c9f7382c092cf943c7768e5bcd57e577485c05)
            check_type(argname="argument additional_accounts", value=additional_accounts, expected_type=type_hints["additional_accounts"])
            check_type(argname="argument filter_in_arns", value=filter_in_arns, expected_type=type_hints["filter_in_arns"])
            check_type(argname="argument filter_out_arns", value=filter_out_arns, expected_type=type_hints["filter_out_arns"])
            check_type(argname="argument network_insights_path_id", value=network_insights_path_id, expected_type=type_hints["network_insights_path_id"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if additional_accounts is not None:
            self._values["additional_accounts"] = additional_accounts
        if filter_in_arns is not None:
            self._values["filter_in_arns"] = filter_in_arns
        if filter_out_arns is not None:
            self._values["filter_out_arns"] = filter_out_arns
        if network_insights_path_id is not None:
            self._values["network_insights_path_id"] = network_insights_path_id
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def additional_accounts(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The member accounts that contain resources that the path can traverse.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html#cfn-ec2-networkinsightsanalysis-additionalaccounts
        '''
        result = self._values.get("additional_accounts")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def filter_in_arns(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The Amazon Resource Names (ARN) of the resources that the path must traverse.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html#cfn-ec2-networkinsightsanalysis-filterinarns
        '''
        result = self._values.get("filter_in_arns")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def filter_out_arns(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The Amazon Resource Names (ARN) of the resources that the path must ignore.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html#cfn-ec2-networkinsightsanalysis-filteroutarns
        '''
        result = self._values.get("filter_out_arns")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def network_insights_path_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the path.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html#cfn-ec2-networkinsightsanalysis-networkinsightspathid
        '''
        result = self._values.get("network_insights_path_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags to apply.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html#cfn-ec2-networkinsightsanalysis-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnNetworkInsightsAnalysisMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnNetworkInsightsAnalysisPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkInsightsAnalysisPropsMixin",
):
    '''Specifies a network insights analysis.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html
    :cloudformationResource: AWS::EC2::NetworkInsightsAnalysis
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_network_insights_analysis_props_mixin = ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin(ec2_mixins.CfnNetworkInsightsAnalysisMixinProps(
            additional_accounts=["additionalAccounts"],
            filter_in_arns=["filterInArns"],
            filter_out_arns=["filterOutArns"],
            network_insights_path_id="networkInsightsPathId",
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnNetworkInsightsAnalysisMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::NetworkInsightsAnalysis``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3ce0a306dbe9120ac8fd73180d2724fa4cf25ceaec00d2fd960a91d50c3d44ac)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3c031d0869cdb70dbe2b8a44759401da1b4701c085e30e0db72615efdf3207ae)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__00d1b813ea1b0cd9683068d0ecd9a0518e2ad3f32b407a5feef624d18165d7ab)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnNetworkInsightsAnalysisMixinProps":
        return typing.cast("CfnNetworkInsightsAnalysisMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkInsightsAnalysisPropsMixin.AdditionalDetailProperty",
        jsii_struct_bases=[],
        name_mapping={
            "additional_detail_type": "additionalDetailType",
            "component": "component",
            "load_balancers": "loadBalancers",
            "service_name": "serviceName",
        },
    )
    class AdditionalDetailProperty:
        def __init__(
            self,
            *,
            additional_detail_type: typing.Optional[builtins.str] = None,
            component: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            load_balancers: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            service_name: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes an additional detail for a path analysis.

            For more information, see `Reachability Analyzer additional detail codes <https://docs.aws.amazon.com/vpc/latest/reachability/additional-detail-codes.html>`_ .

            :param additional_detail_type: The additional detail code.
            :param component: The path component.
            :param load_balancers: The load balancers.
            :param service_name: The name of the VPC endpoint service.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-additionaldetail.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                additional_detail_property = ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AdditionalDetailProperty(
                    additional_detail_type="additionalDetailType",
                    component=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    load_balancers=[ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    )],
                    service_name="serviceName"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__7326ea3a400ab406f6b58238c0f8a75ec4d88e8c037e517ab3bd3968841e9080)
                check_type(argname="argument additional_detail_type", value=additional_detail_type, expected_type=type_hints["additional_detail_type"])
                check_type(argname="argument component", value=component, expected_type=type_hints["component"])
                check_type(argname="argument load_balancers", value=load_balancers, expected_type=type_hints["load_balancers"])
                check_type(argname="argument service_name", value=service_name, expected_type=type_hints["service_name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if additional_detail_type is not None:
                self._values["additional_detail_type"] = additional_detail_type
            if component is not None:
                self._values["component"] = component
            if load_balancers is not None:
                self._values["load_balancers"] = load_balancers
            if service_name is not None:
                self._values["service_name"] = service_name

        @builtins.property
        def additional_detail_type(self) -> typing.Optional[builtins.str]:
            '''The additional detail code.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-additionaldetail.html#cfn-ec2-networkinsightsanalysis-additionaldetail-additionaldetailtype
            '''
            result = self._values.get("additional_detail_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def component(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]]:
            '''The path component.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-additionaldetail.html#cfn-ec2-networkinsightsanalysis-additionaldetail-component
            '''
            result = self._values.get("component")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]], result)

        @builtins.property
        def load_balancers(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]]]]:
            '''The load balancers.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-additionaldetail.html#cfn-ec2-networkinsightsanalysis-additionaldetail-loadbalancers
            '''
            result = self._values.get("load_balancers")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]]]], result)

        @builtins.property
        def service_name(self) -> typing.Optional[builtins.str]:
            '''The name of the VPC endpoint service.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-additionaldetail.html#cfn-ec2-networkinsightsanalysis-additionaldetail-servicename
            '''
            result = self._values.get("service_name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AdditionalDetailProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkInsightsAnalysisPropsMixin.AlternatePathHintProperty",
        jsii_struct_bases=[],
        name_mapping={"component_arn": "componentArn", "component_id": "componentId"},
    )
    class AlternatePathHintProperty:
        def __init__(
            self,
            *,
            component_arn: typing.Optional[builtins.str] = None,
            component_id: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes an potential intermediate component of a feasible path.

            :param component_arn: The Amazon Resource Name (ARN) of the component.
            :param component_id: The ID of the component.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-alternatepathhint.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                alternate_path_hint_property = ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AlternatePathHintProperty(
                    component_arn="componentArn",
                    component_id="componentId"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__bac411709452f264c3f6da44e7dc337d74da4ef8763884cb8b063fa42a8ff590)
                check_type(argname="argument component_arn", value=component_arn, expected_type=type_hints["component_arn"])
                check_type(argname="argument component_id", value=component_id, expected_type=type_hints["component_id"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if component_arn is not None:
                self._values["component_arn"] = component_arn
            if component_id is not None:
                self._values["component_id"] = component_id

        @builtins.property
        def component_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the component.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-alternatepathhint.html#cfn-ec2-networkinsightsanalysis-alternatepathhint-componentarn
            '''
            result = self._values.get("component_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def component_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the component.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-alternatepathhint.html#cfn-ec2-networkinsightsanalysis-alternatepathhint-componentid
            '''
            result = self._values.get("component_id")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AlternatePathHintProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisAclRuleProperty",
        jsii_struct_bases=[],
        name_mapping={
            "cidr": "cidr",
            "egress": "egress",
            "port_range": "portRange",
            "protocol": "protocol",
            "rule_action": "ruleAction",
            "rule_number": "ruleNumber",
        },
    )
    class AnalysisAclRuleProperty:
        def __init__(
            self,
            *,
            cidr: typing.Optional[builtins.str] = None,
            egress: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            port_range: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.PortRangeProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            protocol: typing.Optional[builtins.str] = None,
            rule_action: typing.Optional[builtins.str] = None,
            rule_number: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Describes a network access control (ACL) rule.

            :param cidr: The IPv4 address range, in CIDR notation.
            :param egress: Indicates whether the rule is an outbound rule.
            :param port_range: The range of ports.
            :param protocol: The protocol.
            :param rule_action: Indicates whether to allow or deny traffic that matches the rule.
            :param rule_number: The rule number.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisaclrule.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                analysis_acl_rule_property = ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisAclRuleProperty(
                    cidr="cidr",
                    egress=False,
                    port_range=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.PortRangeProperty(
                        from=123,
                        to=123
                    ),
                    protocol="protocol",
                    rule_action="ruleAction",
                    rule_number=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__1923826e28de467f3d279853470a0a796cb0161ebf954e0fc8fa5cdc75c45159)
                check_type(argname="argument cidr", value=cidr, expected_type=type_hints["cidr"])
                check_type(argname="argument egress", value=egress, expected_type=type_hints["egress"])
                check_type(argname="argument port_range", value=port_range, expected_type=type_hints["port_range"])
                check_type(argname="argument protocol", value=protocol, expected_type=type_hints["protocol"])
                check_type(argname="argument rule_action", value=rule_action, expected_type=type_hints["rule_action"])
                check_type(argname="argument rule_number", value=rule_number, expected_type=type_hints["rule_number"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if cidr is not None:
                self._values["cidr"] = cidr
            if egress is not None:
                self._values["egress"] = egress
            if port_range is not None:
                self._values["port_range"] = port_range
            if protocol is not None:
                self._values["protocol"] = protocol
            if rule_action is not None:
                self._values["rule_action"] = rule_action
            if rule_number is not None:
                self._values["rule_number"] = rule_number

        @builtins.property
        def cidr(self) -> typing.Optional[builtins.str]:
            '''The IPv4 address range, in CIDR notation.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisaclrule.html#cfn-ec2-networkinsightsanalysis-analysisaclrule-cidr
            '''
            result = self._values.get("cidr")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def egress(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether the rule is an outbound rule.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisaclrule.html#cfn-ec2-networkinsightsanalysis-analysisaclrule-egress
            '''
            result = self._values.get("egress")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def port_range(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.PortRangeProperty"]]:
            '''The range of ports.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisaclrule.html#cfn-ec2-networkinsightsanalysis-analysisaclrule-portrange
            '''
            result = self._values.get("port_range")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.PortRangeProperty"]], result)

        @builtins.property
        def protocol(self) -> typing.Optional[builtins.str]:
            '''The protocol.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisaclrule.html#cfn-ec2-networkinsightsanalysis-analysisaclrule-protocol
            '''
            result = self._values.get("protocol")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def rule_action(self) -> typing.Optional[builtins.str]:
            '''Indicates whether to allow or deny traffic that matches the rule.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisaclrule.html#cfn-ec2-networkinsightsanalysis-analysisaclrule-ruleaction
            '''
            result = self._values.get("rule_action")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def rule_number(self) -> typing.Optional[jsii.Number]:
            '''The rule number.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisaclrule.html#cfn-ec2-networkinsightsanalysis-analysisaclrule-rulenumber
            '''
            result = self._values.get("rule_number")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AnalysisAclRuleProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty",
        jsii_struct_bases=[],
        name_mapping={"arn": "arn", "id": "id"},
    )
    class AnalysisComponentProperty:
        def __init__(
            self,
            *,
            arn: typing.Optional[builtins.str] = None,
            id: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes a path component.

            :param arn: The Amazon Resource Name (ARN) of the component.
            :param id: The ID of the component.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysiscomponent.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                analysis_component_property = ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                    arn="arn",
                    id="id"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__61a24c33b307b619bc4d691b8356d3a0463e27a46aececeaa20c3fc0283c22a7)
                check_type(argname="argument arn", value=arn, expected_type=type_hints["arn"])
                check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if arn is not None:
                self._values["arn"] = arn
            if id is not None:
                self._values["id"] = id

        @builtins.property
        def arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the component.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysiscomponent.html#cfn-ec2-networkinsightsanalysis-analysiscomponent-arn
            '''
            result = self._values.get("arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def id(self) -> typing.Optional[builtins.str]:
            '''The ID of the component.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysiscomponent.html#cfn-ec2-networkinsightsanalysis-analysiscomponent-id
            '''
            result = self._values.get("id")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AnalysisComponentProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisLoadBalancerListenerProperty",
        jsii_struct_bases=[],
        name_mapping={
            "instance_port": "instancePort",
            "load_balancer_port": "loadBalancerPort",
        },
    )
    class AnalysisLoadBalancerListenerProperty:
        def __init__(
            self,
            *,
            instance_port: typing.Optional[jsii.Number] = None,
            load_balancer_port: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Describes a load balancer listener.

            :param instance_port: [Classic Load Balancers] The back-end port for the listener.
            :param load_balancer_port: The port on which the load balancer is listening.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisloadbalancerlistener.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                analysis_load_balancer_listener_property = ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisLoadBalancerListenerProperty(
                    instance_port=123,
                    load_balancer_port=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__fa049116c68e1feb8015f56fcdac4d7f224c854f338049a946e3b4f607aed7fb)
                check_type(argname="argument instance_port", value=instance_port, expected_type=type_hints["instance_port"])
                check_type(argname="argument load_balancer_port", value=load_balancer_port, expected_type=type_hints["load_balancer_port"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if instance_port is not None:
                self._values["instance_port"] = instance_port
            if load_balancer_port is not None:
                self._values["load_balancer_port"] = load_balancer_port

        @builtins.property
        def instance_port(self) -> typing.Optional[jsii.Number]:
            '''[Classic Load Balancers] The back-end port for the listener.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisloadbalancerlistener.html#cfn-ec2-networkinsightsanalysis-analysisloadbalancerlistener-instanceport
            '''
            result = self._values.get("instance_port")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def load_balancer_port(self) -> typing.Optional[jsii.Number]:
            '''The port on which the load balancer is listening.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisloadbalancerlistener.html#cfn-ec2-networkinsightsanalysis-analysisloadbalancerlistener-loadbalancerport
            '''
            result = self._values.get("load_balancer_port")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AnalysisLoadBalancerListenerProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisLoadBalancerTargetProperty",
        jsii_struct_bases=[],
        name_mapping={
            "address": "address",
            "availability_zone": "availabilityZone",
            "instance": "instance",
            "port": "port",
        },
    )
    class AnalysisLoadBalancerTargetProperty:
        def __init__(
            self,
            *,
            address: typing.Optional[builtins.str] = None,
            availability_zone: typing.Optional[builtins.str] = None,
            instance: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            port: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Describes a load balancer target.

            :param address: The IP address.
            :param availability_zone: The Availability Zone.
            :param instance: Information about the instance.
            :param port: The port on which the target is listening.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisloadbalancertarget.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                analysis_load_balancer_target_property = ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisLoadBalancerTargetProperty(
                    address="address",
                    availability_zone="availabilityZone",
                    instance=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    port=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__2f9b4a1c11c7a16bf24761e48cdf429d4bb39786e35e2e8e1511fda1bc96a26e)
                check_type(argname="argument address", value=address, expected_type=type_hints["address"])
                check_type(argname="argument availability_zone", value=availability_zone, expected_type=type_hints["availability_zone"])
                check_type(argname="argument instance", value=instance, expected_type=type_hints["instance"])
                check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if address is not None:
                self._values["address"] = address
            if availability_zone is not None:
                self._values["availability_zone"] = availability_zone
            if instance is not None:
                self._values["instance"] = instance
            if port is not None:
                self._values["port"] = port

        @builtins.property
        def address(self) -> typing.Optional[builtins.str]:
            '''The IP address.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisloadbalancertarget.html#cfn-ec2-networkinsightsanalysis-analysisloadbalancertarget-address
            '''
            result = self._values.get("address")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def availability_zone(self) -> typing.Optional[builtins.str]:
            '''The Availability Zone.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisloadbalancertarget.html#cfn-ec2-networkinsightsanalysis-analysisloadbalancertarget-availabilityzone
            '''
            result = self._values.get("availability_zone")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def instance(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]]:
            '''Information about the instance.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisloadbalancertarget.html#cfn-ec2-networkinsightsanalysis-analysisloadbalancertarget-instance
            '''
            result = self._values.get("instance")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]], result)

        @builtins.property
        def port(self) -> typing.Optional[jsii.Number]:
            '''The port on which the target is listening.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisloadbalancertarget.html#cfn-ec2-networkinsightsanalysis-analysisloadbalancertarget-port
            '''
            result = self._values.get("port")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AnalysisLoadBalancerTargetProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisPacketHeaderProperty",
        jsii_struct_bases=[],
        name_mapping={
            "destination_addresses": "destinationAddresses",
            "destination_port_ranges": "destinationPortRanges",
            "protocol": "protocol",
            "source_addresses": "sourceAddresses",
            "source_port_ranges": "sourcePortRanges",
        },
    )
    class AnalysisPacketHeaderProperty:
        def __init__(
            self,
            *,
            destination_addresses: typing.Optional[typing.Sequence[builtins.str]] = None,
            destination_port_ranges: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.PortRangeProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            protocol: typing.Optional[builtins.str] = None,
            source_addresses: typing.Optional[typing.Sequence[builtins.str]] = None,
            source_port_ranges: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.PortRangeProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ) -> None:
            '''Describes a header.

            Reflects any changes made by a component as traffic passes through. The fields of an inbound header are null except for the first component of a path.

            :param destination_addresses: The destination addresses.
            :param destination_port_ranges: The destination port ranges.
            :param protocol: The protocol.
            :param source_addresses: The source addresses.
            :param source_port_ranges: The source port ranges.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysispacketheader.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                analysis_packet_header_property = ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisPacketHeaderProperty(
                    destination_addresses=["destinationAddresses"],
                    destination_port_ranges=[ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.PortRangeProperty(
                        from=123,
                        to=123
                    )],
                    protocol="protocol",
                    source_addresses=["sourceAddresses"],
                    source_port_ranges=[ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.PortRangeProperty(
                        from=123,
                        to=123
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__0367461e816c11043c71ec8531c2d0cdeffcbc7d424106c3ab0468738faed5f2)
                check_type(argname="argument destination_addresses", value=destination_addresses, expected_type=type_hints["destination_addresses"])
                check_type(argname="argument destination_port_ranges", value=destination_port_ranges, expected_type=type_hints["destination_port_ranges"])
                check_type(argname="argument protocol", value=protocol, expected_type=type_hints["protocol"])
                check_type(argname="argument source_addresses", value=source_addresses, expected_type=type_hints["source_addresses"])
                check_type(argname="argument source_port_ranges", value=source_port_ranges, expected_type=type_hints["source_port_ranges"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if destination_addresses is not None:
                self._values["destination_addresses"] = destination_addresses
            if destination_port_ranges is not None:
                self._values["destination_port_ranges"] = destination_port_ranges
            if protocol is not None:
                self._values["protocol"] = protocol
            if source_addresses is not None:
                self._values["source_addresses"] = source_addresses
            if source_port_ranges is not None:
                self._values["source_port_ranges"] = source_port_ranges

        @builtins.property
        def destination_addresses(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The destination addresses.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysispacketheader.html#cfn-ec2-networkinsightsanalysis-analysispacketheader-destinationaddresses
            '''
            result = self._values.get("destination_addresses")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def destination_port_ranges(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.PortRangeProperty"]]]]:
            '''The destination port ranges.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysispacketheader.html#cfn-ec2-networkinsightsanalysis-analysispacketheader-destinationportranges
            '''
            result = self._values.get("destination_port_ranges")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.PortRangeProperty"]]]], result)

        @builtins.property
        def protocol(self) -> typing.Optional[builtins.str]:
            '''The protocol.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysispacketheader.html#cfn-ec2-networkinsightsanalysis-analysispacketheader-protocol
            '''
            result = self._values.get("protocol")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def source_addresses(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The source addresses.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysispacketheader.html#cfn-ec2-networkinsightsanalysis-analysispacketheader-sourceaddresses
            '''
            result = self._values.get("source_addresses")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def source_port_ranges(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.PortRangeProperty"]]]]:
            '''The source port ranges.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysispacketheader.html#cfn-ec2-networkinsightsanalysis-analysispacketheader-sourceportranges
            '''
            result = self._values.get("source_port_ranges")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.PortRangeProperty"]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AnalysisPacketHeaderProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisRouteTableRouteProperty",
        jsii_struct_bases=[],
        name_mapping={
            "destination_cidr": "destinationCidr",
            "destination_prefix_list_id": "destinationPrefixListId",
            "egress_only_internet_gateway_id": "egressOnlyInternetGatewayId",
            "gateway_id": "gatewayId",
            "instance_id": "instanceId",
            "nat_gateway_id": "natGatewayId",
            "network_interface_id": "networkInterfaceId",
            "origin": "origin",
            "state": "state",
            "transit_gateway_id": "transitGatewayId",
            "vpc_peering_connection_id": "vpcPeeringConnectionId",
        },
    )
    class AnalysisRouteTableRouteProperty:
        def __init__(
            self,
            *,
            destination_cidr: typing.Optional[builtins.str] = None,
            destination_prefix_list_id: typing.Optional[builtins.str] = None,
            egress_only_internet_gateway_id: typing.Optional[builtins.str] = None,
            gateway_id: typing.Optional[builtins.str] = None,
            instance_id: typing.Optional[builtins.str] = None,
            nat_gateway_id: typing.Optional[builtins.str] = None,
            network_interface_id: typing.Optional[builtins.str] = None,
            origin: typing.Optional[builtins.str] = None,
            state: typing.Optional[builtins.str] = None,
            transit_gateway_id: typing.Optional[builtins.str] = None,
            vpc_peering_connection_id: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes a route table route.

            :param destination_cidr: The destination IPv4 address, in CIDR notation.
            :param destination_prefix_list_id: The prefix of the AWS service.
            :param egress_only_internet_gateway_id: The ID of an egress-only internet gateway.
            :param gateway_id: The ID of the gateway, such as an internet gateway or virtual private gateway.
            :param instance_id: The ID of the instance, such as a NAT instance.
            :param nat_gateway_id: The ID of a NAT gateway.
            :param network_interface_id: The ID of a network interface.
            :param origin: Describes how the route was created. The following are the possible values:. - CreateRouteTable - The route was automatically created when the route table was created. - CreateRoute - The route was manually added to the route table. - EnableVgwRoutePropagation - The route was propagated by route propagation.
            :param state: The state. The following are the possible values:. - active - blackhole
            :param transit_gateway_id: The ID of a transit gateway.
            :param vpc_peering_connection_id: The ID of a VPC peering connection.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                analysis_route_table_route_property = ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisRouteTableRouteProperty(
                    destination_cidr="destinationCidr",
                    destination_prefix_list_id="destinationPrefixListId",
                    egress_only_internet_gateway_id="egressOnlyInternetGatewayId",
                    gateway_id="gatewayId",
                    instance_id="instanceId",
                    nat_gateway_id="natGatewayId",
                    network_interface_id="networkInterfaceId",
                    origin="origin",
                    state="state",
                    transit_gateway_id="transitGatewayId",
                    vpc_peering_connection_id="vpcPeeringConnectionId"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__84304a16293fc0d84cc074809cbe1d903d501e1858542b8399ed802c259b81db)
                check_type(argname="argument destination_cidr", value=destination_cidr, expected_type=type_hints["destination_cidr"])
                check_type(argname="argument destination_prefix_list_id", value=destination_prefix_list_id, expected_type=type_hints["destination_prefix_list_id"])
                check_type(argname="argument egress_only_internet_gateway_id", value=egress_only_internet_gateway_id, expected_type=type_hints["egress_only_internet_gateway_id"])
                check_type(argname="argument gateway_id", value=gateway_id, expected_type=type_hints["gateway_id"])
                check_type(argname="argument instance_id", value=instance_id, expected_type=type_hints["instance_id"])
                check_type(argname="argument nat_gateway_id", value=nat_gateway_id, expected_type=type_hints["nat_gateway_id"])
                check_type(argname="argument network_interface_id", value=network_interface_id, expected_type=type_hints["network_interface_id"])
                check_type(argname="argument origin", value=origin, expected_type=type_hints["origin"])
                check_type(argname="argument state", value=state, expected_type=type_hints["state"])
                check_type(argname="argument transit_gateway_id", value=transit_gateway_id, expected_type=type_hints["transit_gateway_id"])
                check_type(argname="argument vpc_peering_connection_id", value=vpc_peering_connection_id, expected_type=type_hints["vpc_peering_connection_id"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if destination_cidr is not None:
                self._values["destination_cidr"] = destination_cidr
            if destination_prefix_list_id is not None:
                self._values["destination_prefix_list_id"] = destination_prefix_list_id
            if egress_only_internet_gateway_id is not None:
                self._values["egress_only_internet_gateway_id"] = egress_only_internet_gateway_id
            if gateway_id is not None:
                self._values["gateway_id"] = gateway_id
            if instance_id is not None:
                self._values["instance_id"] = instance_id
            if nat_gateway_id is not None:
                self._values["nat_gateway_id"] = nat_gateway_id
            if network_interface_id is not None:
                self._values["network_interface_id"] = network_interface_id
            if origin is not None:
                self._values["origin"] = origin
            if state is not None:
                self._values["state"] = state
            if transit_gateway_id is not None:
                self._values["transit_gateway_id"] = transit_gateway_id
            if vpc_peering_connection_id is not None:
                self._values["vpc_peering_connection_id"] = vpc_peering_connection_id

        @builtins.property
        def destination_cidr(self) -> typing.Optional[builtins.str]:
            '''The destination IPv4 address, in CIDR notation.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-destinationcidr
            '''
            result = self._values.get("destination_cidr")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def destination_prefix_list_id(self) -> typing.Optional[builtins.str]:
            '''The prefix of the AWS service.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-destinationprefixlistid
            '''
            result = self._values.get("destination_prefix_list_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def egress_only_internet_gateway_id(self) -> typing.Optional[builtins.str]:
            '''The ID of an egress-only internet gateway.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-egressonlyinternetgatewayid
            '''
            result = self._values.get("egress_only_internet_gateway_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def gateway_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the gateway, such as an internet gateway or virtual private gateway.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-gatewayid
            '''
            result = self._values.get("gateway_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def instance_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the instance, such as a NAT instance.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-instanceid
            '''
            result = self._values.get("instance_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def nat_gateway_id(self) -> typing.Optional[builtins.str]:
            '''The ID of a NAT gateway.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-natgatewayid
            '''
            result = self._values.get("nat_gateway_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def network_interface_id(self) -> typing.Optional[builtins.str]:
            '''The ID of a network interface.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-networkinterfaceid
            '''
            result = self._values.get("network_interface_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def origin(self) -> typing.Optional[builtins.str]:
            '''Describes how the route was created. The following are the possible values:.

            - CreateRouteTable - The route was automatically created when the route table was created.
            - CreateRoute - The route was manually added to the route table.
            - EnableVgwRoutePropagation - The route was propagated by route propagation.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-origin
            '''
            result = self._values.get("origin")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def state(self) -> typing.Optional[builtins.str]:
            '''The state. The following are the possible values:.

            - active
            - blackhole

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-state
            '''
            result = self._values.get("state")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def transit_gateway_id(self) -> typing.Optional[builtins.str]:
            '''The ID of a transit gateway.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-transitgatewayid
            '''
            result = self._values.get("transit_gateway_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def vpc_peering_connection_id(self) -> typing.Optional[builtins.str]:
            '''The ID of a VPC peering connection.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-vpcpeeringconnectionid
            '''
            result = self._values.get("vpc_peering_connection_id")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AnalysisRouteTableRouteProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisSecurityGroupRuleProperty",
        jsii_struct_bases=[],
        name_mapping={
            "cidr": "cidr",
            "direction": "direction",
            "port_range": "portRange",
            "prefix_list_id": "prefixListId",
            "protocol": "protocol",
            "security_group_id": "securityGroupId",
        },
    )
    class AnalysisSecurityGroupRuleProperty:
        def __init__(
            self,
            *,
            cidr: typing.Optional[builtins.str] = None,
            direction: typing.Optional[builtins.str] = None,
            port_range: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.PortRangeProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            prefix_list_id: typing.Optional[builtins.str] = None,
            protocol: typing.Optional[builtins.str] = None,
            security_group_id: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes a security group rule.

            :param cidr: The IPv4 address range, in CIDR notation.
            :param direction: The direction. The following are the possible values:. - egress - ingress
            :param port_range: The port range.
            :param prefix_list_id: The prefix list ID.
            :param protocol: The protocol name.
            :param security_group_id: The security group ID.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysissecuritygrouprule.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                analysis_security_group_rule_property = ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisSecurityGroupRuleProperty(
                    cidr="cidr",
                    direction="direction",
                    port_range=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.PortRangeProperty(
                        from=123,
                        to=123
                    ),
                    prefix_list_id="prefixListId",
                    protocol="protocol",
                    security_group_id="securityGroupId"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__ff8f34175a086820fbae63928e74c475d84a4da438fe72adad3496d5e658eae5)
                check_type(argname="argument cidr", value=cidr, expected_type=type_hints["cidr"])
                check_type(argname="argument direction", value=direction, expected_type=type_hints["direction"])
                check_type(argname="argument port_range", value=port_range, expected_type=type_hints["port_range"])
                check_type(argname="argument prefix_list_id", value=prefix_list_id, expected_type=type_hints["prefix_list_id"])
                check_type(argname="argument protocol", value=protocol, expected_type=type_hints["protocol"])
                check_type(argname="argument security_group_id", value=security_group_id, expected_type=type_hints["security_group_id"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if cidr is not None:
                self._values["cidr"] = cidr
            if direction is not None:
                self._values["direction"] = direction
            if port_range is not None:
                self._values["port_range"] = port_range
            if prefix_list_id is not None:
                self._values["prefix_list_id"] = prefix_list_id
            if protocol is not None:
                self._values["protocol"] = protocol
            if security_group_id is not None:
                self._values["security_group_id"] = security_group_id

        @builtins.property
        def cidr(self) -> typing.Optional[builtins.str]:
            '''The IPv4 address range, in CIDR notation.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysissecuritygrouprule.html#cfn-ec2-networkinsightsanalysis-analysissecuritygrouprule-cidr
            '''
            result = self._values.get("cidr")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def direction(self) -> typing.Optional[builtins.str]:
            '''The direction. The following are the possible values:.

            - egress
            - ingress

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysissecuritygrouprule.html#cfn-ec2-networkinsightsanalysis-analysissecuritygrouprule-direction
            '''
            result = self._values.get("direction")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def port_range(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.PortRangeProperty"]]:
            '''The port range.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysissecuritygrouprule.html#cfn-ec2-networkinsightsanalysis-analysissecuritygrouprule-portrange
            '''
            result = self._values.get("port_range")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.PortRangeProperty"]], result)

        @builtins.property
        def prefix_list_id(self) -> typing.Optional[builtins.str]:
            '''The prefix list ID.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysissecuritygrouprule.html#cfn-ec2-networkinsightsanalysis-analysissecuritygrouprule-prefixlistid
            '''
            result = self._values.get("prefix_list_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def protocol(self) -> typing.Optional[builtins.str]:
            '''The protocol name.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysissecuritygrouprule.html#cfn-ec2-networkinsightsanalysis-analysissecuritygrouprule-protocol
            '''
            result = self._values.get("protocol")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def security_group_id(self) -> typing.Optional[builtins.str]:
            '''The security group ID.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysissecuritygrouprule.html#cfn-ec2-networkinsightsanalysis-analysissecuritygrouprule-securitygroupid
            '''
            result = self._values.get("security_group_id")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AnalysisSecurityGroupRuleProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkInsightsAnalysisPropsMixin.ExplanationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "acl": "acl",
            "acl_rule": "aclRule",
            "address": "address",
            "addresses": "addresses",
            "attached_to": "attachedTo",
            "availability_zones": "availabilityZones",
            "cidrs": "cidrs",
            "classic_load_balancer_listener": "classicLoadBalancerListener",
            "component": "component",
            "component_account": "componentAccount",
            "component_region": "componentRegion",
            "customer_gateway": "customerGateway",
            "destination": "destination",
            "destination_vpc": "destinationVpc",
            "direction": "direction",
            "elastic_load_balancer_listener": "elasticLoadBalancerListener",
            "explanation_code": "explanationCode",
            "ingress_route_table": "ingressRouteTable",
            "internet_gateway": "internetGateway",
            "load_balancer_arn": "loadBalancerArn",
            "load_balancer_listener_port": "loadBalancerListenerPort",
            "load_balancer_target": "loadBalancerTarget",
            "load_balancer_target_group": "loadBalancerTargetGroup",
            "load_balancer_target_groups": "loadBalancerTargetGroups",
            "load_balancer_target_port": "loadBalancerTargetPort",
            "missing_component": "missingComponent",
            "nat_gateway": "natGateway",
            "network_interface": "networkInterface",
            "packet_field": "packetField",
            "port": "port",
            "port_ranges": "portRanges",
            "prefix_list": "prefixList",
            "protocols": "protocols",
            "route_table": "routeTable",
            "route_table_route": "routeTableRoute",
            "security_group": "securityGroup",
            "security_group_rule": "securityGroupRule",
            "security_groups": "securityGroups",
            "source_vpc": "sourceVpc",
            "state": "state",
            "subnet": "subnet",
            "subnet_route_table": "subnetRouteTable",
            "transit_gateway": "transitGateway",
            "transit_gateway_attachment": "transitGatewayAttachment",
            "transit_gateway_route_table": "transitGatewayRouteTable",
            "transit_gateway_route_table_route": "transitGatewayRouteTableRoute",
            "vpc": "vpc",
            "vpc_endpoint": "vpcEndpoint",
            "vpc_peering_connection": "vpcPeeringConnection",
            "vpn_connection": "vpnConnection",
            "vpn_gateway": "vpnGateway",
        },
    )
    class ExplanationProperty:
        def __init__(
            self,
            *,
            acl: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            acl_rule: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisAclRuleProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            address: typing.Optional[builtins.str] = None,
            addresses: typing.Optional[typing.Sequence[builtins.str]] = None,
            attached_to: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            availability_zones: typing.Optional[typing.Sequence[builtins.str]] = None,
            cidrs: typing.Optional[typing.Sequence[builtins.str]] = None,
            classic_load_balancer_listener: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisLoadBalancerListenerProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            component: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            component_account: typing.Optional[builtins.str] = None,
            component_region: typing.Optional[builtins.str] = None,
            customer_gateway: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            destination: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            destination_vpc: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            direction: typing.Optional[builtins.str] = None,
            elastic_load_balancer_listener: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            explanation_code: typing.Optional[builtins.str] = None,
            ingress_route_table: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            internet_gateway: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            load_balancer_arn: typing.Optional[builtins.str] = None,
            load_balancer_listener_port: typing.Optional[jsii.Number] = None,
            load_balancer_target: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisLoadBalancerTargetProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            load_balancer_target_group: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            load_balancer_target_groups: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            load_balancer_target_port: typing.Optional[jsii.Number] = None,
            missing_component: typing.Optional[builtins.str] = None,
            nat_gateway: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            network_interface: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            packet_field: typing.Optional[builtins.str] = None,
            port: typing.Optional[jsii.Number] = None,
            port_ranges: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.PortRangeProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            prefix_list: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            protocols: typing.Optional[typing.Sequence[builtins.str]] = None,
            route_table: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            route_table_route: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisRouteTableRouteProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            security_group: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            security_group_rule: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisSecurityGroupRuleProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            security_groups: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            source_vpc: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            state: typing.Optional[builtins.str] = None,
            subnet: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            subnet_route_table: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            transit_gateway: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            transit_gateway_attachment: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            transit_gateway_route_table: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            transit_gateway_route_table_route: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.TransitGatewayRouteTableRouteProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            vpc: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            vpc_endpoint: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            vpc_peering_connection: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            vpn_connection: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            vpn_gateway: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Describes an explanation code for an unreachable path.

            For more information, see `Reachability Analyzer explanation codes <https://docs.aws.amazon.com/vpc/latest/reachability/explanation-codes.html>`_ .

            :param acl: The network ACL.
            :param acl_rule: The network ACL rule.
            :param address: The IPv4 address, in CIDR notation.
            :param addresses: The IPv4 addresses, in CIDR notation.
            :param attached_to: The resource to which the component is attached.
            :param availability_zones: The Availability Zones.
            :param cidrs: The CIDR ranges.
            :param classic_load_balancer_listener: The listener for a Classic Load Balancer.
            :param component: The component.
            :param component_account: The AWS account for the component.
            :param component_region: The Region for the component.
            :param customer_gateway: The customer gateway.
            :param destination: The destination.
            :param destination_vpc: The destination VPC.
            :param direction: The direction. The following are the possible values:. - egress - ingress
            :param elastic_load_balancer_listener: The load balancer listener.
            :param explanation_code: The explanation code.
            :param ingress_route_table: The route table.
            :param internet_gateway: The internet gateway.
            :param load_balancer_arn: The Amazon Resource Name (ARN) of the load balancer.
            :param load_balancer_listener_port: The listener port of the load balancer.
            :param load_balancer_target: The target.
            :param load_balancer_target_group: The target group.
            :param load_balancer_target_groups: The target groups.
            :param load_balancer_target_port: The target port.
            :param missing_component: The missing component.
            :param nat_gateway: The NAT gateway.
            :param network_interface: The network interface.
            :param packet_field: The packet field.
            :param port: The port.
            :param port_ranges: The port ranges.
            :param prefix_list: The prefix list.
            :param protocols: The protocols.
            :param route_table: The route table.
            :param route_table_route: The route table route.
            :param security_group: The security group.
            :param security_group_rule: The security group rule.
            :param security_groups: The security groups.
            :param source_vpc: The source VPC.
            :param state: The state.
            :param subnet: The subnet.
            :param subnet_route_table: The route table for the subnet.
            :param transit_gateway: The transit gateway.
            :param transit_gateway_attachment: The transit gateway attachment.
            :param transit_gateway_route_table: The transit gateway route table.
            :param transit_gateway_route_table_route: The transit gateway route table route.
            :param vpc: The component VPC.
            :param vpc_endpoint: The VPC endpoint.
            :param vpc_peering_connection: The VPC peering connection.
            :param vpn_connection: The VPN connection.
            :param vpn_gateway: The VPN gateway.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                explanation_property = ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.ExplanationProperty(
                    acl=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    acl_rule=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisAclRuleProperty(
                        cidr="cidr",
                        egress=False,
                        port_range=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.PortRangeProperty(
                            from=123,
                            to=123
                        ),
                        protocol="protocol",
                        rule_action="ruleAction",
                        rule_number=123
                    ),
                    address="address",
                    addresses=["addresses"],
                    attached_to=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    availability_zones=["availabilityZones"],
                    cidrs=["cidrs"],
                    classic_load_balancer_listener=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisLoadBalancerListenerProperty(
                        instance_port=123,
                        load_balancer_port=123
                    ),
                    component=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    component_account="componentAccount",
                    component_region="componentRegion",
                    customer_gateway=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    destination=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    destination_vpc=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    direction="direction",
                    elastic_load_balancer_listener=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    explanation_code="explanationCode",
                    ingress_route_table=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    internet_gateway=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    load_balancer_arn="loadBalancerArn",
                    load_balancer_listener_port=123,
                    load_balancer_target=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisLoadBalancerTargetProperty(
                        address="address",
                        availability_zone="availabilityZone",
                        instance=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                            arn="arn",
                            id="id"
                        ),
                        port=123
                    ),
                    load_balancer_target_group=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    load_balancer_target_groups=[ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    )],
                    load_balancer_target_port=123,
                    missing_component="missingComponent",
                    nat_gateway=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    network_interface=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    packet_field="packetField",
                    port=123,
                    port_ranges=[ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.PortRangeProperty(
                        from=123,
                        to=123
                    )],
                    prefix_list=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    protocols=["protocols"],
                    route_table=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    route_table_route=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisRouteTableRouteProperty(
                        destination_cidr="destinationCidr",
                        destination_prefix_list_id="destinationPrefixListId",
                        egress_only_internet_gateway_id="egressOnlyInternetGatewayId",
                        gateway_id="gatewayId",
                        instance_id="instanceId",
                        nat_gateway_id="natGatewayId",
                        network_interface_id="networkInterfaceId",
                        origin="origin",
                        state="state",
                        transit_gateway_id="transitGatewayId",
                        vpc_peering_connection_id="vpcPeeringConnectionId"
                    ),
                    security_group=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    security_group_rule=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisSecurityGroupRuleProperty(
                        cidr="cidr",
                        direction="direction",
                        port_range=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.PortRangeProperty(
                            from=123,
                            to=123
                        ),
                        prefix_list_id="prefixListId",
                        protocol="protocol",
                        security_group_id="securityGroupId"
                    ),
                    security_groups=[ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    )],
                    source_vpc=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    state="state",
                    subnet=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    subnet_route_table=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    transit_gateway=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    transit_gateway_attachment=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    transit_gateway_route_table=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    transit_gateway_route_table_route=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.TransitGatewayRouteTableRouteProperty(
                        attachment_id="attachmentId",
                        destination_cidr="destinationCidr",
                        prefix_list_id="prefixListId",
                        resource_id="resourceId",
                        resource_type="resourceType",
                        route_origin="routeOrigin",
                        state="state"
                    ),
                    vpc=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    vpc_endpoint=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    vpc_peering_connection=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    vpn_connection=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    vpn_gateway=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__c7c2c3061b433a46abb88340becbd31d93c80d005ebc7853683160b6c194edba)
                check_type(argname="argument acl", value=acl, expected_type=type_hints["acl"])
                check_type(argname="argument acl_rule", value=acl_rule, expected_type=type_hints["acl_rule"])
                check_type(argname="argument address", value=address, expected_type=type_hints["address"])
                check_type(argname="argument addresses", value=addresses, expected_type=type_hints["addresses"])
                check_type(argname="argument attached_to", value=attached_to, expected_type=type_hints["attached_to"])
                check_type(argname="argument availability_zones", value=availability_zones, expected_type=type_hints["availability_zones"])
                check_type(argname="argument cidrs", value=cidrs, expected_type=type_hints["cidrs"])
                check_type(argname="argument classic_load_balancer_listener", value=classic_load_balancer_listener, expected_type=type_hints["classic_load_balancer_listener"])
                check_type(argname="argument component", value=component, expected_type=type_hints["component"])
                check_type(argname="argument component_account", value=component_account, expected_type=type_hints["component_account"])
                check_type(argname="argument component_region", value=component_region, expected_type=type_hints["component_region"])
                check_type(argname="argument customer_gateway", value=customer_gateway, expected_type=type_hints["customer_gateway"])
                check_type(argname="argument destination", value=destination, expected_type=type_hints["destination"])
                check_type(argname="argument destination_vpc", value=destination_vpc, expected_type=type_hints["destination_vpc"])
                check_type(argname="argument direction", value=direction, expected_type=type_hints["direction"])
                check_type(argname="argument elastic_load_balancer_listener", value=elastic_load_balancer_listener, expected_type=type_hints["elastic_load_balancer_listener"])
                check_type(argname="argument explanation_code", value=explanation_code, expected_type=type_hints["explanation_code"])
                check_type(argname="argument ingress_route_table", value=ingress_route_table, expected_type=type_hints["ingress_route_table"])
                check_type(argname="argument internet_gateway", value=internet_gateway, expected_type=type_hints["internet_gateway"])
                check_type(argname="argument load_balancer_arn", value=load_balancer_arn, expected_type=type_hints["load_balancer_arn"])
                check_type(argname="argument load_balancer_listener_port", value=load_balancer_listener_port, expected_type=type_hints["load_balancer_listener_port"])
                check_type(argname="argument load_balancer_target", value=load_balancer_target, expected_type=type_hints["load_balancer_target"])
                check_type(argname="argument load_balancer_target_group", value=load_balancer_target_group, expected_type=type_hints["load_balancer_target_group"])
                check_type(argname="argument load_balancer_target_groups", value=load_balancer_target_groups, expected_type=type_hints["load_balancer_target_groups"])
                check_type(argname="argument load_balancer_target_port", value=load_balancer_target_port, expected_type=type_hints["load_balancer_target_port"])
                check_type(argname="argument missing_component", value=missing_component, expected_type=type_hints["missing_component"])
                check_type(argname="argument nat_gateway", value=nat_gateway, expected_type=type_hints["nat_gateway"])
                check_type(argname="argument network_interface", value=network_interface, expected_type=type_hints["network_interface"])
                check_type(argname="argument packet_field", value=packet_field, expected_type=type_hints["packet_field"])
                check_type(argname="argument port", value=port, expected_type=type_hints["port"])
                check_type(argname="argument port_ranges", value=port_ranges, expected_type=type_hints["port_ranges"])
                check_type(argname="argument prefix_list", value=prefix_list, expected_type=type_hints["prefix_list"])
                check_type(argname="argument protocols", value=protocols, expected_type=type_hints["protocols"])
                check_type(argname="argument route_table", value=route_table, expected_type=type_hints["route_table"])
                check_type(argname="argument route_table_route", value=route_table_route, expected_type=type_hints["route_table_route"])
                check_type(argname="argument security_group", value=security_group, expected_type=type_hints["security_group"])
                check_type(argname="argument security_group_rule", value=security_group_rule, expected_type=type_hints["security_group_rule"])
                check_type(argname="argument security_groups", value=security_groups, expected_type=type_hints["security_groups"])
                check_type(argname="argument source_vpc", value=source_vpc, expected_type=type_hints["source_vpc"])
                check_type(argname="argument state", value=state, expected_type=type_hints["state"])
                check_type(argname="argument subnet", value=subnet, expected_type=type_hints["subnet"])
                check_type(argname="argument subnet_route_table", value=subnet_route_table, expected_type=type_hints["subnet_route_table"])
                check_type(argname="argument transit_gateway", value=transit_gateway, expected_type=type_hints["transit_gateway"])
                check_type(argname="argument transit_gateway_attachment", value=transit_gateway_attachment, expected_type=type_hints["transit_gateway_attachment"])
                check_type(argname="argument transit_gateway_route_table", value=transit_gateway_route_table, expected_type=type_hints["transit_gateway_route_table"])
                check_type(argname="argument transit_gateway_route_table_route", value=transit_gateway_route_table_route, expected_type=type_hints["transit_gateway_route_table_route"])
                check_type(argname="argument vpc", value=vpc, expected_type=type_hints["vpc"])
                check_type(argname="argument vpc_endpoint", value=vpc_endpoint, expected_type=type_hints["vpc_endpoint"])
                check_type(argname="argument vpc_peering_connection", value=vpc_peering_connection, expected_type=type_hints["vpc_peering_connection"])
                check_type(argname="argument vpn_connection", value=vpn_connection, expected_type=type_hints["vpn_connection"])
                check_type(argname="argument vpn_gateway", value=vpn_gateway, expected_type=type_hints["vpn_gateway"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if acl is not None:
                self._values["acl"] = acl
            if acl_rule is not None:
                self._values["acl_rule"] = acl_rule
            if address is not None:
                self._values["address"] = address
            if addresses is not None:
                self._values["addresses"] = addresses
            if attached_to is not None:
                self._values["attached_to"] = attached_to
            if availability_zones is not None:
                self._values["availability_zones"] = availability_zones
            if cidrs is not None:
                self._values["cidrs"] = cidrs
            if classic_load_balancer_listener is not None:
                self._values["classic_load_balancer_listener"] = classic_load_balancer_listener
            if component is not None:
                self._values["component"] = component
            if component_account is not None:
                self._values["component_account"] = component_account
            if component_region is not None:
                self._values["component_region"] = component_region
            if customer_gateway is not None:
                self._values["customer_gateway"] = customer_gateway
            if destination is not None:
                self._values["destination"] = destination
            if destination_vpc is not None:
                self._values["destination_vpc"] = destination_vpc
            if direction is not None:
                self._values["direction"] = direction
            if elastic_load_balancer_listener is not None:
                self._values["elastic_load_balancer_listener"] = elastic_load_balancer_listener
            if explanation_code is not None:
                self._values["explanation_code"] = explanation_code
            if ingress_route_table is not None:
                self._values["ingress_route_table"] = ingress_route_table
            if internet_gateway is not None:
                self._values["internet_gateway"] = internet_gateway
            if load_balancer_arn is not None:
                self._values["load_balancer_arn"] = load_balancer_arn
            if load_balancer_listener_port is not None:
                self._values["load_balancer_listener_port"] = load_balancer_listener_port
            if load_balancer_target is not None:
                self._values["load_balancer_target"] = load_balancer_target
            if load_balancer_target_group is not None:
                self._values["load_balancer_target_group"] = load_balancer_target_group
            if load_balancer_target_groups is not None:
                self._values["load_balancer_target_groups"] = load_balancer_target_groups
            if load_balancer_target_port is not None:
                self._values["load_balancer_target_port"] = load_balancer_target_port
            if missing_component is not None:
                self._values["missing_component"] = missing_component
            if nat_gateway is not None:
                self._values["nat_gateway"] = nat_gateway
            if network_interface is not None:
                self._values["network_interface"] = network_interface
            if packet_field is not None:
                self._values["packet_field"] = packet_field
            if port is not None:
                self._values["port"] = port
            if port_ranges is not None:
                self._values["port_ranges"] = port_ranges
            if prefix_list is not None:
                self._values["prefix_list"] = prefix_list
            if protocols is not None:
                self._values["protocols"] = protocols
            if route_table is not None:
                self._values["route_table"] = route_table
            if route_table_route is not None:
                self._values["route_table_route"] = route_table_route
            if security_group is not None:
                self._values["security_group"] = security_group
            if security_group_rule is not None:
                self._values["security_group_rule"] = security_group_rule
            if security_groups is not None:
                self._values["security_groups"] = security_groups
            if source_vpc is not None:
                self._values["source_vpc"] = source_vpc
            if state is not None:
                self._values["state"] = state
            if subnet is not None:
                self._values["subnet"] = subnet
            if subnet_route_table is not None:
                self._values["subnet_route_table"] = subnet_route_table
            if transit_gateway is not None:
                self._values["transit_gateway"] = transit_gateway
            if transit_gateway_attachment is not None:
                self._values["transit_gateway_attachment"] = transit_gateway_attachment
            if transit_gateway_route_table is not None:
                self._values["transit_gateway_route_table"] = transit_gateway_route_table
            if transit_gateway_route_table_route is not None:
                self._values["transit_gateway_route_table_route"] = transit_gateway_route_table_route
            if vpc is not None:
                self._values["vpc"] = vpc
            if vpc_endpoint is not None:
                self._values["vpc_endpoint"] = vpc_endpoint
            if vpc_peering_connection is not None:
                self._values["vpc_peering_connection"] = vpc_peering_connection
            if vpn_connection is not None:
                self._values["vpn_connection"] = vpn_connection
            if vpn_gateway is not None:
                self._values["vpn_gateway"] = vpn_gateway

        @builtins.property
        def acl(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]]:
            '''The network ACL.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-acl
            '''
            result = self._values.get("acl")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]], result)

        @builtins.property
        def acl_rule(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisAclRuleProperty"]]:
            '''The network ACL rule.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-aclrule
            '''
            result = self._values.get("acl_rule")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisAclRuleProperty"]], result)

        @builtins.property
        def address(self) -> typing.Optional[builtins.str]:
            '''The IPv4 address, in CIDR notation.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-address
            '''
            result = self._values.get("address")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def addresses(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The IPv4 addresses, in CIDR notation.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-addresses
            '''
            result = self._values.get("addresses")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def attached_to(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]]:
            '''The resource to which the component is attached.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-attachedto
            '''
            result = self._values.get("attached_to")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]], result)

        @builtins.property
        def availability_zones(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The Availability Zones.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-availabilityzones
            '''
            result = self._values.get("availability_zones")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def cidrs(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The CIDR ranges.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-cidrs
            '''
            result = self._values.get("cidrs")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def classic_load_balancer_listener(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisLoadBalancerListenerProperty"]]:
            '''The listener for a Classic Load Balancer.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-classicloadbalancerlistener
            '''
            result = self._values.get("classic_load_balancer_listener")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisLoadBalancerListenerProperty"]], result)

        @builtins.property
        def component(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]]:
            '''The component.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-component
            '''
            result = self._values.get("component")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]], result)

        @builtins.property
        def component_account(self) -> typing.Optional[builtins.str]:
            '''The AWS account for the component.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-componentaccount
            '''
            result = self._values.get("component_account")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def component_region(self) -> typing.Optional[builtins.str]:
            '''The Region for the component.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-componentregion
            '''
            result = self._values.get("component_region")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def customer_gateway(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]]:
            '''The customer gateway.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-customergateway
            '''
            result = self._values.get("customer_gateway")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]], result)

        @builtins.property
        def destination(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]]:
            '''The destination.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-destination
            '''
            result = self._values.get("destination")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]], result)

        @builtins.property
        def destination_vpc(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]]:
            '''The destination VPC.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-destinationvpc
            '''
            result = self._values.get("destination_vpc")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]], result)

        @builtins.property
        def direction(self) -> typing.Optional[builtins.str]:
            '''The direction. The following are the possible values:.

            - egress
            - ingress

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-direction
            '''
            result = self._values.get("direction")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def elastic_load_balancer_listener(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]]:
            '''The load balancer listener.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-elasticloadbalancerlistener
            '''
            result = self._values.get("elastic_load_balancer_listener")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]], result)

        @builtins.property
        def explanation_code(self) -> typing.Optional[builtins.str]:
            '''The explanation code.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-explanationcode
            '''
            result = self._values.get("explanation_code")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def ingress_route_table(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]]:
            '''The route table.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-ingressroutetable
            '''
            result = self._values.get("ingress_route_table")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]], result)

        @builtins.property
        def internet_gateway(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]]:
            '''The internet gateway.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-internetgateway
            '''
            result = self._values.get("internet_gateway")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]], result)

        @builtins.property
        def load_balancer_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the load balancer.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-loadbalancerarn
            '''
            result = self._values.get("load_balancer_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def load_balancer_listener_port(self) -> typing.Optional[jsii.Number]:
            '''The listener port of the load balancer.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-loadbalancerlistenerport
            '''
            result = self._values.get("load_balancer_listener_port")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def load_balancer_target(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisLoadBalancerTargetProperty"]]:
            '''The target.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-loadbalancertarget
            '''
            result = self._values.get("load_balancer_target")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisLoadBalancerTargetProperty"]], result)

        @builtins.property
        def load_balancer_target_group(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]]:
            '''The target group.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-loadbalancertargetgroup
            '''
            result = self._values.get("load_balancer_target_group")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]], result)

        @builtins.property
        def load_balancer_target_groups(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]]]]:
            '''The target groups.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-loadbalancertargetgroups
            '''
            result = self._values.get("load_balancer_target_groups")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]]]], result)

        @builtins.property
        def load_balancer_target_port(self) -> typing.Optional[jsii.Number]:
            '''The target port.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-loadbalancertargetport
            '''
            result = self._values.get("load_balancer_target_port")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def missing_component(self) -> typing.Optional[builtins.str]:
            '''The missing component.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-missingcomponent
            '''
            result = self._values.get("missing_component")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def nat_gateway(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]]:
            '''The NAT gateway.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-natgateway
            '''
            result = self._values.get("nat_gateway")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]], result)

        @builtins.property
        def network_interface(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]]:
            '''The network interface.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-networkinterface
            '''
            result = self._values.get("network_interface")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]], result)

        @builtins.property
        def packet_field(self) -> typing.Optional[builtins.str]:
            '''The packet field.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-packetfield
            '''
            result = self._values.get("packet_field")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def port(self) -> typing.Optional[jsii.Number]:
            '''The port.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-port
            '''
            result = self._values.get("port")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def port_ranges(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.PortRangeProperty"]]]]:
            '''The port ranges.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-portranges
            '''
            result = self._values.get("port_ranges")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.PortRangeProperty"]]]], result)

        @builtins.property
        def prefix_list(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]]:
            '''The prefix list.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-prefixlist
            '''
            result = self._values.get("prefix_list")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]], result)

        @builtins.property
        def protocols(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The protocols.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-protocols
            '''
            result = self._values.get("protocols")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def route_table(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]]:
            '''The route table.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-routetable
            '''
            result = self._values.get("route_table")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]], result)

        @builtins.property
        def route_table_route(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisRouteTableRouteProperty"]]:
            '''The route table route.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-routetableroute
            '''
            result = self._values.get("route_table_route")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisRouteTableRouteProperty"]], result)

        @builtins.property
        def security_group(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]]:
            '''The security group.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-securitygroup
            '''
            result = self._values.get("security_group")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]], result)

        @builtins.property
        def security_group_rule(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisSecurityGroupRuleProperty"]]:
            '''The security group rule.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-securitygrouprule
            '''
            result = self._values.get("security_group_rule")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisSecurityGroupRuleProperty"]], result)

        @builtins.property
        def security_groups(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]]]]:
            '''The security groups.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-securitygroups
            '''
            result = self._values.get("security_groups")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]]]], result)

        @builtins.property
        def source_vpc(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]]:
            '''The source VPC.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-sourcevpc
            '''
            result = self._values.get("source_vpc")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]], result)

        @builtins.property
        def state(self) -> typing.Optional[builtins.str]:
            '''The state.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-state
            '''
            result = self._values.get("state")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def subnet(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]]:
            '''The subnet.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-subnet
            '''
            result = self._values.get("subnet")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]], result)

        @builtins.property
        def subnet_route_table(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]]:
            '''The route table for the subnet.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-subnetroutetable
            '''
            result = self._values.get("subnet_route_table")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]], result)

        @builtins.property
        def transit_gateway(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]]:
            '''The transit gateway.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-transitgateway
            '''
            result = self._values.get("transit_gateway")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]], result)

        @builtins.property
        def transit_gateway_attachment(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]]:
            '''The transit gateway attachment.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-transitgatewayattachment
            '''
            result = self._values.get("transit_gateway_attachment")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]], result)

        @builtins.property
        def transit_gateway_route_table(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]]:
            '''The transit gateway route table.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-transitgatewayroutetable
            '''
            result = self._values.get("transit_gateway_route_table")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]], result)

        @builtins.property
        def transit_gateway_route_table_route(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.TransitGatewayRouteTableRouteProperty"]]:
            '''The transit gateway route table route.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-transitgatewayroutetableroute
            '''
            result = self._values.get("transit_gateway_route_table_route")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.TransitGatewayRouteTableRouteProperty"]], result)

        @builtins.property
        def vpc(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]]:
            '''The component VPC.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-vpc
            '''
            result = self._values.get("vpc")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]], result)

        @builtins.property
        def vpc_endpoint(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]]:
            '''The VPC endpoint.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-vpcendpoint
            '''
            result = self._values.get("vpc_endpoint")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]], result)

        @builtins.property
        def vpc_peering_connection(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]]:
            '''The VPC peering connection.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-vpcpeeringconnection
            '''
            result = self._values.get("vpc_peering_connection")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]], result)

        @builtins.property
        def vpn_connection(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]]:
            '''The VPN connection.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-vpnconnection
            '''
            result = self._values.get("vpn_connection")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]], result)

        @builtins.property
        def vpn_gateway(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]]:
            '''The VPN gateway.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-vpngateway
            '''
            result = self._values.get("vpn_gateway")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ExplanationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkInsightsAnalysisPropsMixin.PathComponentProperty",
        jsii_struct_bases=[],
        name_mapping={
            "acl_rule": "aclRule",
            "additional_details": "additionalDetails",
            "component": "component",
            "destination_vpc": "destinationVpc",
            "elastic_load_balancer_listener": "elasticLoadBalancerListener",
            "explanations": "explanations",
            "inbound_header": "inboundHeader",
            "outbound_header": "outboundHeader",
            "route_table_route": "routeTableRoute",
            "security_group_rule": "securityGroupRule",
            "sequence_number": "sequenceNumber",
            "service_name": "serviceName",
            "source_vpc": "sourceVpc",
            "subnet": "subnet",
            "transit_gateway": "transitGateway",
            "transit_gateway_route_table_route": "transitGatewayRouteTableRoute",
            "vpc": "vpc",
        },
    )
    class PathComponentProperty:
        def __init__(
            self,
            *,
            acl_rule: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisAclRuleProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            additional_details: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AdditionalDetailProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            component: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            destination_vpc: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            elastic_load_balancer_listener: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            explanations: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.ExplanationProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            inbound_header: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisPacketHeaderProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            outbound_header: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisPacketHeaderProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            route_table_route: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisRouteTableRouteProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            security_group_rule: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisSecurityGroupRuleProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            sequence_number: typing.Optional[jsii.Number] = None,
            service_name: typing.Optional[builtins.str] = None,
            source_vpc: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            subnet: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            transit_gateway: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            transit_gateway_route_table_route: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.TransitGatewayRouteTableRouteProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            vpc: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Describes a path component.

            :param acl_rule: The network ACL rule.
            :param additional_details: The additional details.
            :param component: The component.
            :param destination_vpc: The destination VPC.
            :param elastic_load_balancer_listener: The load balancer listener.
            :param explanations: The explanation codes.
            :param inbound_header: The inbound header.
            :param outbound_header: The outbound header.
            :param route_table_route: The route table route.
            :param security_group_rule: The security group rule.
            :param sequence_number: The sequence number.
            :param service_name: The name of the VPC endpoint service.
            :param source_vpc: The source VPC.
            :param subnet: The subnet.
            :param transit_gateway: The transit gateway.
            :param transit_gateway_route_table_route: The route in a transit gateway route table.
            :param vpc: The component VPC.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                path_component_property = ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.PathComponentProperty(
                    acl_rule=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisAclRuleProperty(
                        cidr="cidr",
                        egress=False,
                        port_range=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.PortRangeProperty(
                            from=123,
                            to=123
                        ),
                        protocol="protocol",
                        rule_action="ruleAction",
                        rule_number=123
                    ),
                    additional_details=[ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AdditionalDetailProperty(
                        additional_detail_type="additionalDetailType",
                        component=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                            arn="arn",
                            id="id"
                        ),
                        load_balancers=[ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                            arn="arn",
                            id="id"
                        )],
                        service_name="serviceName"
                    )],
                    component=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    destination_vpc=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    elastic_load_balancer_listener=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    explanations=[ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.ExplanationProperty(
                        acl=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                            arn="arn",
                            id="id"
                        ),
                        acl_rule=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisAclRuleProperty(
                            cidr="cidr",
                            egress=False,
                            port_range=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.PortRangeProperty(
                                from=123,
                                to=123
                            ),
                            protocol="protocol",
                            rule_action="ruleAction",
                            rule_number=123
                        ),
                        address="address",
                        addresses=["addresses"],
                        attached_to=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                            arn="arn",
                            id="id"
                        ),
                        availability_zones=["availabilityZones"],
                        cidrs=["cidrs"],
                        classic_load_balancer_listener=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisLoadBalancerListenerProperty(
                            instance_port=123,
                            load_balancer_port=123
                        ),
                        component=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                            arn="arn",
                            id="id"
                        ),
                        component_account="componentAccount",
                        component_region="componentRegion",
                        customer_gateway=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                            arn="arn",
                            id="id"
                        ),
                        destination=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                            arn="arn",
                            id="id"
                        ),
                        destination_vpc=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                            arn="arn",
                            id="id"
                        ),
                        direction="direction",
                        elastic_load_balancer_listener=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                            arn="arn",
                            id="id"
                        ),
                        explanation_code="explanationCode",
                        ingress_route_table=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                            arn="arn",
                            id="id"
                        ),
                        internet_gateway=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                            arn="arn",
                            id="id"
                        ),
                        load_balancer_arn="loadBalancerArn",
                        load_balancer_listener_port=123,
                        load_balancer_target=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisLoadBalancerTargetProperty(
                            address="address",
                            availability_zone="availabilityZone",
                            instance=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                                arn="arn",
                                id="id"
                            ),
                            port=123
                        ),
                        load_balancer_target_group=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                            arn="arn",
                            id="id"
                        ),
                        load_balancer_target_groups=[ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                            arn="arn",
                            id="id"
                        )],
                        load_balancer_target_port=123,
                        missing_component="missingComponent",
                        nat_gateway=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                            arn="arn",
                            id="id"
                        ),
                        network_interface=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                            arn="arn",
                            id="id"
                        ),
                        packet_field="packetField",
                        port=123,
                        port_ranges=[ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.PortRangeProperty(
                            from=123,
                            to=123
                        )],
                        prefix_list=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                            arn="arn",
                            id="id"
                        ),
                        protocols=["protocols"],
                        route_table=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                            arn="arn",
                            id="id"
                        ),
                        route_table_route=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisRouteTableRouteProperty(
                            destination_cidr="destinationCidr",
                            destination_prefix_list_id="destinationPrefixListId",
                            egress_only_internet_gateway_id="egressOnlyInternetGatewayId",
                            gateway_id="gatewayId",
                            instance_id="instanceId",
                            nat_gateway_id="natGatewayId",
                            network_interface_id="networkInterfaceId",
                            origin="origin",
                            state="state",
                            transit_gateway_id="transitGatewayId",
                            vpc_peering_connection_id="vpcPeeringConnectionId"
                        ),
                        security_group=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                            arn="arn",
                            id="id"
                        ),
                        security_group_rule=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisSecurityGroupRuleProperty(
                            cidr="cidr",
                            direction="direction",
                            port_range=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.PortRangeProperty(
                                from=123,
                                to=123
                            ),
                            prefix_list_id="prefixListId",
                            protocol="protocol",
                            security_group_id="securityGroupId"
                        ),
                        security_groups=[ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                            arn="arn",
                            id="id"
                        )],
                        source_vpc=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                            arn="arn",
                            id="id"
                        ),
                        state="state",
                        subnet=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                            arn="arn",
                            id="id"
                        ),
                        subnet_route_table=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                            arn="arn",
                            id="id"
                        ),
                        transit_gateway=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                            arn="arn",
                            id="id"
                        ),
                        transit_gateway_attachment=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                            arn="arn",
                            id="id"
                        ),
                        transit_gateway_route_table=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                            arn="arn",
                            id="id"
                        ),
                        transit_gateway_route_table_route=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.TransitGatewayRouteTableRouteProperty(
                            attachment_id="attachmentId",
                            destination_cidr="destinationCidr",
                            prefix_list_id="prefixListId",
                            resource_id="resourceId",
                            resource_type="resourceType",
                            route_origin="routeOrigin",
                            state="state"
                        ),
                        vpc=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                            arn="arn",
                            id="id"
                        ),
                        vpc_endpoint=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                            arn="arn",
                            id="id"
                        ),
                        vpc_peering_connection=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                            arn="arn",
                            id="id"
                        ),
                        vpn_connection=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                            arn="arn",
                            id="id"
                        ),
                        vpn_gateway=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                            arn="arn",
                            id="id"
                        )
                    )],
                    inbound_header=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisPacketHeaderProperty(
                        destination_addresses=["destinationAddresses"],
                        destination_port_ranges=[ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.PortRangeProperty(
                            from=123,
                            to=123
                        )],
                        protocol="protocol",
                        source_addresses=["sourceAddresses"],
                        source_port_ranges=[ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.PortRangeProperty(
                            from=123,
                            to=123
                        )]
                    ),
                    outbound_header=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisPacketHeaderProperty(
                        destination_addresses=["destinationAddresses"],
                        destination_port_ranges=[ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.PortRangeProperty(
                            from=123,
                            to=123
                        )],
                        protocol="protocol",
                        source_addresses=["sourceAddresses"],
                        source_port_ranges=[ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.PortRangeProperty(
                            from=123,
                            to=123
                        )]
                    ),
                    route_table_route=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisRouteTableRouteProperty(
                        destination_cidr="destinationCidr",
                        destination_prefix_list_id="destinationPrefixListId",
                        egress_only_internet_gateway_id="egressOnlyInternetGatewayId",
                        gateway_id="gatewayId",
                        instance_id="instanceId",
                        nat_gateway_id="natGatewayId",
                        network_interface_id="networkInterfaceId",
                        origin="origin",
                        state="state",
                        transit_gateway_id="transitGatewayId",
                        vpc_peering_connection_id="vpcPeeringConnectionId"
                    ),
                    security_group_rule=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisSecurityGroupRuleProperty(
                        cidr="cidr",
                        direction="direction",
                        port_range=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.PortRangeProperty(
                            from=123,
                            to=123
                        ),
                        prefix_list_id="prefixListId",
                        protocol="protocol",
                        security_group_id="securityGroupId"
                    ),
                    sequence_number=123,
                    service_name="serviceName",
                    source_vpc=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    subnet=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    transit_gateway=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    transit_gateway_route_table_route=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.TransitGatewayRouteTableRouteProperty(
                        attachment_id="attachmentId",
                        destination_cidr="destinationCidr",
                        prefix_list_id="prefixListId",
                        resource_id="resourceId",
                        resource_type="resourceType",
                        route_origin="routeOrigin",
                        state="state"
                    ),
                    vpc=ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__d55f31184075d7059874669c059a4bbcbd46d664cb62acdad0d73329a7c39f8c)
                check_type(argname="argument acl_rule", value=acl_rule, expected_type=type_hints["acl_rule"])
                check_type(argname="argument additional_details", value=additional_details, expected_type=type_hints["additional_details"])
                check_type(argname="argument component", value=component, expected_type=type_hints["component"])
                check_type(argname="argument destination_vpc", value=destination_vpc, expected_type=type_hints["destination_vpc"])
                check_type(argname="argument elastic_load_balancer_listener", value=elastic_load_balancer_listener, expected_type=type_hints["elastic_load_balancer_listener"])
                check_type(argname="argument explanations", value=explanations, expected_type=type_hints["explanations"])
                check_type(argname="argument inbound_header", value=inbound_header, expected_type=type_hints["inbound_header"])
                check_type(argname="argument outbound_header", value=outbound_header, expected_type=type_hints["outbound_header"])
                check_type(argname="argument route_table_route", value=route_table_route, expected_type=type_hints["route_table_route"])
                check_type(argname="argument security_group_rule", value=security_group_rule, expected_type=type_hints["security_group_rule"])
                check_type(argname="argument sequence_number", value=sequence_number, expected_type=type_hints["sequence_number"])
                check_type(argname="argument service_name", value=service_name, expected_type=type_hints["service_name"])
                check_type(argname="argument source_vpc", value=source_vpc, expected_type=type_hints["source_vpc"])
                check_type(argname="argument subnet", value=subnet, expected_type=type_hints["subnet"])
                check_type(argname="argument transit_gateway", value=transit_gateway, expected_type=type_hints["transit_gateway"])
                check_type(argname="argument transit_gateway_route_table_route", value=transit_gateway_route_table_route, expected_type=type_hints["transit_gateway_route_table_route"])
                check_type(argname="argument vpc", value=vpc, expected_type=type_hints["vpc"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if acl_rule is not None:
                self._values["acl_rule"] = acl_rule
            if additional_details is not None:
                self._values["additional_details"] = additional_details
            if component is not None:
                self._values["component"] = component
            if destination_vpc is not None:
                self._values["destination_vpc"] = destination_vpc
            if elastic_load_balancer_listener is not None:
                self._values["elastic_load_balancer_listener"] = elastic_load_balancer_listener
            if explanations is not None:
                self._values["explanations"] = explanations
            if inbound_header is not None:
                self._values["inbound_header"] = inbound_header
            if outbound_header is not None:
                self._values["outbound_header"] = outbound_header
            if route_table_route is not None:
                self._values["route_table_route"] = route_table_route
            if security_group_rule is not None:
                self._values["security_group_rule"] = security_group_rule
            if sequence_number is not None:
                self._values["sequence_number"] = sequence_number
            if service_name is not None:
                self._values["service_name"] = service_name
            if source_vpc is not None:
                self._values["source_vpc"] = source_vpc
            if subnet is not None:
                self._values["subnet"] = subnet
            if transit_gateway is not None:
                self._values["transit_gateway"] = transit_gateway
            if transit_gateway_route_table_route is not None:
                self._values["transit_gateway_route_table_route"] = transit_gateway_route_table_route
            if vpc is not None:
                self._values["vpc"] = vpc

        @builtins.property
        def acl_rule(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisAclRuleProperty"]]:
            '''The network ACL rule.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-aclrule
            '''
            result = self._values.get("acl_rule")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisAclRuleProperty"]], result)

        @builtins.property
        def additional_details(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AdditionalDetailProperty"]]]]:
            '''The additional details.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-additionaldetails
            '''
            result = self._values.get("additional_details")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AdditionalDetailProperty"]]]], result)

        @builtins.property
        def component(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]]:
            '''The component.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-component
            '''
            result = self._values.get("component")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]], result)

        @builtins.property
        def destination_vpc(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]]:
            '''The destination VPC.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-destinationvpc
            '''
            result = self._values.get("destination_vpc")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]], result)

        @builtins.property
        def elastic_load_balancer_listener(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]]:
            '''The load balancer listener.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-elasticloadbalancerlistener
            '''
            result = self._values.get("elastic_load_balancer_listener")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]], result)

        @builtins.property
        def explanations(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.ExplanationProperty"]]]]:
            '''The explanation codes.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-explanations
            '''
            result = self._values.get("explanations")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.ExplanationProperty"]]]], result)

        @builtins.property
        def inbound_header(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisPacketHeaderProperty"]]:
            '''The inbound header.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-inboundheader
            '''
            result = self._values.get("inbound_header")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisPacketHeaderProperty"]], result)

        @builtins.property
        def outbound_header(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisPacketHeaderProperty"]]:
            '''The outbound header.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-outboundheader
            '''
            result = self._values.get("outbound_header")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisPacketHeaderProperty"]], result)

        @builtins.property
        def route_table_route(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisRouteTableRouteProperty"]]:
            '''The route table route.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-routetableroute
            '''
            result = self._values.get("route_table_route")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisRouteTableRouteProperty"]], result)

        @builtins.property
        def security_group_rule(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisSecurityGroupRuleProperty"]]:
            '''The security group rule.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-securitygrouprule
            '''
            result = self._values.get("security_group_rule")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisSecurityGroupRuleProperty"]], result)

        @builtins.property
        def sequence_number(self) -> typing.Optional[jsii.Number]:
            '''The sequence number.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-sequencenumber
            '''
            result = self._values.get("sequence_number")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def service_name(self) -> typing.Optional[builtins.str]:
            '''The name of the VPC endpoint service.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-servicename
            '''
            result = self._values.get("service_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def source_vpc(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]]:
            '''The source VPC.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-sourcevpc
            '''
            result = self._values.get("source_vpc")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]], result)

        @builtins.property
        def subnet(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]]:
            '''The subnet.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-subnet
            '''
            result = self._values.get("subnet")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]], result)

        @builtins.property
        def transit_gateway(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]]:
            '''The transit gateway.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-transitgateway
            '''
            result = self._values.get("transit_gateway")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]], result)

        @builtins.property
        def transit_gateway_route_table_route(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.TransitGatewayRouteTableRouteProperty"]]:
            '''The route in a transit gateway route table.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-transitgatewayroutetableroute
            '''
            result = self._values.get("transit_gateway_route_table_route")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.TransitGatewayRouteTableRouteProperty"]], result)

        @builtins.property
        def vpc(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]]:
            '''The component VPC.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-vpc
            '''
            result = self._values.get("vpc")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PathComponentProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkInsightsAnalysisPropsMixin.PortRangeProperty",
        jsii_struct_bases=[],
        name_mapping={"from_": "from", "to": "to"},
    )
    class PortRangeProperty:
        def __init__(
            self,
            *,
            from_: typing.Optional[jsii.Number] = None,
            to: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Describes a range of ports.

            :param from_: The first port in the range.
            :param to: The last port in the range.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-portrange.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                port_range_property = ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.PortRangeProperty(
                    from=123,
                    to=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__7b1c5bae9bb53ef42b0bc7349975d9f67868b9631191efb4f7be3048a5a5063e)
                check_type(argname="argument from_", value=from_, expected_type=type_hints["from_"])
                check_type(argname="argument to", value=to, expected_type=type_hints["to"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if from_ is not None:
                self._values["from_"] = from_
            if to is not None:
                self._values["to"] = to

        @builtins.property
        def from_(self) -> typing.Optional[jsii.Number]:
            '''The first port in the range.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-portrange.html#cfn-ec2-networkinsightsanalysis-portrange-from
            '''
            result = self._values.get("from_")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def to(self) -> typing.Optional[jsii.Number]:
            '''The last port in the range.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-portrange.html#cfn-ec2-networkinsightsanalysis-portrange-to
            '''
            result = self._values.get("to")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PortRangeProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkInsightsAnalysisPropsMixin.TransitGatewayRouteTableRouteProperty",
        jsii_struct_bases=[],
        name_mapping={
            "attachment_id": "attachmentId",
            "destination_cidr": "destinationCidr",
            "prefix_list_id": "prefixListId",
            "resource_id": "resourceId",
            "resource_type": "resourceType",
            "route_origin": "routeOrigin",
            "state": "state",
        },
    )
    class TransitGatewayRouteTableRouteProperty:
        def __init__(
            self,
            *,
            attachment_id: typing.Optional[builtins.str] = None,
            destination_cidr: typing.Optional[builtins.str] = None,
            prefix_list_id: typing.Optional[builtins.str] = None,
            resource_id: typing.Optional[builtins.str] = None,
            resource_type: typing.Optional[builtins.str] = None,
            route_origin: typing.Optional[builtins.str] = None,
            state: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes a route in a transit gateway route table.

            :param attachment_id: The ID of the route attachment.
            :param destination_cidr: The CIDR block used for destination matches.
            :param prefix_list_id: The ID of the prefix list.
            :param resource_id: The ID of the resource for the route attachment.
            :param resource_type: The resource type for the route attachment.
            :param route_origin: The route origin. The following are the possible values:. - static - propagated
            :param state: The state of the route.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-transitgatewayroutetableroute.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                transit_gateway_route_table_route_property = ec2_mixins.CfnNetworkInsightsAnalysisPropsMixin.TransitGatewayRouteTableRouteProperty(
                    attachment_id="attachmentId",
                    destination_cidr="destinationCidr",
                    prefix_list_id="prefixListId",
                    resource_id="resourceId",
                    resource_type="resourceType",
                    route_origin="routeOrigin",
                    state="state"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__c0901058b815a896a9bc0cb903e99c970ddfff7f606bb311cf5cde3cd1ae96de)
                check_type(argname="argument attachment_id", value=attachment_id, expected_type=type_hints["attachment_id"])
                check_type(argname="argument destination_cidr", value=destination_cidr, expected_type=type_hints["destination_cidr"])
                check_type(argname="argument prefix_list_id", value=prefix_list_id, expected_type=type_hints["prefix_list_id"])
                check_type(argname="argument resource_id", value=resource_id, expected_type=type_hints["resource_id"])
                check_type(argname="argument resource_type", value=resource_type, expected_type=type_hints["resource_type"])
                check_type(argname="argument route_origin", value=route_origin, expected_type=type_hints["route_origin"])
                check_type(argname="argument state", value=state, expected_type=type_hints["state"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if attachment_id is not None:
                self._values["attachment_id"] = attachment_id
            if destination_cidr is not None:
                self._values["destination_cidr"] = destination_cidr
            if prefix_list_id is not None:
                self._values["prefix_list_id"] = prefix_list_id
            if resource_id is not None:
                self._values["resource_id"] = resource_id
            if resource_type is not None:
                self._values["resource_type"] = resource_type
            if route_origin is not None:
                self._values["route_origin"] = route_origin
            if state is not None:
                self._values["state"] = state

        @builtins.property
        def attachment_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the route attachment.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-transitgatewayroutetableroute.html#cfn-ec2-networkinsightsanalysis-transitgatewayroutetableroute-attachmentid
            '''
            result = self._values.get("attachment_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def destination_cidr(self) -> typing.Optional[builtins.str]:
            '''The CIDR block used for destination matches.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-transitgatewayroutetableroute.html#cfn-ec2-networkinsightsanalysis-transitgatewayroutetableroute-destinationcidr
            '''
            result = self._values.get("destination_cidr")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def prefix_list_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the prefix list.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-transitgatewayroutetableroute.html#cfn-ec2-networkinsightsanalysis-transitgatewayroutetableroute-prefixlistid
            '''
            result = self._values.get("prefix_list_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def resource_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the resource for the route attachment.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-transitgatewayroutetableroute.html#cfn-ec2-networkinsightsanalysis-transitgatewayroutetableroute-resourceid
            '''
            result = self._values.get("resource_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def resource_type(self) -> typing.Optional[builtins.str]:
            '''The resource type for the route attachment.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-transitgatewayroutetableroute.html#cfn-ec2-networkinsightsanalysis-transitgatewayroutetableroute-resourcetype
            '''
            result = self._values.get("resource_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def route_origin(self) -> typing.Optional[builtins.str]:
            '''The route origin. The following are the possible values:.

            - static
            - propagated

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-transitgatewayroutetableroute.html#cfn-ec2-networkinsightsanalysis-transitgatewayroutetableroute-routeorigin
            '''
            result = self._values.get("route_origin")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def state(self) -> typing.Optional[builtins.str]:
            '''The state of the route.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-transitgatewayroutetableroute.html#cfn-ec2-networkinsightsanalysis-transitgatewayroutetableroute-state
            '''
            result = self._values.get("state")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TransitGatewayRouteTableRouteProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkInsightsPathMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "destination": "destination",
        "destination_ip": "destinationIp",
        "destination_port": "destinationPort",
        "filter_at_destination": "filterAtDestination",
        "filter_at_source": "filterAtSource",
        "protocol": "protocol",
        "source": "source",
        "source_ip": "sourceIp",
        "tags": "tags",
    },
)
class CfnNetworkInsightsPathMixinProps:
    def __init__(
        self,
        *,
        destination: typing.Optional[builtins.str] = None,
        destination_ip: typing.Optional[builtins.str] = None,
        destination_port: typing.Optional[jsii.Number] = None,
        filter_at_destination: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsPathPropsMixin.PathFilterProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        filter_at_source: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsPathPropsMixin.PathFilterProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        protocol: typing.Optional[builtins.str] = None,
        source: typing.Optional[builtins.str] = None,
        source_ip: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnNetworkInsightsPathPropsMixin.

        :param destination: The ID or ARN of the destination. If the resource is in another account, you must specify an ARN.
        :param destination_ip: The IP address of the destination.
        :param destination_port: The destination port.
        :param filter_at_destination: Scopes the analysis to network paths that match specific filters at the destination. If you specify this parameter, you can't specify the parameter for the destination IP address.
        :param filter_at_source: Scopes the analysis to network paths that match specific filters at the source. If you specify this parameter, you can't specify the parameters for the source IP address or the destination port.
        :param protocol: The protocol.
        :param source: The ID or ARN of the source. If the resource is in another account, you must specify an ARN.
        :param source_ip: The IP address of the source.
        :param tags: The tags to add to the path.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_network_insights_path_mixin_props = ec2_mixins.CfnNetworkInsightsPathMixinProps(
                destination="destination",
                destination_ip="destinationIp",
                destination_port=123,
                filter_at_destination=ec2_mixins.CfnNetworkInsightsPathPropsMixin.PathFilterProperty(
                    destination_address="destinationAddress",
                    destination_port_range=ec2_mixins.CfnNetworkInsightsPathPropsMixin.FilterPortRangeProperty(
                        from_port=123,
                        to_port=123
                    ),
                    source_address="sourceAddress",
                    source_port_range=ec2_mixins.CfnNetworkInsightsPathPropsMixin.FilterPortRangeProperty(
                        from_port=123,
                        to_port=123
                    )
                ),
                filter_at_source=ec2_mixins.CfnNetworkInsightsPathPropsMixin.PathFilterProperty(
                    destination_address="destinationAddress",
                    destination_port_range=ec2_mixins.CfnNetworkInsightsPathPropsMixin.FilterPortRangeProperty(
                        from_port=123,
                        to_port=123
                    ),
                    source_address="sourceAddress",
                    source_port_range=ec2_mixins.CfnNetworkInsightsPathPropsMixin.FilterPortRangeProperty(
                        from_port=123,
                        to_port=123
                    )
                ),
                protocol="protocol",
                source="source",
                source_ip="sourceIp",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6aa749e33f80367942994e7bfe06e8d409f0504fc16a8b266c1ff013218052da)
            check_type(argname="argument destination", value=destination, expected_type=type_hints["destination"])
            check_type(argname="argument destination_ip", value=destination_ip, expected_type=type_hints["destination_ip"])
            check_type(argname="argument destination_port", value=destination_port, expected_type=type_hints["destination_port"])
            check_type(argname="argument filter_at_destination", value=filter_at_destination, expected_type=type_hints["filter_at_destination"])
            check_type(argname="argument filter_at_source", value=filter_at_source, expected_type=type_hints["filter_at_source"])
            check_type(argname="argument protocol", value=protocol, expected_type=type_hints["protocol"])
            check_type(argname="argument source", value=source, expected_type=type_hints["source"])
            check_type(argname="argument source_ip", value=source_ip, expected_type=type_hints["source_ip"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if destination is not None:
            self._values["destination"] = destination
        if destination_ip is not None:
            self._values["destination_ip"] = destination_ip
        if destination_port is not None:
            self._values["destination_port"] = destination_port
        if filter_at_destination is not None:
            self._values["filter_at_destination"] = filter_at_destination
        if filter_at_source is not None:
            self._values["filter_at_source"] = filter_at_source
        if protocol is not None:
            self._values["protocol"] = protocol
        if source is not None:
            self._values["source"] = source
        if source_ip is not None:
            self._values["source_ip"] = source_ip
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def destination(self) -> typing.Optional[builtins.str]:
        '''The ID or ARN of the destination.

        If the resource is in another account, you must specify an ARN.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-destination
        '''
        result = self._values.get("destination")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def destination_ip(self) -> typing.Optional[builtins.str]:
        '''The IP address of the destination.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-destinationip
        '''
        result = self._values.get("destination_ip")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def destination_port(self) -> typing.Optional[jsii.Number]:
        '''The destination port.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-destinationport
        '''
        result = self._values.get("destination_port")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def filter_at_destination(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsPathPropsMixin.PathFilterProperty"]]:
        '''Scopes the analysis to network paths that match specific filters at the destination.

        If you specify this parameter, you can't specify the parameter for the destination IP address.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-filteratdestination
        '''
        result = self._values.get("filter_at_destination")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsPathPropsMixin.PathFilterProperty"]], result)

    @builtins.property
    def filter_at_source(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsPathPropsMixin.PathFilterProperty"]]:
        '''Scopes the analysis to network paths that match specific filters at the source.

        If you specify this parameter, you can't specify the parameters for the source IP address or the destination port.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-filteratsource
        '''
        result = self._values.get("filter_at_source")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsPathPropsMixin.PathFilterProperty"]], result)

    @builtins.property
    def protocol(self) -> typing.Optional[builtins.str]:
        '''The protocol.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-protocol
        '''
        result = self._values.get("protocol")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def source(self) -> typing.Optional[builtins.str]:
        '''The ID or ARN of the source.

        If the resource is in another account, you must specify an ARN.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-source
        '''
        result = self._values.get("source")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def source_ip(self) -> typing.Optional[builtins.str]:
        '''The IP address of the source.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-sourceip
        '''
        result = self._values.get("source_ip")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags to add to the path.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnNetworkInsightsPathMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnNetworkInsightsPathPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkInsightsPathPropsMixin",
):
    '''Specifies a path to analyze for reachability.

    VPC Reachability Analyzer enables you to analyze and debug network reachability between two resources in your virtual private cloud (VPC). For more information, see the `Reachability Analyzer User Guide <https://docs.aws.amazon.com/vpc/latest/reachability/what-is-reachability-analyzer.html>`_ .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html
    :cloudformationResource: AWS::EC2::NetworkInsightsPath
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_network_insights_path_props_mixin = ec2_mixins.CfnNetworkInsightsPathPropsMixin(ec2_mixins.CfnNetworkInsightsPathMixinProps(
            destination="destination",
            destination_ip="destinationIp",
            destination_port=123,
            filter_at_destination=ec2_mixins.CfnNetworkInsightsPathPropsMixin.PathFilterProperty(
                destination_address="destinationAddress",
                destination_port_range=ec2_mixins.CfnNetworkInsightsPathPropsMixin.FilterPortRangeProperty(
                    from_port=123,
                    to_port=123
                ),
                source_address="sourceAddress",
                source_port_range=ec2_mixins.CfnNetworkInsightsPathPropsMixin.FilterPortRangeProperty(
                    from_port=123,
                    to_port=123
                )
            ),
            filter_at_source=ec2_mixins.CfnNetworkInsightsPathPropsMixin.PathFilterProperty(
                destination_address="destinationAddress",
                destination_port_range=ec2_mixins.CfnNetworkInsightsPathPropsMixin.FilterPortRangeProperty(
                    from_port=123,
                    to_port=123
                ),
                source_address="sourceAddress",
                source_port_range=ec2_mixins.CfnNetworkInsightsPathPropsMixin.FilterPortRangeProperty(
                    from_port=123,
                    to_port=123
                )
            ),
            protocol="protocol",
            source="source",
            source_ip="sourceIp",
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnNetworkInsightsPathMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::NetworkInsightsPath``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3e5e83658d7a85ba99e4e360403b5009923a4ac1ac9a31453d7509db6c003540)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e16935d940c40abece8320fd10a47ddd000741bac114464b62a97190dfd1a23c)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__72258fbc73943ea7e34b62a0ae8314ba34155d6f9bb8686408d6ebbb2478ba74)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnNetworkInsightsPathMixinProps":
        return typing.cast("CfnNetworkInsightsPathMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkInsightsPathPropsMixin.FilterPortRangeProperty",
        jsii_struct_bases=[],
        name_mapping={"from_port": "fromPort", "to_port": "toPort"},
    )
    class FilterPortRangeProperty:
        def __init__(
            self,
            *,
            from_port: typing.Optional[jsii.Number] = None,
            to_port: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Describes a port range.

            :param from_port: The first port in the range.
            :param to_port: The last port in the range.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-filterportrange.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                filter_port_range_property = ec2_mixins.CfnNetworkInsightsPathPropsMixin.FilterPortRangeProperty(
                    from_port=123,
                    to_port=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__70362d998e73c43f0bcbbc776ce1a9e6f95a1c7c7ec293a5f556177949f569c2)
                check_type(argname="argument from_port", value=from_port, expected_type=type_hints["from_port"])
                check_type(argname="argument to_port", value=to_port, expected_type=type_hints["to_port"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if from_port is not None:
                self._values["from_port"] = from_port
            if to_port is not None:
                self._values["to_port"] = to_port

        @builtins.property
        def from_port(self) -> typing.Optional[jsii.Number]:
            '''The first port in the range.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-filterportrange.html#cfn-ec2-networkinsightspath-filterportrange-fromport
            '''
            result = self._values.get("from_port")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def to_port(self) -> typing.Optional[jsii.Number]:
            '''The last port in the range.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-filterportrange.html#cfn-ec2-networkinsightspath-filterportrange-toport
            '''
            result = self._values.get("to_port")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "FilterPortRangeProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkInsightsPathPropsMixin.PathFilterProperty",
        jsii_struct_bases=[],
        name_mapping={
            "destination_address": "destinationAddress",
            "destination_port_range": "destinationPortRange",
            "source_address": "sourceAddress",
            "source_port_range": "sourcePortRange",
        },
    )
    class PathFilterProperty:
        def __init__(
            self,
            *,
            destination_address: typing.Optional[builtins.str] = None,
            destination_port_range: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsPathPropsMixin.FilterPortRangeProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            source_address: typing.Optional[builtins.str] = None,
            source_port_range: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInsightsPathPropsMixin.FilterPortRangeProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Describes a set of filters for a path analysis.

            Use path filters to scope the analysis when there can be multiple resulting paths.

            :param destination_address: The destination IPv4 address.
            :param destination_port_range: The destination port range.
            :param source_address: The source IPv4 address.
            :param source_port_range: The source port range.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-pathfilter.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                path_filter_property = ec2_mixins.CfnNetworkInsightsPathPropsMixin.PathFilterProperty(
                    destination_address="destinationAddress",
                    destination_port_range=ec2_mixins.CfnNetworkInsightsPathPropsMixin.FilterPortRangeProperty(
                        from_port=123,
                        to_port=123
                    ),
                    source_address="sourceAddress",
                    source_port_range=ec2_mixins.CfnNetworkInsightsPathPropsMixin.FilterPortRangeProperty(
                        from_port=123,
                        to_port=123
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__e8e811c26844ac8fc86580826953bfd4b9da82f4526a1b341ebc9ab627192b08)
                check_type(argname="argument destination_address", value=destination_address, expected_type=type_hints["destination_address"])
                check_type(argname="argument destination_port_range", value=destination_port_range, expected_type=type_hints["destination_port_range"])
                check_type(argname="argument source_address", value=source_address, expected_type=type_hints["source_address"])
                check_type(argname="argument source_port_range", value=source_port_range, expected_type=type_hints["source_port_range"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if destination_address is not None:
                self._values["destination_address"] = destination_address
            if destination_port_range is not None:
                self._values["destination_port_range"] = destination_port_range
            if source_address is not None:
                self._values["source_address"] = source_address
            if source_port_range is not None:
                self._values["source_port_range"] = source_port_range

        @builtins.property
        def destination_address(self) -> typing.Optional[builtins.str]:
            '''The destination IPv4 address.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-pathfilter.html#cfn-ec2-networkinsightspath-pathfilter-destinationaddress
            '''
            result = self._values.get("destination_address")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def destination_port_range(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsPathPropsMixin.FilterPortRangeProperty"]]:
            '''The destination port range.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-pathfilter.html#cfn-ec2-networkinsightspath-pathfilter-destinationportrange
            '''
            result = self._values.get("destination_port_range")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsPathPropsMixin.FilterPortRangeProperty"]], result)

        @builtins.property
        def source_address(self) -> typing.Optional[builtins.str]:
            '''The source IPv4 address.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-pathfilter.html#cfn-ec2-networkinsightspath-pathfilter-sourceaddress
            '''
            result = self._values.get("source_address")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def source_port_range(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsPathPropsMixin.FilterPortRangeProperty"]]:
            '''The source port range.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-pathfilter.html#cfn-ec2-networkinsightspath-pathfilter-sourceportrange
            '''
            result = self._values.get("source_port_range")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInsightsPathPropsMixin.FilterPortRangeProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PathFilterProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkInterfaceAttachmentMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "delete_on_termination": "deleteOnTermination",
        "device_index": "deviceIndex",
        "ena_queue_count": "enaQueueCount",
        "ena_srd_specification": "enaSrdSpecification",
        "instance_id": "instanceId",
        "network_interface_id": "networkInterfaceId",
    },
)
class CfnNetworkInterfaceAttachmentMixinProps:
    def __init__(
        self,
        *,
        delete_on_termination: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        device_index: typing.Optional[builtins.str] = None,
        ena_queue_count: typing.Optional[jsii.Number] = None,
        ena_srd_specification: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInterfaceAttachmentPropsMixin.EnaSrdSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        instance_id: typing.Optional[builtins.str] = None,
        network_interface_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnNetworkInterfaceAttachmentPropsMixin.

        :param delete_on_termination: Whether to delete the network interface when the instance terminates. By default, this value is set to ``true`` . Default: - true
        :param device_index: The network interface's position in the attachment order. For example, the first attached network interface has a ``DeviceIndex`` of 0.
        :param ena_queue_count: The number of ENA queues created with the instance.
        :param ena_srd_specification: Configures ENA Express for the network interface that this action attaches to the instance.
        :param instance_id: The ID of the instance to which you will attach the ENI.
        :param network_interface_id: The ID of the ENI that you want to attach.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfaceattachment.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_network_interface_attachment_mixin_props = ec2_mixins.CfnNetworkInterfaceAttachmentMixinProps(
                delete_on_termination=False,
                device_index="deviceIndex",
                ena_queue_count=123,
                ena_srd_specification=ec2_mixins.CfnNetworkInterfaceAttachmentPropsMixin.EnaSrdSpecificationProperty(
                    ena_srd_enabled=False,
                    ena_srd_udp_specification=ec2_mixins.CfnNetworkInterfaceAttachmentPropsMixin.EnaSrdUdpSpecificationProperty(
                        ena_srd_udp_enabled=False
                    )
                ),
                instance_id="instanceId",
                network_interface_id="networkInterfaceId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b1f4eb45034f4f5b319608034b11da2e7126d52d5555e6fa55bb1ddea65649a4)
            check_type(argname="argument delete_on_termination", value=delete_on_termination, expected_type=type_hints["delete_on_termination"])
            check_type(argname="argument device_index", value=device_index, expected_type=type_hints["device_index"])
            check_type(argname="argument ena_queue_count", value=ena_queue_count, expected_type=type_hints["ena_queue_count"])
            check_type(argname="argument ena_srd_specification", value=ena_srd_specification, expected_type=type_hints["ena_srd_specification"])
            check_type(argname="argument instance_id", value=instance_id, expected_type=type_hints["instance_id"])
            check_type(argname="argument network_interface_id", value=network_interface_id, expected_type=type_hints["network_interface_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if delete_on_termination is not None:
            self._values["delete_on_termination"] = delete_on_termination
        if device_index is not None:
            self._values["device_index"] = device_index
        if ena_queue_count is not None:
            self._values["ena_queue_count"] = ena_queue_count
        if ena_srd_specification is not None:
            self._values["ena_srd_specification"] = ena_srd_specification
        if instance_id is not None:
            self._values["instance_id"] = instance_id
        if network_interface_id is not None:
            self._values["network_interface_id"] = network_interface_id

    @builtins.property
    def delete_on_termination(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Whether to delete the network interface when the instance terminates.

        By default, this value is set to ``true`` .

        :default: - true

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfaceattachment.html#cfn-ec2-networkinterfaceattachment-deleteontermination
        '''
        result = self._values.get("delete_on_termination")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def device_index(self) -> typing.Optional[builtins.str]:
        '''The network interface's position in the attachment order.

        For example, the first attached network interface has a ``DeviceIndex`` of 0.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfaceattachment.html#cfn-ec2-networkinterfaceattachment-deviceindex
        '''
        result = self._values.get("device_index")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ena_queue_count(self) -> typing.Optional[jsii.Number]:
        '''The number of ENA queues created with the instance.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfaceattachment.html#cfn-ec2-networkinterfaceattachment-enaqueuecount
        '''
        result = self._values.get("ena_queue_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def ena_srd_specification(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInterfaceAttachmentPropsMixin.EnaSrdSpecificationProperty"]]:
        '''Configures ENA Express for the network interface that this action attaches to the instance.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfaceattachment.html#cfn-ec2-networkinterfaceattachment-enasrdspecification
        '''
        result = self._values.get("ena_srd_specification")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInterfaceAttachmentPropsMixin.EnaSrdSpecificationProperty"]], result)

    @builtins.property
    def instance_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the instance to which you will attach the ENI.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfaceattachment.html#cfn-ec2-networkinterfaceattachment-instanceid
        '''
        result = self._values.get("instance_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def network_interface_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the ENI that you want to attach.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfaceattachment.html#cfn-ec2-networkinterfaceattachment-networkinterfaceid
        '''
        result = self._values.get("network_interface_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnNetworkInterfaceAttachmentMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnNetworkInterfaceAttachmentPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkInterfaceAttachmentPropsMixin",
):
    '''Attaches an elastic network interface (ENI) to an Amazon EC2 instance.

    You can use this resource type to attach additional network interfaces to an instance without interruption.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfaceattachment.html
    :cloudformationResource: AWS::EC2::NetworkInterfaceAttachment
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_network_interface_attachment_props_mixin = ec2_mixins.CfnNetworkInterfaceAttachmentPropsMixin(ec2_mixins.CfnNetworkInterfaceAttachmentMixinProps(
            delete_on_termination=False,
            device_index="deviceIndex",
            ena_queue_count=123,
            ena_srd_specification=ec2_mixins.CfnNetworkInterfaceAttachmentPropsMixin.EnaSrdSpecificationProperty(
                ena_srd_enabled=False,
                ena_srd_udp_specification=ec2_mixins.CfnNetworkInterfaceAttachmentPropsMixin.EnaSrdUdpSpecificationProperty(
                    ena_srd_udp_enabled=False
                )
            ),
            instance_id="instanceId",
            network_interface_id="networkInterfaceId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnNetworkInterfaceAttachmentMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::NetworkInterfaceAttachment``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d2e921f512f81d273ddbbc5c5689880b49290e2469a3afafbe12f34a9cc8f8db)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e3135fd80817efe2b124a0b7c0300ace8e105e4febb495cb3218b76e1fe38ff5)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c748786a87b501dd3026e817b8024e1ef7f17c3e451f0c5fbe15991f27f59bb9)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnNetworkInterfaceAttachmentMixinProps":
        return typing.cast("CfnNetworkInterfaceAttachmentMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkInterfaceAttachmentPropsMixin.EnaSrdSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "ena_srd_enabled": "enaSrdEnabled",
            "ena_srd_udp_specification": "enaSrdUdpSpecification",
        },
    )
    class EnaSrdSpecificationProperty:
        def __init__(
            self,
            *,
            ena_srd_enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            ena_srd_udp_specification: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInterfaceAttachmentPropsMixin.EnaSrdUdpSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''ENA Express uses AWS Scalable Reliable Datagram (SRD) technology to increase the maximum bandwidth used per stream and minimize tail latency of network traffic between EC2 instances.

            With ENA Express, you can communicate between two EC2 instances in the same subnet within the same account, or in different accounts. Both sending and receiving instances must have ENA Express enabled.

            To improve the reliability of network packet delivery, ENA Express reorders network packets on the receiving end by default. However, some UDP-based applications are designed to handle network packets that are out of order to reduce the overhead for packet delivery at the network layer. When ENA Express is enabled, you can specify whether UDP network traffic uses it.

            :param ena_srd_enabled: Indicates whether ENA Express is enabled for the network interface.
            :param ena_srd_udp_specification: Configures ENA Express for UDP network traffic.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterfaceattachment-enasrdspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                ena_srd_specification_property = ec2_mixins.CfnNetworkInterfaceAttachmentPropsMixin.EnaSrdSpecificationProperty(
                    ena_srd_enabled=False,
                    ena_srd_udp_specification=ec2_mixins.CfnNetworkInterfaceAttachmentPropsMixin.EnaSrdUdpSpecificationProperty(
                        ena_srd_udp_enabled=False
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__4f1e092756b6dfdd82c9b8bf400ae792b41654ef51495207c7ad43b94970a75a)
                check_type(argname="argument ena_srd_enabled", value=ena_srd_enabled, expected_type=type_hints["ena_srd_enabled"])
                check_type(argname="argument ena_srd_udp_specification", value=ena_srd_udp_specification, expected_type=type_hints["ena_srd_udp_specification"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if ena_srd_enabled is not None:
                self._values["ena_srd_enabled"] = ena_srd_enabled
            if ena_srd_udp_specification is not None:
                self._values["ena_srd_udp_specification"] = ena_srd_udp_specification

        @builtins.property
        def ena_srd_enabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether ENA Express is enabled for the network interface.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterfaceattachment-enasrdspecification.html#cfn-ec2-networkinterfaceattachment-enasrdspecification-enasrdenabled
            '''
            result = self._values.get("ena_srd_enabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def ena_srd_udp_specification(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInterfaceAttachmentPropsMixin.EnaSrdUdpSpecificationProperty"]]:
            '''Configures ENA Express for UDP network traffic.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterfaceattachment-enasrdspecification.html#cfn-ec2-networkinterfaceattachment-enasrdspecification-enasrdudpspecification
            '''
            result = self._values.get("ena_srd_udp_specification")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInterfaceAttachmentPropsMixin.EnaSrdUdpSpecificationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "EnaSrdSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkInterfaceAttachmentPropsMixin.EnaSrdUdpSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={"ena_srd_udp_enabled": "enaSrdUdpEnabled"},
    )
    class EnaSrdUdpSpecificationProperty:
        def __init__(
            self,
            *,
            ena_srd_udp_enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        ) -> None:
            '''ENA Express is compatible with both TCP and UDP transport protocols.

            When it's enabled, TCP traffic automatically uses it. However, some UDP-based applications are designed to handle network packets that are out of order, without a need for retransmission, such as live video broadcasting or other near-real-time applications. For UDP traffic, you can specify whether to use ENA Express, based on your application environment needs.

            :param ena_srd_udp_enabled: Indicates whether UDP traffic to and from the instance uses ENA Express. To specify this setting, you must first enable ENA Express.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterfaceattachment-enasrdudpspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                ena_srd_udp_specification_property = ec2_mixins.CfnNetworkInterfaceAttachmentPropsMixin.EnaSrdUdpSpecificationProperty(
                    ena_srd_udp_enabled=False
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__9200910cdaf785d98b05d7091064df5392918720835e2721b92fc62078f0555c)
                check_type(argname="argument ena_srd_udp_enabled", value=ena_srd_udp_enabled, expected_type=type_hints["ena_srd_udp_enabled"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if ena_srd_udp_enabled is not None:
                self._values["ena_srd_udp_enabled"] = ena_srd_udp_enabled

        @builtins.property
        def ena_srd_udp_enabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether UDP traffic to and from the instance uses ENA Express.

            To specify this setting, you must first enable ENA Express.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterfaceattachment-enasrdudpspecification.html#cfn-ec2-networkinterfaceattachment-enasrdudpspecification-enasrdudpenabled
            '''
            result = self._values.get("ena_srd_udp_enabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "EnaSrdUdpSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkInterfaceMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "connection_tracking_specification": "connectionTrackingSpecification",
        "description": "description",
        "enable_primary_ipv6": "enablePrimaryIpv6",
        "group_set": "groupSet",
        "interface_type": "interfaceType",
        "ipv4_prefix_count": "ipv4PrefixCount",
        "ipv4_prefixes": "ipv4Prefixes",
        "ipv6_address_count": "ipv6AddressCount",
        "ipv6_addresses": "ipv6Addresses",
        "ipv6_prefix_count": "ipv6PrefixCount",
        "ipv6_prefixes": "ipv6Prefixes",
        "private_ip_address": "privateIpAddress",
        "private_ip_addresses": "privateIpAddresses",
        "public_ip_dns_hostname_type_specification": "publicIpDnsHostnameTypeSpecification",
        "secondary_private_ip_address_count": "secondaryPrivateIpAddressCount",
        "source_dest_check": "sourceDestCheck",
        "subnet_id": "subnetId",
        "tags": "tags",
    },
)
class CfnNetworkInterfaceMixinProps:
    def __init__(
        self,
        *,
        connection_tracking_specification: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInterfacePropsMixin.ConnectionTrackingSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        description: typing.Optional[builtins.str] = None,
        enable_primary_ipv6: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        group_set: typing.Optional[typing.Sequence[builtins.str]] = None,
        interface_type: typing.Optional[builtins.str] = None,
        ipv4_prefix_count: typing.Optional[jsii.Number] = None,
        ipv4_prefixes: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInterfacePropsMixin.Ipv4PrefixSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ipv6_address_count: typing.Optional[jsii.Number] = None,
        ipv6_addresses: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInterfacePropsMixin.InstanceIpv6AddressProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ipv6_prefix_count: typing.Optional[jsii.Number] = None,
        ipv6_prefixes: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInterfacePropsMixin.Ipv6PrefixSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        private_ip_address: typing.Optional[builtins.str] = None,
        private_ip_addresses: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnNetworkInterfacePropsMixin.PrivateIpAddressSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        public_ip_dns_hostname_type_specification: typing.Optional[builtins.str] = None,
        secondary_private_ip_address_count: typing.Optional[jsii.Number] = None,
        source_dest_check: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        subnet_id: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnNetworkInterfacePropsMixin.

        :param connection_tracking_specification: A connection tracking specification for the network interface.
        :param description: A description for the network interface.
        :param enable_primary_ipv6: If youre modifying a network interface in a dual-stack or IPv6-only subnet, you have the option to assign a primary IPv6 IP address. A primary IPv6 address is an IPv6 GUA address associated with an ENI that you have enabled to use a primary IPv6 address. Use this option if the instance that this ENI will be attached to relies on its IPv6 address not changing. AWS will automatically assign an IPv6 address associated with the ENI attached to your instance to be the primary IPv6 address. Once you enable an IPv6 GUA address to be a primary IPv6, you cannot disable it. When you enable an IPv6 GUA address to be a primary IPv6, the first IPv6 GUA will be made the primary IPv6 address until the instance is terminated or the network interface is detached. If you have multiple IPv6 addresses associated with an ENI attached to your instance and you enable a primary IPv6 address, the first IPv6 GUA address associated with the ENI becomes the primary IPv6 address.
        :param group_set: The IDs of the security groups associated with this network interface.
        :param interface_type: The type of network interface. The default is ``interface`` . The supported values are ``efa`` and ``trunk`` .
        :param ipv4_prefix_count: The number of IPv4 prefixes to be automatically assigned to the network interface. When creating a network interface, you can't specify a count of IPv4 prefixes if you've specified one of the following: specific IPv4 prefixes, specific private IPv4 addresses, or a count of private IPv4 addresses.
        :param ipv4_prefixes: The IPv4 delegated prefixes that are assigned to the network interface. When creating a network interface, you can't specify IPv4 prefixes if you've specified one of the following: a count of IPv4 prefixes, specific private IPv4 addresses, or a count of private IPv4 addresses.
        :param ipv6_address_count: The number of IPv6 addresses to assign to the network interface. Amazon EC2 automatically selects the IPv6 addresses from the subnet range. To specify specific IPv6 addresses, use the ``Ipv6Addresses`` property and don't specify this property. When creating a network interface, you can't specify a count of IPv6 addresses if you've specified one of the following: specific IPv6 addresses, specific IPv6 prefixes, or a count of IPv6 prefixes.
        :param ipv6_addresses: The IPv6 addresses from the IPv6 CIDR block range of your subnet to assign to the network interface. If you're specifying a number of IPv6 addresses, use the ``Ipv6AddressCount`` property and don't specify this property. When creating a network interface, you can't specify IPv6 addresses if you've specified one of the following: a count of IPv6 addresses, specific IPv6 prefixes, or a count of IPv6 prefixes.
        :param ipv6_prefix_count: The number of IPv6 prefixes to be automatically assigned to the network interface. When creating a network interface, you can't specify a count of IPv6 prefixes if you've specified one of the following: specific IPv6 prefixes, specific IPv6 addresses, or a count of IPv6 addresses.
        :param ipv6_prefixes: The IPv6 delegated prefixes that are assigned to the network interface. When creating a network interface, you can't specify IPv6 prefixes if you've specified one of the following: a count of IPv6 prefixes, specific IPv6 addresses, or a count of IPv6 addresses.
        :param private_ip_address: The private IPv4 address to assign to the network interface as the primary private IP address. If you want to specify multiple private IP addresses, use the ``PrivateIpAddresses`` property.
        :param private_ip_addresses: The private IPv4 addresses to assign to the network interface. You can specify a primary private IP address by setting the value of the ``Primary`` property to ``true`` in the ``PrivateIpAddressSpecification`` property. If you want EC2 to automatically assign private IP addresses, use the ``SecondaryPrivateIpAddressCount`` property and do not specify this property. When creating a network interface, you can't specify private IPv4 addresses if you've specified one of the following: a count of private IPv4 addresses, specific IPv4 prefixes, or a count of IPv4 prefixes.
        :param public_ip_dns_hostname_type_specification: Public IP DNS hostname type.
        :param secondary_private_ip_address_count: The number of secondary private IPv4 addresses to assign to a network interface. When you specify a number of secondary IPv4 addresses, Amazon EC2 selects these IP addresses within the subnet's IPv4 CIDR range. You can't specify this option and specify more than one private IP address using ``privateIpAddresses`` . When creating a Network Interface, you can't specify a count of private IPv4 addresses if you've specified one of the following: specific private IPv4 addresses, specific IPv4 prefixes, or a count of IPv4 prefixes.
        :param source_dest_check: Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives. If the value is ``true`` , source/destination checks are enabled; otherwise, they are disabled. The default value is ``true`` . You must disable source/destination checks if the instance runs services such as network address translation, routing, or firewalls.
        :param subnet_id: The ID of the subnet to associate with the network interface.
        :param tags: The tags to apply to the network interface.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_network_interface_mixin_props = ec2_mixins.CfnNetworkInterfaceMixinProps(
                connection_tracking_specification=ec2_mixins.CfnNetworkInterfacePropsMixin.ConnectionTrackingSpecificationProperty(
                    tcp_established_timeout=123,
                    udp_stream_timeout=123,
                    udp_timeout=123
                ),
                description="description",
                enable_primary_ipv6=False,
                group_set=["groupSet"],
                interface_type="interfaceType",
                ipv4_prefix_count=123,
                ipv4_prefixes=[ec2_mixins.CfnNetworkInterfacePropsMixin.Ipv4PrefixSpecificationProperty(
                    ipv4_prefix="ipv4Prefix"
                )],
                ipv6_address_count=123,
                ipv6_addresses=[ec2_mixins.CfnNetworkInterfacePropsMixin.InstanceIpv6AddressProperty(
                    ipv6_address="ipv6Address"
                )],
                ipv6_prefix_count=123,
                ipv6_prefixes=[ec2_mixins.CfnNetworkInterfacePropsMixin.Ipv6PrefixSpecificationProperty(
                    ipv6_prefix="ipv6Prefix"
                )],
                private_ip_address="privateIpAddress",
                private_ip_addresses=[ec2_mixins.CfnNetworkInterfacePropsMixin.PrivateIpAddressSpecificationProperty(
                    primary=False,
                    private_ip_address="privateIpAddress"
                )],
                public_ip_dns_hostname_type_specification="publicIpDnsHostnameTypeSpecification",
                secondary_private_ip_address_count=123,
                source_dest_check=False,
                subnet_id="subnetId",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ba8899d7a1cb6df8789ae4e62b9bb3947e99baa1f6ae5062eaab0929aca85282)
            check_type(argname="argument connection_tracking_specification", value=connection_tracking_specification, expected_type=type_hints["connection_tracking_specification"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument enable_primary_ipv6", value=enable_primary_ipv6, expected_type=type_hints["enable_primary_ipv6"])
            check_type(argname="argument group_set", value=group_set, expected_type=type_hints["group_set"])
            check_type(argname="argument interface_type", value=interface_type, expected_type=type_hints["interface_type"])
            check_type(argname="argument ipv4_prefix_count", value=ipv4_prefix_count, expected_type=type_hints["ipv4_prefix_count"])
            check_type(argname="argument ipv4_prefixes", value=ipv4_prefixes, expected_type=type_hints["ipv4_prefixes"])
            check_type(argname="argument ipv6_address_count", value=ipv6_address_count, expected_type=type_hints["ipv6_address_count"])
            check_type(argname="argument ipv6_addresses", value=ipv6_addresses, expected_type=type_hints["ipv6_addresses"])
            check_type(argname="argument ipv6_prefix_count", value=ipv6_prefix_count, expected_type=type_hints["ipv6_prefix_count"])
            check_type(argname="argument ipv6_prefixes", value=ipv6_prefixes, expected_type=type_hints["ipv6_prefixes"])
            check_type(argname="argument private_ip_address", value=private_ip_address, expected_type=type_hints["private_ip_address"])
            check_type(argname="argument private_ip_addresses", value=private_ip_addresses, expected_type=type_hints["private_ip_addresses"])
            check_type(argname="argument public_ip_dns_hostname_type_specification", value=public_ip_dns_hostname_type_specification, expected_type=type_hints["public_ip_dns_hostname_type_specification"])
            check_type(argname="argument secondary_private_ip_address_count", value=secondary_private_ip_address_count, expected_type=type_hints["secondary_private_ip_address_count"])
            check_type(argname="argument source_dest_check", value=source_dest_check, expected_type=type_hints["source_dest_check"])
            check_type(argname="argument subnet_id", value=subnet_id, expected_type=type_hints["subnet_id"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if connection_tracking_specification is not None:
            self._values["connection_tracking_specification"] = connection_tracking_specification
        if description is not None:
            self._values["description"] = description
        if enable_primary_ipv6 is not None:
            self._values["enable_primary_ipv6"] = enable_primary_ipv6
        if group_set is not None:
            self._values["group_set"] = group_set
        if interface_type is not None:
            self._values["interface_type"] = interface_type
        if ipv4_prefix_count is not None:
            self._values["ipv4_prefix_count"] = ipv4_prefix_count
        if ipv4_prefixes is not None:
            self._values["ipv4_prefixes"] = ipv4_prefixes
        if ipv6_address_count is not None:
            self._values["ipv6_address_count"] = ipv6_address_count
        if ipv6_addresses is not None:
            self._values["ipv6_addresses"] = ipv6_addresses
        if ipv6_prefix_count is not None:
            self._values["ipv6_prefix_count"] = ipv6_prefix_count
        if ipv6_prefixes is not None:
            self._values["ipv6_prefixes"] = ipv6_prefixes
        if private_ip_address is not None:
            self._values["private_ip_address"] = private_ip_address
        if private_ip_addresses is not None:
            self._values["private_ip_addresses"] = private_ip_addresses
        if public_ip_dns_hostname_type_specification is not None:
            self._values["public_ip_dns_hostname_type_specification"] = public_ip_dns_hostname_type_specification
        if secondary_private_ip_address_count is not None:
            self._values["secondary_private_ip_address_count"] = secondary_private_ip_address_count
        if source_dest_check is not None:
            self._values["source_dest_check"] = source_dest_check
        if subnet_id is not None:
            self._values["subnet_id"] = subnet_id
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def connection_tracking_specification(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInterfacePropsMixin.ConnectionTrackingSpecificationProperty"]]:
        '''A connection tracking specification for the network interface.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-connectiontrackingspecification
        '''
        result = self._values.get("connection_tracking_specification")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInterfacePropsMixin.ConnectionTrackingSpecificationProperty"]], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''A description for the network interface.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_primary_ipv6(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''If youre modifying a network interface in a dual-stack or IPv6-only subnet, you have the option to assign a primary IPv6 IP address.

        A primary IPv6 address is an IPv6 GUA address associated with an ENI that you have enabled to use a primary IPv6 address. Use this option if the instance that this ENI will be attached to relies on its IPv6 address not changing. AWS will automatically assign an IPv6 address associated with the ENI attached to your instance to be the primary IPv6 address. Once you enable an IPv6 GUA address to be a primary IPv6, you cannot disable it. When you enable an IPv6 GUA address to be a primary IPv6, the first IPv6 GUA will be made the primary IPv6 address until the instance is terminated or the network interface is detached. If you have multiple IPv6 addresses associated with an ENI attached to your instance and you enable a primary IPv6 address, the first IPv6 GUA address associated with the ENI becomes the primary IPv6 address.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-enableprimaryipv6
        '''
        result = self._values.get("enable_primary_ipv6")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def group_set(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The IDs of the security groups associated with this network interface.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-groupset
        '''
        result = self._values.get("group_set")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def interface_type(self) -> typing.Optional[builtins.str]:
        '''The type of network interface.

        The default is ``interface`` . The supported values are ``efa`` and ``trunk`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-interfacetype
        '''
        result = self._values.get("interface_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ipv4_prefix_count(self) -> typing.Optional[jsii.Number]:
        '''The number of IPv4 prefixes to be automatically assigned to the network interface.

        When creating a network interface, you can't specify a count of IPv4 prefixes if you've specified one of the following: specific IPv4 prefixes, specific private IPv4 addresses, or a count of private IPv4 addresses.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-ipv4prefixcount
        '''
        result = self._values.get("ipv4_prefix_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def ipv4_prefixes(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInterfacePropsMixin.Ipv4PrefixSpecificationProperty"]]]]:
        '''The IPv4 delegated prefixes that are assigned to the network interface.

        When creating a network interface, you can't specify IPv4 prefixes if you've specified one of the following: a count of IPv4 prefixes, specific private IPv4 addresses, or a count of private IPv4 addresses.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-ipv4prefixes
        '''
        result = self._values.get("ipv4_prefixes")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInterfacePropsMixin.Ipv4PrefixSpecificationProperty"]]]], result)

    @builtins.property
    def ipv6_address_count(self) -> typing.Optional[jsii.Number]:
        '''The number of IPv6 addresses to assign to the network interface.

        Amazon EC2 automatically selects the IPv6 addresses from the subnet range. To specify specific IPv6 addresses, use the ``Ipv6Addresses`` property and don't specify this property.

        When creating a network interface, you can't specify a count of IPv6 addresses if you've specified one of the following: specific IPv6 addresses, specific IPv6 prefixes, or a count of IPv6 prefixes.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-ipv6addresscount
        '''
        result = self._values.get("ipv6_address_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def ipv6_addresses(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInterfacePropsMixin.InstanceIpv6AddressProperty"]]]]:
        '''The IPv6 addresses from the IPv6 CIDR block range of your subnet to assign to the network interface.

        If you're specifying a number of IPv6 addresses, use the ``Ipv6AddressCount`` property and don't specify this property.

        When creating a network interface, you can't specify IPv6 addresses if you've specified one of the following: a count of IPv6 addresses, specific IPv6 prefixes, or a count of IPv6 prefixes.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-ipv6addresses
        '''
        result = self._values.get("ipv6_addresses")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInterfacePropsMixin.InstanceIpv6AddressProperty"]]]], result)

    @builtins.property
    def ipv6_prefix_count(self) -> typing.Optional[jsii.Number]:
        '''The number of IPv6 prefixes to be automatically assigned to the network interface.

        When creating a network interface, you can't specify a count of IPv6 prefixes if you've specified one of the following: specific IPv6 prefixes, specific IPv6 addresses, or a count of IPv6 addresses.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-ipv6prefixcount
        '''
        result = self._values.get("ipv6_prefix_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def ipv6_prefixes(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInterfacePropsMixin.Ipv6PrefixSpecificationProperty"]]]]:
        '''The IPv6 delegated prefixes that are assigned to the network interface.

        When creating a network interface, you can't specify IPv6 prefixes if you've specified one of the following: a count of IPv6 prefixes, specific IPv6 addresses, or a count of IPv6 addresses.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-ipv6prefixes
        '''
        result = self._values.get("ipv6_prefixes")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInterfacePropsMixin.Ipv6PrefixSpecificationProperty"]]]], result)

    @builtins.property
    def private_ip_address(self) -> typing.Optional[builtins.str]:
        '''The private IPv4 address to assign to the network interface as the primary private IP address.

        If you want to specify multiple private IP addresses, use the ``PrivateIpAddresses`` property.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-privateipaddress
        '''
        result = self._values.get("private_ip_address")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def private_ip_addresses(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInterfacePropsMixin.PrivateIpAddressSpecificationProperty"]]]]:
        '''The private IPv4 addresses to assign to the network interface.

        You can specify a primary private IP address by setting the value of the ``Primary`` property to ``true`` in the ``PrivateIpAddressSpecification`` property. If you want EC2 to automatically assign private IP addresses, use the ``SecondaryPrivateIpAddressCount`` property and do not specify this property.

        When creating a network interface, you can't specify private IPv4 addresses if you've specified one of the following: a count of private IPv4 addresses, specific IPv4 prefixes, or a count of IPv4 prefixes.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-privateipaddresses
        '''
        result = self._values.get("private_ip_addresses")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnNetworkInterfacePropsMixin.PrivateIpAddressSpecificationProperty"]]]], result)

    @builtins.property
    def public_ip_dns_hostname_type_specification(
        self,
    ) -> typing.Optional[builtins.str]:
        '''Public IP DNS hostname type.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-publicipdnshostnametypespecification
        '''
        result = self._values.get("public_ip_dns_hostname_type_specification")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secondary_private_ip_address_count(self) -> typing.Optional[jsii.Number]:
        '''The number of secondary private IPv4 addresses to assign to a network interface.

        When you specify a number of secondary IPv4 addresses, Amazon EC2 selects these IP addresses within the subnet's IPv4 CIDR range. You can't specify this option and specify more than one private IP address using ``privateIpAddresses`` .

        When creating a Network Interface, you can't specify a count of private IPv4 addresses if you've specified one of the following: specific private IPv4 addresses, specific IPv4 prefixes, or a count of IPv4 prefixes.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-secondaryprivateipaddresscount
        '''
        result = self._values.get("secondary_private_ip_address_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def source_dest_check(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives.

        If the value is ``true`` , source/destination checks are enabled; otherwise, they are disabled. The default value is ``true`` . You must disable source/destination checks if the instance runs services such as network address translation, routing, or firewalls.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-sourcedestcheck
        '''
        result = self._values.get("source_dest_check")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def subnet_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the subnet to associate with the network interface.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-subnetid
        '''
        result = self._values.get("subnet_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags to apply to the network interface.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnNetworkInterfaceMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkInterfacePermissionMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "aws_account_id": "awsAccountId",
        "network_interface_id": "networkInterfaceId",
        "permission": "permission",
    },
)
class CfnNetworkInterfacePermissionMixinProps:
    def __init__(
        self,
        *,
        aws_account_id: typing.Optional[builtins.str] = None,
        network_interface_id: typing.Optional[builtins.str] = None,
        permission: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnNetworkInterfacePermissionPropsMixin.

        :param aws_account_id: The AWS account ID.
        :param network_interface_id: The ID of the network interface.
        :param permission: The type of permission to grant: ``INSTANCE-ATTACH`` or ``EIP-ASSOCIATE`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfacepermission.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_network_interface_permission_mixin_props = ec2_mixins.CfnNetworkInterfacePermissionMixinProps(
                aws_account_id="awsAccountId",
                network_interface_id="networkInterfaceId",
                permission="permission"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__842fc21e18c154ac0eeffc10633f90b057942701d14c87663facbc8b707d7da5)
            check_type(argname="argument aws_account_id", value=aws_account_id, expected_type=type_hints["aws_account_id"])
            check_type(argname="argument network_interface_id", value=network_interface_id, expected_type=type_hints["network_interface_id"])
            check_type(argname="argument permission", value=permission, expected_type=type_hints["permission"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if aws_account_id is not None:
            self._values["aws_account_id"] = aws_account_id
        if network_interface_id is not None:
            self._values["network_interface_id"] = network_interface_id
        if permission is not None:
            self._values["permission"] = permission

    @builtins.property
    def aws_account_id(self) -> typing.Optional[builtins.str]:
        '''The AWS account ID.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfacepermission.html#cfn-ec2-networkinterfacepermission-awsaccountid
        '''
        result = self._values.get("aws_account_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def network_interface_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the network interface.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfacepermission.html#cfn-ec2-networkinterfacepermission-networkinterfaceid
        '''
        result = self._values.get("network_interface_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def permission(self) -> typing.Optional[builtins.str]:
        '''The type of permission to grant: ``INSTANCE-ATTACH`` or ``EIP-ASSOCIATE`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfacepermission.html#cfn-ec2-networkinterfacepermission-permission
        '''
        result = self._values.get("permission")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnNetworkInterfacePermissionMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnNetworkInterfacePermissionPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkInterfacePermissionPropsMixin",
):
    '''Specifies a permission for the network interface, For example, you can grant an AWS -authorized account permission to attach the network interface to an instance in their account.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfacepermission.html
    :cloudformationResource: AWS::EC2::NetworkInterfacePermission
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_network_interface_permission_props_mixin = ec2_mixins.CfnNetworkInterfacePermissionPropsMixin(ec2_mixins.CfnNetworkInterfacePermissionMixinProps(
            aws_account_id="awsAccountId",
            network_interface_id="networkInterfaceId",
            permission="permission"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnNetworkInterfacePermissionMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::NetworkInterfacePermission``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a87622d97556ddbb198f15704f4137110e28444b8356b6a5a8f9b4bb6d31d2a5)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__47dfff50e7b8fcef996bcee52aa4d473c673fb3515f829c30db1832cb896b238)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__02ace1bcd759e11bc58e84b7756b6813b726c081ad052591b8acafc167e8d7a3)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnNetworkInterfacePermissionMixinProps":
        return typing.cast("CfnNetworkInterfacePermissionMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.implements(_IMixin_11e4b965)
class CfnNetworkInterfacePropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkInterfacePropsMixin",
):
    '''Describes a network interface in an Amazon EC2 instance for AWS CloudFormation .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html
    :cloudformationResource: AWS::EC2::NetworkInterface
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_network_interface_props_mixin = ec2_mixins.CfnNetworkInterfacePropsMixin(ec2_mixins.CfnNetworkInterfaceMixinProps(
            connection_tracking_specification=ec2_mixins.CfnNetworkInterfacePropsMixin.ConnectionTrackingSpecificationProperty(
                tcp_established_timeout=123,
                udp_stream_timeout=123,
                udp_timeout=123
            ),
            description="description",
            enable_primary_ipv6=False,
            group_set=["groupSet"],
            interface_type="interfaceType",
            ipv4_prefix_count=123,
            ipv4_prefixes=[ec2_mixins.CfnNetworkInterfacePropsMixin.Ipv4PrefixSpecificationProperty(
                ipv4_prefix="ipv4Prefix"
            )],
            ipv6_address_count=123,
            ipv6_addresses=[ec2_mixins.CfnNetworkInterfacePropsMixin.InstanceIpv6AddressProperty(
                ipv6_address="ipv6Address"
            )],
            ipv6_prefix_count=123,
            ipv6_prefixes=[ec2_mixins.CfnNetworkInterfacePropsMixin.Ipv6PrefixSpecificationProperty(
                ipv6_prefix="ipv6Prefix"
            )],
            private_ip_address="privateIpAddress",
            private_ip_addresses=[ec2_mixins.CfnNetworkInterfacePropsMixin.PrivateIpAddressSpecificationProperty(
                primary=False,
                private_ip_address="privateIpAddress"
            )],
            public_ip_dns_hostname_type_specification="publicIpDnsHostnameTypeSpecification",
            secondary_private_ip_address_count=123,
            source_dest_check=False,
            subnet_id="subnetId",
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnNetworkInterfaceMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::NetworkInterface``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8814c582e1d68570a42007dee51b71c3ca8e0ba3a9abc4a4f615a85ac51d56ba)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8d133d99846465488f8bd331c575498715e222fa16964958959111a30fade813)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6de35757b2a50c8c59a41800caf1de3b6b368c74ce26338a88e1f7518214b71c)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnNetworkInterfaceMixinProps":
        return typing.cast("CfnNetworkInterfaceMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkInterfacePropsMixin.ConnectionTrackingSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "tcp_established_timeout": "tcpEstablishedTimeout",
            "udp_stream_timeout": "udpStreamTimeout",
            "udp_timeout": "udpTimeout",
        },
    )
    class ConnectionTrackingSpecificationProperty:
        def __init__(
            self,
            *,
            tcp_established_timeout: typing.Optional[jsii.Number] = None,
            udp_stream_timeout: typing.Optional[jsii.Number] = None,
            udp_timeout: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Configurable options for connection tracking on a network interface.

            For more information, see `Connection tracking timeouts <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-connection-tracking.html#connection-tracking-timeouts>`_ in the *Amazon Elastic Compute Cloud User Guide* .

            :param tcp_established_timeout: Timeout (in seconds) for idle TCP connections in an established state. Min: 60 seconds. Max: 432000 seconds (5 days). Default: 432000 seconds. Recommended: Less than 432000 seconds.
            :param udp_stream_timeout: Timeout (in seconds) for idle UDP flows classified as streams which have seen more than one request-response transaction. Min: 60 seconds. Max: 180 seconds (3 minutes). Default: 180 seconds.
            :param udp_timeout: Timeout (in seconds) for idle UDP flows that have seen traffic only in a single direction or a single request-response transaction. Min: 30 seconds. Max: 60 seconds. Default: 30 seconds.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-connectiontrackingspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                connection_tracking_specification_property = ec2_mixins.CfnNetworkInterfacePropsMixin.ConnectionTrackingSpecificationProperty(
                    tcp_established_timeout=123,
                    udp_stream_timeout=123,
                    udp_timeout=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__15d9c2c50c83febc14cb68ca45f247f76bd34a12534804739d26c71f786e9ed0)
                check_type(argname="argument tcp_established_timeout", value=tcp_established_timeout, expected_type=type_hints["tcp_established_timeout"])
                check_type(argname="argument udp_stream_timeout", value=udp_stream_timeout, expected_type=type_hints["udp_stream_timeout"])
                check_type(argname="argument udp_timeout", value=udp_timeout, expected_type=type_hints["udp_timeout"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if tcp_established_timeout is not None:
                self._values["tcp_established_timeout"] = tcp_established_timeout
            if udp_stream_timeout is not None:
                self._values["udp_stream_timeout"] = udp_stream_timeout
            if udp_timeout is not None:
                self._values["udp_timeout"] = udp_timeout

        @builtins.property
        def tcp_established_timeout(self) -> typing.Optional[jsii.Number]:
            '''Timeout (in seconds) for idle TCP connections in an established state.

            Min: 60 seconds. Max: 432000 seconds (5 days). Default: 432000 seconds. Recommended: Less than 432000 seconds.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-connectiontrackingspecification.html#cfn-ec2-networkinterface-connectiontrackingspecification-tcpestablishedtimeout
            '''
            result = self._values.get("tcp_established_timeout")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def udp_stream_timeout(self) -> typing.Optional[jsii.Number]:
            '''Timeout (in seconds) for idle UDP flows classified as streams which have seen more than one request-response transaction.

            Min: 60 seconds. Max: 180 seconds (3 minutes). Default: 180 seconds.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-connectiontrackingspecification.html#cfn-ec2-networkinterface-connectiontrackingspecification-udpstreamtimeout
            '''
            result = self._values.get("udp_stream_timeout")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def udp_timeout(self) -> typing.Optional[jsii.Number]:
            '''Timeout (in seconds) for idle UDP flows that have seen traffic only in a single direction or a single request-response transaction.

            Min: 30 seconds. Max: 60 seconds. Default: 30 seconds.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-connectiontrackingspecification.html#cfn-ec2-networkinterface-connectiontrackingspecification-udptimeout
            '''
            result = self._values.get("udp_timeout")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ConnectionTrackingSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkInterfacePropsMixin.InstanceIpv6AddressProperty",
        jsii_struct_bases=[],
        name_mapping={"ipv6_address": "ipv6Address"},
    )
    class InstanceIpv6AddressProperty:
        def __init__(
            self,
            *,
            ipv6_address: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes the IPv6 addresses to associate with the network interface.

            :param ipv6_address: An IPv6 address to associate with the network interface.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-instanceipv6address.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                instance_ipv6_address_property = ec2_mixins.CfnNetworkInterfacePropsMixin.InstanceIpv6AddressProperty(
                    ipv6_address="ipv6Address"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__e610428ece8f1704c4b46162b4e590a35d6dab2c5f780734bf286aa4cf294304)
                check_type(argname="argument ipv6_address", value=ipv6_address, expected_type=type_hints["ipv6_address"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if ipv6_address is not None:
                self._values["ipv6_address"] = ipv6_address

        @builtins.property
        def ipv6_address(self) -> typing.Optional[builtins.str]:
            '''An IPv6 address to associate with the network interface.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-instanceipv6address.html#cfn-ec2-networkinterface-instanceipv6address-ipv6address
            '''
            result = self._values.get("ipv6_address")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "InstanceIpv6AddressProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkInterfacePropsMixin.Ipv4PrefixSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={"ipv4_prefix": "ipv4Prefix"},
    )
    class Ipv4PrefixSpecificationProperty:
        def __init__(
            self,
            *,
            ipv4_prefix: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes an IPv4 prefix.

            :param ipv4_prefix: The IPv4 prefix. For information, see `Assigning prefixes to network interfaces <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-prefix-eni.html>`_ in the *Amazon EC2 User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-ipv4prefixspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                ipv4_prefix_specification_property = ec2_mixins.CfnNetworkInterfacePropsMixin.Ipv4PrefixSpecificationProperty(
                    ipv4_prefix="ipv4Prefix"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__15df342d08f40166ed1b3f2f9c7720b3aecd873125e83c6df018b5047751ddc4)
                check_type(argname="argument ipv4_prefix", value=ipv4_prefix, expected_type=type_hints["ipv4_prefix"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if ipv4_prefix is not None:
                self._values["ipv4_prefix"] = ipv4_prefix

        @builtins.property
        def ipv4_prefix(self) -> typing.Optional[builtins.str]:
            '''The IPv4 prefix.

            For information, see `Assigning prefixes to network interfaces <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-prefix-eni.html>`_ in the *Amazon EC2 User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-ipv4prefixspecification.html#cfn-ec2-networkinterface-ipv4prefixspecification-ipv4prefix
            '''
            result = self._values.get("ipv4_prefix")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "Ipv4PrefixSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkInterfacePropsMixin.Ipv6PrefixSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={"ipv6_prefix": "ipv6Prefix"},
    )
    class Ipv6PrefixSpecificationProperty:
        def __init__(
            self,
            *,
            ipv6_prefix: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes the IPv6 prefix.

            :param ipv6_prefix: The IPv6 prefix. For information, see `Assigning prefixes to Amazon EC2 network interfaces <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-prefix-eni.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-ipv6prefixspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                ipv6_prefix_specification_property = ec2_mixins.CfnNetworkInterfacePropsMixin.Ipv6PrefixSpecificationProperty(
                    ipv6_prefix="ipv6Prefix"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__934b0598113db2173b749fd699f1f4469cd8b77d04d11d98e72fa50f9a10bec4)
                check_type(argname="argument ipv6_prefix", value=ipv6_prefix, expected_type=type_hints["ipv6_prefix"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if ipv6_prefix is not None:
                self._values["ipv6_prefix"] = ipv6_prefix

        @builtins.property
        def ipv6_prefix(self) -> typing.Optional[builtins.str]:
            '''The IPv6 prefix.

            For information, see `Assigning prefixes to Amazon EC2 network interfaces <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-prefix-eni.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-ipv6prefixspecification.html#cfn-ec2-networkinterface-ipv6prefixspecification-ipv6prefix
            '''
            result = self._values.get("ipv6_prefix")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "Ipv6PrefixSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkInterfacePropsMixin.PrivateIpAddressSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={"primary": "primary", "private_ip_address": "privateIpAddress"},
    )
    class PrivateIpAddressSpecificationProperty:
        def __init__(
            self,
            *,
            primary: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            private_ip_address: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes a secondary private IPv4 address for a network interface.

            :param primary: Sets the private IP address as the primary private address. You can set only one primary private IP address. If you don't specify a primary private IP address, Amazon EC2 automatically assigns a primary private IP address.
            :param private_ip_address: The private IP address of the network interface.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-privateipaddressspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                private_ip_address_specification_property = ec2_mixins.CfnNetworkInterfacePropsMixin.PrivateIpAddressSpecificationProperty(
                    primary=False,
                    private_ip_address="privateIpAddress"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__6b70e32c0cdea5f6acc46b72fea40cbfba3924f1dd1dde85ad048ebbe6059c1c)
                check_type(argname="argument primary", value=primary, expected_type=type_hints["primary"])
                check_type(argname="argument private_ip_address", value=private_ip_address, expected_type=type_hints["private_ip_address"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if primary is not None:
                self._values["primary"] = primary
            if private_ip_address is not None:
                self._values["private_ip_address"] = private_ip_address

        @builtins.property
        def primary(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Sets the private IP address as the primary private address.

            You can set only one primary private IP address. If you don't specify a primary private IP address, Amazon EC2 automatically assigns a primary private IP address.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-privateipaddressspecification.html#cfn-ec2-networkinterface-privateipaddressspecification-primary
            '''
            result = self._values.get("primary")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def private_ip_address(self) -> typing.Optional[builtins.str]:
            '''The private IP address of the network interface.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-privateipaddressspecification.html#cfn-ec2-networkinterface-privateipaddressspecification-privateipaddress
            '''
            result = self._values.get("private_ip_address")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PrivateIpAddressSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkInterfacePropsMixin.PublicIpDnsNameOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "dns_hostname_type": "dnsHostnameType",
            "public_dual_stack_dns_name": "publicDualStackDnsName",
            "public_ipv4_dns_name": "publicIpv4DnsName",
            "public_ipv6_dns_name": "publicIpv6DnsName",
        },
    )
    class PublicIpDnsNameOptionsProperty:
        def __init__(
            self,
            *,
            dns_hostname_type: typing.Optional[builtins.str] = None,
            public_dual_stack_dns_name: typing.Optional[builtins.str] = None,
            public_ipv4_dns_name: typing.Optional[builtins.str] = None,
            public_ipv6_dns_name: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Public hostname type options.

            For more information, see `EC2 instance hostnames, DNS names, and domains <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html>`_ in the *Amazon EC2 User Guide* .

            :param dns_hostname_type: The public hostname type. For more information, see `EC2 instance hostnames, DNS names, and domains <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html>`_ in the *Amazon EC2 User Guide* .
            :param public_dual_stack_dns_name: A dual-stack public hostname for a network interface. Requests from within the VPC resolve to both the private IPv4 address and the IPv6 Global Unicast Address of the network interface. Requests from the internet resolve to both the public IPv4 and the IPv6 GUA address of the network interface.
            :param public_ipv4_dns_name: An IPv4-enabled public hostname for a network interface. Requests from within the VPC resolve to the private primary IPv4 address of the network interface. Requests from the internet resolve to the public IPv4 address of the network interface.
            :param public_ipv6_dns_name: An IPv6-enabled public hostname for a network interface. Requests from within the VPC or from the internet resolve to the IPv6 GUA of the network interface.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-publicipdnsnameoptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                public_ip_dns_name_options_property = ec2_mixins.CfnNetworkInterfacePropsMixin.PublicIpDnsNameOptionsProperty(
                    dns_hostname_type="dnsHostnameType",
                    public_dual_stack_dns_name="publicDualStackDnsName",
                    public_ipv4_dns_name="publicIpv4DnsName",
                    public_ipv6_dns_name="publicIpv6DnsName"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__3204ccca498321f58eb0856ef128b909111f93c2282676f70cdbbabd7a2b9c66)
                check_type(argname="argument dns_hostname_type", value=dns_hostname_type, expected_type=type_hints["dns_hostname_type"])
                check_type(argname="argument public_dual_stack_dns_name", value=public_dual_stack_dns_name, expected_type=type_hints["public_dual_stack_dns_name"])
                check_type(argname="argument public_ipv4_dns_name", value=public_ipv4_dns_name, expected_type=type_hints["public_ipv4_dns_name"])
                check_type(argname="argument public_ipv6_dns_name", value=public_ipv6_dns_name, expected_type=type_hints["public_ipv6_dns_name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if dns_hostname_type is not None:
                self._values["dns_hostname_type"] = dns_hostname_type
            if public_dual_stack_dns_name is not None:
                self._values["public_dual_stack_dns_name"] = public_dual_stack_dns_name
            if public_ipv4_dns_name is not None:
                self._values["public_ipv4_dns_name"] = public_ipv4_dns_name
            if public_ipv6_dns_name is not None:
                self._values["public_ipv6_dns_name"] = public_ipv6_dns_name

        @builtins.property
        def dns_hostname_type(self) -> typing.Optional[builtins.str]:
            '''The public hostname type.

            For more information, see `EC2 instance hostnames, DNS names, and domains <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html>`_ in the *Amazon EC2 User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-publicipdnsnameoptions.html#cfn-ec2-networkinterface-publicipdnsnameoptions-dnshostnametype
            '''
            result = self._values.get("dns_hostname_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def public_dual_stack_dns_name(self) -> typing.Optional[builtins.str]:
            '''A dual-stack public hostname for a network interface.

            Requests from within the VPC resolve to both the private IPv4 address and the IPv6 Global Unicast Address of the network interface. Requests from the internet resolve to both the public IPv4 and the IPv6 GUA address of the network interface.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-publicipdnsnameoptions.html#cfn-ec2-networkinterface-publicipdnsnameoptions-publicdualstackdnsname
            '''
            result = self._values.get("public_dual_stack_dns_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def public_ipv4_dns_name(self) -> typing.Optional[builtins.str]:
            '''An IPv4-enabled public hostname for a network interface.

            Requests from within the VPC resolve to the private primary IPv4 address of the network interface. Requests from the internet resolve to the public IPv4 address of the network interface.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-publicipdnsnameoptions.html#cfn-ec2-networkinterface-publicipdnsnameoptions-publicipv4dnsname
            '''
            result = self._values.get("public_ipv4_dns_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def public_ipv6_dns_name(self) -> typing.Optional[builtins.str]:
            '''An IPv6-enabled public hostname for a network interface.

            Requests from within the VPC or from the internet resolve to the IPv6 GUA of the network interface.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-publicipdnsnameoptions.html#cfn-ec2-networkinterface-publicipdnsnameoptions-publicipv6dnsname
            '''
            result = self._values.get("public_ipv6_dns_name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PublicIpDnsNameOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkPerformanceMetricSubscriptionMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "destination": "destination",
        "metric": "metric",
        "source": "source",
        "statistic": "statistic",
    },
)
class CfnNetworkPerformanceMetricSubscriptionMixinProps:
    def __init__(
        self,
        *,
        destination: typing.Optional[builtins.str] = None,
        metric: typing.Optional[builtins.str] = None,
        source: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnNetworkPerformanceMetricSubscriptionPropsMixin.

        :param destination: The Region or Availability Zone that's the target for the subscription. For example, ``eu-west-1`` .
        :param metric: The metric used for the subscription.
        :param source: The Region or Availability Zone that's the source for the subscription. For example, ``us-east-1`` .
        :param statistic: The statistic used for the subscription.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkperformancemetricsubscription.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_network_performance_metric_subscription_mixin_props = ec2_mixins.CfnNetworkPerformanceMetricSubscriptionMixinProps(
                destination="destination",
                metric="metric",
                source="source",
                statistic="statistic"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2e59d999cef5da0d3fb5cc1df26fe8dc1c030355cfce09e19759bdbb51243ed0)
            check_type(argname="argument destination", value=destination, expected_type=type_hints["destination"])
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument source", value=source, expected_type=type_hints["source"])
            check_type(argname="argument statistic", value=statistic, expected_type=type_hints["statistic"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if destination is not None:
            self._values["destination"] = destination
        if metric is not None:
            self._values["metric"] = metric
        if source is not None:
            self._values["source"] = source
        if statistic is not None:
            self._values["statistic"] = statistic

    @builtins.property
    def destination(self) -> typing.Optional[builtins.str]:
        '''The Region or Availability Zone that's the target for the subscription.

        For example, ``eu-west-1`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkperformancemetricsubscription.html#cfn-ec2-networkperformancemetricsubscription-destination
        '''
        result = self._values.get("destination")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def metric(self) -> typing.Optional[builtins.str]:
        '''The metric used for the subscription.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkperformancemetricsubscription.html#cfn-ec2-networkperformancemetricsubscription-metric
        '''
        result = self._values.get("metric")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def source(self) -> typing.Optional[builtins.str]:
        '''The Region or Availability Zone that's the source for the subscription.

        For example, ``us-east-1`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkperformancemetricsubscription.html#cfn-ec2-networkperformancemetricsubscription-source
        '''
        result = self._values.get("source")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def statistic(self) -> typing.Optional[builtins.str]:
        '''The statistic used for the subscription.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkperformancemetricsubscription.html#cfn-ec2-networkperformancemetricsubscription-statistic
        '''
        result = self._values.get("statistic")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnNetworkPerformanceMetricSubscriptionMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnNetworkPerformanceMetricSubscriptionPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnNetworkPerformanceMetricSubscriptionPropsMixin",
):
    '''Describes Infrastructure Performance subscriptions.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkperformancemetricsubscription.html
    :cloudformationResource: AWS::EC2::NetworkPerformanceMetricSubscription
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_network_performance_metric_subscription_props_mixin = ec2_mixins.CfnNetworkPerformanceMetricSubscriptionPropsMixin(ec2_mixins.CfnNetworkPerformanceMetricSubscriptionMixinProps(
            destination="destination",
            metric="metric",
            source="source",
            statistic="statistic"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnNetworkPerformanceMetricSubscriptionMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::NetworkPerformanceMetricSubscription``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__77a11ea3ab7e9fd741cd11e958e4198c8a02f830aefdf4a97b844a3bfdabbac6)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0178bba9641d33d604911a8d3762475d13463fa8f77df6663b7a6b80e2db2ead)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0cecb24eae197b0b841a161a7049bd67519e72f349d506b9e6a0e81bc144984d)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnNetworkPerformanceMetricSubscriptionMixinProps":
        return typing.cast("CfnNetworkPerformanceMetricSubscriptionMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnPlacementGroupMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "partition_count": "partitionCount",
        "spread_level": "spreadLevel",
        "strategy": "strategy",
        "tags": "tags",
    },
)
class CfnPlacementGroupMixinProps:
    def __init__(
        self,
        *,
        partition_count: typing.Optional[jsii.Number] = None,
        spread_level: typing.Optional[builtins.str] = None,
        strategy: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnPlacementGroupPropsMixin.

        :param partition_count: The number of partitions. Valid only when *Strategy* is set to ``partition`` .
        :param spread_level: Determines how placement groups spread instances. - Host  You can use ``host`` only with Outpost placement groups. - Rack  No usage restrictions.
        :param strategy: The placement strategy.
        :param tags: The tags to apply to the new placement group.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-placementgroup.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_placement_group_mixin_props = ec2_mixins.CfnPlacementGroupMixinProps(
                partition_count=123,
                spread_level="spreadLevel",
                strategy="strategy",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__85d4d1325334f9d22842fdeb9a409def6a76c2c4c808bad1c12f4bbef6498d48)
            check_type(argname="argument partition_count", value=partition_count, expected_type=type_hints["partition_count"])
            check_type(argname="argument spread_level", value=spread_level, expected_type=type_hints["spread_level"])
            check_type(argname="argument strategy", value=strategy, expected_type=type_hints["strategy"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if partition_count is not None:
            self._values["partition_count"] = partition_count
        if spread_level is not None:
            self._values["spread_level"] = spread_level
        if strategy is not None:
            self._values["strategy"] = strategy
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def partition_count(self) -> typing.Optional[jsii.Number]:
        '''The number of partitions.

        Valid only when *Strategy* is set to ``partition`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-placementgroup.html#cfn-ec2-placementgroup-partitioncount
        '''
        result = self._values.get("partition_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def spread_level(self) -> typing.Optional[builtins.str]:
        '''Determines how placement groups spread instances.

        - Host  You can use ``host`` only with Outpost placement groups.
        - Rack  No usage restrictions.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-placementgroup.html#cfn-ec2-placementgroup-spreadlevel
        '''
        result = self._values.get("spread_level")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def strategy(self) -> typing.Optional[builtins.str]:
        '''The placement strategy.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-placementgroup.html#cfn-ec2-placementgroup-strategy
        '''
        result = self._values.get("strategy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags to apply to the new placement group.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-placementgroup.html#cfn-ec2-placementgroup-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnPlacementGroupMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnPlacementGroupPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnPlacementGroupPropsMixin",
):
    '''Specifies a placement group in which to launch instances.

    The strategy of the placement group determines how the instances are organized within the group.

    A ``cluster`` placement group is a logical grouping of instances within a single Availability Zone that benefit from low network latency, high network throughput. A ``spread`` placement group places instances on distinct hardware. A ``partition`` placement group places groups of instances in different partitions, where instances in one partition do not share the same hardware with instances in another partition.

    For more information, see `Placement Groups <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/placement-groups.html>`_ in the *Amazon EC2 User Guide* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-placementgroup.html
    :cloudformationResource: AWS::EC2::PlacementGroup
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_placement_group_props_mixin = ec2_mixins.CfnPlacementGroupPropsMixin(ec2_mixins.CfnPlacementGroupMixinProps(
            partition_count=123,
            spread_level="spreadLevel",
            strategy="strategy",
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnPlacementGroupMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::PlacementGroup``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bb1e4a0ab53a2ed21005bbd161912217129aba3a61b9a9c8e899a858d1b3ea61)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8c7eb5402698f950846c385c35d4900aad013fc87c0ec5d64135b7f8415ce90f)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d92d38de8a4ad8ad1f0289659aff7a9bc602a71be53b0fa3820ce4178caed90f)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnPlacementGroupMixinProps":
        return typing.cast("CfnPlacementGroupMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnPrefixListMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "address_family": "addressFamily",
        "entries": "entries",
        "max_entries": "maxEntries",
        "prefix_list_name": "prefixListName",
        "tags": "tags",
    },
)
class CfnPrefixListMixinProps:
    def __init__(
        self,
        *,
        address_family: typing.Optional[builtins.str] = None,
        entries: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPrefixListPropsMixin.EntryProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        max_entries: typing.Optional[jsii.Number] = None,
        prefix_list_name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnPrefixListPropsMixin.

        :param address_family: The IP address type. Valid Values: ``IPv4`` | ``IPv6``
        :param entries: The entries for the prefix list.
        :param max_entries: The maximum number of entries for the prefix list. You can't modify the entries and the size of a prefix list at the same time. This property is required when you create a prefix list.
        :param prefix_list_name: A name for the prefix list. Constraints: Up to 255 characters in length. The name cannot start with ``com.amazonaws`` .
        :param tags: The tags for the prefix list.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_prefix_list_mixin_props = ec2_mixins.CfnPrefixListMixinProps(
                address_family="addressFamily",
                entries=[ec2_mixins.CfnPrefixListPropsMixin.EntryProperty(
                    cidr="cidr",
                    description="description"
                )],
                max_entries=123,
                prefix_list_name="prefixListName",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__54f9f1d6bffd75f28cfaa68196f9f7b90cf993729e1a19dd145a01d797cd3226)
            check_type(argname="argument address_family", value=address_family, expected_type=type_hints["address_family"])
            check_type(argname="argument entries", value=entries, expected_type=type_hints["entries"])
            check_type(argname="argument max_entries", value=max_entries, expected_type=type_hints["max_entries"])
            check_type(argname="argument prefix_list_name", value=prefix_list_name, expected_type=type_hints["prefix_list_name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if address_family is not None:
            self._values["address_family"] = address_family
        if entries is not None:
            self._values["entries"] = entries
        if max_entries is not None:
            self._values["max_entries"] = max_entries
        if prefix_list_name is not None:
            self._values["prefix_list_name"] = prefix_list_name
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def address_family(self) -> typing.Optional[builtins.str]:
        '''The IP address type.

        Valid Values: ``IPv4`` | ``IPv6``

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html#cfn-ec2-prefixlist-addressfamily
        '''
        result = self._values.get("address_family")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def entries(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPrefixListPropsMixin.EntryProperty"]]]]:
        '''The entries for the prefix list.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html#cfn-ec2-prefixlist-entries
        '''
        result = self._values.get("entries")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPrefixListPropsMixin.EntryProperty"]]]], result)

    @builtins.property
    def max_entries(self) -> typing.Optional[jsii.Number]:
        '''The maximum number of entries for the prefix list.

        You can't modify the entries and the size of a prefix list at the same time.

        This property is required when you create a prefix list.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html#cfn-ec2-prefixlist-maxentries
        '''
        result = self._values.get("max_entries")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def prefix_list_name(self) -> typing.Optional[builtins.str]:
        '''A name for the prefix list.

        Constraints: Up to 255 characters in length. The name cannot start with ``com.amazonaws`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html#cfn-ec2-prefixlist-prefixlistname
        '''
        result = self._values.get("prefix_list_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags for the prefix list.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html#cfn-ec2-prefixlist-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnPrefixListMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnPrefixListPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnPrefixListPropsMixin",
):
    '''Specifies a managed prefix list.

    You can add one or more entries to the prefix list. Each entry consists of a CIDR block and an optional description.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html
    :cloudformationResource: AWS::EC2::PrefixList
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_prefix_list_props_mixin = ec2_mixins.CfnPrefixListPropsMixin(ec2_mixins.CfnPrefixListMixinProps(
            address_family="addressFamily",
            entries=[ec2_mixins.CfnPrefixListPropsMixin.EntryProperty(
                cidr="cidr",
                description="description"
            )],
            max_entries=123,
            prefix_list_name="prefixListName",
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnPrefixListMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::PrefixList``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8e4ee30c82286464153faf767c7887855c4383d2d01a0b2c66719db185a9be53)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b56751f9f6b2e370d5045807bf2ffeb5e836ce70e3c87af17854c3b4eabe05d2)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c28de386216ffef61c8313d20cc060e536da30b1ef475b60251ef7eb894bb5fc)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnPrefixListMixinProps":
        return typing.cast("CfnPrefixListMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnPrefixListPropsMixin.EntryProperty",
        jsii_struct_bases=[],
        name_mapping={"cidr": "cidr", "description": "description"},
    )
    class EntryProperty:
        def __init__(
            self,
            *,
            cidr: typing.Optional[builtins.str] = None,
            description: typing.Optional[builtins.str] = None,
        ) -> None:
            '''An entry for a prefix list.

            :param cidr: The CIDR block.
            :param description: A description for the entry. Constraints: Up to 255 characters in length.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-prefixlist-entry.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                entry_property = ec2_mixins.CfnPrefixListPropsMixin.EntryProperty(
                    cidr="cidr",
                    description="description"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__b73742aaf31ae9e675bf1f0e841a8f327f017b2281898aa19cbd117efc807fc0)
                check_type(argname="argument cidr", value=cidr, expected_type=type_hints["cidr"])
                check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if cidr is not None:
                self._values["cidr"] = cidr
            if description is not None:
                self._values["description"] = description

        @builtins.property
        def cidr(self) -> typing.Optional[builtins.str]:
            '''The CIDR block.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-prefixlist-entry.html#cfn-ec2-prefixlist-entry-cidr
            '''
            result = self._values.get("cidr")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def description(self) -> typing.Optional[builtins.str]:
            '''A description for the entry.

            Constraints: Up to 255 characters in length.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-prefixlist-entry.html#cfn-ec2-prefixlist-entry-description
            '''
            result = self._values.get("description")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "EntryProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnRouteMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "carrier_gateway_id": "carrierGatewayId",
        "core_network_arn": "coreNetworkArn",
        "destination_cidr_block": "destinationCidrBlock",
        "destination_ipv6_cidr_block": "destinationIpv6CidrBlock",
        "destination_prefix_list_id": "destinationPrefixListId",
        "egress_only_internet_gateway_id": "egressOnlyInternetGatewayId",
        "gateway_id": "gatewayId",
        "instance_id": "instanceId",
        "local_gateway_id": "localGatewayId",
        "nat_gateway_id": "natGatewayId",
        "network_interface_id": "networkInterfaceId",
        "route_table_id": "routeTableId",
        "transit_gateway_id": "transitGatewayId",
        "vpc_endpoint_id": "vpcEndpointId",
        "vpc_peering_connection_id": "vpcPeeringConnectionId",
    },
)
class CfnRouteMixinProps:
    def __init__(
        self,
        *,
        carrier_gateway_id: typing.Optional[builtins.str] = None,
        core_network_arn: typing.Optional[builtins.str] = None,
        destination_cidr_block: typing.Optional[builtins.str] = None,
        destination_ipv6_cidr_block: typing.Optional[builtins.str] = None,
        destination_prefix_list_id: typing.Optional[builtins.str] = None,
        egress_only_internet_gateway_id: typing.Optional[builtins.str] = None,
        gateway_id: typing.Optional[builtins.str] = None,
        instance_id: typing.Optional[builtins.str] = None,
        local_gateway_id: typing.Optional[builtins.str] = None,
        nat_gateway_id: typing.Optional[builtins.str] = None,
        network_interface_id: typing.Optional[builtins.str] = None,
        route_table_id: typing.Optional[builtins.str] = None,
        transit_gateway_id: typing.Optional[builtins.str] = None,
        vpc_endpoint_id: typing.Optional[builtins.str] = None,
        vpc_peering_connection_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnRoutePropsMixin.

        :param carrier_gateway_id: The ID of the carrier gateway. You can only use this option when the VPC contains a subnet which is associated with a Wavelength Zone.
        :param core_network_arn: The Amazon Resource Name (ARN) of the core network.
        :param destination_cidr_block: The IPv4 CIDR address block used for the destination match. Routing decisions are based on the most specific match. We modify the specified CIDR block to its canonical form; for example, if you specify ``100.68.0.18/18`` , we modify it to ``100.68.0.0/18`` .
        :param destination_ipv6_cidr_block: The IPv6 CIDR block used for the destination match. Routing decisions are based on the most specific match.
        :param destination_prefix_list_id: The ID of a prefix list used for the destination match.
        :param egress_only_internet_gateway_id: [IPv6 traffic only] The ID of an egress-only internet gateway.
        :param gateway_id: The ID of an internet gateway or virtual private gateway attached to your VPC.
        :param instance_id: The ID of a NAT instance in your VPC. The operation fails if you specify an instance ID unless exactly one network interface is attached.
        :param local_gateway_id: The ID of the local gateway.
        :param nat_gateway_id: [IPv4 traffic only] The ID of a NAT gateway.
        :param network_interface_id: The ID of a network interface.
        :param route_table_id: The ID of the route table for the route.
        :param transit_gateway_id: The ID of a transit gateway.
        :param vpc_endpoint_id: The ID of a VPC endpoint. Supported for Gateway Load Balancer endpoints only.
        :param vpc_peering_connection_id: The ID of a VPC peering connection.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_route_mixin_props = ec2_mixins.CfnRouteMixinProps(
                carrier_gateway_id="carrierGatewayId",
                core_network_arn="coreNetworkArn",
                destination_cidr_block="destinationCidrBlock",
                destination_ipv6_cidr_block="destinationIpv6CidrBlock",
                destination_prefix_list_id="destinationPrefixListId",
                egress_only_internet_gateway_id="egressOnlyInternetGatewayId",
                gateway_id="gatewayId",
                instance_id="instanceId",
                local_gateway_id="localGatewayId",
                nat_gateway_id="natGatewayId",
                network_interface_id="networkInterfaceId",
                route_table_id="routeTableId",
                transit_gateway_id="transitGatewayId",
                vpc_endpoint_id="vpcEndpointId",
                vpc_peering_connection_id="vpcPeeringConnectionId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__82322c7ef24fc4cf9ccc12569083519b922a7678cf5917c51f414abcac894401)
            check_type(argname="argument carrier_gateway_id", value=carrier_gateway_id, expected_type=type_hints["carrier_gateway_id"])
            check_type(argname="argument core_network_arn", value=core_network_arn, expected_type=type_hints["core_network_arn"])
            check_type(argname="argument destination_cidr_block", value=destination_cidr_block, expected_type=type_hints["destination_cidr_block"])
            check_type(argname="argument destination_ipv6_cidr_block", value=destination_ipv6_cidr_block, expected_type=type_hints["destination_ipv6_cidr_block"])
            check_type(argname="argument destination_prefix_list_id", value=destination_prefix_list_id, expected_type=type_hints["destination_prefix_list_id"])
            check_type(argname="argument egress_only_internet_gateway_id", value=egress_only_internet_gateway_id, expected_type=type_hints["egress_only_internet_gateway_id"])
            check_type(argname="argument gateway_id", value=gateway_id, expected_type=type_hints["gateway_id"])
            check_type(argname="argument instance_id", value=instance_id, expected_type=type_hints["instance_id"])
            check_type(argname="argument local_gateway_id", value=local_gateway_id, expected_type=type_hints["local_gateway_id"])
            check_type(argname="argument nat_gateway_id", value=nat_gateway_id, expected_type=type_hints["nat_gateway_id"])
            check_type(argname="argument network_interface_id", value=network_interface_id, expected_type=type_hints["network_interface_id"])
            check_type(argname="argument route_table_id", value=route_table_id, expected_type=type_hints["route_table_id"])
            check_type(argname="argument transit_gateway_id", value=transit_gateway_id, expected_type=type_hints["transit_gateway_id"])
            check_type(argname="argument vpc_endpoint_id", value=vpc_endpoint_id, expected_type=type_hints["vpc_endpoint_id"])
            check_type(argname="argument vpc_peering_connection_id", value=vpc_peering_connection_id, expected_type=type_hints["vpc_peering_connection_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if carrier_gateway_id is not None:
            self._values["carrier_gateway_id"] = carrier_gateway_id
        if core_network_arn is not None:
            self._values["core_network_arn"] = core_network_arn
        if destination_cidr_block is not None:
            self._values["destination_cidr_block"] = destination_cidr_block
        if destination_ipv6_cidr_block is not None:
            self._values["destination_ipv6_cidr_block"] = destination_ipv6_cidr_block
        if destination_prefix_list_id is not None:
            self._values["destination_prefix_list_id"] = destination_prefix_list_id
        if egress_only_internet_gateway_id is not None:
            self._values["egress_only_internet_gateway_id"] = egress_only_internet_gateway_id
        if gateway_id is not None:
            self._values["gateway_id"] = gateway_id
        if instance_id is not None:
            self._values["instance_id"] = instance_id
        if local_gateway_id is not None:
            self._values["local_gateway_id"] = local_gateway_id
        if nat_gateway_id is not None:
            self._values["nat_gateway_id"] = nat_gateway_id
        if network_interface_id is not None:
            self._values["network_interface_id"] = network_interface_id
        if route_table_id is not None:
            self._values["route_table_id"] = route_table_id
        if transit_gateway_id is not None:
            self._values["transit_gateway_id"] = transit_gateway_id
        if vpc_endpoint_id is not None:
            self._values["vpc_endpoint_id"] = vpc_endpoint_id
        if vpc_peering_connection_id is not None:
            self._values["vpc_peering_connection_id"] = vpc_peering_connection_id

    @builtins.property
    def carrier_gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the carrier gateway.

        You can only use this option when the VPC contains a subnet which is associated with a Wavelength Zone.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-carriergatewayid
        '''
        result = self._values.get("carrier_gateway_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def core_network_arn(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the core network.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-corenetworkarn
        '''
        result = self._values.get("core_network_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def destination_cidr_block(self) -> typing.Optional[builtins.str]:
        '''The IPv4 CIDR address block used for the destination match.

        Routing decisions are based on the most specific match. We modify the specified CIDR block to its canonical form; for example, if you specify ``100.68.0.18/18`` , we modify it to ``100.68.0.0/18`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-destinationcidrblock
        '''
        result = self._values.get("destination_cidr_block")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def destination_ipv6_cidr_block(self) -> typing.Optional[builtins.str]:
        '''The IPv6 CIDR block used for the destination match.

        Routing decisions are based on the most specific match.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-destinationipv6cidrblock
        '''
        result = self._values.get("destination_ipv6_cidr_block")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def destination_prefix_list_id(self) -> typing.Optional[builtins.str]:
        '''The ID of a prefix list used for the destination match.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-destinationprefixlistid
        '''
        result = self._values.get("destination_prefix_list_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def egress_only_internet_gateway_id(self) -> typing.Optional[builtins.str]:
        '''[IPv6 traffic only] The ID of an egress-only internet gateway.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-egressonlyinternetgatewayid
        '''
        result = self._values.get("egress_only_internet_gateway_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of an internet gateway or virtual private gateway attached to your VPC.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-gatewayid
        '''
        result = self._values.get("gateway_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def instance_id(self) -> typing.Optional[builtins.str]:
        '''The ID of a NAT instance in your VPC.

        The operation fails if you specify an instance ID unless exactly one network interface is attached.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-instanceid
        '''
        result = self._values.get("instance_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the local gateway.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-localgatewayid
        '''
        result = self._values.get("local_gateway_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def nat_gateway_id(self) -> typing.Optional[builtins.str]:
        '''[IPv4 traffic only] The ID of a NAT gateway.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-natgatewayid
        '''
        result = self._values.get("nat_gateway_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def network_interface_id(self) -> typing.Optional[builtins.str]:
        '''The ID of a network interface.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-networkinterfaceid
        '''
        result = self._values.get("network_interface_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def route_table_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the route table for the route.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-routetableid
        '''
        result = self._values.get("route_table_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def transit_gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of a transit gateway.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-transitgatewayid
        '''
        result = self._values.get("transit_gateway_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpc_endpoint_id(self) -> typing.Optional[builtins.str]:
        '''The ID of a VPC endpoint.

        Supported for Gateway Load Balancer endpoints only.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-vpcendpointid
        '''
        result = self._values.get("vpc_endpoint_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpc_peering_connection_id(self) -> typing.Optional[builtins.str]:
        '''The ID of a VPC peering connection.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-vpcpeeringconnectionid
        '''
        result = self._values.get("vpc_peering_connection_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnRouteMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnRoutePropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnRoutePropsMixin",
):
    '''Specifies a route in a route table. For more information, see `Routes <https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Route_Tables.html#route-table-routes>`_ in the *Amazon VPC User Guide* .

    You must specify either a destination CIDR block or prefix list ID. You must also specify exactly one of the resources as the target.

    If you create a route that references a transit gateway in the same template where you create the transit gateway, you must declare a dependency on the transit gateway attachment. The route table cannot use the transit gateway until it has successfully attached to the VPC. Add a `DependsOn Attribute <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html>`_ in the ``AWS::EC2::Route`` resource to explicitly declare a dependency on the ``AWS::EC2::TransitGatewayAttachment`` resource.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html
    :cloudformationResource: AWS::EC2::Route
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_route_props_mixin = ec2_mixins.CfnRoutePropsMixin(ec2_mixins.CfnRouteMixinProps(
            carrier_gateway_id="carrierGatewayId",
            core_network_arn="coreNetworkArn",
            destination_cidr_block="destinationCidrBlock",
            destination_ipv6_cidr_block="destinationIpv6CidrBlock",
            destination_prefix_list_id="destinationPrefixListId",
            egress_only_internet_gateway_id="egressOnlyInternetGatewayId",
            gateway_id="gatewayId",
            instance_id="instanceId",
            local_gateway_id="localGatewayId",
            nat_gateway_id="natGatewayId",
            network_interface_id="networkInterfaceId",
            route_table_id="routeTableId",
            transit_gateway_id="transitGatewayId",
            vpc_endpoint_id="vpcEndpointId",
            vpc_peering_connection_id="vpcPeeringConnectionId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnRouteMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::Route``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eb72a9d8d13d80a800ceb12aaa4a5c8ff944cc161a933bce804ef2e142075a65)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cc57c141eaba292d3f04933b7abe48b8e03fbee1f5495149459043892b3ba8ee)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__41b8169bf8fda01dcd0ca174c3f654d6e61a4f406169d42a9054a407ff9ae585)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnRouteMixinProps":
        return typing.cast("CfnRouteMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnRouteServerAssociationMixinProps",
    jsii_struct_bases=[],
    name_mapping={"route_server_id": "routeServerId", "vpc_id": "vpcId"},
)
class CfnRouteServerAssociationMixinProps:
    def __init__(
        self,
        *,
        route_server_id: typing.Optional[builtins.str] = None,
        vpc_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnRouteServerAssociationPropsMixin.

        :param route_server_id: The ID of the associated route server.
        :param vpc_id: The ID of the associated VPC.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routeserverassociation.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_route_server_association_mixin_props = ec2_mixins.CfnRouteServerAssociationMixinProps(
                route_server_id="routeServerId",
                vpc_id="vpcId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7174855bc013932c701809b02578d449ee5584f3f0545561da096ba39ff8b7e1)
            check_type(argname="argument route_server_id", value=route_server_id, expected_type=type_hints["route_server_id"])
            check_type(argname="argument vpc_id", value=vpc_id, expected_type=type_hints["vpc_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if route_server_id is not None:
            self._values["route_server_id"] = route_server_id
        if vpc_id is not None:
            self._values["vpc_id"] = vpc_id

    @builtins.property
    def route_server_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the associated route server.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routeserverassociation.html#cfn-ec2-routeserverassociation-routeserverid
        '''
        result = self._values.get("route_server_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpc_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the associated VPC.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routeserverassociation.html#cfn-ec2-routeserverassociation-vpcid
        '''
        result = self._values.get("vpc_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnRouteServerAssociationMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnRouteServerAssociationPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnRouteServerAssociationPropsMixin",
):
    '''Specifies the association between a route server and a VPC.

    A route server association is the connection established between a route server and a VPC.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routeserverassociation.html
    :cloudformationResource: AWS::EC2::RouteServerAssociation
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_route_server_association_props_mixin = ec2_mixins.CfnRouteServerAssociationPropsMixin(ec2_mixins.CfnRouteServerAssociationMixinProps(
            route_server_id="routeServerId",
            vpc_id="vpcId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnRouteServerAssociationMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::RouteServerAssociation``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9a711b840d0c23decebfed2922534922a771c14c81270f37f1dda2e2b0f833c6)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b899f66692fa1d07e7aa13d7b7c23992d10158d1efbef81e5cb8f7d43750f12c)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fa6cb530e2c33493295049046ee06039a03dc2b373339be66958c8ba0d3d2699)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnRouteServerAssociationMixinProps":
        return typing.cast("CfnRouteServerAssociationMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnRouteServerEndpointMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "route_server_id": "routeServerId",
        "subnet_id": "subnetId",
        "tags": "tags",
    },
)
class CfnRouteServerEndpointMixinProps:
    def __init__(
        self,
        *,
        route_server_id: typing.Optional[builtins.str] = None,
        subnet_id: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnRouteServerEndpointPropsMixin.

        :param route_server_id: The ID of the route server associated with this endpoint.
        :param subnet_id: The ID of the subnet to place the route server endpoint into.
        :param tags: Any tags assigned to the route server endpoint.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routeserverendpoint.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_route_server_endpoint_mixin_props = ec2_mixins.CfnRouteServerEndpointMixinProps(
                route_server_id="routeServerId",
                subnet_id="subnetId",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5cfd42a155747febaa676b5905fae1016e14faa6de69402b1cd19cc9dff6d28d)
            check_type(argname="argument route_server_id", value=route_server_id, expected_type=type_hints["route_server_id"])
            check_type(argname="argument subnet_id", value=subnet_id, expected_type=type_hints["subnet_id"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if route_server_id is not None:
            self._values["route_server_id"] = route_server_id
        if subnet_id is not None:
            self._values["subnet_id"] = subnet_id
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def route_server_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the route server associated with this endpoint.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routeserverendpoint.html#cfn-ec2-routeserverendpoint-routeserverid
        '''
        result = self._values.get("route_server_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def subnet_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the subnet to place the route server endpoint into.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routeserverendpoint.html#cfn-ec2-routeserverendpoint-subnetid
        '''
        result = self._values.get("subnet_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''Any tags assigned to the route server endpoint.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routeserverendpoint.html#cfn-ec2-routeserverendpoint-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnRouteServerEndpointMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnRouteServerEndpointPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnRouteServerEndpointPropsMixin",
):
    '''Creates a new endpoint for a route server in a specified subnet.

    A route server endpoint is an AWS -managed component inside a subnet that facilitates `BGP (Border Gateway Protocol) <https://docs.aws.amazon.com/https://en.wikipedia.org/wiki/Border_Gateway_Protocol>`_ connections between your route server and your BGP peers.

    For more information see `Dynamic routing in your VPC with VPC Route Server <https://docs.aws.amazon.com/vpc/latest/userguide/dynamic-routing-route-server.html>`_ in the *Amazon VPC User Guide* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routeserverendpoint.html
    :cloudformationResource: AWS::EC2::RouteServerEndpoint
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_route_server_endpoint_props_mixin = ec2_mixins.CfnRouteServerEndpointPropsMixin(ec2_mixins.CfnRouteServerEndpointMixinProps(
            route_server_id="routeServerId",
            subnet_id="subnetId",
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnRouteServerEndpointMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::RouteServerEndpoint``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c60bb416cd1a8794c3e4df1f7f69f04097b4a7c11081b25a51ba34fbf0f7179c)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a32ad93e428e377c4a64c8f108328c2c0b20e9dca84941443ebbb41690713b98)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__33ccae950a0a43d1bcebca96d44572b17195cbe1b61d41189daf1403184f44ac)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnRouteServerEndpointMixinProps":
        return typing.cast("CfnRouteServerEndpointMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnRouteServerMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "amazon_side_asn": "amazonSideAsn",
        "persist_routes": "persistRoutes",
        "persist_routes_duration": "persistRoutesDuration",
        "sns_notifications_enabled": "snsNotificationsEnabled",
        "tags": "tags",
    },
)
class CfnRouteServerMixinProps:
    def __init__(
        self,
        *,
        amazon_side_asn: typing.Optional[jsii.Number] = None,
        persist_routes: typing.Optional[builtins.str] = None,
        persist_routes_duration: typing.Optional[jsii.Number] = None,
        sns_notifications_enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnRouteServerPropsMixin.

        :param amazon_side_asn: The Border Gateway Protocol (BGP) Autonomous System Number (ASN) for the appliance. Valid values are from 1 to 4294967295. We recommend using a private ASN in the 6451265534 (16-bit ASN) or 42000000004294967294 (32-bit ASN) range.
        :param persist_routes: Indicates whether routes should be persisted after all BGP sessions are terminated.
        :param persist_routes_duration: The number of minutes a route server will wait after BGP is re-established to unpersist the routes in the FIB and RIB. Value must be in the range of 1-5. The default value is 1. Only valid if ``persistRoutesState`` is 'enabled'. If you set the duration to 1 minute, then when your network appliance re-establishes BGP with route server, it has 1 minute to relearn it's adjacent network and advertise those routes to route server before route server resumes normal functionality. In most cases, 1 minute is probably sufficient. If, however, you have concerns that your BGP network may not be capable of fully re-establishing and re-learning everything in 1 minute, you can increase the duration up to 5 minutes.
        :param sns_notifications_enabled: Indicates whether SNS notifications are enabled for the route server. Enabling SNS notifications persists BGP status changes to an SNS topic provisioned by AWS .
        :param tags: Any tags assigned to the route server.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routeserver.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_route_server_mixin_props = ec2_mixins.CfnRouteServerMixinProps(
                amazon_side_asn=123,
                persist_routes="persistRoutes",
                persist_routes_duration=123,
                sns_notifications_enabled=False,
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2480af15cb2d3d35a13be6cb2714d1f50bb42da3bc913941f884b65fb9c5a0df)
            check_type(argname="argument amazon_side_asn", value=amazon_side_asn, expected_type=type_hints["amazon_side_asn"])
            check_type(argname="argument persist_routes", value=persist_routes, expected_type=type_hints["persist_routes"])
            check_type(argname="argument persist_routes_duration", value=persist_routes_duration, expected_type=type_hints["persist_routes_duration"])
            check_type(argname="argument sns_notifications_enabled", value=sns_notifications_enabled, expected_type=type_hints["sns_notifications_enabled"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if amazon_side_asn is not None:
            self._values["amazon_side_asn"] = amazon_side_asn
        if persist_routes is not None:
            self._values["persist_routes"] = persist_routes
        if persist_routes_duration is not None:
            self._values["persist_routes_duration"] = persist_routes_duration
        if sns_notifications_enabled is not None:
            self._values["sns_notifications_enabled"] = sns_notifications_enabled
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def amazon_side_asn(self) -> typing.Optional[jsii.Number]:
        '''The Border Gateway Protocol (BGP) Autonomous System Number (ASN) for the appliance.

        Valid values are from 1 to 4294967295. We recommend using a private ASN in the 6451265534 (16-bit ASN) or 42000000004294967294 (32-bit ASN) range.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routeserver.html#cfn-ec2-routeserver-amazonsideasn
        '''
        result = self._values.get("amazon_side_asn")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def persist_routes(self) -> typing.Optional[builtins.str]:
        '''Indicates whether routes should be persisted after all BGP sessions are terminated.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routeserver.html#cfn-ec2-routeserver-persistroutes
        '''
        result = self._values.get("persist_routes")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def persist_routes_duration(self) -> typing.Optional[jsii.Number]:
        '''The number of minutes a route server will wait after BGP is re-established to unpersist the routes in the FIB and RIB.

        Value must be in the range of 1-5. The default value is 1. Only valid if ``persistRoutesState`` is 'enabled'.

        If you set the duration to 1 minute, then when your network appliance re-establishes BGP with route server, it has 1 minute to relearn it's adjacent network and advertise those routes to route server before route server resumes normal functionality. In most cases, 1 minute is probably sufficient. If, however, you have concerns that your BGP network may not be capable of fully re-establishing and re-learning everything in 1 minute, you can increase the duration up to 5 minutes.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routeserver.html#cfn-ec2-routeserver-persistroutesduration
        '''
        result = self._values.get("persist_routes_duration")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sns_notifications_enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Indicates whether SNS notifications are enabled for the route server.

        Enabling SNS notifications persists BGP status changes to an SNS topic provisioned by AWS .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routeserver.html#cfn-ec2-routeserver-snsnotificationsenabled
        '''
        result = self._values.get("sns_notifications_enabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''Any tags assigned to the route server.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routeserver.html#cfn-ec2-routeserver-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnRouteServerMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class CfnRouteServerPeerEventLogs(
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnRouteServerPeerEventLogs",
):
    '''Builder for CfnRouteServerPeerLogsMixin to generate EVENT_LOGS for CfnRouteServerPeer.

    :cloudformationResource: AWS::EC2::RouteServerPeer
    :logType: EVENT_LOGS
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_route_server_peer_event_logs = ec2_mixins.CfnRouteServerPeerEventLogs()
    '''

    def __init__(self) -> None:
        '''
        :stability: experimental
        '''
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="toFirehose")
    def to_firehose(
        self,
        delivery_stream: "_aws_cdk_interfaces_aws_kinesisfirehose_ceddda9d.IDeliveryStreamRef",
    ) -> "CfnRouteServerPeerLogsMixin":
        '''Send logs to a Firehose Delivery Stream.

        :param delivery_stream: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e62af65b07d05908bdf46d749244d1cc99dffcd32323e46cecdfbebcbeb947b9)
            check_type(argname="argument delivery_stream", value=delivery_stream, expected_type=type_hints["delivery_stream"])
        return typing.cast("CfnRouteServerPeerLogsMixin", jsii.invoke(self, "toFirehose", [delivery_stream]))

    @jsii.member(jsii_name="toLogGroup")
    def to_log_group(
        self,
        log_group: "_aws_cdk_interfaces_aws_logs_ceddda9d.ILogGroupRef",
    ) -> "CfnRouteServerPeerLogsMixin":
        '''Send logs to a CloudWatch Log Group.

        :param log_group: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b982f19ff649590805549ffc3f5e8f8bf05456543fc9b2e398f71eb61adc82a4)
            check_type(argname="argument log_group", value=log_group, expected_type=type_hints["log_group"])
        return typing.cast("CfnRouteServerPeerLogsMixin", jsii.invoke(self, "toLogGroup", [log_group]))

    @jsii.member(jsii_name="toS3")
    def to_s3(
        self,
        bucket: "_aws_cdk_interfaces_aws_s3_ceddda9d.IBucketRef",
    ) -> "CfnRouteServerPeerLogsMixin":
        '''Send logs to an S3 Bucket.

        :param bucket: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e5aa15c5a090e9206ad9c49e22bbcd6540feaba02aa8a94bb2f96441f7de6fe9)
            check_type(argname="argument bucket", value=bucket, expected_type=type_hints["bucket"])
        return typing.cast("CfnRouteServerPeerLogsMixin", jsii.invoke(self, "toS3", [bucket]))


@jsii.implements(_IMixin_11e4b965)
class CfnRouteServerPeerLogsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnRouteServerPeerLogsMixin",
):
    '''Specifies a BGP peer configuration for a route server endpoint.

    A route server peer is a session between a route server endpoint and the device deployed in AWS (such as a firewall appliance or other network security function running on an EC2 instance).

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routeserverpeer.html
    :cloudformationResource: AWS::EC2::RouteServerPeer
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import aws_logs as logs
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        # logs_delivery: logs.ILogsDelivery
        
        cfn_route_server_peer_logs_mixin = ec2_mixins.CfnRouteServerPeerLogsMixin("logType", logs_delivery)
    '''

    def __init__(
        self,
        log_type: builtins.str,
        log_delivery: "_ILogsDelivery_0d3c9e29",
    ) -> None:
        '''Create a mixin to enable vended logs for ``AWS::EC2::RouteServerPeer``.

        :param log_type: Type of logs that are getting vended.
        :param log_delivery: Object in charge of setting up the delivery source, delivery destination, and delivery connection.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e887379c7ce461cf348e2d0a8886b52ad7923d6fee0347023e8e70995b5c98ad)
            check_type(argname="argument log_type", value=log_type, expected_type=type_hints["log_type"])
            check_type(argname="argument log_delivery", value=log_delivery, expected_type=type_hints["log_delivery"])
        jsii.create(self.__class__, self, [log_type, log_delivery])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        resource: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply vended logs configuration to the construct.

        :param resource: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b53a309af28da1eec8b32e48fe86c145f2eda70f8ac9c3a10faefedb25aa2368)
            check_type(argname="argument resource", value=resource, expected_type=type_hints["resource"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [resource]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct (has vendedLogs property).

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8e3988d66ef777b3f2816b11e3632f39fd0e01a4920356b90f4e74fc630aba7b)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="EVENT_LOGS")
    def EVENT_LOGS(cls) -> "CfnRouteServerPeerEventLogs":
        return typing.cast("CfnRouteServerPeerEventLogs", jsii.sget(cls, "EVENT_LOGS"))

    @builtins.property
    @jsii.member(jsii_name="logDelivery")
    def _log_delivery(self) -> "_ILogsDelivery_0d3c9e29":
        return typing.cast("_ILogsDelivery_0d3c9e29", jsii.get(self, "logDelivery"))

    @builtins.property
    @jsii.member(jsii_name="logType")
    def _log_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "logType"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnRouteServerPeerMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "bgp_options": "bgpOptions",
        "peer_address": "peerAddress",
        "route_server_endpoint_id": "routeServerEndpointId",
        "tags": "tags",
    },
)
class CfnRouteServerPeerMixinProps:
    def __init__(
        self,
        *,
        bgp_options: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnRouteServerPeerPropsMixin.BgpOptionsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        peer_address: typing.Optional[builtins.str] = None,
        route_server_endpoint_id: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnRouteServerPeerPropsMixin.

        :param bgp_options: The BGP configuration options for this peer, including ASN (Autonomous System Number) and BFD (Bidrectional Forwarding Detection) settings.
        :param peer_address: The IPv4 address of the peer device.
        :param route_server_endpoint_id: The ID of the route server endpoint associated with this peer.
        :param tags: Any tags assigned to the route server peer.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routeserverpeer.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_route_server_peer_mixin_props = ec2_mixins.CfnRouteServerPeerMixinProps(
                bgp_options=ec2_mixins.CfnRouteServerPeerPropsMixin.BgpOptionsProperty(
                    peer_asn=123,
                    peer_liveness_detection="peerLivenessDetection"
                ),
                peer_address="peerAddress",
                route_server_endpoint_id="routeServerEndpointId",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__23d7b4e4677f86ed600f3de488dd3f7d7c39e60069c06404abb424bc59bf8d40)
            check_type(argname="argument bgp_options", value=bgp_options, expected_type=type_hints["bgp_options"])
            check_type(argname="argument peer_address", value=peer_address, expected_type=type_hints["peer_address"])
            check_type(argname="argument route_server_endpoint_id", value=route_server_endpoint_id, expected_type=type_hints["route_server_endpoint_id"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if bgp_options is not None:
            self._values["bgp_options"] = bgp_options
        if peer_address is not None:
            self._values["peer_address"] = peer_address
        if route_server_endpoint_id is not None:
            self._values["route_server_endpoint_id"] = route_server_endpoint_id
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def bgp_options(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnRouteServerPeerPropsMixin.BgpOptionsProperty"]]:
        '''The BGP configuration options for this peer, including ASN (Autonomous System Number) and BFD (Bidrectional Forwarding Detection) settings.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routeserverpeer.html#cfn-ec2-routeserverpeer-bgpoptions
        '''
        result = self._values.get("bgp_options")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnRouteServerPeerPropsMixin.BgpOptionsProperty"]], result)

    @builtins.property
    def peer_address(self) -> typing.Optional[builtins.str]:
        '''The IPv4 address of the peer device.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routeserverpeer.html#cfn-ec2-routeserverpeer-peeraddress
        '''
        result = self._values.get("peer_address")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def route_server_endpoint_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the route server endpoint associated with this peer.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routeserverpeer.html#cfn-ec2-routeserverpeer-routeserverendpointid
        '''
        result = self._values.get("route_server_endpoint_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''Any tags assigned to the route server peer.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routeserverpeer.html#cfn-ec2-routeserverpeer-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnRouteServerPeerMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnRouteServerPeerPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnRouteServerPeerPropsMixin",
):
    '''Specifies a BGP peer configuration for a route server endpoint.

    A route server peer is a session between a route server endpoint and the device deployed in AWS (such as a firewall appliance or other network security function running on an EC2 instance).

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routeserverpeer.html
    :cloudformationResource: AWS::EC2::RouteServerPeer
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_route_server_peer_props_mixin = ec2_mixins.CfnRouteServerPeerPropsMixin(ec2_mixins.CfnRouteServerPeerMixinProps(
            bgp_options=ec2_mixins.CfnRouteServerPeerPropsMixin.BgpOptionsProperty(
                peer_asn=123,
                peer_liveness_detection="peerLivenessDetection"
            ),
            peer_address="peerAddress",
            route_server_endpoint_id="routeServerEndpointId",
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnRouteServerPeerMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::RouteServerPeer``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c916425b7277689a5ae6fa9518e048f868c9d1d8c3393ba03c5da02880780e76)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6eed4970751922be1e775116d5884975b78fc7128aa90337633b315961e3a5dd)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0340163d25fc60edd6a8977bc60f424d104bf72b0a3d3c34004932d89ea2a126)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnRouteServerPeerMixinProps":
        return typing.cast("CfnRouteServerPeerMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnRouteServerPeerPropsMixin.BgpOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "peer_asn": "peerAsn",
            "peer_liveness_detection": "peerLivenessDetection",
        },
    )
    class BgpOptionsProperty:
        def __init__(
            self,
            *,
            peer_asn: typing.Optional[jsii.Number] = None,
            peer_liveness_detection: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The BGP configuration options for this peer, including ASN (Autonomous System Number) and BFD (Bidrectional Forwarding Detection) settings.

            :param peer_asn: The Border Gateway Protocol (BGP) Autonomous System Number (ASN) for the appliance. Valid values are from 1 to 4294967295. We recommend using a private ASN in the 6451265534 (16-bit ASN) or 42000000004294967294 (32-bit ASN) range.
            :param peer_liveness_detection: The liveness detection protocol used for the BGP peer. The requested liveness detection protocol for the BGP peer. - ``bgp-keepalive`` : The standard BGP keep alive mechanism ( `RFC4271 <https://docs.aws.amazon.com/https://www.rfc-editor.org/rfc/rfc4271#page-21>`_ ) that is stable but may take longer to fail-over in cases of network impact or router failure. - ``bfd`` : An additional Bidirectional Forwarding Detection (BFD) protocol ( `RFC5880 <https://docs.aws.amazon.com/https://www.rfc-editor.org/rfc/rfc5880>`_ ) that enables fast failover by using more sensitive liveness detection. Defaults to ``bgp-keepalive`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-routeserverpeer-bgpoptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                bgp_options_property = ec2_mixins.CfnRouteServerPeerPropsMixin.BgpOptionsProperty(
                    peer_asn=123,
                    peer_liveness_detection="peerLivenessDetection"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__a4ff7f4b8e93cf4c4b3d217e320f4ee147cb8d2b269aeac4ec8bbbdc7d4843e0)
                check_type(argname="argument peer_asn", value=peer_asn, expected_type=type_hints["peer_asn"])
                check_type(argname="argument peer_liveness_detection", value=peer_liveness_detection, expected_type=type_hints["peer_liveness_detection"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if peer_asn is not None:
                self._values["peer_asn"] = peer_asn
            if peer_liveness_detection is not None:
                self._values["peer_liveness_detection"] = peer_liveness_detection

        @builtins.property
        def peer_asn(self) -> typing.Optional[jsii.Number]:
            '''The Border Gateway Protocol (BGP) Autonomous System Number (ASN) for the appliance.

            Valid values are from 1 to 4294967295. We recommend using a private ASN in the 6451265534 (16-bit ASN) or 42000000004294967294 (32-bit ASN) range.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-routeserverpeer-bgpoptions.html#cfn-ec2-routeserverpeer-bgpoptions-peerasn
            '''
            result = self._values.get("peer_asn")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def peer_liveness_detection(self) -> typing.Optional[builtins.str]:
            '''The liveness detection protocol used for the BGP peer.

            The requested liveness detection protocol for the BGP peer.

            - ``bgp-keepalive`` : The standard BGP keep alive mechanism ( `RFC4271 <https://docs.aws.amazon.com/https://www.rfc-editor.org/rfc/rfc4271#page-21>`_ ) that is stable but may take longer to fail-over in cases of network impact or router failure.
            - ``bfd`` : An additional Bidirectional Forwarding Detection (BFD) protocol ( `RFC5880 <https://docs.aws.amazon.com/https://www.rfc-editor.org/rfc/rfc5880>`_ ) that enables fast failover by using more sensitive liveness detection.

            Defaults to ``bgp-keepalive`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-routeserverpeer-bgpoptions.html#cfn-ec2-routeserverpeer-bgpoptions-peerlivenessdetection
            '''
            result = self._values.get("peer_liveness_detection")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "BgpOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnRouteServerPropagationMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "route_server_id": "routeServerId",
        "route_table_id": "routeTableId",
    },
)
class CfnRouteServerPropagationMixinProps:
    def __init__(
        self,
        *,
        route_server_id: typing.Optional[builtins.str] = None,
        route_table_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnRouteServerPropagationPropsMixin.

        :param route_server_id: The ID of the route server configured for route propagation.
        :param route_table_id: The ID of the route table configured for route server propagation.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routeserverpropagation.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_route_server_propagation_mixin_props = ec2_mixins.CfnRouteServerPropagationMixinProps(
                route_server_id="routeServerId",
                route_table_id="routeTableId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f60d31a866abdd61948547c41cc7342a7ef13569d0bef024dabbec56e3adaaf1)
            check_type(argname="argument route_server_id", value=route_server_id, expected_type=type_hints["route_server_id"])
            check_type(argname="argument route_table_id", value=route_table_id, expected_type=type_hints["route_table_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if route_server_id is not None:
            self._values["route_server_id"] = route_server_id
        if route_table_id is not None:
            self._values["route_table_id"] = route_table_id

    @builtins.property
    def route_server_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the route server configured for route propagation.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routeserverpropagation.html#cfn-ec2-routeserverpropagation-routeserverid
        '''
        result = self._values.get("route_server_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def route_table_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the route table configured for route server propagation.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routeserverpropagation.html#cfn-ec2-routeserverpropagation-routetableid
        '''
        result = self._values.get("route_table_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnRouteServerPropagationMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnRouteServerPropagationPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnRouteServerPropagationPropsMixin",
):
    '''Specifies route propagation from a route server to a route table.

    For more information see `Dynamic routing in your VPC with VPC Route Server <https://docs.aws.amazon.com/vpc/latest/userguide/dynamic-routing-route-server.html>`_ in the *Amazon VPC User Guide* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routeserverpropagation.html
    :cloudformationResource: AWS::EC2::RouteServerPropagation
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_route_server_propagation_props_mixin = ec2_mixins.CfnRouteServerPropagationPropsMixin(ec2_mixins.CfnRouteServerPropagationMixinProps(
            route_server_id="routeServerId",
            route_table_id="routeTableId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnRouteServerPropagationMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::RouteServerPropagation``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e525643ecdde452c5ec34e33b78dc4df260e6fbd7f393e2cfe8faa9872d458fd)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9b70bb1ec8b7007a0da1e231e1014ec2f61bc5bf64117fde375b90ad562de322)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f681d6ccb4601c45d7c542e6845fbfe3a38ae1aacb1bc1af89523812022fa1a9)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnRouteServerPropagationMixinProps":
        return typing.cast("CfnRouteServerPropagationMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.implements(_IMixin_11e4b965)
class CfnRouteServerPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnRouteServerPropsMixin",
):
    '''Specifies a route server to manage dynamic routing in a VPC.

    Amazon VPC Route Server simplifies routing for traffic between workloads that are deployed within a VPC and its internet gateways. With this feature, VPC Route Server dynamically updates VPC and internet gateway route tables with your preferred routes to achieve routing fault tolerance for those workloads. This enables you to automatically reroute traffic within a VPC, which increases the manageability of VPC routing and interoperability with third-party workloads.

    For more information see `Dynamic routing in your VPC with VPC Route Server <https://docs.aws.amazon.com/vpc/latest/userguide/dynamic-routing-route-server.html>`_ in the *Amazon VPC User Guide* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routeserver.html
    :cloudformationResource: AWS::EC2::RouteServer
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_route_server_props_mixin = ec2_mixins.CfnRouteServerPropsMixin(ec2_mixins.CfnRouteServerMixinProps(
            amazon_side_asn=123,
            persist_routes="persistRoutes",
            persist_routes_duration=123,
            sns_notifications_enabled=False,
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnRouteServerMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::RouteServer``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__39a64501aff440c7baeb3cf595a9488753c2a8763ba176e2150c096df6e8b50b)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__667fc4040bc5a0ddbbbe46c61a7d4fd1b0985aff398baf70c6823d4e67389292)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__971b6f87df1615275c1559054d9f25f32115cb40e1ad701f1d5f2bf7c2235e0d)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnRouteServerMixinProps":
        return typing.cast("CfnRouteServerMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnRouteTableMixinProps",
    jsii_struct_bases=[],
    name_mapping={"tags": "tags", "vpc_id": "vpcId"},
)
class CfnRouteTableMixinProps:
    def __init__(
        self,
        *,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        vpc_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnRouteTablePropsMixin.

        :param tags: Any tags assigned to the route table.
        :param vpc_id: The ID of the VPC.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routetable.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_route_table_mixin_props = ec2_mixins.CfnRouteTableMixinProps(
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                vpc_id="vpcId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__57d211aefa5d44f81b9bd1aa488a05b8f3322ef57ad58ead910d9766bdb892d8)
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument vpc_id", value=vpc_id, expected_type=type_hints["vpc_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if tags is not None:
            self._values["tags"] = tags
        if vpc_id is not None:
            self._values["vpc_id"] = vpc_id

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''Any tags assigned to the route table.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routetable.html#cfn-ec2-routetable-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def vpc_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the VPC.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routetable.html#cfn-ec2-routetable-vpcid
        '''
        result = self._values.get("vpc_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnRouteTableMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnRouteTablePropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnRouteTablePropsMixin",
):
    '''Specifies a route table for the specified VPC.

    After you create a route table, you can add routes and associate the table with a subnet.

    For more information, see `Route tables <https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Route_Tables.html>`_ in the *Amazon VPC User Guide* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routetable.html
    :cloudformationResource: AWS::EC2::RouteTable
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_route_table_props_mixin = ec2_mixins.CfnRouteTablePropsMixin(ec2_mixins.CfnRouteTableMixinProps(
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            vpc_id="vpcId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnRouteTableMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::RouteTable``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1f01ca4cef3ef219214ace82860edb224714e9d3764625ecb187b278817e46f9)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cf9d91b3e55497efebe78b86dc6b08f757be3a31e494b3ce030274cdcdffde63)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c72de2109c79077a69626bb9fa6ad1f1af9e834eeea6b6f725c03c0716649bb3)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnRouteTableMixinProps":
        return typing.cast("CfnRouteTableMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSecurityGroupEgressMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "cidr_ip": "cidrIp",
        "cidr_ipv6": "cidrIpv6",
        "description": "description",
        "destination_prefix_list_id": "destinationPrefixListId",
        "destination_security_group_id": "destinationSecurityGroupId",
        "from_port": "fromPort",
        "group_id": "groupId",
        "ip_protocol": "ipProtocol",
        "to_port": "toPort",
    },
)
class CfnSecurityGroupEgressMixinProps:
    def __init__(
        self,
        *,
        cidr_ip: typing.Optional[builtins.str] = None,
        cidr_ipv6: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        destination_prefix_list_id: typing.Optional[builtins.str] = None,
        destination_security_group_id: typing.Optional[builtins.str] = None,
        from_port: typing.Optional[jsii.Number] = None,
        group_id: typing.Optional[builtins.str] = None,
        ip_protocol: typing.Optional[builtins.str] = None,
        to_port: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Properties for CfnSecurityGroupEgressPropsMixin.

        :param cidr_ip: The IPv4 address range, in CIDR format. You must specify exactly one of the following: ``CidrIp`` , ``CidrIpv6`` , ``DestinationPrefixListId`` , or ``DestinationSecurityGroupId`` . For examples of rules that you can add to security groups for specific access scenarios, see `Security group rules for different use cases <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html>`_ in the *Amazon EC2 User Guide* .
        :param cidr_ipv6: The IPv6 address range, in CIDR format. You must specify exactly one of the following: ``CidrIp`` , ``CidrIpv6`` , ``DestinationPrefixListId`` , or ``DestinationSecurityGroupId`` . For examples of rules that you can add to security groups for specific access scenarios, see `Security group rules for different use cases <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html>`_ in the *Amazon EC2 User Guide* .
        :param description: The description of an egress (outbound) security group rule. Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
        :param destination_prefix_list_id: The prefix list IDs for an AWS service. This is the AWS service to access through a VPC endpoint from instances associated with the security group. You must specify exactly one of the following: ``CidrIp`` , ``CidrIpv6`` , ``DestinationPrefixListId`` , or ``DestinationSecurityGroupId`` .
        :param destination_security_group_id: The ID of the security group. You must specify exactly one of the following: ``CidrIp`` , ``CidrIpv6`` , ``DestinationPrefixListId`` , or ``DestinationSecurityGroupId`` .
        :param from_port: If the protocol is TCP or UDP, this is the start of the port range. If the protocol is ICMP or ICMPv6, this is the ICMP type or -1 (all ICMP types).
        :param group_id: The ID of the security group. You must specify either the security group ID or the security group name in the request. For security groups in a nondefault VPC, you must specify the security group ID.
        :param ip_protocol: The IP protocol name ( ``tcp`` , ``udp`` , ``icmp`` , ``icmpv6`` ) or number (see `Protocol Numbers <https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml>`_ ). Use ``-1`` to specify all protocols. When authorizing security group rules, specifying ``-1`` or a protocol number other than ``tcp`` , ``udp`` , ``icmp`` , or ``icmpv6`` allows traffic on all ports, regardless of any port range you specify. For ``tcp`` , ``udp`` , and ``icmp`` , you must specify a port range. For ``icmpv6`` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.
        :param to_port: If the protocol is TCP or UDP, this is the end of the port range. If the protocol is ICMP or ICMPv6, this is the ICMP code or -1 (all ICMP codes). If the start port is -1 (all ICMP types), then the end port must be -1 (all ICMP codes).

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_security_group_egress_mixin_props = ec2_mixins.CfnSecurityGroupEgressMixinProps(
                cidr_ip="cidrIp",
                cidr_ipv6="cidrIpv6",
                description="description",
                destination_prefix_list_id="destinationPrefixListId",
                destination_security_group_id="destinationSecurityGroupId",
                from_port=123,
                group_id="groupId",
                ip_protocol="ipProtocol",
                to_port=123
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3c3899d635c39e73e3cabe279f23c268324e8d4bd394f194900b08595bd28d95)
            check_type(argname="argument cidr_ip", value=cidr_ip, expected_type=type_hints["cidr_ip"])
            check_type(argname="argument cidr_ipv6", value=cidr_ipv6, expected_type=type_hints["cidr_ipv6"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument destination_prefix_list_id", value=destination_prefix_list_id, expected_type=type_hints["destination_prefix_list_id"])
            check_type(argname="argument destination_security_group_id", value=destination_security_group_id, expected_type=type_hints["destination_security_group_id"])
            check_type(argname="argument from_port", value=from_port, expected_type=type_hints["from_port"])
            check_type(argname="argument group_id", value=group_id, expected_type=type_hints["group_id"])
            check_type(argname="argument ip_protocol", value=ip_protocol, expected_type=type_hints["ip_protocol"])
            check_type(argname="argument to_port", value=to_port, expected_type=type_hints["to_port"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if cidr_ip is not None:
            self._values["cidr_ip"] = cidr_ip
        if cidr_ipv6 is not None:
            self._values["cidr_ipv6"] = cidr_ipv6
        if description is not None:
            self._values["description"] = description
        if destination_prefix_list_id is not None:
            self._values["destination_prefix_list_id"] = destination_prefix_list_id
        if destination_security_group_id is not None:
            self._values["destination_security_group_id"] = destination_security_group_id
        if from_port is not None:
            self._values["from_port"] = from_port
        if group_id is not None:
            self._values["group_id"] = group_id
        if ip_protocol is not None:
            self._values["ip_protocol"] = ip_protocol
        if to_port is not None:
            self._values["to_port"] = to_port

    @builtins.property
    def cidr_ip(self) -> typing.Optional[builtins.str]:
        '''The IPv4 address range, in CIDR format.

        You must specify exactly one of the following: ``CidrIp`` , ``CidrIpv6`` , ``DestinationPrefixListId`` , or ``DestinationSecurityGroupId`` .

        For examples of rules that you can add to security groups for specific access scenarios, see `Security group rules for different use cases <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html>`_ in the *Amazon EC2 User Guide* .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-cidrip
        '''
        result = self._values.get("cidr_ip")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def cidr_ipv6(self) -> typing.Optional[builtins.str]:
        '''The IPv6 address range, in CIDR format.

        You must specify exactly one of the following: ``CidrIp`` , ``CidrIpv6`` , ``DestinationPrefixListId`` , or ``DestinationSecurityGroupId`` .

        For examples of rules that you can add to security groups for specific access scenarios, see `Security group rules for different use cases <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html>`_ in the *Amazon EC2 User Guide* .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-cidripv6
        '''
        result = self._values.get("cidr_ipv6")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''The description of an egress (outbound) security group rule.

        Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def destination_prefix_list_id(self) -> typing.Optional[builtins.str]:
        '''The prefix list IDs for an AWS service.

        This is the AWS service to access through a VPC endpoint from instances associated with the security group.

        You must specify exactly one of the following: ``CidrIp`` , ``CidrIpv6`` , ``DestinationPrefixListId`` , or ``DestinationSecurityGroupId`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-destinationprefixlistid
        '''
        result = self._values.get("destination_prefix_list_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def destination_security_group_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the security group.

        You must specify exactly one of the following: ``CidrIp`` , ``CidrIpv6`` , ``DestinationPrefixListId`` , or ``DestinationSecurityGroupId`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-destinationsecuritygroupid
        '''
        result = self._values.get("destination_security_group_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def from_port(self) -> typing.Optional[jsii.Number]:
        '''If the protocol is TCP or UDP, this is the start of the port range.

        If the protocol is ICMP or ICMPv6, this is the ICMP type or -1 (all ICMP types).

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-fromport
        '''
        result = self._values.get("from_port")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def group_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the security group.

        You must specify either the security group ID or the security group name in the request. For security groups in a nondefault VPC, you must specify the security group ID.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-groupid
        '''
        result = self._values.get("group_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ip_protocol(self) -> typing.Optional[builtins.str]:
        '''The IP protocol name ( ``tcp`` , ``udp`` , ``icmp`` , ``icmpv6`` ) or number (see `Protocol Numbers <https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml>`_ ).

        Use ``-1`` to specify all protocols. When authorizing security group rules, specifying ``-1`` or a protocol number other than ``tcp`` , ``udp`` , ``icmp`` , or ``icmpv6`` allows traffic on all ports, regardless of any port range you specify. For ``tcp`` , ``udp`` , and ``icmp`` , you must specify a port range. For ``icmpv6`` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-ipprotocol
        '''
        result = self._values.get("ip_protocol")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def to_port(self) -> typing.Optional[jsii.Number]:
        '''If the protocol is TCP or UDP, this is the end of the port range.

        If the protocol is ICMP or ICMPv6, this is the ICMP code or -1 (all ICMP codes). If the start port is -1 (all ICMP types), then the end port must be -1 (all ICMP codes).

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-toport
        '''
        result = self._values.get("to_port")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnSecurityGroupEgressMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnSecurityGroupEgressPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSecurityGroupEgressPropsMixin",
):
    '''Adds the specified outbound (egress) rule to a security group.

    An outbound rule permits instances to send traffic to the specified IPv4 or IPv6 address range, the IP addresses that are specified by a prefix list, or the instances that are associated with a destination security group. For more information, see `Security group rules <https://docs.aws.amazon.com/vpc/latest/userguide/security-group-rules.html>`_ .

    You must specify exactly one of the following destinations: an IPv4 address range, an IPv6 address range, a prefix list, or a security group.

    You must specify a protocol for each rule (for example, TCP). If the protocol is TCP or UDP, you must also specify a port or port range. If the protocol is ICMP or ICMPv6, you must also specify the ICMP/ICMPv6 type and code. To specify all types or all codes, use -1.

    Rule changes are propagated to instances associated with the security group as quickly as possible. However, a small delay might occur.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html
    :cloudformationResource: AWS::EC2::SecurityGroupEgress
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_security_group_egress_props_mixin = ec2_mixins.CfnSecurityGroupEgressPropsMixin(ec2_mixins.CfnSecurityGroupEgressMixinProps(
            cidr_ip="cidrIp",
            cidr_ipv6="cidrIpv6",
            description="description",
            destination_prefix_list_id="destinationPrefixListId",
            destination_security_group_id="destinationSecurityGroupId",
            from_port=123,
            group_id="groupId",
            ip_protocol="ipProtocol",
            to_port=123
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnSecurityGroupEgressMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::SecurityGroupEgress``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__607aea1004b764eb4f8771cd8db8ebcda47e35d3c3c9426e71febe8f818b8ef1)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__37777a183f1a008728df9f0ba720fd16295f1572d144357b6f333dee1f1fbee6)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__495acd89dd53cca5a5143a0d7b41479e6cb1015fcda0d5028ed7702959078695)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnSecurityGroupEgressMixinProps":
        return typing.cast("CfnSecurityGroupEgressMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSecurityGroupIngressMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "cidr_ip": "cidrIp",
        "cidr_ipv6": "cidrIpv6",
        "description": "description",
        "from_port": "fromPort",
        "group_id": "groupId",
        "group_name": "groupName",
        "ip_protocol": "ipProtocol",
        "source_prefix_list_id": "sourcePrefixListId",
        "source_security_group_id": "sourceSecurityGroupId",
        "source_security_group_name": "sourceSecurityGroupName",
        "source_security_group_owner_id": "sourceSecurityGroupOwnerId",
        "to_port": "toPort",
    },
)
class CfnSecurityGroupIngressMixinProps:
    def __init__(
        self,
        *,
        cidr_ip: typing.Optional[builtins.str] = None,
        cidr_ipv6: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        from_port: typing.Optional[jsii.Number] = None,
        group_id: typing.Optional[builtins.str] = None,
        group_name: typing.Optional[builtins.str] = None,
        ip_protocol: typing.Optional[builtins.str] = None,
        source_prefix_list_id: typing.Optional[builtins.str] = None,
        source_security_group_id: typing.Optional[builtins.str] = None,
        source_security_group_name: typing.Optional[builtins.str] = None,
        source_security_group_owner_id: typing.Optional[builtins.str] = None,
        to_port: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Properties for CfnSecurityGroupIngressPropsMixin.

        :param cidr_ip: The IPv4 address range, in CIDR format. You must specify exactly one of the following: ``CidrIp`` , ``CidrIpv6`` , ``SourcePrefixListId`` , or ``SourceSecurityGroupId`` . For examples of rules that you can add to security groups for specific access scenarios, see `Security group rules for different use cases <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html>`_ in the *Amazon EC2 User Guide* .
        :param cidr_ipv6: The IPv6 address range, in CIDR format. You must specify exactly one of the following: ``CidrIp`` , ``CidrIpv6`` , ``SourcePrefixListId`` , or ``SourceSecurityGroupId`` . For examples of rules that you can add to security groups for specific access scenarios, see `Security group rules for different use cases <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html>`_ in the *Amazon EC2 User Guide* .
        :param description: Updates the description of an ingress (inbound) security group rule. You can replace an existing description, or add a description to a rule that did not have one previously. Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
        :param from_port: The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number. A value of ``-1`` indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all codes. Use this for ICMP and any protocol that uses ports.
        :param group_id: The ID of the security group.
        :param group_name: [Default VPC] The name of the security group. For security groups for a default VPC you can specify either the ID or the name of the security group. For security groups for a nondefault VPC, you must specify the ID of the security group.
        :param ip_protocol: The IP protocol name ( ``tcp`` , ``udp`` , ``icmp`` , ``icmpv6`` ) or number (see `Protocol Numbers <https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml>`_ ). Use ``-1`` to specify all protocols. When authorizing security group rules, specifying ``-1`` or a protocol number other than ``tcp`` , ``udp`` , ``icmp`` , or ``icmpv6`` allows traffic on all ports, regardless of any port range you specify. For ``tcp`` , ``udp`` , and ``icmp`` , you must specify a port range. For ``icmpv6`` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.
        :param source_prefix_list_id: The ID of a prefix list.
        :param source_security_group_id: The ID of the security group. You must specify either the security group ID or the security group name. For security groups in a nondefault VPC, you must specify the security group ID.
        :param source_security_group_name: [Default VPC] The name of the source security group. You must specify either the security group ID or the security group name. You can't specify the group name in combination with an IP address range. Creates rules that grant full ICMP, UDP, and TCP access. For security groups in a nondefault VPC, you must specify the group ID.
        :param source_security_group_owner_id: [nondefault VPC] The AWS account ID for the source security group, if the source security group is in a different account. You can't specify this property with an IP address range. Creates rules that grant full ICMP, UDP, and TCP access. If you specify ``SourceSecurityGroupName`` or ``SourceSecurityGroupId`` and that security group is owned by a different account than the account creating the stack, you must specify ``SourceSecurityGroupOwnerId`` ; otherwise, this property is optional.
        :param to_port: The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code. A value of ``-1`` indicates all ICMP/ICMPv6 codes for the specified ICMP type. If you specify all ICMP/ICMPv6 types, you must specify all codes. Use this for ICMP and any protocol that uses ports.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_security_group_ingress_mixin_props = ec2_mixins.CfnSecurityGroupIngressMixinProps(
                cidr_ip="cidrIp",
                cidr_ipv6="cidrIpv6",
                description="description",
                from_port=123,
                group_id="groupId",
                group_name="groupName",
                ip_protocol="ipProtocol",
                source_prefix_list_id="sourcePrefixListId",
                source_security_group_id="sourceSecurityGroupId",
                source_security_group_name="sourceSecurityGroupName",
                source_security_group_owner_id="sourceSecurityGroupOwnerId",
                to_port=123
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6c56bf6a2395c3ca5a91c2d8ceccf287dce6a1f41b3a3edbb1cbdb92ecd3a5f5)
            check_type(argname="argument cidr_ip", value=cidr_ip, expected_type=type_hints["cidr_ip"])
            check_type(argname="argument cidr_ipv6", value=cidr_ipv6, expected_type=type_hints["cidr_ipv6"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument from_port", value=from_port, expected_type=type_hints["from_port"])
            check_type(argname="argument group_id", value=group_id, expected_type=type_hints["group_id"])
            check_type(argname="argument group_name", value=group_name, expected_type=type_hints["group_name"])
            check_type(argname="argument ip_protocol", value=ip_protocol, expected_type=type_hints["ip_protocol"])
            check_type(argname="argument source_prefix_list_id", value=source_prefix_list_id, expected_type=type_hints["source_prefix_list_id"])
            check_type(argname="argument source_security_group_id", value=source_security_group_id, expected_type=type_hints["source_security_group_id"])
            check_type(argname="argument source_security_group_name", value=source_security_group_name, expected_type=type_hints["source_security_group_name"])
            check_type(argname="argument source_security_group_owner_id", value=source_security_group_owner_id, expected_type=type_hints["source_security_group_owner_id"])
            check_type(argname="argument to_port", value=to_port, expected_type=type_hints["to_port"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if cidr_ip is not None:
            self._values["cidr_ip"] = cidr_ip
        if cidr_ipv6 is not None:
            self._values["cidr_ipv6"] = cidr_ipv6
        if description is not None:
            self._values["description"] = description
        if from_port is not None:
            self._values["from_port"] = from_port
        if group_id is not None:
            self._values["group_id"] = group_id
        if group_name is not None:
            self._values["group_name"] = group_name
        if ip_protocol is not None:
            self._values["ip_protocol"] = ip_protocol
        if source_prefix_list_id is not None:
            self._values["source_prefix_list_id"] = source_prefix_list_id
        if source_security_group_id is not None:
            self._values["source_security_group_id"] = source_security_group_id
        if source_security_group_name is not None:
            self._values["source_security_group_name"] = source_security_group_name
        if source_security_group_owner_id is not None:
            self._values["source_security_group_owner_id"] = source_security_group_owner_id
        if to_port is not None:
            self._values["to_port"] = to_port

    @builtins.property
    def cidr_ip(self) -> typing.Optional[builtins.str]:
        '''The IPv4 address range, in CIDR format.

        You must specify exactly one of the following: ``CidrIp`` , ``CidrIpv6`` , ``SourcePrefixListId`` , or ``SourceSecurityGroupId`` .

        For examples of rules that you can add to security groups for specific access scenarios, see `Security group rules for different use cases <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html>`_ in the *Amazon EC2 User Guide* .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-cidrip
        '''
        result = self._values.get("cidr_ip")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def cidr_ipv6(self) -> typing.Optional[builtins.str]:
        '''The IPv6 address range, in CIDR format.

        You must specify exactly one of the following: ``CidrIp`` , ``CidrIpv6`` , ``SourcePrefixListId`` , or ``SourceSecurityGroupId`` .

        For examples of rules that you can add to security groups for specific access scenarios, see `Security group rules for different use cases <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html>`_ in the *Amazon EC2 User Guide* .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-cidripv6
        '''
        result = self._values.get("cidr_ipv6")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''Updates the description of an ingress (inbound) security group rule.

        You can replace an existing description, or add a description to a rule that did not have one previously.

        Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def from_port(self) -> typing.Optional[jsii.Number]:
        '''The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number.

        A value of ``-1`` indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all codes.

        Use this for ICMP and any protocol that uses ports.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-fromport
        '''
        result = self._values.get("from_port")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def group_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the security group.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-groupid
        '''
        result = self._values.get("group_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def group_name(self) -> typing.Optional[builtins.str]:
        '''[Default VPC] The name of the security group.

        For security groups for a default VPC you can specify either the ID or the name of the security group. For security groups for a nondefault VPC, you must specify the ID of the security group.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-groupname
        '''
        result = self._values.get("group_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ip_protocol(self) -> typing.Optional[builtins.str]:
        '''The IP protocol name ( ``tcp`` , ``udp`` , ``icmp`` , ``icmpv6`` ) or number (see `Protocol Numbers <https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml>`_ ).

        Use ``-1`` to specify all protocols. When authorizing security group rules, specifying ``-1`` or a protocol number other than ``tcp`` , ``udp`` , ``icmp`` , or ``icmpv6`` allows traffic on all ports, regardless of any port range you specify. For ``tcp`` , ``udp`` , and ``icmp`` , you must specify a port range. For ``icmpv6`` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-ipprotocol
        '''
        result = self._values.get("ip_protocol")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def source_prefix_list_id(self) -> typing.Optional[builtins.str]:
        '''The ID of a prefix list.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-sourceprefixlistid
        '''
        result = self._values.get("source_prefix_list_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def source_security_group_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the security group.

        You must specify either the security group ID or the security group name. For security groups in a nondefault VPC, you must specify the security group ID.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-sourcesecuritygroupid
        '''
        result = self._values.get("source_security_group_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def source_security_group_name(self) -> typing.Optional[builtins.str]:
        '''[Default VPC] The name of the source security group.

        You must specify either the security group ID or the security group name. You can't specify the group name in combination with an IP address range. Creates rules that grant full ICMP, UDP, and TCP access.

        For security groups in a nondefault VPC, you must specify the group ID.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-sourcesecuritygroupname
        '''
        result = self._values.get("source_security_group_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def source_security_group_owner_id(self) -> typing.Optional[builtins.str]:
        '''[nondefault VPC] The AWS account ID for the source security group, if the source security group is in a different account.

        You can't specify this property with an IP address range. Creates rules that grant full ICMP, UDP, and TCP access.

        If you specify ``SourceSecurityGroupName`` or ``SourceSecurityGroupId`` and that security group is owned by a different account than the account creating the stack, you must specify ``SourceSecurityGroupOwnerId`` ; otherwise, this property is optional.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-sourcesecuritygroupownerid
        '''
        result = self._values.get("source_security_group_owner_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def to_port(self) -> typing.Optional[jsii.Number]:
        '''The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code.

        A value of ``-1`` indicates all ICMP/ICMPv6 codes for the specified ICMP type. If you specify all ICMP/ICMPv6 types, you must specify all codes.

        Use this for ICMP and any protocol that uses ports.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html#cfn-ec2-securitygroupingress-toport
        '''
        result = self._values.get("to_port")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnSecurityGroupIngressMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnSecurityGroupIngressPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSecurityGroupIngressPropsMixin",
):
    '''Adds an inbound (ingress) rule to a security group.

    An inbound rule permits instances to receive traffic from the specified IPv4 or IPv6 address range, the IP addresses that are specified by a prefix list, or the instances that are associated with a source security group. For more information, see `Security group rules <https://docs.aws.amazon.com/vpc/latest/userguide/security-group-rules.html>`_ .

    You must specify exactly one of the following sources: an IPv4 address range, an IPv6 address range, a prefix list, or a security group.

    You must specify a protocol for each rule (for example, TCP). If the protocol is TCP or UDP, you must also specify a port or port range. If the protocol is ICMP or ICMPv6, you must also specify the ICMP/ICMPv6 type and code.

    Rule changes are propagated to instances associated with the security group as quickly as possible. However, a small delay might occur.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupingress.html
    :cloudformationResource: AWS::EC2::SecurityGroupIngress
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_security_group_ingress_props_mixin = ec2_mixins.CfnSecurityGroupIngressPropsMixin(ec2_mixins.CfnSecurityGroupIngressMixinProps(
            cidr_ip="cidrIp",
            cidr_ipv6="cidrIpv6",
            description="description",
            from_port=123,
            group_id="groupId",
            group_name="groupName",
            ip_protocol="ipProtocol",
            source_prefix_list_id="sourcePrefixListId",
            source_security_group_id="sourceSecurityGroupId",
            source_security_group_name="sourceSecurityGroupName",
            source_security_group_owner_id="sourceSecurityGroupOwnerId",
            to_port=123
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnSecurityGroupIngressMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::SecurityGroupIngress``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6af1b4c6e7913a8b26366e182e9e0eabf9b91f97c7e48cf80fe00e7e7dae3b96)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0bafbd199e4d8bbf31b8e47b0703a8e6e739897735c522f31913ab54a14d9214)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__23e498a34184f6c2bab0fec1f0bae81d209871c1937d4ca426a1dc3036a95f29)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnSecurityGroupIngressMixinProps":
        return typing.cast("CfnSecurityGroupIngressMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSecurityGroupMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "group_description": "groupDescription",
        "group_name": "groupName",
        "security_group_egress": "securityGroupEgress",
        "security_group_ingress": "securityGroupIngress",
        "tags": "tags",
        "vpc_id": "vpcId",
    },
)
class CfnSecurityGroupMixinProps:
    def __init__(
        self,
        *,
        group_description: typing.Optional[builtins.str] = None,
        group_name: typing.Optional[builtins.str] = None,
        security_group_egress: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSecurityGroupPropsMixin.EgressProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        security_group_ingress: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSecurityGroupPropsMixin.IngressProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        vpc_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnSecurityGroupPropsMixin.

        :param group_description: A description for the security group. Constraints: Up to 255 characters in length Valid characters: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*
        :param group_name: The name of the security group. Names are case-insensitive and must be unique within the VPC. Constraints: Up to 255 characters in length. Can't start with ``sg-`` . Valid characters: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*
        :param security_group_egress: The outbound rules associated with the security group.
        :param security_group_ingress: The inbound rules associated with the security group.
        :param tags: Any tags assigned to the security group.
        :param vpc_id: The ID of the VPC for the security group. If you do not specify a VPC, the default is to use the default VPC for the Region. If there's no specified VPC and no default VPC, security group creation fails.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroup.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_security_group_mixin_props = ec2_mixins.CfnSecurityGroupMixinProps(
                group_description="groupDescription",
                group_name="groupName",
                security_group_egress=[ec2_mixins.CfnSecurityGroupPropsMixin.EgressProperty(
                    cidr_ip="cidrIp",
                    cidr_ipv6="cidrIpv6",
                    description="description",
                    destination_prefix_list_id="destinationPrefixListId",
                    destination_security_group_id="destinationSecurityGroupId",
                    from_port=123,
                    ip_protocol="ipProtocol",
                    to_port=123
                )],
                security_group_ingress=[ec2_mixins.CfnSecurityGroupPropsMixin.IngressProperty(
                    cidr_ip="cidrIp",
                    cidr_ipv6="cidrIpv6",
                    description="description",
                    from_port=123,
                    ip_protocol="ipProtocol",
                    source_prefix_list_id="sourcePrefixListId",
                    source_security_group_id="sourceSecurityGroupId",
                    source_security_group_name="sourceSecurityGroupName",
                    source_security_group_owner_id="sourceSecurityGroupOwnerId",
                    to_port=123
                )],
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                vpc_id="vpcId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4b126f1cb0b14af7af088c06bb51e0ff49381eb4ffa36b40d3c7d4cbcffc313f)
            check_type(argname="argument group_description", value=group_description, expected_type=type_hints["group_description"])
            check_type(argname="argument group_name", value=group_name, expected_type=type_hints["group_name"])
            check_type(argname="argument security_group_egress", value=security_group_egress, expected_type=type_hints["security_group_egress"])
            check_type(argname="argument security_group_ingress", value=security_group_ingress, expected_type=type_hints["security_group_ingress"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument vpc_id", value=vpc_id, expected_type=type_hints["vpc_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if group_description is not None:
            self._values["group_description"] = group_description
        if group_name is not None:
            self._values["group_name"] = group_name
        if security_group_egress is not None:
            self._values["security_group_egress"] = security_group_egress
        if security_group_ingress is not None:
            self._values["security_group_ingress"] = security_group_ingress
        if tags is not None:
            self._values["tags"] = tags
        if vpc_id is not None:
            self._values["vpc_id"] = vpc_id

    @builtins.property
    def group_description(self) -> typing.Optional[builtins.str]:
        '''A description for the security group.

        Constraints: Up to 255 characters in length

        Valid characters: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroup.html#cfn-ec2-securitygroup-groupdescription
        '''
        result = self._values.get("group_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def group_name(self) -> typing.Optional[builtins.str]:
        '''The name of the security group. Names are case-insensitive and must be unique within the VPC.

        Constraints: Up to 255 characters in length. Can't start with ``sg-`` .

        Valid characters: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroup.html#cfn-ec2-securitygroup-groupname
        '''
        result = self._values.get("group_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def security_group_egress(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSecurityGroupPropsMixin.EgressProperty"]]]]:
        '''The outbound rules associated with the security group.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroup.html#cfn-ec2-securitygroup-securitygroupegress
        '''
        result = self._values.get("security_group_egress")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSecurityGroupPropsMixin.EgressProperty"]]]], result)

    @builtins.property
    def security_group_ingress(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSecurityGroupPropsMixin.IngressProperty"]]]]:
        '''The inbound rules associated with the security group.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroup.html#cfn-ec2-securitygroup-securitygroupingress
        '''
        result = self._values.get("security_group_ingress")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSecurityGroupPropsMixin.IngressProperty"]]]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''Any tags assigned to the security group.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroup.html#cfn-ec2-securitygroup-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def vpc_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the VPC for the security group.

        If you do not specify a VPC, the default is to use the default VPC for the Region. If there's no specified VPC and no default VPC, security group creation fails.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroup.html#cfn-ec2-securitygroup-vpcid
        '''
        result = self._values.get("vpc_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnSecurityGroupMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnSecurityGroupPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSecurityGroupPropsMixin",
):
    '''Specifies a security group.

    You must specify ingress rules to allow inbound traffic. By default, no inbound traffic is allowed.

    When you create a security group, if you do not add egress rules, we add egress rules that allow all outbound IPv4 and IPv6 traffic. Otherwise, we do not add them. After the security group is created, if you remove all egress rules that you added, we do not add egress rules, so no outbound traffic is allowed.

    If you modify a rule, CloudFormation removes the existing rule and then adds a new rule. There is a brief period when neither the original rule or the new rule exists, so the corresponding traffic is dropped.

    This type supports updates. For more information about updating stacks, see `AWS CloudFormation Stacks Updates <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks.html>`_ .
    .. epigraph::

       To cross-reference two security groups in the ingress and egress rules of those security groups, use the `AWS::EC2::SecurityGroupEgress <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-security-group-egress.html>`_ and `AWS::EC2::SecurityGroupIngress <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-security-group-ingress.html>`_ resources to define your rules. Do not use the embedded ingress and egress rules in the ``AWS::EC2::SecurityGroup`` . Doing so creates a circular dependency, which CloudFormation doesn't allow.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroup.html
    :cloudformationResource: AWS::EC2::SecurityGroup
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_security_group_props_mixin = ec2_mixins.CfnSecurityGroupPropsMixin(ec2_mixins.CfnSecurityGroupMixinProps(
            group_description="groupDescription",
            group_name="groupName",
            security_group_egress=[ec2_mixins.CfnSecurityGroupPropsMixin.EgressProperty(
                cidr_ip="cidrIp",
                cidr_ipv6="cidrIpv6",
                description="description",
                destination_prefix_list_id="destinationPrefixListId",
                destination_security_group_id="destinationSecurityGroupId",
                from_port=123,
                ip_protocol="ipProtocol",
                to_port=123
            )],
            security_group_ingress=[ec2_mixins.CfnSecurityGroupPropsMixin.IngressProperty(
                cidr_ip="cidrIp",
                cidr_ipv6="cidrIpv6",
                description="description",
                from_port=123,
                ip_protocol="ipProtocol",
                source_prefix_list_id="sourcePrefixListId",
                source_security_group_id="sourceSecurityGroupId",
                source_security_group_name="sourceSecurityGroupName",
                source_security_group_owner_id="sourceSecurityGroupOwnerId",
                to_port=123
            )],
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            vpc_id="vpcId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnSecurityGroupMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::SecurityGroup``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6349e96c8d096269d3ffc645a7b05b0418eb8c6e0d2b5b14f791fd7516aa8089)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__82824210d31ecff4eec980f3a5aa3d1297ebd4638efaf31ef08cf56bd905a162)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d7818c069e202815233223a48079531220223ed08cb60e6f79f9868ee510c86c)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnSecurityGroupMixinProps":
        return typing.cast("CfnSecurityGroupMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSecurityGroupPropsMixin.EgressProperty",
        jsii_struct_bases=[],
        name_mapping={
            "cidr_ip": "cidrIp",
            "cidr_ipv6": "cidrIpv6",
            "description": "description",
            "destination_prefix_list_id": "destinationPrefixListId",
            "destination_security_group_id": "destinationSecurityGroupId",
            "from_port": "fromPort",
            "ip_protocol": "ipProtocol",
            "to_port": "toPort",
        },
    )
    class EgressProperty:
        def __init__(
            self,
            *,
            cidr_ip: typing.Optional[builtins.str] = None,
            cidr_ipv6: typing.Optional[builtins.str] = None,
            description: typing.Optional[builtins.str] = None,
            destination_prefix_list_id: typing.Optional[builtins.str] = None,
            destination_security_group_id: typing.Optional[builtins.str] = None,
            from_port: typing.Optional[jsii.Number] = None,
            ip_protocol: typing.Optional[builtins.str] = None,
            to_port: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Adds the specified outbound (egress) rule to a security group.

            An outbound rule permits instances to send traffic to the specified IPv4 or IPv6 address range, the IP address ranges that are specified by a prefix list, or the instances that are associated with a destination security group. For more information, see `Security group rules <https://docs.aws.amazon.com/vpc/latest/userguide/security-group-rules.html>`_ .

            You must specify exactly one of the following destinations: an IPv4 address range, an IPv6 address range, a prefix list, or a security group.

            You must specify a protocol for each rule (for example, TCP). If the protocol is TCP or UDP, you must also specify a port or port range. If the protocol is ICMP or ICMPv6, you must also specify the ICMP/ICMPv6 type and code.

            Rule changes are propagated to instances associated with the security group as quickly as possible. However, a small delay might occur.

            :param cidr_ip: The IPv4 address range, in CIDR format. You must specify exactly one of the following: ``CidrIp`` , ``CidrIpv6`` , ``DestinationPrefixListId`` , or ``DestinationSecurityGroupId`` . For examples of rules that you can add to security groups for specific access scenarios, see `Security group rules for different use cases <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html>`_ in the *Amazon EC2 User Guide* .
            :param cidr_ipv6: The IPv6 address range, in CIDR format. You must specify exactly one of the following: ``CidrIp`` , ``CidrIpv6`` , ``DestinationPrefixListId`` , or ``DestinationSecurityGroupId`` . For examples of rules that you can add to security groups for specific access scenarios, see `Security group rules for different use cases <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html>`_ in the *Amazon EC2 User Guide* .
            :param description: A description for the security group rule. Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
            :param destination_prefix_list_id: The prefix list IDs for the destination AWS service. This is the AWS service that you want to access through a VPC endpoint from instances associated with the security group. You must specify exactly one of the following: ``CidrIp`` , ``CidrIpv6`` , ``DestinationPrefixListId`` , or ``DestinationSecurityGroupId`` .
            :param destination_security_group_id: The ID of the destination VPC security group. You must specify exactly one of the following: ``CidrIp`` , ``CidrIpv6`` , ``DestinationPrefixListId`` , or ``DestinationSecurityGroupId`` .
            :param from_port: If the protocol is TCP or UDP, this is the start of the port range. If the protocol is ICMP or ICMPv6, this is the ICMP type or -1 (all ICMP types).
            :param ip_protocol: The IP protocol name ( ``tcp`` , ``udp`` , ``icmp`` , ``icmpv6`` ) or number (see `Protocol Numbers <https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml>`_ ). Use ``-1`` to specify all protocols. When authorizing security group rules, specifying ``-1`` or a protocol number other than ``tcp`` , ``udp`` , ``icmp`` , or ``icmpv6`` allows traffic on all ports, regardless of any port range you specify. For ``tcp`` , ``udp`` , and ``icmp`` , you must specify a port range. For ``icmpv6`` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.
            :param to_port: If the protocol is TCP or UDP, this is the end of the port range. If the protocol is ICMP or ICMPv6, this is the ICMP code or -1 (all ICMP codes). If the start port is -1 (all ICMP types), then the end port must be -1 (all ICMP codes).

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-egress.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                egress_property = ec2_mixins.CfnSecurityGroupPropsMixin.EgressProperty(
                    cidr_ip="cidrIp",
                    cidr_ipv6="cidrIpv6",
                    description="description",
                    destination_prefix_list_id="destinationPrefixListId",
                    destination_security_group_id="destinationSecurityGroupId",
                    from_port=123,
                    ip_protocol="ipProtocol",
                    to_port=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__0a1c9f7d955045ef5a44320aa717072111d3b54c6457b9fe427589098c55dcb1)
                check_type(argname="argument cidr_ip", value=cidr_ip, expected_type=type_hints["cidr_ip"])
                check_type(argname="argument cidr_ipv6", value=cidr_ipv6, expected_type=type_hints["cidr_ipv6"])
                check_type(argname="argument description", value=description, expected_type=type_hints["description"])
                check_type(argname="argument destination_prefix_list_id", value=destination_prefix_list_id, expected_type=type_hints["destination_prefix_list_id"])
                check_type(argname="argument destination_security_group_id", value=destination_security_group_id, expected_type=type_hints["destination_security_group_id"])
                check_type(argname="argument from_port", value=from_port, expected_type=type_hints["from_port"])
                check_type(argname="argument ip_protocol", value=ip_protocol, expected_type=type_hints["ip_protocol"])
                check_type(argname="argument to_port", value=to_port, expected_type=type_hints["to_port"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if cidr_ip is not None:
                self._values["cidr_ip"] = cidr_ip
            if cidr_ipv6 is not None:
                self._values["cidr_ipv6"] = cidr_ipv6
            if description is not None:
                self._values["description"] = description
            if destination_prefix_list_id is not None:
                self._values["destination_prefix_list_id"] = destination_prefix_list_id
            if destination_security_group_id is not None:
                self._values["destination_security_group_id"] = destination_security_group_id
            if from_port is not None:
                self._values["from_port"] = from_port
            if ip_protocol is not None:
                self._values["ip_protocol"] = ip_protocol
            if to_port is not None:
                self._values["to_port"] = to_port

        @builtins.property
        def cidr_ip(self) -> typing.Optional[builtins.str]:
            '''The IPv4 address range, in CIDR format.

            You must specify exactly one of the following: ``CidrIp`` , ``CidrIpv6`` , ``DestinationPrefixListId`` , or ``DestinationSecurityGroupId`` .

            For examples of rules that you can add to security groups for specific access scenarios, see `Security group rules for different use cases <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html>`_ in the *Amazon EC2 User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-egress.html#cfn-ec2-securitygroup-egress-cidrip
            '''
            result = self._values.get("cidr_ip")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def cidr_ipv6(self) -> typing.Optional[builtins.str]:
            '''The IPv6 address range, in CIDR format.

            You must specify exactly one of the following: ``CidrIp`` , ``CidrIpv6`` , ``DestinationPrefixListId`` , or ``DestinationSecurityGroupId`` .

            For examples of rules that you can add to security groups for specific access scenarios, see `Security group rules for different use cases <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html>`_ in the *Amazon EC2 User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-egress.html#cfn-ec2-securitygroup-egress-cidripv6
            '''
            result = self._values.get("cidr_ipv6")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def description(self) -> typing.Optional[builtins.str]:
            '''A description for the security group rule.

            Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-egress.html#cfn-ec2-securitygroup-egress-description
            '''
            result = self._values.get("description")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def destination_prefix_list_id(self) -> typing.Optional[builtins.str]:
            '''The prefix list IDs for the destination AWS service.

            This is the AWS service that you want to access through a VPC endpoint from instances associated with the security group.

            You must specify exactly one of the following: ``CidrIp`` , ``CidrIpv6`` , ``DestinationPrefixListId`` , or ``DestinationSecurityGroupId`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-egress.html#cfn-ec2-securitygroup-egress-destinationprefixlistid
            '''
            result = self._values.get("destination_prefix_list_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def destination_security_group_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the destination VPC security group.

            You must specify exactly one of the following: ``CidrIp`` , ``CidrIpv6`` , ``DestinationPrefixListId`` , or ``DestinationSecurityGroupId`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-egress.html#cfn-ec2-securitygroup-egress-destinationsecuritygroupid
            '''
            result = self._values.get("destination_security_group_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def from_port(self) -> typing.Optional[jsii.Number]:
            '''If the protocol is TCP or UDP, this is the start of the port range.

            If the protocol is ICMP or ICMPv6, this is the ICMP type or -1 (all ICMP types).

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-egress.html#cfn-ec2-securitygroup-egress-fromport
            '''
            result = self._values.get("from_port")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def ip_protocol(self) -> typing.Optional[builtins.str]:
            '''The IP protocol name ( ``tcp`` , ``udp`` , ``icmp`` , ``icmpv6`` ) or number (see `Protocol Numbers <https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml>`_ ).

            Use ``-1`` to specify all protocols. When authorizing security group rules, specifying ``-1`` or a protocol number other than ``tcp`` , ``udp`` , ``icmp`` , or ``icmpv6`` allows traffic on all ports, regardless of any port range you specify. For ``tcp`` , ``udp`` , and ``icmp`` , you must specify a port range. For ``icmpv6`` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-egress.html#cfn-ec2-securitygroup-egress-ipprotocol
            '''
            result = self._values.get("ip_protocol")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def to_port(self) -> typing.Optional[jsii.Number]:
            '''If the protocol is TCP or UDP, this is the end of the port range.

            If the protocol is ICMP or ICMPv6, this is the ICMP code or -1 (all ICMP codes). If the start port is -1 (all ICMP types), then the end port must be -1 (all ICMP codes).

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-egress.html#cfn-ec2-securitygroup-egress-toport
            '''
            result = self._values.get("to_port")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "EgressProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSecurityGroupPropsMixin.IngressProperty",
        jsii_struct_bases=[],
        name_mapping={
            "cidr_ip": "cidrIp",
            "cidr_ipv6": "cidrIpv6",
            "description": "description",
            "from_port": "fromPort",
            "ip_protocol": "ipProtocol",
            "source_prefix_list_id": "sourcePrefixListId",
            "source_security_group_id": "sourceSecurityGroupId",
            "source_security_group_name": "sourceSecurityGroupName",
            "source_security_group_owner_id": "sourceSecurityGroupOwnerId",
            "to_port": "toPort",
        },
    )
    class IngressProperty:
        def __init__(
            self,
            *,
            cidr_ip: typing.Optional[builtins.str] = None,
            cidr_ipv6: typing.Optional[builtins.str] = None,
            description: typing.Optional[builtins.str] = None,
            from_port: typing.Optional[jsii.Number] = None,
            ip_protocol: typing.Optional[builtins.str] = None,
            source_prefix_list_id: typing.Optional[builtins.str] = None,
            source_security_group_id: typing.Optional[builtins.str] = None,
            source_security_group_name: typing.Optional[builtins.str] = None,
            source_security_group_owner_id: typing.Optional[builtins.str] = None,
            to_port: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Adds an inbound (ingress) rule to a security group.

            An inbound rule permits instances to receive traffic from the specified IPv4 or IPv6 address range, the IP address ranges that are specified by a prefix list, or the instances that are associated with a source security group. For more information, see `Security group rules <https://docs.aws.amazon.com/vpc/latest/userguide/security-group-rules.html>`_ .

            You must specify exactly one of the following sources: an IPv4 address range, an IPv6 address range, a prefix list, or a security group.

            You must specify a protocol for each rule (for example, TCP). If the protocol is TCP or UDP, you must also specify a port or port range. If the protocol is ICMP or ICMPv6, you must also specify the ICMP/ICMPv6 type and code.

            Rule changes are propagated to instances associated with the security group as quickly as possible. However, a small delay might occur.

            :param cidr_ip: The IPv4 address range, in CIDR format. You must specify exactly one of the following: ``CidrIp`` , ``CidrIpv6`` , ``SourcePrefixListId`` , or ``SourceSecurityGroupId`` . For examples of rules that you can add to security groups for specific access scenarios, see `Security group rules for different use cases <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html>`_ in the *Amazon EC2 User Guide* .
            :param cidr_ipv6: The IPv6 address range, in CIDR format. You must specify exactly one of the following: ``CidrIp`` , ``CidrIpv6`` , ``SourcePrefixListId`` , or ``SourceSecurityGroupId`` . For examples of rules that you can add to security groups for specific access scenarios, see `Security group rules for different use cases <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html>`_ in the *Amazon EC2 User Guide* .
            :param description: Updates the description of an ingress (inbound) security group rule. You can replace an existing description, or add a description to a rule that did not have one previously. Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
            :param from_port: If the protocol is TCP or UDP, this is the start of the port range. If the protocol is ICMP or ICMPv6, this is the ICMP type or -1 (all ICMP types).
            :param ip_protocol: The IP protocol name ( ``tcp`` , ``udp`` , ``icmp`` , ``icmpv6`` ) or number (see `Protocol Numbers <https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml>`_ ). Use ``-1`` to specify all protocols. When authorizing security group rules, specifying ``-1`` or a protocol number other than ``tcp`` , ``udp`` , ``icmp`` , or ``icmpv6`` allows traffic on all ports, regardless of any port range you specify. For ``tcp`` , ``udp`` , and ``icmp`` , you must specify a port range. For ``icmpv6`` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.
            :param source_prefix_list_id: The ID of a prefix list.
            :param source_security_group_id: The ID of the security group.
            :param source_security_group_name: [Default VPC] The name of the source security group. You must specify either the security group ID or the security group name. You can't specify the group name in combination with an IP address range. Creates rules that grant full ICMP, UDP, and TCP access. For security groups in a nondefault VPC, you must specify the group ID.
            :param source_security_group_owner_id: [nondefault VPC] The AWS account ID for the source security group, if the source security group is in a different account. You can't specify this property with an IP address range. Creates rules that grant full ICMP, UDP, and TCP access. If you specify ``SourceSecurityGroupName`` or ``SourceSecurityGroupId`` and that security group is owned by a different account than the account creating the stack, you must specify the ``SourceSecurityGroupOwnerId`` ; otherwise, this property is optional.
            :param to_port: If the protocol is TCP or UDP, this is the end of the port range. If the protocol is ICMP or ICMPv6, this is the ICMP code or -1 (all ICMP codes). If the start port is -1 (all ICMP types), then the end port must be -1 (all ICMP codes).

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-ingress.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                ingress_property = ec2_mixins.CfnSecurityGroupPropsMixin.IngressProperty(
                    cidr_ip="cidrIp",
                    cidr_ipv6="cidrIpv6",
                    description="description",
                    from_port=123,
                    ip_protocol="ipProtocol",
                    source_prefix_list_id="sourcePrefixListId",
                    source_security_group_id="sourceSecurityGroupId",
                    source_security_group_name="sourceSecurityGroupName",
                    source_security_group_owner_id="sourceSecurityGroupOwnerId",
                    to_port=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__94f5b9d6dbf577079e99f0af127419de2a48784b598ab1073c18da1b7ae4a80f)
                check_type(argname="argument cidr_ip", value=cidr_ip, expected_type=type_hints["cidr_ip"])
                check_type(argname="argument cidr_ipv6", value=cidr_ipv6, expected_type=type_hints["cidr_ipv6"])
                check_type(argname="argument description", value=description, expected_type=type_hints["description"])
                check_type(argname="argument from_port", value=from_port, expected_type=type_hints["from_port"])
                check_type(argname="argument ip_protocol", value=ip_protocol, expected_type=type_hints["ip_protocol"])
                check_type(argname="argument source_prefix_list_id", value=source_prefix_list_id, expected_type=type_hints["source_prefix_list_id"])
                check_type(argname="argument source_security_group_id", value=source_security_group_id, expected_type=type_hints["source_security_group_id"])
                check_type(argname="argument source_security_group_name", value=source_security_group_name, expected_type=type_hints["source_security_group_name"])
                check_type(argname="argument source_security_group_owner_id", value=source_security_group_owner_id, expected_type=type_hints["source_security_group_owner_id"])
                check_type(argname="argument to_port", value=to_port, expected_type=type_hints["to_port"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if cidr_ip is not None:
                self._values["cidr_ip"] = cidr_ip
            if cidr_ipv6 is not None:
                self._values["cidr_ipv6"] = cidr_ipv6
            if description is not None:
                self._values["description"] = description
            if from_port is not None:
                self._values["from_port"] = from_port
            if ip_protocol is not None:
                self._values["ip_protocol"] = ip_protocol
            if source_prefix_list_id is not None:
                self._values["source_prefix_list_id"] = source_prefix_list_id
            if source_security_group_id is not None:
                self._values["source_security_group_id"] = source_security_group_id
            if source_security_group_name is not None:
                self._values["source_security_group_name"] = source_security_group_name
            if source_security_group_owner_id is not None:
                self._values["source_security_group_owner_id"] = source_security_group_owner_id
            if to_port is not None:
                self._values["to_port"] = to_port

        @builtins.property
        def cidr_ip(self) -> typing.Optional[builtins.str]:
            '''The IPv4 address range, in CIDR format.

            You must specify exactly one of the following: ``CidrIp`` , ``CidrIpv6`` , ``SourcePrefixListId`` , or ``SourceSecurityGroupId`` .

            For examples of rules that you can add to security groups for specific access scenarios, see `Security group rules for different use cases <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html>`_ in the *Amazon EC2 User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-ingress.html#cfn-ec2-securitygroup-ingress-cidrip
            '''
            result = self._values.get("cidr_ip")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def cidr_ipv6(self) -> typing.Optional[builtins.str]:
            '''The IPv6 address range, in CIDR format.

            You must specify exactly one of the following: ``CidrIp`` , ``CidrIpv6`` , ``SourcePrefixListId`` , or ``SourceSecurityGroupId`` .

            For examples of rules that you can add to security groups for specific access scenarios, see `Security group rules for different use cases <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html>`_ in the *Amazon EC2 User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-ingress.html#cfn-ec2-securitygroup-ingress-cidripv6
            '''
            result = self._values.get("cidr_ipv6")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def description(self) -> typing.Optional[builtins.str]:
            '''Updates the description of an ingress (inbound) security group rule.

            You can replace an existing description, or add a description to a rule that did not have one previously.

            Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-ingress.html#cfn-ec2-securitygroup-ingress-description
            '''
            result = self._values.get("description")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def from_port(self) -> typing.Optional[jsii.Number]:
            '''If the protocol is TCP or UDP, this is the start of the port range.

            If the protocol is ICMP or ICMPv6, this is the ICMP type or -1 (all ICMP types).

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-ingress.html#cfn-ec2-securitygroup-ingress-fromport
            '''
            result = self._values.get("from_port")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def ip_protocol(self) -> typing.Optional[builtins.str]:
            '''The IP protocol name ( ``tcp`` , ``udp`` , ``icmp`` , ``icmpv6`` ) or number (see `Protocol Numbers <https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml>`_ ).

            Use ``-1`` to specify all protocols. When authorizing security group rules, specifying ``-1`` or a protocol number other than ``tcp`` , ``udp`` , ``icmp`` , or ``icmpv6`` allows traffic on all ports, regardless of any port range you specify. For ``tcp`` , ``udp`` , and ``icmp`` , you must specify a port range. For ``icmpv6`` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-ingress.html#cfn-ec2-securitygroup-ingress-ipprotocol
            '''
            result = self._values.get("ip_protocol")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def source_prefix_list_id(self) -> typing.Optional[builtins.str]:
            '''The ID of a prefix list.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-ingress.html#cfn-ec2-securitygroup-ingress-sourceprefixlistid
            '''
            result = self._values.get("source_prefix_list_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def source_security_group_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the security group.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-ingress.html#cfn-ec2-securitygroup-ingress-sourcesecuritygroupid
            '''
            result = self._values.get("source_security_group_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def source_security_group_name(self) -> typing.Optional[builtins.str]:
            '''[Default VPC] The name of the source security group.

            You must specify either the security group ID or the security group name. You can't specify the group name in combination with an IP address range. Creates rules that grant full ICMP, UDP, and TCP access.

            For security groups in a nondefault VPC, you must specify the group ID.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-ingress.html#cfn-ec2-securitygroup-ingress-sourcesecuritygroupname
            '''
            result = self._values.get("source_security_group_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def source_security_group_owner_id(self) -> typing.Optional[builtins.str]:
            '''[nondefault VPC] The AWS account ID for the source security group, if the source security group is in a different account.

            You can't specify this property with an IP address range. Creates rules that grant full ICMP, UDP, and TCP access.

            If you specify ``SourceSecurityGroupName`` or ``SourceSecurityGroupId`` and that security group is owned by a different account than the account creating the stack, you must specify the ``SourceSecurityGroupOwnerId`` ; otherwise, this property is optional.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-ingress.html#cfn-ec2-securitygroup-ingress-sourcesecuritygroupownerid
            '''
            result = self._values.get("source_security_group_owner_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def to_port(self) -> typing.Optional[jsii.Number]:
            '''If the protocol is TCP or UDP, this is the end of the port range.

            If the protocol is ICMP or ICMPv6, this is the ICMP code or -1 (all ICMP codes). If the start port is -1 (all ICMP types), then the end port must be -1 (all ICMP codes).

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-securitygroup-ingress.html#cfn-ec2-securitygroup-ingress-toport
            '''
            result = self._values.get("to_port")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "IngressProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSecurityGroupVpcAssociationMixinProps",
    jsii_struct_bases=[],
    name_mapping={"group_id": "groupId", "vpc_id": "vpcId"},
)
class CfnSecurityGroupVpcAssociationMixinProps:
    def __init__(
        self,
        *,
        group_id: typing.Optional[builtins.str] = None,
        vpc_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnSecurityGroupVpcAssociationPropsMixin.

        :param group_id: The association's security group ID.
        :param vpc_id: The association's VPC ID.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupvpcassociation.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_security_group_vpc_association_mixin_props = ec2_mixins.CfnSecurityGroupVpcAssociationMixinProps(
                group_id="groupId",
                vpc_id="vpcId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1d8bba0fbbed0786ead22dfdafb814dc1cd500e6c9323f918f2b0f4893ed7b16)
            check_type(argname="argument group_id", value=group_id, expected_type=type_hints["group_id"])
            check_type(argname="argument vpc_id", value=vpc_id, expected_type=type_hints["vpc_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if group_id is not None:
            self._values["group_id"] = group_id
        if vpc_id is not None:
            self._values["vpc_id"] = vpc_id

    @builtins.property
    def group_id(self) -> typing.Optional[builtins.str]:
        '''The association's security group ID.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupvpcassociation.html#cfn-ec2-securitygroupvpcassociation-groupid
        '''
        result = self._values.get("group_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpc_id(self) -> typing.Optional[builtins.str]:
        '''The association's VPC ID.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupvpcassociation.html#cfn-ec2-securitygroupvpcassociation-vpcid
        '''
        result = self._values.get("vpc_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnSecurityGroupVpcAssociationMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnSecurityGroupVpcAssociationPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSecurityGroupVpcAssociationPropsMixin",
):
    '''A security group association with a VPC.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupvpcassociation.html
    :cloudformationResource: AWS::EC2::SecurityGroupVpcAssociation
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_security_group_vpc_association_props_mixin = ec2_mixins.CfnSecurityGroupVpcAssociationPropsMixin(ec2_mixins.CfnSecurityGroupVpcAssociationMixinProps(
            group_id="groupId",
            vpc_id="vpcId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnSecurityGroupVpcAssociationMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::SecurityGroupVpcAssociation``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d0af3930582f38446158719a1c7e48eb827a5d269256562d206eaf18d6811653)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e0ff2953034cbe4dbec2c658e02a71a65f4fd9bcf76d7744ba135db3c45a380d)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ff80db7e1685327b1804bf5fa8ac6762f21fb208ef03346c30f358c9771641d1)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnSecurityGroupVpcAssociationMixinProps":
        return typing.cast("CfnSecurityGroupVpcAssociationMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSnapshotBlockPublicAccessMixinProps",
    jsii_struct_bases=[],
    name_mapping={"state": "state"},
)
class CfnSnapshotBlockPublicAccessMixinProps:
    def __init__(self, *, state: typing.Optional[builtins.str] = None) -> None:
        '''Properties for CfnSnapshotBlockPublicAccessPropsMixin.

        :param state: The mode in which to enable block public access for snapshots for the Region. Specify one of the following values: - ``block-all-sharing`` - Prevents all public sharing of snapshots in the Region. Users in the account will no longer be able to request new public sharing. Additionally, snapshots that are already publicly shared are treated as private and they are no longer publicly available. .. epigraph:: If you enable block public access for snapshots in ``block-all-sharing`` mode, it does not change the permissions for snapshots that are already publicly shared. Instead, it prevents these snapshots from be publicly visible and publicly accessible. Therefore, the attributes for these snapshots still indicate that they are publicly shared, even though they are not publicly available. - ``block-new-sharing`` - Prevents only new public sharing of snapshots in the Region. Users in the account will no longer be able to request new public sharing. However, snapshots that are already publicly shared, remain publicly available.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-snapshotblockpublicaccess.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_snapshot_block_public_access_mixin_props = ec2_mixins.CfnSnapshotBlockPublicAccessMixinProps(
                state="state"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__297530769d14d0feec93aab77b2b8eb92f896078084493eafbf16b1a928c95e7)
            check_type(argname="argument state", value=state, expected_type=type_hints["state"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if state is not None:
            self._values["state"] = state

    @builtins.property
    def state(self) -> typing.Optional[builtins.str]:
        '''The mode in which to enable block public access for snapshots for the Region.

        Specify one of the following values:

        - ``block-all-sharing`` - Prevents all public sharing of snapshots in the Region. Users in the account will no longer be able to request new public sharing. Additionally, snapshots that are already publicly shared are treated as private and they are no longer publicly available.

        .. epigraph::

           If you enable block public access for snapshots in ``block-all-sharing`` mode, it does not change the permissions for snapshots that are already publicly shared. Instead, it prevents these snapshots from be publicly visible and publicly accessible. Therefore, the attributes for these snapshots still indicate that they are publicly shared, even though they are not publicly available.

        - ``block-new-sharing`` - Prevents only new public sharing of snapshots in the Region. Users in the account will no longer be able to request new public sharing. However, snapshots that are already publicly shared, remain publicly available.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-snapshotblockpublicaccess.html#cfn-ec2-snapshotblockpublicaccess-state
        '''
        result = self._values.get("state")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnSnapshotBlockPublicAccessMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnSnapshotBlockPublicAccessPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSnapshotBlockPublicAccessPropsMixin",
):
    '''Specifies the state of the *block public access for snapshots* setting for the Region.

    For more information, see `Block public access for snapshots <https://docs.aws.amazon.com/ebs/latest/userguide/block-public-access-snapshots.html>`_ .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-snapshotblockpublicaccess.html
    :cloudformationResource: AWS::EC2::SnapshotBlockPublicAccess
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_snapshot_block_public_access_props_mixin = ec2_mixins.CfnSnapshotBlockPublicAccessPropsMixin(ec2_mixins.CfnSnapshotBlockPublicAccessMixinProps(
            state="state"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnSnapshotBlockPublicAccessMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::SnapshotBlockPublicAccess``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__90391b006c7994b4ea449044f3bf8bf1c076d670f94e33d97b8a851a0cfdcdab)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b2e3fe550a517a13e9fc8a77a9596ea304e84b4e3f09ce8ef5b4488e03dde6f4)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__69c33d5a9642820d9ea4738f6bf1ab4ff9b3b8d17d8c1367b1f224f1594f2e52)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnSnapshotBlockPublicAccessMixinProps":
        return typing.cast("CfnSnapshotBlockPublicAccessMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSpotFleetMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "spot_fleet_request_config_data": "spotFleetRequestConfigData",
        "tags": "tags",
    },
)
class CfnSpotFleetMixinProps:
    def __init__(
        self,
        *,
        spot_fleet_request_config_data: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSpotFleetPropsMixin.SpotFleetRequestConfigDataProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnSpotFleetPropsMixin.

        :param spot_fleet_request_config_data: Describes the configuration of a Spot Fleet request.
        :param tags: The tags for a Spot Fleet resource.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-spotfleet.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag, CfnTag, CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_spot_fleet_mixin_props = ec2_mixins.CfnSpotFleetMixinProps(
                spot_fleet_request_config_data=ec2_mixins.CfnSpotFleetPropsMixin.SpotFleetRequestConfigDataProperty(
                    allocation_strategy="allocationStrategy",
                    context="context",
                    excess_capacity_termination_policy="excessCapacityTerminationPolicy",
                    iam_fleet_role="iamFleetRole",
                    instance_interruption_behavior="instanceInterruptionBehavior",
                    instance_pools_to_use_count=123,
                    launch_specifications=[ec2_mixins.CfnSpotFleetPropsMixin.SpotFleetLaunchSpecificationProperty(
                        block_device_mappings=[ec2_mixins.CfnSpotFleetPropsMixin.BlockDeviceMappingProperty(
                            device_name="deviceName",
                            ebs=ec2_mixins.CfnSpotFleetPropsMixin.EbsBlockDeviceProperty(
                                delete_on_termination=False,
                                encrypted=False,
                                iops=123,
                                snapshot_id="snapshotId",
                                volume_size=123,
                                volume_type="volumeType"
                            ),
                            no_device="noDevice",
                            virtual_name="virtualName"
                        )],
                        ebs_optimized=False,
                        iam_instance_profile=ec2_mixins.CfnSpotFleetPropsMixin.IamInstanceProfileSpecificationProperty(
                            arn="arn"
                        ),
                        image_id="imageId",
                        instance_requirements=ec2_mixins.CfnSpotFleetPropsMixin.InstanceRequirementsRequestProperty(
                            accelerator_count=ec2_mixins.CfnSpotFleetPropsMixin.AcceleratorCountRequestProperty(
                                max=123,
                                min=123
                            ),
                            accelerator_manufacturers=["acceleratorManufacturers"],
                            accelerator_names=["acceleratorNames"],
                            accelerator_total_memory_mi_b=ec2_mixins.CfnSpotFleetPropsMixin.AcceleratorTotalMemoryMiBRequestProperty(
                                max=123,
                                min=123
                            ),
                            accelerator_types=["acceleratorTypes"],
                            allowed_instance_types=["allowedInstanceTypes"],
                            bare_metal="bareMetal",
                            baseline_ebs_bandwidth_mbps=ec2_mixins.CfnSpotFleetPropsMixin.BaselineEbsBandwidthMbpsRequestProperty(
                                max=123,
                                min=123
                            ),
                            baseline_performance_factors=ec2_mixins.CfnSpotFleetPropsMixin.BaselinePerformanceFactorsRequestProperty(
                                cpu=ec2_mixins.CfnSpotFleetPropsMixin.CpuPerformanceFactorRequestProperty(
                                    references=[ec2_mixins.CfnSpotFleetPropsMixin.PerformanceFactorReferenceRequestProperty(
                                        instance_family="instanceFamily"
                                    )]
                                )
                            ),
                            burstable_performance="burstablePerformance",
                            cpu_manufacturers=["cpuManufacturers"],
                            excluded_instance_types=["excludedInstanceTypes"],
                            instance_generations=["instanceGenerations"],
                            local_storage="localStorage",
                            local_storage_types=["localStorageTypes"],
                            max_spot_price_as_percentage_of_optimal_on_demand_price=123,
                            memory_gi_bPer_vCpu=ec2_mixins.CfnSpotFleetPropsMixin.MemoryGiBPerVCpuRequestProperty(
                                max=123,
                                min=123
                            ),
                            memory_mi_b=ec2_mixins.CfnSpotFleetPropsMixin.MemoryMiBRequestProperty(
                                max=123,
                                min=123
                            ),
                            network_bandwidth_gbps=ec2_mixins.CfnSpotFleetPropsMixin.NetworkBandwidthGbpsRequestProperty(
                                max=123,
                                min=123
                            ),
                            network_interface_count=ec2_mixins.CfnSpotFleetPropsMixin.NetworkInterfaceCountRequestProperty(
                                max=123,
                                min=123
                            ),
                            on_demand_max_price_percentage_over_lowest_price=123,
                            require_encryption_in_transit=False,
                            require_hibernate_support=False,
                            spot_max_price_percentage_over_lowest_price=123,
                            total_local_storage_gb=ec2_mixins.CfnSpotFleetPropsMixin.TotalLocalStorageGBRequestProperty(
                                max=123,
                                min=123
                            ),
                            v_cpu_count=ec2_mixins.CfnSpotFleetPropsMixin.VCpuCountRangeRequestProperty(
                                max=123,
                                min=123
                            )
                        ),
                        instance_type="instanceType",
                        kernel_id="kernelId",
                        key_name="keyName",
                        monitoring=ec2_mixins.CfnSpotFleetPropsMixin.SpotFleetMonitoringProperty(
                            enabled=False
                        ),
                        network_interfaces=[ec2_mixins.CfnSpotFleetPropsMixin.InstanceNetworkInterfaceSpecificationProperty(
                            associate_public_ip_address=False,
                            delete_on_termination=False,
                            description="description",
                            device_index=123,
                            groups=["groups"],
                            ipv6_address_count=123,
                            ipv6_addresses=[ec2_mixins.CfnSpotFleetPropsMixin.InstanceIpv6AddressProperty(
                                ipv6_address="ipv6Address"
                            )],
                            network_interface_id="networkInterfaceId",
                            private_ip_addresses=[ec2_mixins.CfnSpotFleetPropsMixin.PrivateIpAddressSpecificationProperty(
                                primary=False,
                                private_ip_address="privateIpAddress"
                            )],
                            secondary_private_ip_address_count=123,
                            subnet_id="subnetId"
                        )],
                        placement=ec2_mixins.CfnSpotFleetPropsMixin.SpotPlacementProperty(
                            availability_zone="availabilityZone",
                            availability_zone_id="availabilityZoneId",
                            group_name="groupName",
                            tenancy="tenancy"
                        ),
                        ramdisk_id="ramdiskId",
                        security_groups=[ec2_mixins.CfnSpotFleetPropsMixin.GroupIdentifierProperty(
                            group_id="groupId"
                        )],
                        spot_price="spotPrice",
                        subnet_id="subnetId",
                        tag_specifications=[ec2_mixins.CfnSpotFleetPropsMixin.SpotFleetTagSpecificationProperty(
                            resource_type="resourceType",
                            tags=[CfnTag(
                                key="key",
                                value="value"
                            )]
                        )],
                        user_data="userData",
                        weighted_capacity=123
                    )],
                    launch_template_configs=[ec2_mixins.CfnSpotFleetPropsMixin.LaunchTemplateConfigProperty(
                        launch_template_specification=ec2_mixins.CfnSpotFleetPropsMixin.FleetLaunchTemplateSpecificationProperty(
                            launch_template_id="launchTemplateId",
                            launch_template_name="launchTemplateName",
                            version="version"
                        ),
                        overrides=[ec2_mixins.CfnSpotFleetPropsMixin.LaunchTemplateOverridesProperty(
                            availability_zone="availabilityZone",
                            availability_zone_id="availabilityZoneId",
                            instance_requirements=ec2_mixins.CfnSpotFleetPropsMixin.InstanceRequirementsRequestProperty(
                                accelerator_count=ec2_mixins.CfnSpotFleetPropsMixin.AcceleratorCountRequestProperty(
                                    max=123,
                                    min=123
                                ),
                                accelerator_manufacturers=["acceleratorManufacturers"],
                                accelerator_names=["acceleratorNames"],
                                accelerator_total_memory_mi_b=ec2_mixins.CfnSpotFleetPropsMixin.AcceleratorTotalMemoryMiBRequestProperty(
                                    max=123,
                                    min=123
                                ),
                                accelerator_types=["acceleratorTypes"],
                                allowed_instance_types=["allowedInstanceTypes"],
                                bare_metal="bareMetal",
                                baseline_ebs_bandwidth_mbps=ec2_mixins.CfnSpotFleetPropsMixin.BaselineEbsBandwidthMbpsRequestProperty(
                                    max=123,
                                    min=123
                                ),
                                baseline_performance_factors=ec2_mixins.CfnSpotFleetPropsMixin.BaselinePerformanceFactorsRequestProperty(
                                    cpu=ec2_mixins.CfnSpotFleetPropsMixin.CpuPerformanceFactorRequestProperty(
                                        references=[ec2_mixins.CfnSpotFleetPropsMixin.PerformanceFactorReferenceRequestProperty(
                                            instance_family="instanceFamily"
                                        )]
                                    )
                                ),
                                burstable_performance="burstablePerformance",
                                cpu_manufacturers=["cpuManufacturers"],
                                excluded_instance_types=["excludedInstanceTypes"],
                                instance_generations=["instanceGenerations"],
                                local_storage="localStorage",
                                local_storage_types=["localStorageTypes"],
                                max_spot_price_as_percentage_of_optimal_on_demand_price=123,
                                memory_gi_bPer_vCpu=ec2_mixins.CfnSpotFleetPropsMixin.MemoryGiBPerVCpuRequestProperty(
                                    max=123,
                                    min=123
                                ),
                                memory_mi_b=ec2_mixins.CfnSpotFleetPropsMixin.MemoryMiBRequestProperty(
                                    max=123,
                                    min=123
                                ),
                                network_bandwidth_gbps=ec2_mixins.CfnSpotFleetPropsMixin.NetworkBandwidthGbpsRequestProperty(
                                    max=123,
                                    min=123
                                ),
                                network_interface_count=ec2_mixins.CfnSpotFleetPropsMixin.NetworkInterfaceCountRequestProperty(
                                    max=123,
                                    min=123
                                ),
                                on_demand_max_price_percentage_over_lowest_price=123,
                                require_encryption_in_transit=False,
                                require_hibernate_support=False,
                                spot_max_price_percentage_over_lowest_price=123,
                                total_local_storage_gb=ec2_mixins.CfnSpotFleetPropsMixin.TotalLocalStorageGBRequestProperty(
                                    max=123,
                                    min=123
                                ),
                                v_cpu_count=ec2_mixins.CfnSpotFleetPropsMixin.VCpuCountRangeRequestProperty(
                                    max=123,
                                    min=123
                                )
                            ),
                            instance_type="instanceType",
                            priority=123,
                            spot_price="spotPrice",
                            subnet_id="subnetId",
                            weighted_capacity=123
                        )]
                    )],
                    load_balancers_config=ec2_mixins.CfnSpotFleetPropsMixin.LoadBalancersConfigProperty(
                        classic_load_balancers_config=ec2_mixins.CfnSpotFleetPropsMixin.ClassicLoadBalancersConfigProperty(
                            classic_load_balancers=[ec2_mixins.CfnSpotFleetPropsMixin.ClassicLoadBalancerProperty(
                                name="name"
                            )]
                        ),
                        target_groups_config=ec2_mixins.CfnSpotFleetPropsMixin.TargetGroupsConfigProperty(
                            target_groups=[ec2_mixins.CfnSpotFleetPropsMixin.TargetGroupProperty(
                                arn="arn"
                            )]
                        )
                    ),
                    on_demand_allocation_strategy="onDemandAllocationStrategy",
                    on_demand_max_total_price="onDemandMaxTotalPrice",
                    on_demand_target_capacity=123,
                    replace_unhealthy_instances=False,
                    spot_maintenance_strategies=ec2_mixins.CfnSpotFleetPropsMixin.SpotMaintenanceStrategiesProperty(
                        capacity_rebalance=ec2_mixins.CfnSpotFleetPropsMixin.SpotCapacityRebalanceProperty(
                            replacement_strategy="replacementStrategy",
                            termination_delay=123
                        )
                    ),
                    spot_max_total_price="spotMaxTotalPrice",
                    spot_price="spotPrice",
                    tag_specifications=[ec2_mixins.CfnSpotFleetPropsMixin.SpotFleetTagSpecificationProperty(
                        resource_type="resourceType",
                        tags=[CfnTag(
                            key="key",
                            value="value"
                        )]
                    )],
                    target_capacity=123,
                    target_capacity_unit_type="targetCapacityUnitType",
                    terminate_instances_with_expiration=False,
                    type="type",
                    valid_from="validFrom",
                    valid_until="validUntil"
                ),
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__38d7707296a4d0ae2830d001d573e6a3139c137a14c9d396bd7433852c8f4fd1)
            check_type(argname="argument spot_fleet_request_config_data", value=spot_fleet_request_config_data, expected_type=type_hints["spot_fleet_request_config_data"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if spot_fleet_request_config_data is not None:
            self._values["spot_fleet_request_config_data"] = spot_fleet_request_config_data
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def spot_fleet_request_config_data(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.SpotFleetRequestConfigDataProperty"]]:
        '''Describes the configuration of a Spot Fleet request.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-spotfleet.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata
        '''
        result = self._values.get("spot_fleet_request_config_data")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.SpotFleetRequestConfigDataProperty"]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags for a Spot Fleet resource.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-spotfleet.html#cfn-ec2-spotfleet-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnSpotFleetMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnSpotFleetPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSpotFleetPropsMixin",
):
    '''Specifies a Spot Fleet request.

    The Spot Fleet request specifies the total target capacity and the On-Demand target capacity. Amazon EC2 calculates the difference between the total capacity and On-Demand capacity, and launches the difference as Spot capacity.

    You can submit a single request that includes multiple launch specifications that vary by instance type, AMI, Availability Zone, or subnet.

    By default, the Spot Fleet requests Spot Instances in the Spot Instance pool where the price per unit is the lowest. Each launch specification can include its own instance weighting that reflects the value of the instance type to your application workload.

    Alternatively, you can specify that the Spot Fleet distribute the target capacity across the Spot pools included in its launch specifications. By ensuring that the Spot Instances in your Spot Fleet are in different Spot pools, you can improve the availability of your fleet.

    You can specify tags for the Spot Fleet request and instances launched by the fleet. You cannot tag other resource types in a Spot Fleet request because only the ``spot-fleet-request`` and ``instance`` resource types are supported.

    For more information, see `Spot Fleet <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet.html>`_ in the *Amazon EC2 User Guide* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-spotfleet.html
    :cloudformationResource: AWS::EC2::SpotFleet
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag, CfnTag, CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_spot_fleet_props_mixin = ec2_mixins.CfnSpotFleetPropsMixin(ec2_mixins.CfnSpotFleetMixinProps(
            spot_fleet_request_config_data=ec2_mixins.CfnSpotFleetPropsMixin.SpotFleetRequestConfigDataProperty(
                allocation_strategy="allocationStrategy",
                context="context",
                excess_capacity_termination_policy="excessCapacityTerminationPolicy",
                iam_fleet_role="iamFleetRole",
                instance_interruption_behavior="instanceInterruptionBehavior",
                instance_pools_to_use_count=123,
                launch_specifications=[ec2_mixins.CfnSpotFleetPropsMixin.SpotFleetLaunchSpecificationProperty(
                    block_device_mappings=[ec2_mixins.CfnSpotFleetPropsMixin.BlockDeviceMappingProperty(
                        device_name="deviceName",
                        ebs=ec2_mixins.CfnSpotFleetPropsMixin.EbsBlockDeviceProperty(
                            delete_on_termination=False,
                            encrypted=False,
                            iops=123,
                            snapshot_id="snapshotId",
                            volume_size=123,
                            volume_type="volumeType"
                        ),
                        no_device="noDevice",
                        virtual_name="virtualName"
                    )],
                    ebs_optimized=False,
                    iam_instance_profile=ec2_mixins.CfnSpotFleetPropsMixin.IamInstanceProfileSpecificationProperty(
                        arn="arn"
                    ),
                    image_id="imageId",
                    instance_requirements=ec2_mixins.CfnSpotFleetPropsMixin.InstanceRequirementsRequestProperty(
                        accelerator_count=ec2_mixins.CfnSpotFleetPropsMixin.AcceleratorCountRequestProperty(
                            max=123,
                            min=123
                        ),
                        accelerator_manufacturers=["acceleratorManufacturers"],
                        accelerator_names=["acceleratorNames"],
                        accelerator_total_memory_mi_b=ec2_mixins.CfnSpotFleetPropsMixin.AcceleratorTotalMemoryMiBRequestProperty(
                            max=123,
                            min=123
                        ),
                        accelerator_types=["acceleratorTypes"],
                        allowed_instance_types=["allowedInstanceTypes"],
                        bare_metal="bareMetal",
                        baseline_ebs_bandwidth_mbps=ec2_mixins.CfnSpotFleetPropsMixin.BaselineEbsBandwidthMbpsRequestProperty(
                            max=123,
                            min=123
                        ),
                        baseline_performance_factors=ec2_mixins.CfnSpotFleetPropsMixin.BaselinePerformanceFactorsRequestProperty(
                            cpu=ec2_mixins.CfnSpotFleetPropsMixin.CpuPerformanceFactorRequestProperty(
                                references=[ec2_mixins.CfnSpotFleetPropsMixin.PerformanceFactorReferenceRequestProperty(
                                    instance_family="instanceFamily"
                                )]
                            )
                        ),
                        burstable_performance="burstablePerformance",
                        cpu_manufacturers=["cpuManufacturers"],
                        excluded_instance_types=["excludedInstanceTypes"],
                        instance_generations=["instanceGenerations"],
                        local_storage="localStorage",
                        local_storage_types=["localStorageTypes"],
                        max_spot_price_as_percentage_of_optimal_on_demand_price=123,
                        memory_gi_bPer_vCpu=ec2_mixins.CfnSpotFleetPropsMixin.MemoryGiBPerVCpuRequestProperty(
                            max=123,
                            min=123
                        ),
                        memory_mi_b=ec2_mixins.CfnSpotFleetPropsMixin.MemoryMiBRequestProperty(
                            max=123,
                            min=123
                        ),
                        network_bandwidth_gbps=ec2_mixins.CfnSpotFleetPropsMixin.NetworkBandwidthGbpsRequestProperty(
                            max=123,
                            min=123
                        ),
                        network_interface_count=ec2_mixins.CfnSpotFleetPropsMixin.NetworkInterfaceCountRequestProperty(
                            max=123,
                            min=123
                        ),
                        on_demand_max_price_percentage_over_lowest_price=123,
                        require_encryption_in_transit=False,
                        require_hibernate_support=False,
                        spot_max_price_percentage_over_lowest_price=123,
                        total_local_storage_gb=ec2_mixins.CfnSpotFleetPropsMixin.TotalLocalStorageGBRequestProperty(
                            max=123,
                            min=123
                        ),
                        v_cpu_count=ec2_mixins.CfnSpotFleetPropsMixin.VCpuCountRangeRequestProperty(
                            max=123,
                            min=123
                        )
                    ),
                    instance_type="instanceType",
                    kernel_id="kernelId",
                    key_name="keyName",
                    monitoring=ec2_mixins.CfnSpotFleetPropsMixin.SpotFleetMonitoringProperty(
                        enabled=False
                    ),
                    network_interfaces=[ec2_mixins.CfnSpotFleetPropsMixin.InstanceNetworkInterfaceSpecificationProperty(
                        associate_public_ip_address=False,
                        delete_on_termination=False,
                        description="description",
                        device_index=123,
                        groups=["groups"],
                        ipv6_address_count=123,
                        ipv6_addresses=[ec2_mixins.CfnSpotFleetPropsMixin.InstanceIpv6AddressProperty(
                            ipv6_address="ipv6Address"
                        )],
                        network_interface_id="networkInterfaceId",
                        private_ip_addresses=[ec2_mixins.CfnSpotFleetPropsMixin.PrivateIpAddressSpecificationProperty(
                            primary=False,
                            private_ip_address="privateIpAddress"
                        )],
                        secondary_private_ip_address_count=123,
                        subnet_id="subnetId"
                    )],
                    placement=ec2_mixins.CfnSpotFleetPropsMixin.SpotPlacementProperty(
                        availability_zone="availabilityZone",
                        availability_zone_id="availabilityZoneId",
                        group_name="groupName",
                        tenancy="tenancy"
                    ),
                    ramdisk_id="ramdiskId",
                    security_groups=[ec2_mixins.CfnSpotFleetPropsMixin.GroupIdentifierProperty(
                        group_id="groupId"
                    )],
                    spot_price="spotPrice",
                    subnet_id="subnetId",
                    tag_specifications=[ec2_mixins.CfnSpotFleetPropsMixin.SpotFleetTagSpecificationProperty(
                        resource_type="resourceType",
                        tags=[CfnTag(
                            key="key",
                            value="value"
                        )]
                    )],
                    user_data="userData",
                    weighted_capacity=123
                )],
                launch_template_configs=[ec2_mixins.CfnSpotFleetPropsMixin.LaunchTemplateConfigProperty(
                    launch_template_specification=ec2_mixins.CfnSpotFleetPropsMixin.FleetLaunchTemplateSpecificationProperty(
                        launch_template_id="launchTemplateId",
                        launch_template_name="launchTemplateName",
                        version="version"
                    ),
                    overrides=[ec2_mixins.CfnSpotFleetPropsMixin.LaunchTemplateOverridesProperty(
                        availability_zone="availabilityZone",
                        availability_zone_id="availabilityZoneId",
                        instance_requirements=ec2_mixins.CfnSpotFleetPropsMixin.InstanceRequirementsRequestProperty(
                            accelerator_count=ec2_mixins.CfnSpotFleetPropsMixin.AcceleratorCountRequestProperty(
                                max=123,
                                min=123
                            ),
                            accelerator_manufacturers=["acceleratorManufacturers"],
                            accelerator_names=["acceleratorNames"],
                            accelerator_total_memory_mi_b=ec2_mixins.CfnSpotFleetPropsMixin.AcceleratorTotalMemoryMiBRequestProperty(
                                max=123,
                                min=123
                            ),
                            accelerator_types=["acceleratorTypes"],
                            allowed_instance_types=["allowedInstanceTypes"],
                            bare_metal="bareMetal",
                            baseline_ebs_bandwidth_mbps=ec2_mixins.CfnSpotFleetPropsMixin.BaselineEbsBandwidthMbpsRequestProperty(
                                max=123,
                                min=123
                            ),
                            baseline_performance_factors=ec2_mixins.CfnSpotFleetPropsMixin.BaselinePerformanceFactorsRequestProperty(
                                cpu=ec2_mixins.CfnSpotFleetPropsMixin.CpuPerformanceFactorRequestProperty(
                                    references=[ec2_mixins.CfnSpotFleetPropsMixin.PerformanceFactorReferenceRequestProperty(
                                        instance_family="instanceFamily"
                                    )]
                                )
                            ),
                            burstable_performance="burstablePerformance",
                            cpu_manufacturers=["cpuManufacturers"],
                            excluded_instance_types=["excludedInstanceTypes"],
                            instance_generations=["instanceGenerations"],
                            local_storage="localStorage",
                            local_storage_types=["localStorageTypes"],
                            max_spot_price_as_percentage_of_optimal_on_demand_price=123,
                            memory_gi_bPer_vCpu=ec2_mixins.CfnSpotFleetPropsMixin.MemoryGiBPerVCpuRequestProperty(
                                max=123,
                                min=123
                            ),
                            memory_mi_b=ec2_mixins.CfnSpotFleetPropsMixin.MemoryMiBRequestProperty(
                                max=123,
                                min=123
                            ),
                            network_bandwidth_gbps=ec2_mixins.CfnSpotFleetPropsMixin.NetworkBandwidthGbpsRequestProperty(
                                max=123,
                                min=123
                            ),
                            network_interface_count=ec2_mixins.CfnSpotFleetPropsMixin.NetworkInterfaceCountRequestProperty(
                                max=123,
                                min=123
                            ),
                            on_demand_max_price_percentage_over_lowest_price=123,
                            require_encryption_in_transit=False,
                            require_hibernate_support=False,
                            spot_max_price_percentage_over_lowest_price=123,
                            total_local_storage_gb=ec2_mixins.CfnSpotFleetPropsMixin.TotalLocalStorageGBRequestProperty(
                                max=123,
                                min=123
                            ),
                            v_cpu_count=ec2_mixins.CfnSpotFleetPropsMixin.VCpuCountRangeRequestProperty(
                                max=123,
                                min=123
                            )
                        ),
                        instance_type="instanceType",
                        priority=123,
                        spot_price="spotPrice",
                        subnet_id="subnetId",
                        weighted_capacity=123
                    )]
                )],
                load_balancers_config=ec2_mixins.CfnSpotFleetPropsMixin.LoadBalancersConfigProperty(
                    classic_load_balancers_config=ec2_mixins.CfnSpotFleetPropsMixin.ClassicLoadBalancersConfigProperty(
                        classic_load_balancers=[ec2_mixins.CfnSpotFleetPropsMixin.ClassicLoadBalancerProperty(
                            name="name"
                        )]
                    ),
                    target_groups_config=ec2_mixins.CfnSpotFleetPropsMixin.TargetGroupsConfigProperty(
                        target_groups=[ec2_mixins.CfnSpotFleetPropsMixin.TargetGroupProperty(
                            arn="arn"
                        )]
                    )
                ),
                on_demand_allocation_strategy="onDemandAllocationStrategy",
                on_demand_max_total_price="onDemandMaxTotalPrice",
                on_demand_target_capacity=123,
                replace_unhealthy_instances=False,
                spot_maintenance_strategies=ec2_mixins.CfnSpotFleetPropsMixin.SpotMaintenanceStrategiesProperty(
                    capacity_rebalance=ec2_mixins.CfnSpotFleetPropsMixin.SpotCapacityRebalanceProperty(
                        replacement_strategy="replacementStrategy",
                        termination_delay=123
                    )
                ),
                spot_max_total_price="spotMaxTotalPrice",
                spot_price="spotPrice",
                tag_specifications=[ec2_mixins.CfnSpotFleetPropsMixin.SpotFleetTagSpecificationProperty(
                    resource_type="resourceType",
                    tags=[CfnTag(
                        key="key",
                        value="value"
                    )]
                )],
                target_capacity=123,
                target_capacity_unit_type="targetCapacityUnitType",
                terminate_instances_with_expiration=False,
                type="type",
                valid_from="validFrom",
                valid_until="validUntil"
            ),
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnSpotFleetMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::SpotFleet``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5f44c0934133518a52fc157174723e56544f6820fc79641f31d3be7a4d492a66)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f10a0dcef9107d5ba6fecade699b0c211d275c56e02cf4d1ec2548ae1c351a2c)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__623b7e36a0e976cc9bb1f2c5e472b848555794f93e4bbf091a2108214f9d07ec)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnSpotFleetMixinProps":
        return typing.cast("CfnSpotFleetMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSpotFleetPropsMixin.AcceleratorCountRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class AcceleratorCountRequestProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.

            To exclude accelerator-enabled instance types, set ``Max`` to ``0`` .

            :param max: The maximum number of accelerators. To specify no maximum limit, omit this parameter. To exclude accelerator-enabled instance types, set ``Max`` to ``0`` .
            :param min: The minimum number of accelerators. To specify no minimum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-acceleratorcountrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                accelerator_count_request_property = ec2_mixins.CfnSpotFleetPropsMixin.AcceleratorCountRequestProperty(
                    max=123,
                    min=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__4ffc9d5136877f4c9aea0f77bc6403e81622bf34c5664c05b06233018d341fc5)
                check_type(argname="argument max", value=max, expected_type=type_hints["max"])
                check_type(argname="argument min", value=min, expected_type=type_hints["min"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum number of accelerators.

            To specify no maximum limit, omit this parameter. To exclude accelerator-enabled instance types, set ``Max`` to ``0`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-acceleratorcountrequest.html#cfn-ec2-spotfleet-acceleratorcountrequest-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum number of accelerators.

            To specify no minimum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-acceleratorcountrequest.html#cfn-ec2-spotfleet-acceleratorcountrequest-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AcceleratorCountRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSpotFleetPropsMixin.AcceleratorTotalMemoryMiBRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class AcceleratorTotalMemoryMiBRequestProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum amount of total accelerator memory, in MiB.

            :param max: The maximum amount of accelerator memory, in MiB. To specify no maximum limit, omit this parameter.
            :param min: The minimum amount of accelerator memory, in MiB. To specify no minimum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-acceleratortotalmemorymibrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                accelerator_total_memory_mi_bRequest_property = ec2_mixins.CfnSpotFleetPropsMixin.AcceleratorTotalMemoryMiBRequestProperty(
                    max=123,
                    min=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__552626f0a128d6f15c56e0732b796a8f5f31baae39a418960ff2bdeb893f06c1)
                check_type(argname="argument max", value=max, expected_type=type_hints["max"])
                check_type(argname="argument min", value=min, expected_type=type_hints["min"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum amount of accelerator memory, in MiB.

            To specify no maximum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-acceleratortotalmemorymibrequest.html#cfn-ec2-spotfleet-acceleratortotalmemorymibrequest-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum amount of accelerator memory, in MiB.

            To specify no minimum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-acceleratortotalmemorymibrequest.html#cfn-ec2-spotfleet-acceleratortotalmemorymibrequest-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AcceleratorTotalMemoryMiBRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSpotFleetPropsMixin.BaselineEbsBandwidthMbpsRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class BaselineEbsBandwidthMbpsRequestProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps.

            For more information, see `Amazon EBSoptimized instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html>`_ in the *Amazon EC2 User Guide* .

            :param max: The maximum baseline bandwidth, in Mbps. To specify no maximum limit, omit this parameter.
            :param min: The minimum baseline bandwidth, in Mbps. To specify no minimum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-baselineebsbandwidthmbpsrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                baseline_ebs_bandwidth_mbps_request_property = ec2_mixins.CfnSpotFleetPropsMixin.BaselineEbsBandwidthMbpsRequestProperty(
                    max=123,
                    min=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__aef771ed2ea0b562879179cf30bef6e79e955d65ac266d93cc73890a2139615c)
                check_type(argname="argument max", value=max, expected_type=type_hints["max"])
                check_type(argname="argument min", value=min, expected_type=type_hints["min"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum baseline bandwidth, in Mbps.

            To specify no maximum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-baselineebsbandwidthmbpsrequest.html#cfn-ec2-spotfleet-baselineebsbandwidthmbpsrequest-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum baseline bandwidth, in Mbps.

            To specify no minimum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-baselineebsbandwidthmbpsrequest.html#cfn-ec2-spotfleet-baselineebsbandwidthmbpsrequest-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "BaselineEbsBandwidthMbpsRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSpotFleetPropsMixin.BaselinePerformanceFactorsRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"cpu": "cpu"},
    )
    class BaselinePerformanceFactorsRequestProperty:
        def __init__(
            self,
            *,
            cpu: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSpotFleetPropsMixin.CpuPerformanceFactorRequestProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''The baseline performance to consider, using an instance family as a baseline reference.

            The instance family establishes the lowest acceptable level of performance. Amazon EC2 uses this baseline to guide instance type selection, but there is no guarantee that the selected instance types will always exceed the baseline for every application.

            Currently, this parameter only supports CPU performance as a baseline performance factor. For example, specifying ``c6i`` would use the CPU performance of the ``c6i`` family as the baseline reference.

            :param cpu: The CPU performance to consider, using an instance family as the baseline reference.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-baselineperformancefactorsrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                baseline_performance_factors_request_property = ec2_mixins.CfnSpotFleetPropsMixin.BaselinePerformanceFactorsRequestProperty(
                    cpu=ec2_mixins.CfnSpotFleetPropsMixin.CpuPerformanceFactorRequestProperty(
                        references=[ec2_mixins.CfnSpotFleetPropsMixin.PerformanceFactorReferenceRequestProperty(
                            instance_family="instanceFamily"
                        )]
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__10113ee78d18a5c882e5eb889302f44989f7ae6c1a078e0e5ce492b4bd65ff7e)
                check_type(argname="argument cpu", value=cpu, expected_type=type_hints["cpu"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if cpu is not None:
                self._values["cpu"] = cpu

        @builtins.property
        def cpu(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.CpuPerformanceFactorRequestProperty"]]:
            '''The CPU performance to consider, using an instance family as the baseline reference.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-baselineperformancefactorsrequest.html#cfn-ec2-spotfleet-baselineperformancefactorsrequest-cpu
            '''
            result = self._values.get("cpu")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.CpuPerformanceFactorRequestProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "BaselinePerformanceFactorsRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSpotFleetPropsMixin.BlockDeviceMappingProperty",
        jsii_struct_bases=[],
        name_mapping={
            "device_name": "deviceName",
            "ebs": "ebs",
            "no_device": "noDevice",
            "virtual_name": "virtualName",
        },
    )
    class BlockDeviceMappingProperty:
        def __init__(
            self,
            *,
            device_name: typing.Optional[builtins.str] = None,
            ebs: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSpotFleetPropsMixin.EbsBlockDeviceProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            no_device: typing.Optional[builtins.str] = None,
            virtual_name: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies a block device mapping.

            You can specify ``Ebs`` or ``VirtualName`` , but not both.

            :param device_name: The device name. For available device names, see `Device names for volumes <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/device_naming.html>`_ .
            :param ebs: Parameters used to automatically set up EBS volumes when the instance is launched.
            :param no_device: To omit the device from the block device mapping, specify an empty string. When this property is specified, the device is removed from the block device mapping regardless of the assigned value.
            :param virtual_name: The virtual device name ( ``ephemeral`` N). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for ``ephemeral0`` and ``ephemeral1`` . The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume. NVMe instance store volumes are automatically enumerated and assigned a device name. Including them in your block device mapping has no effect. Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-blockdevicemapping.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                block_device_mapping_property = ec2_mixins.CfnSpotFleetPropsMixin.BlockDeviceMappingProperty(
                    device_name="deviceName",
                    ebs=ec2_mixins.CfnSpotFleetPropsMixin.EbsBlockDeviceProperty(
                        delete_on_termination=False,
                        encrypted=False,
                        iops=123,
                        snapshot_id="snapshotId",
                        volume_size=123,
                        volume_type="volumeType"
                    ),
                    no_device="noDevice",
                    virtual_name="virtualName"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__f4f688a9a941d59502e3e9551236452ea77ed79fe379911abd88cb55b2be01e6)
                check_type(argname="argument device_name", value=device_name, expected_type=type_hints["device_name"])
                check_type(argname="argument ebs", value=ebs, expected_type=type_hints["ebs"])
                check_type(argname="argument no_device", value=no_device, expected_type=type_hints["no_device"])
                check_type(argname="argument virtual_name", value=virtual_name, expected_type=type_hints["virtual_name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if device_name is not None:
                self._values["device_name"] = device_name
            if ebs is not None:
                self._values["ebs"] = ebs
            if no_device is not None:
                self._values["no_device"] = no_device
            if virtual_name is not None:
                self._values["virtual_name"] = virtual_name

        @builtins.property
        def device_name(self) -> typing.Optional[builtins.str]:
            '''The device name.

            For available device names, see `Device names for volumes <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/device_naming.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-blockdevicemapping.html#cfn-ec2-spotfleet-blockdevicemapping-devicename
            '''
            result = self._values.get("device_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def ebs(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.EbsBlockDeviceProperty"]]:
            '''Parameters used to automatically set up EBS volumes when the instance is launched.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-blockdevicemapping.html#cfn-ec2-spotfleet-blockdevicemapping-ebs
            '''
            result = self._values.get("ebs")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.EbsBlockDeviceProperty"]], result)

        @builtins.property
        def no_device(self) -> typing.Optional[builtins.str]:
            '''To omit the device from the block device mapping, specify an empty string.

            When this property is specified, the device is removed from the block device mapping regardless of the assigned value.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-blockdevicemapping.html#cfn-ec2-spotfleet-blockdevicemapping-nodevice
            '''
            result = self._values.get("no_device")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def virtual_name(self) -> typing.Optional[builtins.str]:
            '''The virtual device name ( ``ephemeral`` N).

            Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for ``ephemeral0`` and ``ephemeral1`` . The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.

            NVMe instance store volumes are automatically enumerated and assigned a device name. Including them in your block device mapping has no effect.

            Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-blockdevicemapping.html#cfn-ec2-spotfleet-blockdevicemapping-virtualname
            '''
            result = self._values.get("virtual_name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "BlockDeviceMappingProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSpotFleetPropsMixin.ClassicLoadBalancerProperty",
        jsii_struct_bases=[],
        name_mapping={"name": "name"},
    )
    class ClassicLoadBalancerProperty:
        def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
            '''Specifies a Classic Load Balancer.

            :param name: The name of the load balancer.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-classicloadbalancer.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                classic_load_balancer_property = ec2_mixins.CfnSpotFleetPropsMixin.ClassicLoadBalancerProperty(
                    name="name"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__2e2f4080d77bba067bf927f835deca977fc69d1962e42cc7c7b7185f4cc62591)
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if name is not None:
                self._values["name"] = name

        @builtins.property
        def name(self) -> typing.Optional[builtins.str]:
            '''The name of the load balancer.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-classicloadbalancer.html#cfn-ec2-spotfleet-classicloadbalancer-name
            '''
            result = self._values.get("name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ClassicLoadBalancerProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSpotFleetPropsMixin.ClassicLoadBalancersConfigProperty",
        jsii_struct_bases=[],
        name_mapping={"classic_load_balancers": "classicLoadBalancers"},
    )
    class ClassicLoadBalancersConfigProperty:
        def __init__(
            self,
            *,
            classic_load_balancers: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSpotFleetPropsMixin.ClassicLoadBalancerProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ) -> None:
            '''Specifies the Classic Load Balancers to attach to a Spot Fleet.

            Spot Fleet registers the running Spot Instances with these Classic Load Balancers.

            :param classic_load_balancers: One or more Classic Load Balancers.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-classicloadbalancersconfig.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                classic_load_balancers_config_property = ec2_mixins.CfnSpotFleetPropsMixin.ClassicLoadBalancersConfigProperty(
                    classic_load_balancers=[ec2_mixins.CfnSpotFleetPropsMixin.ClassicLoadBalancerProperty(
                        name="name"
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__bfa38537187155be5f63e0c7dc84d50da469f3f830ba12d3dd4db6b3f355b661)
                check_type(argname="argument classic_load_balancers", value=classic_load_balancers, expected_type=type_hints["classic_load_balancers"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if classic_load_balancers is not None:
                self._values["classic_load_balancers"] = classic_load_balancers

        @builtins.property
        def classic_load_balancers(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.ClassicLoadBalancerProperty"]]]]:
            '''One or more Classic Load Balancers.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-classicloadbalancersconfig.html#cfn-ec2-spotfleet-classicloadbalancersconfig-classicloadbalancers
            '''
            result = self._values.get("classic_load_balancers")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.ClassicLoadBalancerProperty"]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ClassicLoadBalancersConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSpotFleetPropsMixin.CpuPerformanceFactorRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"references": "references"},
    )
    class CpuPerformanceFactorRequestProperty:
        def __init__(
            self,
            *,
            references: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSpotFleetPropsMixin.PerformanceFactorReferenceRequestProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ) -> None:
            '''The CPU performance to consider, using an instance family as the baseline reference.

            :param references: Specify an instance family to use as the baseline reference for CPU performance. All instance types that match your specified attributes will be compared against the CPU performance of the referenced instance family, regardless of CPU manufacturer or architecture differences. .. epigraph:: Currently, only one instance family can be specified in the list.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-cpuperformancefactorrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                cpu_performance_factor_request_property = ec2_mixins.CfnSpotFleetPropsMixin.CpuPerformanceFactorRequestProperty(
                    references=[ec2_mixins.CfnSpotFleetPropsMixin.PerformanceFactorReferenceRequestProperty(
                        instance_family="instanceFamily"
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__0936e06d5752c03e42520625b1f219256125a9dc8f69fcc78a64744f8e3476da)
                check_type(argname="argument references", value=references, expected_type=type_hints["references"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if references is not None:
                self._values["references"] = references

        @builtins.property
        def references(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.PerformanceFactorReferenceRequestProperty"]]]]:
            '''Specify an instance family to use as the baseline reference for CPU performance.

            All instance types that match your specified attributes will be compared against the CPU performance of the referenced instance family, regardless of CPU manufacturer or architecture differences.
            .. epigraph::

               Currently, only one instance family can be specified in the list.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-cpuperformancefactorrequest.html#cfn-ec2-spotfleet-cpuperformancefactorrequest-references
            '''
            result = self._values.get("references")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.PerformanceFactorReferenceRequestProperty"]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "CpuPerformanceFactorRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSpotFleetPropsMixin.EbsBlockDeviceProperty",
        jsii_struct_bases=[],
        name_mapping={
            "delete_on_termination": "deleteOnTermination",
            "encrypted": "encrypted",
            "iops": "iops",
            "snapshot_id": "snapshotId",
            "volume_size": "volumeSize",
            "volume_type": "volumeType",
        },
    )
    class EbsBlockDeviceProperty:
        def __init__(
            self,
            *,
            delete_on_termination: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            encrypted: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            iops: typing.Optional[jsii.Number] = None,
            snapshot_id: typing.Optional[builtins.str] = None,
            volume_size: typing.Optional[jsii.Number] = None,
            volume_type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes a block device for an EBS volume.

            :param delete_on_termination: Indicates whether the EBS volume is deleted on instance termination. For more information, see `Preserving Amazon EBS volumes on instance termination <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination>`_ in the *Amazon EC2 User Guide* .
            :param encrypted: Indicates whether the encryption state of an EBS volume is changed while being restored from a backing snapshot. The effect of setting the encryption state to ``true`` depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see `Amazon EBS Encryption <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-parameters>`_ in the *Amazon EC2 User Guide* . In no case can you remove encryption from an encrypted volume. Encrypted volumes can only be attached to instances that support Amazon EBS encryption. For more information, see `Supported Instance Types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances>`_ . This parameter is not returned by `DescribeImageAttribute <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImageAttribute.html>`_ .
            :param iops: The number of I/O operations per second (IOPS). For ``gp3`` , ``io1`` , and ``io2`` volumes, this represents the number of IOPS that are provisioned for the volume. For ``gp2`` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. The following are the supported values for each volume type: - ``gp3`` : 3,000 - 80,000 IOPS - ``io1`` : 100 - 64,000 IOPS - ``io2`` : 100 - 256,000 IOPS For ``io2`` volumes, you can achieve up to 256,000 IOPS on `instances built on the Nitro System <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances>`_ . On other instances, you can achieve performance up to 32,000 IOPS. This parameter is required for ``io1`` and ``io2`` volumes. The default for ``gp3`` volumes is 3,000 IOPS.
            :param snapshot_id: The ID of the snapshot.
            :param volume_size: The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size. The following are the supported sizes for each volume type: - ``gp2`` : 1 - 16,384 GiB - ``gp3`` : 1 - 65,536 GiB - ``io1`` : 4 - 16,384 GiB - ``io2`` : 4 - 65,536 GiB - ``st1`` and ``sc1`` : 125 - 16,384 GiB - ``standard`` : 1 - 1024 GiB
            :param volume_type: The volume type. For more information, see `Amazon EBS volume types <https://docs.aws.amazon.com/ebs/latest/userguide/ebs-volume-types.html>`_ in the *Amazon EBS User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-ebsblockdevice.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                ebs_block_device_property = ec2_mixins.CfnSpotFleetPropsMixin.EbsBlockDeviceProperty(
                    delete_on_termination=False,
                    encrypted=False,
                    iops=123,
                    snapshot_id="snapshotId",
                    volume_size=123,
                    volume_type="volumeType"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__e1370eab1cffb0d063d8b79851262e5557e42495219934bc6f5ff0885d1e4cbe)
                check_type(argname="argument delete_on_termination", value=delete_on_termination, expected_type=type_hints["delete_on_termination"])
                check_type(argname="argument encrypted", value=encrypted, expected_type=type_hints["encrypted"])
                check_type(argname="argument iops", value=iops, expected_type=type_hints["iops"])
                check_type(argname="argument snapshot_id", value=snapshot_id, expected_type=type_hints["snapshot_id"])
                check_type(argname="argument volume_size", value=volume_size, expected_type=type_hints["volume_size"])
                check_type(argname="argument volume_type", value=volume_type, expected_type=type_hints["volume_type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if delete_on_termination is not None:
                self._values["delete_on_termination"] = delete_on_termination
            if encrypted is not None:
                self._values["encrypted"] = encrypted
            if iops is not None:
                self._values["iops"] = iops
            if snapshot_id is not None:
                self._values["snapshot_id"] = snapshot_id
            if volume_size is not None:
                self._values["volume_size"] = volume_size
            if volume_type is not None:
                self._values["volume_type"] = volume_type

        @builtins.property
        def delete_on_termination(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether the EBS volume is deleted on instance termination.

            For more information, see `Preserving Amazon EBS volumes on instance termination <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination>`_ in the *Amazon EC2 User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-ebsblockdevice.html#cfn-ec2-spotfleet-ebsblockdevice-deleteontermination
            '''
            result = self._values.get("delete_on_termination")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def encrypted(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether the encryption state of an EBS volume is changed while being restored from a backing snapshot.

            The effect of setting the encryption state to ``true`` depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see `Amazon EBS Encryption <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-parameters>`_ in the *Amazon EC2 User Guide* .

            In no case can you remove encryption from an encrypted volume.

            Encrypted volumes can only be attached to instances that support Amazon EBS encryption. For more information, see `Supported Instance Types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances>`_ .

            This parameter is not returned by `DescribeImageAttribute <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImageAttribute.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-ebsblockdevice.html#cfn-ec2-spotfleet-ebsblockdevice-encrypted
            '''
            result = self._values.get("encrypted")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def iops(self) -> typing.Optional[jsii.Number]:
            '''The number of I/O operations per second (IOPS).

            For ``gp3`` , ``io1`` , and ``io2`` volumes, this represents the number of IOPS that are provisioned for the volume. For ``gp2`` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.

            The following are the supported values for each volume type:

            - ``gp3`` : 3,000 - 80,000 IOPS
            - ``io1`` : 100 - 64,000 IOPS
            - ``io2`` : 100 - 256,000 IOPS

            For ``io2`` volumes, you can achieve up to 256,000 IOPS on `instances built on the Nitro System <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances>`_ . On other instances, you can achieve performance up to 32,000 IOPS.

            This parameter is required for ``io1`` and ``io2`` volumes. The default for ``gp3`` volumes is 3,000 IOPS.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-ebsblockdevice.html#cfn-ec2-spotfleet-ebsblockdevice-iops
            '''
            result = self._values.get("iops")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def snapshot_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the snapshot.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-ebsblockdevice.html#cfn-ec2-spotfleet-ebsblockdevice-snapshotid
            '''
            result = self._values.get("snapshot_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def volume_size(self) -> typing.Optional[jsii.Number]:
            '''The size of the volume, in GiBs.

            You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size.

            The following are the supported sizes for each volume type:

            - ``gp2`` : 1 - 16,384 GiB
            - ``gp3`` : 1 - 65,536 GiB
            - ``io1`` : 4 - 16,384 GiB
            - ``io2`` : 4 - 65,536 GiB
            - ``st1`` and ``sc1`` : 125 - 16,384 GiB
            - ``standard`` : 1 - 1024 GiB

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-ebsblockdevice.html#cfn-ec2-spotfleet-ebsblockdevice-volumesize
            '''
            result = self._values.get("volume_size")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def volume_type(self) -> typing.Optional[builtins.str]:
            '''The volume type.

            For more information, see `Amazon EBS volume types <https://docs.aws.amazon.com/ebs/latest/userguide/ebs-volume-types.html>`_ in the *Amazon EBS User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-ebsblockdevice.html#cfn-ec2-spotfleet-ebsblockdevice-volumetype
            '''
            result = self._values.get("volume_type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "EbsBlockDeviceProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSpotFleetPropsMixin.FleetLaunchTemplateSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "launch_template_id": "launchTemplateId",
            "launch_template_name": "launchTemplateName",
            "version": "version",
        },
    )
    class FleetLaunchTemplateSpecificationProperty:
        def __init__(
            self,
            *,
            launch_template_id: typing.Optional[builtins.str] = None,
            launch_template_name: typing.Optional[builtins.str] = None,
            version: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies the launch template to be used by the Spot Fleet request for configuring Amazon EC2 instances.

            You must specify the following:

            - The ID or the name of the launch template, but not both.
            - The version of the launch template.

            ``FleetLaunchTemplateSpecification`` is a property of the `AWS::EC2::SpotFleet <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-spotfleet.html>`_ resource.

            For information about creating a launch template, see `AWS::EC2::LaunchTemplate <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html>`_ and `Create a launch template <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#create-launch-template>`_ in the *Amazon EC2 User Guide* .

            For examples of launch templates, see `Examples <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#aws-resource-ec2-launchtemplate--examples>`_ .

            :param launch_template_id: The ID of the launch template. You must specify the ``LaunchTemplateId`` or the ``LaunchTemplateName`` , but not both.
            :param launch_template_name: The name of the launch template. You must specify the ``LaunchTemplateName`` or the ``LaunchTemplateId`` , but not both.
            :param version: The version number of the launch template. Specifying ``$Latest`` or ``$Default`` for the template version number is not supported. However, you can specify ``LatestVersionNumber`` or ``DefaultVersionNumber`` using the ``Fn::GetAtt`` intrinsic function. For more information, see `Fn::GetAtt <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#aws-resource-ec2-launchtemplate-return-values-fn--getatt>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-fleetlaunchtemplatespecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                fleet_launch_template_specification_property = ec2_mixins.CfnSpotFleetPropsMixin.FleetLaunchTemplateSpecificationProperty(
                    launch_template_id="launchTemplateId",
                    launch_template_name="launchTemplateName",
                    version="version"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__3ef52e5ae991ab8f9ee350cdd87c2195c64d4dc36fd00fcc4e917e037269f57d)
                check_type(argname="argument launch_template_id", value=launch_template_id, expected_type=type_hints["launch_template_id"])
                check_type(argname="argument launch_template_name", value=launch_template_name, expected_type=type_hints["launch_template_name"])
                check_type(argname="argument version", value=version, expected_type=type_hints["version"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if launch_template_id is not None:
                self._values["launch_template_id"] = launch_template_id
            if launch_template_name is not None:
                self._values["launch_template_name"] = launch_template_name
            if version is not None:
                self._values["version"] = version

        @builtins.property
        def launch_template_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the launch template.

            You must specify the ``LaunchTemplateId`` or the ``LaunchTemplateName`` , but not both.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-fleetlaunchtemplatespecification.html#cfn-ec2-spotfleet-fleetlaunchtemplatespecification-launchtemplateid
            '''
            result = self._values.get("launch_template_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def launch_template_name(self) -> typing.Optional[builtins.str]:
            '''The name of the launch template.

            You must specify the ``LaunchTemplateName`` or the ``LaunchTemplateId`` , but not both.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-fleetlaunchtemplatespecification.html#cfn-ec2-spotfleet-fleetlaunchtemplatespecification-launchtemplatename
            '''
            result = self._values.get("launch_template_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def version(self) -> typing.Optional[builtins.str]:
            '''The version number of the launch template.

            Specifying ``$Latest`` or ``$Default`` for the template version number is not supported. However, you can specify ``LatestVersionNumber`` or ``DefaultVersionNumber`` using the ``Fn::GetAtt`` intrinsic function. For more information, see `Fn::GetAtt <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#aws-resource-ec2-launchtemplate-return-values-fn--getatt>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-fleetlaunchtemplatespecification.html#cfn-ec2-spotfleet-fleetlaunchtemplatespecification-version
            '''
            result = self._values.get("version")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "FleetLaunchTemplateSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSpotFleetPropsMixin.GroupIdentifierProperty",
        jsii_struct_bases=[],
        name_mapping={"group_id": "groupId"},
    )
    class GroupIdentifierProperty:
        def __init__(self, *, group_id: typing.Optional[builtins.str] = None) -> None:
            '''Describes a security group.

            :param group_id: The ID of the security group.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-groupidentifier.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                group_identifier_property = ec2_mixins.CfnSpotFleetPropsMixin.GroupIdentifierProperty(
                    group_id="groupId"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__a83ac6ddf2c9a3465efa512c22d6a343ec66edd44076af4179ed66634a3c8fa4)
                check_type(argname="argument group_id", value=group_id, expected_type=type_hints["group_id"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if group_id is not None:
                self._values["group_id"] = group_id

        @builtins.property
        def group_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the security group.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-groupidentifier.html#cfn-ec2-spotfleet-groupidentifier-groupid
            '''
            result = self._values.get("group_id")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "GroupIdentifierProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSpotFleetPropsMixin.IamInstanceProfileSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={"arn": "arn"},
    )
    class IamInstanceProfileSpecificationProperty:
        def __init__(self, *, arn: typing.Optional[builtins.str] = None) -> None:
            '''Describes an IAM instance profile.

            :param arn: The Amazon Resource Name (ARN) of the instance profile.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-iaminstanceprofilespecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                iam_instance_profile_specification_property = ec2_mixins.CfnSpotFleetPropsMixin.IamInstanceProfileSpecificationProperty(
                    arn="arn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__303424c0bed8b597227a51ecbfd57b9eb0f84a0aec546a66ce99e104010530aa)
                check_type(argname="argument arn", value=arn, expected_type=type_hints["arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if arn is not None:
                self._values["arn"] = arn

        @builtins.property
        def arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the instance profile.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-iaminstanceprofilespecification.html#cfn-ec2-spotfleet-iaminstanceprofilespecification-arn
            '''
            result = self._values.get("arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "IamInstanceProfileSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSpotFleetPropsMixin.InstanceIpv6AddressProperty",
        jsii_struct_bases=[],
        name_mapping={"ipv6_address": "ipv6Address"},
    )
    class InstanceIpv6AddressProperty:
        def __init__(
            self,
            *,
            ipv6_address: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes an IPv6 address.

            :param ipv6_address: The IPv6 address.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instanceipv6address.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                instance_ipv6_address_property = ec2_mixins.CfnSpotFleetPropsMixin.InstanceIpv6AddressProperty(
                    ipv6_address="ipv6Address"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__d25a66a1a5b3fcded0e2b91e1b5afee9b1a7e932773dcc27d3c335198afec655)
                check_type(argname="argument ipv6_address", value=ipv6_address, expected_type=type_hints["ipv6_address"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if ipv6_address is not None:
                self._values["ipv6_address"] = ipv6_address

        @builtins.property
        def ipv6_address(self) -> typing.Optional[builtins.str]:
            '''The IPv6 address.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instanceipv6address.html#cfn-ec2-spotfleet-instanceipv6address-ipv6address
            '''
            result = self._values.get("ipv6_address")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "InstanceIpv6AddressProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSpotFleetPropsMixin.InstanceNetworkInterfaceSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "associate_public_ip_address": "associatePublicIpAddress",
            "delete_on_termination": "deleteOnTermination",
            "description": "description",
            "device_index": "deviceIndex",
            "groups": "groups",
            "ipv6_address_count": "ipv6AddressCount",
            "ipv6_addresses": "ipv6Addresses",
            "network_interface_id": "networkInterfaceId",
            "private_ip_addresses": "privateIpAddresses",
            "secondary_private_ip_address_count": "secondaryPrivateIpAddressCount",
            "subnet_id": "subnetId",
        },
    )
    class InstanceNetworkInterfaceSpecificationProperty:
        def __init__(
            self,
            *,
            associate_public_ip_address: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            delete_on_termination: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            description: typing.Optional[builtins.str] = None,
            device_index: typing.Optional[jsii.Number] = None,
            groups: typing.Optional[typing.Sequence[builtins.str]] = None,
            ipv6_address_count: typing.Optional[jsii.Number] = None,
            ipv6_addresses: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSpotFleetPropsMixin.InstanceIpv6AddressProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            network_interface_id: typing.Optional[builtins.str] = None,
            private_ip_addresses: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSpotFleetPropsMixin.PrivateIpAddressSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            secondary_private_ip_address_count: typing.Optional[jsii.Number] = None,
            subnet_id: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes a network interface.

            :param associate_public_ip_address: Indicates whether to assign a public IPv4 address to an instance you launch in a VPC. The public IP address can only be assigned to a network interface for eth0, and can only be assigned to a new network interface, not an existing one. You cannot specify more than one network interface in the request. If launching into a default subnet, the default value is ``true`` . AWS charges for all public IPv4 addresses, including public IPv4 addresses associated with running instances and Elastic IP addresses. For more information, see the *Public IPv4 Address* tab on the `Amazon VPC pricing page <https://docs.aws.amazon.com/vpc/pricing/>`_ .
            :param delete_on_termination: Indicates whether the network interface is deleted when the instance is terminated.
            :param description: The description of the network interface. Applies only if creating a network interface when launching an instance.
            :param device_index: The position of the network interface in the attachment order. A primary network interface has a device index of 0. If you specify a network interface when launching an instance, you must specify the device index.
            :param groups: The IDs of the security groups for the network interface. Applies only if creating a network interface when launching an instance.
            :param ipv6_address_count: A number of IPv6 addresses to assign to the network interface. Amazon EC2 chooses the IPv6 addresses from the range of the subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.
            :param ipv6_addresses: The IPv6 addresses to assign to the network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.
            :param network_interface_id: The ID of the network interface. If you are creating a Spot Fleet, omit this parameter because you cant specify a network interface ID in a launch specification.
            :param private_ip_addresses: The private IPv4 addresses to assign to the network interface. Only one private IPv4 address can be designated as primary. You cannot specify this option if you're launching more than one instance in a `RunInstances <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html>`_ request.
            :param secondary_private_ip_address_count: The number of secondary private IPv4 addresses. You cant specify this parameter and also specify a secondary private IP address using the ``PrivateIpAddress`` parameter.
            :param subnet_id: The ID of the subnet associated with the network interface.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                instance_network_interface_specification_property = ec2_mixins.CfnSpotFleetPropsMixin.InstanceNetworkInterfaceSpecificationProperty(
                    associate_public_ip_address=False,
                    delete_on_termination=False,
                    description="description",
                    device_index=123,
                    groups=["groups"],
                    ipv6_address_count=123,
                    ipv6_addresses=[ec2_mixins.CfnSpotFleetPropsMixin.InstanceIpv6AddressProperty(
                        ipv6_address="ipv6Address"
                    )],
                    network_interface_id="networkInterfaceId",
                    private_ip_addresses=[ec2_mixins.CfnSpotFleetPropsMixin.PrivateIpAddressSpecificationProperty(
                        primary=False,
                        private_ip_address="privateIpAddress"
                    )],
                    secondary_private_ip_address_count=123,
                    subnet_id="subnetId"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__742db8a91202b8e1b9a6e91545589c40fa9bee7dae23fdf9363014de40e8e45f)
                check_type(argname="argument associate_public_ip_address", value=associate_public_ip_address, expected_type=type_hints["associate_public_ip_address"])
                check_type(argname="argument delete_on_termination", value=delete_on_termination, expected_type=type_hints["delete_on_termination"])
                check_type(argname="argument description", value=description, expected_type=type_hints["description"])
                check_type(argname="argument device_index", value=device_index, expected_type=type_hints["device_index"])
                check_type(argname="argument groups", value=groups, expected_type=type_hints["groups"])
                check_type(argname="argument ipv6_address_count", value=ipv6_address_count, expected_type=type_hints["ipv6_address_count"])
                check_type(argname="argument ipv6_addresses", value=ipv6_addresses, expected_type=type_hints["ipv6_addresses"])
                check_type(argname="argument network_interface_id", value=network_interface_id, expected_type=type_hints["network_interface_id"])
                check_type(argname="argument private_ip_addresses", value=private_ip_addresses, expected_type=type_hints["private_ip_addresses"])
                check_type(argname="argument secondary_private_ip_address_count", value=secondary_private_ip_address_count, expected_type=type_hints["secondary_private_ip_address_count"])
                check_type(argname="argument subnet_id", value=subnet_id, expected_type=type_hints["subnet_id"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if associate_public_ip_address is not None:
                self._values["associate_public_ip_address"] = associate_public_ip_address
            if delete_on_termination is not None:
                self._values["delete_on_termination"] = delete_on_termination
            if description is not None:
                self._values["description"] = description
            if device_index is not None:
                self._values["device_index"] = device_index
            if groups is not None:
                self._values["groups"] = groups
            if ipv6_address_count is not None:
                self._values["ipv6_address_count"] = ipv6_address_count
            if ipv6_addresses is not None:
                self._values["ipv6_addresses"] = ipv6_addresses
            if network_interface_id is not None:
                self._values["network_interface_id"] = network_interface_id
            if private_ip_addresses is not None:
                self._values["private_ip_addresses"] = private_ip_addresses
            if secondary_private_ip_address_count is not None:
                self._values["secondary_private_ip_address_count"] = secondary_private_ip_address_count
            if subnet_id is not None:
                self._values["subnet_id"] = subnet_id

        @builtins.property
        def associate_public_ip_address(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether to assign a public IPv4 address to an instance you launch in a VPC.

            The public IP address can only be assigned to a network interface for eth0, and can only be assigned to a new network interface, not an existing one. You cannot specify more than one network interface in the request. If launching into a default subnet, the default value is ``true`` .

            AWS charges for all public IPv4 addresses, including public IPv4 addresses associated with running instances and Elastic IP addresses. For more information, see the *Public IPv4 Address* tab on the `Amazon VPC pricing page <https://docs.aws.amazon.com/vpc/pricing/>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-associatepublicipaddress
            '''
            result = self._values.get("associate_public_ip_address")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def delete_on_termination(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether the network interface is deleted when the instance is terminated.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-deleteontermination
            '''
            result = self._values.get("delete_on_termination")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def description(self) -> typing.Optional[builtins.str]:
            '''The description of the network interface.

            Applies only if creating a network interface when launching an instance.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-description
            '''
            result = self._values.get("description")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def device_index(self) -> typing.Optional[jsii.Number]:
            '''The position of the network interface in the attachment order.

            A primary network interface has a device index of 0.

            If you specify a network interface when launching an instance, you must specify the device index.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-deviceindex
            '''
            result = self._values.get("device_index")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def groups(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The IDs of the security groups for the network interface.

            Applies only if creating a network interface when launching an instance.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-groups
            '''
            result = self._values.get("groups")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def ipv6_address_count(self) -> typing.Optional[jsii.Number]:
            '''A number of IPv6 addresses to assign to the network interface.

            Amazon EC2 chooses the IPv6 addresses from the range of the subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-ipv6addresscount
            '''
            result = self._values.get("ipv6_address_count")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def ipv6_addresses(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.InstanceIpv6AddressProperty"]]]]:
            '''The IPv6 addresses to assign to the network interface.

            You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-ipv6addresses
            '''
            result = self._values.get("ipv6_addresses")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.InstanceIpv6AddressProperty"]]]], result)

        @builtins.property
        def network_interface_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the network interface.

            If you are creating a Spot Fleet, omit this parameter because you cant specify a network interface ID in a launch specification.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-networkinterfaceid
            '''
            result = self._values.get("network_interface_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def private_ip_addresses(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.PrivateIpAddressSpecificationProperty"]]]]:
            '''The private IPv4 addresses to assign to the network interface.

            Only one private IPv4 address can be designated as primary. You cannot specify this option if you're launching more than one instance in a `RunInstances <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html>`_ request.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-privateipaddresses
            '''
            result = self._values.get("private_ip_addresses")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.PrivateIpAddressSpecificationProperty"]]]], result)

        @builtins.property
        def secondary_private_ip_address_count(self) -> typing.Optional[jsii.Number]:
            '''The number of secondary private IPv4 addresses.

            You cant specify this parameter and also specify a secondary private IP address using the ``PrivateIpAddress`` parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-secondaryprivateipaddresscount
            '''
            result = self._values.get("secondary_private_ip_address_count")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def subnet_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the subnet associated with the network interface.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-subnetid
            '''
            result = self._values.get("subnet_id")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "InstanceNetworkInterfaceSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSpotFleetPropsMixin.InstanceRequirementsRequestProperty",
        jsii_struct_bases=[],
        name_mapping={
            "accelerator_count": "acceleratorCount",
            "accelerator_manufacturers": "acceleratorManufacturers",
            "accelerator_names": "acceleratorNames",
            "accelerator_total_memory_mib": "acceleratorTotalMemoryMiB",
            "accelerator_types": "acceleratorTypes",
            "allowed_instance_types": "allowedInstanceTypes",
            "bare_metal": "bareMetal",
            "baseline_ebs_bandwidth_mbps": "baselineEbsBandwidthMbps",
            "baseline_performance_factors": "baselinePerformanceFactors",
            "burstable_performance": "burstablePerformance",
            "cpu_manufacturers": "cpuManufacturers",
            "excluded_instance_types": "excludedInstanceTypes",
            "instance_generations": "instanceGenerations",
            "local_storage": "localStorage",
            "local_storage_types": "localStorageTypes",
            "max_spot_price_as_percentage_of_optimal_on_demand_price": "maxSpotPriceAsPercentageOfOptimalOnDemandPrice",
            "memory_gib_per_v_cpu": "memoryGiBPerVCpu",
            "memory_mib": "memoryMiB",
            "network_bandwidth_gbps": "networkBandwidthGbps",
            "network_interface_count": "networkInterfaceCount",
            "on_demand_max_price_percentage_over_lowest_price": "onDemandMaxPricePercentageOverLowestPrice",
            "require_encryption_in_transit": "requireEncryptionInTransit",
            "require_hibernate_support": "requireHibernateSupport",
            "spot_max_price_percentage_over_lowest_price": "spotMaxPricePercentageOverLowestPrice",
            "total_local_storage_gb": "totalLocalStorageGb",
            "v_cpu_count": "vCpuCount",
        },
    )
    class InstanceRequirementsRequestProperty:
        def __init__(
            self,
            *,
            accelerator_count: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSpotFleetPropsMixin.AcceleratorCountRequestProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            accelerator_manufacturers: typing.Optional[typing.Sequence[builtins.str]] = None,
            accelerator_names: typing.Optional[typing.Sequence[builtins.str]] = None,
            accelerator_total_memory_mib: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSpotFleetPropsMixin.AcceleratorTotalMemoryMiBRequestProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            accelerator_types: typing.Optional[typing.Sequence[builtins.str]] = None,
            allowed_instance_types: typing.Optional[typing.Sequence[builtins.str]] = None,
            bare_metal: typing.Optional[builtins.str] = None,
            baseline_ebs_bandwidth_mbps: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSpotFleetPropsMixin.BaselineEbsBandwidthMbpsRequestProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            baseline_performance_factors: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSpotFleetPropsMixin.BaselinePerformanceFactorsRequestProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            burstable_performance: typing.Optional[builtins.str] = None,
            cpu_manufacturers: typing.Optional[typing.Sequence[builtins.str]] = None,
            excluded_instance_types: typing.Optional[typing.Sequence[builtins.str]] = None,
            instance_generations: typing.Optional[typing.Sequence[builtins.str]] = None,
            local_storage: typing.Optional[builtins.str] = None,
            local_storage_types: typing.Optional[typing.Sequence[builtins.str]] = None,
            max_spot_price_as_percentage_of_optimal_on_demand_price: typing.Optional[jsii.Number] = None,
            memory_gib_per_v_cpu: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSpotFleetPropsMixin.MemoryGiBPerVCpuRequestProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            memory_mib: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSpotFleetPropsMixin.MemoryMiBRequestProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            network_bandwidth_gbps: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSpotFleetPropsMixin.NetworkBandwidthGbpsRequestProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            network_interface_count: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSpotFleetPropsMixin.NetworkInterfaceCountRequestProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            on_demand_max_price_percentage_over_lowest_price: typing.Optional[jsii.Number] = None,
            require_encryption_in_transit: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            require_hibernate_support: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            spot_max_price_percentage_over_lowest_price: typing.Optional[jsii.Number] = None,
            total_local_storage_gb: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSpotFleetPropsMixin.TotalLocalStorageGBRequestProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            v_cpu_count: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSpotFleetPropsMixin.VCpuCountRangeRequestProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''The attributes for the instance types.

            When you specify instance attributes, Amazon EC2 will identify instance types with these attributes.

            You must specify ``VCpuCount`` and ``MemoryMiB`` . All other attributes are optional. Any unspecified optional attribute is set to its default.

            When you specify multiple attributes, you get instance types that satisfy all of the specified attributes. If you specify multiple values for an attribute, you get instance types that satisfy any of the specified values.

            To limit the list of instance types from which Amazon EC2 can identify matching instance types, you can use one of the following parameters, but not both in the same request:

            - ``AllowedInstanceTypes`` - The instance types to include in the list. All other instance types are ignored, even if they match your specified attributes.
            - ``ExcludedInstanceTypes`` - The instance types to exclude from the list, even if they match your specified attributes.

            .. epigraph::

               If you specify ``InstanceRequirements`` , you can't specify ``InstanceType`` .

               Attribute-based instance type selection is only supported when using Auto Scaling groups, EC2 Fleet, and Spot Fleet to launch instances. If you plan to use the launch template in the `launch instance wizard <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-instance-wizard.html>`_ , or with the `RunInstances <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html>`_ API or `AWS::EC2::Instance <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html>`_ AWS CloudFormation resource, you can't specify ``InstanceRequirements`` .

            For more information, see `Specify attributes for instance type selection for EC2 Fleet or Spot Fleet <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html>`_ and `Spot placement score <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html>`_ in the *Amazon EC2 User Guide* .

            :param accelerator_count: The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance. To exclude accelerator-enabled instance types, set ``Max`` to ``0`` . Default: No minimum or maximum limits
            :param accelerator_manufacturers: Indicates whether instance types must have accelerators by specific manufacturers. - For instance types with AWS devices, specify ``amazon-web-services`` . - For instance types with AMD devices, specify ``amd`` . - For instance types with Habana devices, specify ``habana`` . - For instance types with NVIDIA devices, specify ``nvidia`` . - For instance types with Xilinx devices, specify ``xilinx`` . Default: Any manufacturer
            :param accelerator_names: The accelerators that must be on the instance type. - For instance types with NVIDIA A10G GPUs, specify ``a10g`` . - For instance types with NVIDIA A100 GPUs, specify ``a100`` . - For instance types with NVIDIA H100 GPUs, specify ``h100`` . - For instance types with AWS Inferentia chips, specify ``inferentia`` . - For instance types with AWS Inferentia2 chips, specify ``inferentia2`` . - For instance types with Habana Gaudi HL-205 GPUs, specify ``gaudi-hl-205`` . - For instance types with NVIDIA GRID K520 GPUs, specify ``k520`` . - For instance types with NVIDIA K80 GPUs, specify ``k80`` . - For instance types with NVIDIA L4 GPUs, specify ``l4`` . - For instance types with NVIDIA L40S GPUs, specify ``l40s`` . - For instance types with NVIDIA M60 GPUs, specify ``m60`` . - For instance types with AMD Radeon Pro V520 GPUs, specify ``radeon-pro-v520`` . - For instance types with AWS Trainium chips, specify ``trainium`` . - For instance types with AWS Trainium2 chips, specify ``trainium2`` . - For instance types with NVIDIA T4 GPUs, specify ``t4`` . - For instance types with NVIDIA T4G GPUs, specify ``t4g`` . - For instance types with Xilinx U30 cards, specify ``u30`` . - For instance types with Xilinx VU9P FPGAs, specify ``vu9p`` . - For instance types with NVIDIA V100 GPUs, specify ``v100`` . Default: Any accelerator
            :param accelerator_total_memory_mib: The minimum and maximum amount of total accelerator memory, in MiB. Default: No minimum or maximum limits
            :param accelerator_types: The accelerator types that must be on the instance type. - For instance types with FPGA accelerators, specify ``fpga`` . - For instance types with GPU accelerators, specify ``gpu`` . - For instance types with Inference accelerators, specify ``inference`` . - For instance types with Media accelerators, specify ``media`` . Default: Any accelerator type
            :param allowed_instance_types: The instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes. You can use strings with one or more wild cards, represented by an asterisk ( ``*`` ), to allow an instance type, size, or generation. The following are examples: ``m5.8xlarge`` , ``c5*.*`` , ``m5a.*`` , ``r*`` , ``*3*`` . For example, if you specify ``c5*`` ,Amazon EC2 will allow the entire C5 instance family, which includes all C5a and C5n instance types. If you specify ``m5a.*`` , Amazon EC2 will allow all the M5a instance types, but not the M5n instance types. .. epigraph:: If you specify ``AllowedInstanceTypes`` , you can't specify ``ExcludedInstanceTypes`` . Default: All instance types
            :param bare_metal: Indicates whether bare metal instance types must be included, excluded, or required. - To include bare metal instance types, specify ``included`` . - To require only bare metal instance types, specify ``required`` . - To exclude bare metal instance types, specify ``excluded`` . Default: ``excluded``
            :param baseline_ebs_bandwidth_mbps: The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see `Amazon EBSoptimized instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html>`_ in the *Amazon EC2 User Guide* . Default: No minimum or maximum limits
            :param baseline_performance_factors: The baseline performance to consider, using an instance family as a baseline reference. The instance family establishes the lowest acceptable level of performance. Amazon EC2 uses this baseline to guide instance type selection, but there is no guarantee that the selected instance types will always exceed the baseline for every application. Currently, this parameter only supports CPU performance as a baseline performance factor. For more information, see `Performance protection <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html#ec2fleet-abis-performance-protection>`_ in the *Amazon EC2 User Guide* .
            :param burstable_performance: Indicates whether burstable performance T instance types are included, excluded, or required. For more information, see `Burstable performance instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html>`_ . - To include burstable performance instance types, specify ``included`` . - To require only burstable performance instance types, specify ``required`` . - To exclude burstable performance instance types, specify ``excluded`` . Default: ``excluded``
            :param cpu_manufacturers: The CPU manufacturers to include. - For instance types with Intel CPUs, specify ``intel`` . - For instance types with AMD CPUs, specify ``amd`` . - For instance types with AWS CPUs, specify ``amazon-web-services`` . - For instance types with Apple CPUs, specify ``apple`` . .. epigraph:: Don't confuse the CPU manufacturer with the CPU architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template. Default: Any manufacturer
            :param excluded_instance_types: The instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk ( ``*`` ), to exclude an instance family, type, size, or generation. The following are examples: ``m5.8xlarge`` , ``c5*.*`` , ``m5a.*`` , ``r*`` , ``*3*`` . For example, if you specify ``c5*`` ,Amazon EC2 will exclude the entire C5 instance family, which includes all C5a and C5n instance types. If you specify ``m5a.*`` , Amazon EC2 will exclude all the M5a instance types, but not the M5n instance types. .. epigraph:: If you specify ``ExcludedInstanceTypes`` , you can't specify ``AllowedInstanceTypes`` . Default: No excluded instance types
            :param instance_generations: Indicates whether current or previous generation instance types are included. The current generation instance types are recommended for use. Current generation instance types are typically the latest two to three generations in each instance family. For more information, see `Instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html>`_ in the *Amazon EC2 User Guide* . For current generation instance types, specify ``current`` . For previous generation instance types, specify ``previous`` . Default: Current and previous generation instance types
            :param local_storage: Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, `Amazon EC2 instance store <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html>`_ in the *Amazon EC2 User Guide* . - To include instance types with instance store volumes, specify ``included`` . - To require only instance types with instance store volumes, specify ``required`` . - To exclude instance types with instance store volumes, specify ``excluded`` . Default: ``included``
            :param local_storage_types: The type of local storage that is required. - For instance types with hard disk drive (HDD) storage, specify ``hdd`` . - For instance types with solid state drive (SSD) storage, specify ``ssd`` . Default: ``hdd`` and ``ssd``
            :param max_spot_price_as_percentage_of_optimal_on_demand_price: [Price protection] The price protection threshold for Spot Instances, as a percentage of an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold. The parameter accepts an integer, which Amazon EC2 interprets as a percentage. If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib`` , the price protection threshold is based on the per vCPU or per memory price instead of the per instance price. .. epigraph:: Only one of ``SpotMaxPricePercentageOverLowestPrice`` or ``MaxSpotPriceAsPercentageOfOptimalOnDemandPrice`` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as ``999999`` .
            :param memory_gib_per_v_cpu: The minimum and maximum amount of memory per vCPU, in GiB. Default: No minimum or maximum limits
            :param memory_mib: The minimum and maximum amount of memory, in MiB.
            :param network_bandwidth_gbps: The minimum and maximum amount of baseline network bandwidth, in gigabits per second (Gbps). For more information, see `Amazon EC2 instance network bandwidth <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-network-bandwidth.html>`_ in the *Amazon EC2 User Guide* . Default: No minimum or maximum limits
            :param network_interface_count: The minimum and maximum number of network interfaces. Default: No minimum or maximum limits
            :param on_demand_max_price_percentage_over_lowest_price: [Price protection] The price protection threshold for On-Demand Instances, as a percentage higher than an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold. The parameter accepts an integer, which Amazon EC2 interprets as a percentage. To indicate no price protection threshold, specify a high value, such as ``999999`` . This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ and `GetInstanceTypesFromInstanceRequirements <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html>`_ . .. epigraph:: If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib`` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price. Default: ``20``
            :param require_encryption_in_transit: Specifies whether instance types must support encrypting in-transit traffic between instances. For more information, including the supported instance types, see `Encryption in transit <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/data-protection.html#encryption-transit>`_ in the *Amazon EC2 User Guide* . Default: ``false``
            :param require_hibernate_support: Indicates whether instance types must support hibernation for On-Demand Instances. This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ . Default: ``false``
            :param spot_max_price_percentage_over_lowest_price: [Price protection] The price protection threshold for Spot Instances, as a percentage higher than an identified Spot price. The identified Spot price is the Spot price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified Spot price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose Spot price exceeds your specified threshold. The parameter accepts an integer, which Amazon EC2 interprets as a percentage. If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib`` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price. This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ and `GetInstanceTypesFromInstanceRequirements <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html>`_ . .. epigraph:: Only one of ``SpotMaxPricePercentageOverLowestPrice`` or ``MaxSpotPriceAsPercentageOfOptimalOnDemandPrice`` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as ``999999`` . Default: ``100``
            :param total_local_storage_gb: The minimum and maximum amount of total local storage, in GB. Default: No minimum or maximum limits
            :param v_cpu_count: The minimum and maximum number of vCPUs.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                instance_requirements_request_property = ec2_mixins.CfnSpotFleetPropsMixin.InstanceRequirementsRequestProperty(
                    accelerator_count=ec2_mixins.CfnSpotFleetPropsMixin.AcceleratorCountRequestProperty(
                        max=123,
                        min=123
                    ),
                    accelerator_manufacturers=["acceleratorManufacturers"],
                    accelerator_names=["acceleratorNames"],
                    accelerator_total_memory_mi_b=ec2_mixins.CfnSpotFleetPropsMixin.AcceleratorTotalMemoryMiBRequestProperty(
                        max=123,
                        min=123
                    ),
                    accelerator_types=["acceleratorTypes"],
                    allowed_instance_types=["allowedInstanceTypes"],
                    bare_metal="bareMetal",
                    baseline_ebs_bandwidth_mbps=ec2_mixins.CfnSpotFleetPropsMixin.BaselineEbsBandwidthMbpsRequestProperty(
                        max=123,
                        min=123
                    ),
                    baseline_performance_factors=ec2_mixins.CfnSpotFleetPropsMixin.BaselinePerformanceFactorsRequestProperty(
                        cpu=ec2_mixins.CfnSpotFleetPropsMixin.CpuPerformanceFactorRequestProperty(
                            references=[ec2_mixins.CfnSpotFleetPropsMixin.PerformanceFactorReferenceRequestProperty(
                                instance_family="instanceFamily"
                            )]
                        )
                    ),
                    burstable_performance="burstablePerformance",
                    cpu_manufacturers=["cpuManufacturers"],
                    excluded_instance_types=["excludedInstanceTypes"],
                    instance_generations=["instanceGenerations"],
                    local_storage="localStorage",
                    local_storage_types=["localStorageTypes"],
                    max_spot_price_as_percentage_of_optimal_on_demand_price=123,
                    memory_gi_bPer_vCpu=ec2_mixins.CfnSpotFleetPropsMixin.MemoryGiBPerVCpuRequestProperty(
                        max=123,
                        min=123
                    ),
                    memory_mi_b=ec2_mixins.CfnSpotFleetPropsMixin.MemoryMiBRequestProperty(
                        max=123,
                        min=123
                    ),
                    network_bandwidth_gbps=ec2_mixins.CfnSpotFleetPropsMixin.NetworkBandwidthGbpsRequestProperty(
                        max=123,
                        min=123
                    ),
                    network_interface_count=ec2_mixins.CfnSpotFleetPropsMixin.NetworkInterfaceCountRequestProperty(
                        max=123,
                        min=123
                    ),
                    on_demand_max_price_percentage_over_lowest_price=123,
                    require_encryption_in_transit=False,
                    require_hibernate_support=False,
                    spot_max_price_percentage_over_lowest_price=123,
                    total_local_storage_gb=ec2_mixins.CfnSpotFleetPropsMixin.TotalLocalStorageGBRequestProperty(
                        max=123,
                        min=123
                    ),
                    v_cpu_count=ec2_mixins.CfnSpotFleetPropsMixin.VCpuCountRangeRequestProperty(
                        max=123,
                        min=123
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__4d55884cd3a399caafb6c4fa0d7489ff6691b5499a97de05104b1dcbd5088e13)
                check_type(argname="argument accelerator_count", value=accelerator_count, expected_type=type_hints["accelerator_count"])
                check_type(argname="argument accelerator_manufacturers", value=accelerator_manufacturers, expected_type=type_hints["accelerator_manufacturers"])
                check_type(argname="argument accelerator_names", value=accelerator_names, expected_type=type_hints["accelerator_names"])
                check_type(argname="argument accelerator_total_memory_mib", value=accelerator_total_memory_mib, expected_type=type_hints["accelerator_total_memory_mib"])
                check_type(argname="argument accelerator_types", value=accelerator_types, expected_type=type_hints["accelerator_types"])
                check_type(argname="argument allowed_instance_types", value=allowed_instance_types, expected_type=type_hints["allowed_instance_types"])
                check_type(argname="argument bare_metal", value=bare_metal, expected_type=type_hints["bare_metal"])
                check_type(argname="argument baseline_ebs_bandwidth_mbps", value=baseline_ebs_bandwidth_mbps, expected_type=type_hints["baseline_ebs_bandwidth_mbps"])
                check_type(argname="argument baseline_performance_factors", value=baseline_performance_factors, expected_type=type_hints["baseline_performance_factors"])
                check_type(argname="argument burstable_performance", value=burstable_performance, expected_type=type_hints["burstable_performance"])
                check_type(argname="argument cpu_manufacturers", value=cpu_manufacturers, expected_type=type_hints["cpu_manufacturers"])
                check_type(argname="argument excluded_instance_types", value=excluded_instance_types, expected_type=type_hints["excluded_instance_types"])
                check_type(argname="argument instance_generations", value=instance_generations, expected_type=type_hints["instance_generations"])
                check_type(argname="argument local_storage", value=local_storage, expected_type=type_hints["local_storage"])
                check_type(argname="argument local_storage_types", value=local_storage_types, expected_type=type_hints["local_storage_types"])
                check_type(argname="argument max_spot_price_as_percentage_of_optimal_on_demand_price", value=max_spot_price_as_percentage_of_optimal_on_demand_price, expected_type=type_hints["max_spot_price_as_percentage_of_optimal_on_demand_price"])
                check_type(argname="argument memory_gib_per_v_cpu", value=memory_gib_per_v_cpu, expected_type=type_hints["memory_gib_per_v_cpu"])
                check_type(argname="argument memory_mib", value=memory_mib, expected_type=type_hints["memory_mib"])
                check_type(argname="argument network_bandwidth_gbps", value=network_bandwidth_gbps, expected_type=type_hints["network_bandwidth_gbps"])
                check_type(argname="argument network_interface_count", value=network_interface_count, expected_type=type_hints["network_interface_count"])
                check_type(argname="argument on_demand_max_price_percentage_over_lowest_price", value=on_demand_max_price_percentage_over_lowest_price, expected_type=type_hints["on_demand_max_price_percentage_over_lowest_price"])
                check_type(argname="argument require_encryption_in_transit", value=require_encryption_in_transit, expected_type=type_hints["require_encryption_in_transit"])
                check_type(argname="argument require_hibernate_support", value=require_hibernate_support, expected_type=type_hints["require_hibernate_support"])
                check_type(argname="argument spot_max_price_percentage_over_lowest_price", value=spot_max_price_percentage_over_lowest_price, expected_type=type_hints["spot_max_price_percentage_over_lowest_price"])
                check_type(argname="argument total_local_storage_gb", value=total_local_storage_gb, expected_type=type_hints["total_local_storage_gb"])
                check_type(argname="argument v_cpu_count", value=v_cpu_count, expected_type=type_hints["v_cpu_count"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if accelerator_count is not None:
                self._values["accelerator_count"] = accelerator_count
            if accelerator_manufacturers is not None:
                self._values["accelerator_manufacturers"] = accelerator_manufacturers
            if accelerator_names is not None:
                self._values["accelerator_names"] = accelerator_names
            if accelerator_total_memory_mib is not None:
                self._values["accelerator_total_memory_mib"] = accelerator_total_memory_mib
            if accelerator_types is not None:
                self._values["accelerator_types"] = accelerator_types
            if allowed_instance_types is not None:
                self._values["allowed_instance_types"] = allowed_instance_types
            if bare_metal is not None:
                self._values["bare_metal"] = bare_metal
            if baseline_ebs_bandwidth_mbps is not None:
                self._values["baseline_ebs_bandwidth_mbps"] = baseline_ebs_bandwidth_mbps
            if baseline_performance_factors is not None:
                self._values["baseline_performance_factors"] = baseline_performance_factors
            if burstable_performance is not None:
                self._values["burstable_performance"] = burstable_performance
            if cpu_manufacturers is not None:
                self._values["cpu_manufacturers"] = cpu_manufacturers
            if excluded_instance_types is not None:
                self._values["excluded_instance_types"] = excluded_instance_types
            if instance_generations is not None:
                self._values["instance_generations"] = instance_generations
            if local_storage is not None:
                self._values["local_storage"] = local_storage
            if local_storage_types is not None:
                self._values["local_storage_types"] = local_storage_types
            if max_spot_price_as_percentage_of_optimal_on_demand_price is not None:
                self._values["max_spot_price_as_percentage_of_optimal_on_demand_price"] = max_spot_price_as_percentage_of_optimal_on_demand_price
            if memory_gib_per_v_cpu is not None:
                self._values["memory_gib_per_v_cpu"] = memory_gib_per_v_cpu
            if memory_mib is not None:
                self._values["memory_mib"] = memory_mib
            if network_bandwidth_gbps is not None:
                self._values["network_bandwidth_gbps"] = network_bandwidth_gbps
            if network_interface_count is not None:
                self._values["network_interface_count"] = network_interface_count
            if on_demand_max_price_percentage_over_lowest_price is not None:
                self._values["on_demand_max_price_percentage_over_lowest_price"] = on_demand_max_price_percentage_over_lowest_price
            if require_encryption_in_transit is not None:
                self._values["require_encryption_in_transit"] = require_encryption_in_transit
            if require_hibernate_support is not None:
                self._values["require_hibernate_support"] = require_hibernate_support
            if spot_max_price_percentage_over_lowest_price is not None:
                self._values["spot_max_price_percentage_over_lowest_price"] = spot_max_price_percentage_over_lowest_price
            if total_local_storage_gb is not None:
                self._values["total_local_storage_gb"] = total_local_storage_gb
            if v_cpu_count is not None:
                self._values["v_cpu_count"] = v_cpu_count

        @builtins.property
        def accelerator_count(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.AcceleratorCountRequestProperty"]]:
            '''The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.

            To exclude accelerator-enabled instance types, set ``Max`` to ``0`` .

            Default: No minimum or maximum limits

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-acceleratorcount
            '''
            result = self._values.get("accelerator_count")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.AcceleratorCountRequestProperty"]], result)

        @builtins.property
        def accelerator_manufacturers(
            self,
        ) -> typing.Optional[typing.List[builtins.str]]:
            '''Indicates whether instance types must have accelerators by specific manufacturers.

            - For instance types with AWS devices, specify ``amazon-web-services`` .
            - For instance types with AMD devices, specify ``amd`` .
            - For instance types with Habana devices, specify ``habana`` .
            - For instance types with NVIDIA devices, specify ``nvidia`` .
            - For instance types with Xilinx devices, specify ``xilinx`` .

            Default: Any manufacturer

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-acceleratormanufacturers
            '''
            result = self._values.get("accelerator_manufacturers")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def accelerator_names(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The accelerators that must be on the instance type.

            - For instance types with NVIDIA A10G GPUs, specify ``a10g`` .
            - For instance types with NVIDIA A100 GPUs, specify ``a100`` .
            - For instance types with NVIDIA H100 GPUs, specify ``h100`` .
            - For instance types with AWS Inferentia chips, specify ``inferentia`` .
            - For instance types with AWS Inferentia2 chips, specify ``inferentia2`` .
            - For instance types with Habana Gaudi HL-205 GPUs, specify ``gaudi-hl-205`` .
            - For instance types with NVIDIA GRID K520 GPUs, specify ``k520`` .
            - For instance types with NVIDIA K80 GPUs, specify ``k80`` .
            - For instance types with NVIDIA L4 GPUs, specify ``l4`` .
            - For instance types with NVIDIA L40S GPUs, specify ``l40s`` .
            - For instance types with NVIDIA M60 GPUs, specify ``m60`` .
            - For instance types with AMD Radeon Pro V520 GPUs, specify ``radeon-pro-v520`` .
            - For instance types with AWS Trainium chips, specify ``trainium`` .
            - For instance types with AWS Trainium2 chips, specify ``trainium2`` .
            - For instance types with NVIDIA T4 GPUs, specify ``t4`` .
            - For instance types with NVIDIA T4G GPUs, specify ``t4g`` .
            - For instance types with Xilinx U30 cards, specify ``u30`` .
            - For instance types with Xilinx VU9P FPGAs, specify ``vu9p`` .
            - For instance types with NVIDIA V100 GPUs, specify ``v100`` .

            Default: Any accelerator

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-acceleratornames
            '''
            result = self._values.get("accelerator_names")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def accelerator_total_memory_mib(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.AcceleratorTotalMemoryMiBRequestProperty"]]:
            '''The minimum and maximum amount of total accelerator memory, in MiB.

            Default: No minimum or maximum limits

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-acceleratortotalmemorymib
            '''
            result = self._values.get("accelerator_total_memory_mib")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.AcceleratorTotalMemoryMiBRequestProperty"]], result)

        @builtins.property
        def accelerator_types(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The accelerator types that must be on the instance type.

            - For instance types with FPGA accelerators, specify ``fpga`` .
            - For instance types with GPU accelerators, specify ``gpu`` .
            - For instance types with Inference accelerators, specify ``inference`` .
            - For instance types with Media accelerators, specify ``media`` .

            Default: Any accelerator type

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-acceleratortypes
            '''
            result = self._values.get("accelerator_types")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def allowed_instance_types(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The instance types to apply your specified attributes against.

            All other instance types are ignored, even if they match your specified attributes.

            You can use strings with one or more wild cards, represented by an asterisk ( ``*`` ), to allow an instance type, size, or generation. The following are examples: ``m5.8xlarge`` , ``c5*.*`` , ``m5a.*`` , ``r*`` , ``*3*`` .

            For example, if you specify ``c5*`` ,Amazon EC2 will allow the entire C5 instance family, which includes all C5a and C5n instance types. If you specify ``m5a.*`` , Amazon EC2 will allow all the M5a instance types, but not the M5n instance types.
            .. epigraph::

               If you specify ``AllowedInstanceTypes`` , you can't specify ``ExcludedInstanceTypes`` .

            Default: All instance types

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-allowedinstancetypes
            '''
            result = self._values.get("allowed_instance_types")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def bare_metal(self) -> typing.Optional[builtins.str]:
            '''Indicates whether bare metal instance types must be included, excluded, or required.

            - To include bare metal instance types, specify ``included`` .
            - To require only bare metal instance types, specify ``required`` .
            - To exclude bare metal instance types, specify ``excluded`` .

            Default: ``excluded``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-baremetal
            '''
            result = self._values.get("bare_metal")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def baseline_ebs_bandwidth_mbps(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.BaselineEbsBandwidthMbpsRequestProperty"]]:
            '''The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps.

            For more information, see `Amazon EBSoptimized instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html>`_ in the *Amazon EC2 User Guide* .

            Default: No minimum or maximum limits

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-baselineebsbandwidthmbps
            '''
            result = self._values.get("baseline_ebs_bandwidth_mbps")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.BaselineEbsBandwidthMbpsRequestProperty"]], result)

        @builtins.property
        def baseline_performance_factors(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.BaselinePerformanceFactorsRequestProperty"]]:
            '''The baseline performance to consider, using an instance family as a baseline reference.

            The instance family establishes the lowest acceptable level of performance. Amazon EC2 uses this baseline to guide instance type selection, but there is no guarantee that the selected instance types will always exceed the baseline for every application. Currently, this parameter only supports CPU performance as a baseline performance factor. For more information, see `Performance protection <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html#ec2fleet-abis-performance-protection>`_ in the *Amazon EC2 User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-baselineperformancefactors
            '''
            result = self._values.get("baseline_performance_factors")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.BaselinePerformanceFactorsRequestProperty"]], result)

        @builtins.property
        def burstable_performance(self) -> typing.Optional[builtins.str]:
            '''Indicates whether burstable performance T instance types are included, excluded, or required.

            For more information, see `Burstable performance instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html>`_ .

            - To include burstable performance instance types, specify ``included`` .
            - To require only burstable performance instance types, specify ``required`` .
            - To exclude burstable performance instance types, specify ``excluded`` .

            Default: ``excluded``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-burstableperformance
            '''
            result = self._values.get("burstable_performance")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def cpu_manufacturers(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The CPU manufacturers to include.

            - For instance types with Intel CPUs, specify ``intel`` .
            - For instance types with AMD CPUs, specify ``amd`` .
            - For instance types with AWS CPUs, specify ``amazon-web-services`` .
            - For instance types with Apple CPUs, specify ``apple`` .

            .. epigraph::

               Don't confuse the CPU manufacturer with the CPU architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.

            Default: Any manufacturer

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-cpumanufacturers
            '''
            result = self._values.get("cpu_manufacturers")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def excluded_instance_types(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The instance types to exclude.

            You can use strings with one or more wild cards, represented by an asterisk ( ``*`` ), to exclude an instance family, type, size, or generation. The following are examples: ``m5.8xlarge`` , ``c5*.*`` , ``m5a.*`` , ``r*`` , ``*3*`` .

            For example, if you specify ``c5*`` ,Amazon EC2 will exclude the entire C5 instance family, which includes all C5a and C5n instance types. If you specify ``m5a.*`` , Amazon EC2 will exclude all the M5a instance types, but not the M5n instance types.
            .. epigraph::

               If you specify ``ExcludedInstanceTypes`` , you can't specify ``AllowedInstanceTypes`` .

            Default: No excluded instance types

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-excludedinstancetypes
            '''
            result = self._values.get("excluded_instance_types")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def instance_generations(self) -> typing.Optional[typing.List[builtins.str]]:
            '''Indicates whether current or previous generation instance types are included.

            The current generation instance types are recommended for use. Current generation instance types are typically the latest two to three generations in each instance family. For more information, see `Instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html>`_ in the *Amazon EC2 User Guide* .

            For current generation instance types, specify ``current`` .

            For previous generation instance types, specify ``previous`` .

            Default: Current and previous generation instance types

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-instancegenerations
            '''
            result = self._values.get("instance_generations")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def local_storage(self) -> typing.Optional[builtins.str]:
            '''Indicates whether instance types with instance store volumes are included, excluded, or required.

            For more information, `Amazon EC2 instance store <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html>`_ in the *Amazon EC2 User Guide* .

            - To include instance types with instance store volumes, specify ``included`` .
            - To require only instance types with instance store volumes, specify ``required`` .
            - To exclude instance types with instance store volumes, specify ``excluded`` .

            Default: ``included``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-localstorage
            '''
            result = self._values.get("local_storage")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def local_storage_types(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The type of local storage that is required.

            - For instance types with hard disk drive (HDD) storage, specify ``hdd`` .
            - For instance types with solid state drive (SSD) storage, specify ``ssd`` .

            Default: ``hdd`` and ``ssd``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-localstoragetypes
            '''
            result = self._values.get("local_storage_types")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def max_spot_price_as_percentage_of_optimal_on_demand_price(
            self,
        ) -> typing.Optional[jsii.Number]:
            '''[Price protection] The price protection threshold for Spot Instances, as a percentage of an identified On-Demand price.

            The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.

            The parameter accepts an integer, which Amazon EC2 interprets as a percentage.

            If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib`` , the price protection threshold is based on the per vCPU or per memory price instead of the per instance price.
            .. epigraph::

               Only one of ``SpotMaxPricePercentageOverLowestPrice`` or ``MaxSpotPriceAsPercentageOfOptimalOnDemandPrice`` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as ``999999`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-maxspotpriceaspercentageofoptimalondemandprice
            '''
            result = self._values.get("max_spot_price_as_percentage_of_optimal_on_demand_price")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def memory_gib_per_v_cpu(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.MemoryGiBPerVCpuRequestProperty"]]:
            '''The minimum and maximum amount of memory per vCPU, in GiB.

            Default: No minimum or maximum limits

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-memorygibpervcpu
            '''
            result = self._values.get("memory_gib_per_v_cpu")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.MemoryGiBPerVCpuRequestProperty"]], result)

        @builtins.property
        def memory_mib(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.MemoryMiBRequestProperty"]]:
            '''The minimum and maximum amount of memory, in MiB.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-memorymib
            '''
            result = self._values.get("memory_mib")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.MemoryMiBRequestProperty"]], result)

        @builtins.property
        def network_bandwidth_gbps(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.NetworkBandwidthGbpsRequestProperty"]]:
            '''The minimum and maximum amount of baseline network bandwidth, in gigabits per second (Gbps).

            For more information, see `Amazon EC2 instance network bandwidth <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-network-bandwidth.html>`_ in the *Amazon EC2 User Guide* .

            Default: No minimum or maximum limits

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-networkbandwidthgbps
            '''
            result = self._values.get("network_bandwidth_gbps")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.NetworkBandwidthGbpsRequestProperty"]], result)

        @builtins.property
        def network_interface_count(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.NetworkInterfaceCountRequestProperty"]]:
            '''The minimum and maximum number of network interfaces.

            Default: No minimum or maximum limits

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-networkinterfacecount
            '''
            result = self._values.get("network_interface_count")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.NetworkInterfaceCountRequestProperty"]], result)

        @builtins.property
        def on_demand_max_price_percentage_over_lowest_price(
            self,
        ) -> typing.Optional[jsii.Number]:
            '''[Price protection] The price protection threshold for On-Demand Instances, as a percentage higher than an identified On-Demand price.

            The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.

            The parameter accepts an integer, which Amazon EC2 interprets as a percentage.

            To indicate no price protection threshold, specify a high value, such as ``999999`` .

            This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ and `GetInstanceTypesFromInstanceRequirements <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html>`_ .
            .. epigraph::

               If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib`` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.

            Default: ``20``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-ondemandmaxpricepercentageoverlowestprice
            '''
            result = self._values.get("on_demand_max_price_percentage_over_lowest_price")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def require_encryption_in_transit(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Specifies whether instance types must support encrypting in-transit traffic between instances.

            For more information, including the supported instance types, see `Encryption in transit <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/data-protection.html#encryption-transit>`_ in the *Amazon EC2 User Guide* .

            Default: ``false``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-requireencryptionintransit
            '''
            result = self._values.get("require_encryption_in_transit")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def require_hibernate_support(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether instance types must support hibernation for On-Demand Instances.

            This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ .

            Default: ``false``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-requirehibernatesupport
            '''
            result = self._values.get("require_hibernate_support")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def spot_max_price_percentage_over_lowest_price(
            self,
        ) -> typing.Optional[jsii.Number]:
            '''[Price protection] The price protection threshold for Spot Instances, as a percentage higher than an identified Spot price.

            The identified Spot price is the Spot price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified Spot price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose Spot price exceeds your specified threshold.

            The parameter accepts an integer, which Amazon EC2 interprets as a percentage.

            If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib`` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.

            This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ and `GetInstanceTypesFromInstanceRequirements <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html>`_ .
            .. epigraph::

               Only one of ``SpotMaxPricePercentageOverLowestPrice`` or ``MaxSpotPriceAsPercentageOfOptimalOnDemandPrice`` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as ``999999`` .

            Default: ``100``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-spotmaxpricepercentageoverlowestprice
            '''
            result = self._values.get("spot_max_price_percentage_over_lowest_price")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def total_local_storage_gb(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.TotalLocalStorageGBRequestProperty"]]:
            '''The minimum and maximum amount of total local storage, in GB.

            Default: No minimum or maximum limits

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-totallocalstoragegb
            '''
            result = self._values.get("total_local_storage_gb")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.TotalLocalStorageGBRequestProperty"]], result)

        @builtins.property
        def v_cpu_count(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.VCpuCountRangeRequestProperty"]]:
            '''The minimum and maximum number of vCPUs.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-vcpucount
            '''
            result = self._values.get("v_cpu_count")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.VCpuCountRangeRequestProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "InstanceRequirementsRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSpotFleetPropsMixin.LaunchTemplateConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "launch_template_specification": "launchTemplateSpecification",
            "overrides": "overrides",
        },
    )
    class LaunchTemplateConfigProperty:
        def __init__(
            self,
            *,
            launch_template_specification: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSpotFleetPropsMixin.FleetLaunchTemplateSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            overrides: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSpotFleetPropsMixin.LaunchTemplateOverridesProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ) -> None:
            '''Specifies a launch template and overrides.

            :param launch_template_specification: The launch template to use. Make sure that the launch template does not contain the ``NetworkInterfaceId`` parameter because you can't specify a network interface ID in a Spot Fleet.
            :param overrides: Any parameters that you specify override the same parameters in the launch template.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateconfig.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                launch_template_config_property = ec2_mixins.CfnSpotFleetPropsMixin.LaunchTemplateConfigProperty(
                    launch_template_specification=ec2_mixins.CfnSpotFleetPropsMixin.FleetLaunchTemplateSpecificationProperty(
                        launch_template_id="launchTemplateId",
                        launch_template_name="launchTemplateName",
                        version="version"
                    ),
                    overrides=[ec2_mixins.CfnSpotFleetPropsMixin.LaunchTemplateOverridesProperty(
                        availability_zone="availabilityZone",
                        availability_zone_id="availabilityZoneId",
                        instance_requirements=ec2_mixins.CfnSpotFleetPropsMixin.InstanceRequirementsRequestProperty(
                            accelerator_count=ec2_mixins.CfnSpotFleetPropsMixin.AcceleratorCountRequestProperty(
                                max=123,
                                min=123
                            ),
                            accelerator_manufacturers=["acceleratorManufacturers"],
                            accelerator_names=["acceleratorNames"],
                            accelerator_total_memory_mi_b=ec2_mixins.CfnSpotFleetPropsMixin.AcceleratorTotalMemoryMiBRequestProperty(
                                max=123,
                                min=123
                            ),
                            accelerator_types=["acceleratorTypes"],
                            allowed_instance_types=["allowedInstanceTypes"],
                            bare_metal="bareMetal",
                            baseline_ebs_bandwidth_mbps=ec2_mixins.CfnSpotFleetPropsMixin.BaselineEbsBandwidthMbpsRequestProperty(
                                max=123,
                                min=123
                            ),
                            baseline_performance_factors=ec2_mixins.CfnSpotFleetPropsMixin.BaselinePerformanceFactorsRequestProperty(
                                cpu=ec2_mixins.CfnSpotFleetPropsMixin.CpuPerformanceFactorRequestProperty(
                                    references=[ec2_mixins.CfnSpotFleetPropsMixin.PerformanceFactorReferenceRequestProperty(
                                        instance_family="instanceFamily"
                                    )]
                                )
                            ),
                            burstable_performance="burstablePerformance",
                            cpu_manufacturers=["cpuManufacturers"],
                            excluded_instance_types=["excludedInstanceTypes"],
                            instance_generations=["instanceGenerations"],
                            local_storage="localStorage",
                            local_storage_types=["localStorageTypes"],
                            max_spot_price_as_percentage_of_optimal_on_demand_price=123,
                            memory_gi_bPer_vCpu=ec2_mixins.CfnSpotFleetPropsMixin.MemoryGiBPerVCpuRequestProperty(
                                max=123,
                                min=123
                            ),
                            memory_mi_b=ec2_mixins.CfnSpotFleetPropsMixin.MemoryMiBRequestProperty(
                                max=123,
                                min=123
                            ),
                            network_bandwidth_gbps=ec2_mixins.CfnSpotFleetPropsMixin.NetworkBandwidthGbpsRequestProperty(
                                max=123,
                                min=123
                            ),
                            network_interface_count=ec2_mixins.CfnSpotFleetPropsMixin.NetworkInterfaceCountRequestProperty(
                                max=123,
                                min=123
                            ),
                            on_demand_max_price_percentage_over_lowest_price=123,
                            require_encryption_in_transit=False,
                            require_hibernate_support=False,
                            spot_max_price_percentage_over_lowest_price=123,
                            total_local_storage_gb=ec2_mixins.CfnSpotFleetPropsMixin.TotalLocalStorageGBRequestProperty(
                                max=123,
                                min=123
                            ),
                            v_cpu_count=ec2_mixins.CfnSpotFleetPropsMixin.VCpuCountRangeRequestProperty(
                                max=123,
                                min=123
                            )
                        ),
                        instance_type="instanceType",
                        priority=123,
                        spot_price="spotPrice",
                        subnet_id="subnetId",
                        weighted_capacity=123
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__c75488536f3f88db6ffa05da35984419ca2926ad0967f45c7f5ad89884367519)
                check_type(argname="argument launch_template_specification", value=launch_template_specification, expected_type=type_hints["launch_template_specification"])
                check_type(argname="argument overrides", value=overrides, expected_type=type_hints["overrides"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if launch_template_specification is not None:
                self._values["launch_template_specification"] = launch_template_specification
            if overrides is not None:
                self._values["overrides"] = overrides

        @builtins.property
        def launch_template_specification(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.FleetLaunchTemplateSpecificationProperty"]]:
            '''The launch template to use.

            Make sure that the launch template does not contain the ``NetworkInterfaceId`` parameter because you can't specify a network interface ID in a Spot Fleet.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateconfig.html#cfn-ec2-spotfleet-launchtemplateconfig-launchtemplatespecification
            '''
            result = self._values.get("launch_template_specification")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.FleetLaunchTemplateSpecificationProperty"]], result)

        @builtins.property
        def overrides(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.LaunchTemplateOverridesProperty"]]]]:
            '''Any parameters that you specify override the same parameters in the launch template.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateconfig.html#cfn-ec2-spotfleet-launchtemplateconfig-overrides
            '''
            result = self._values.get("overrides")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.LaunchTemplateOverridesProperty"]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "LaunchTemplateConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSpotFleetPropsMixin.LaunchTemplateOverridesProperty",
        jsii_struct_bases=[],
        name_mapping={
            "availability_zone": "availabilityZone",
            "availability_zone_id": "availabilityZoneId",
            "instance_requirements": "instanceRequirements",
            "instance_type": "instanceType",
            "priority": "priority",
            "spot_price": "spotPrice",
            "subnet_id": "subnetId",
            "weighted_capacity": "weightedCapacity",
        },
    )
    class LaunchTemplateOverridesProperty:
        def __init__(
            self,
            *,
            availability_zone: typing.Optional[builtins.str] = None,
            availability_zone_id: typing.Optional[builtins.str] = None,
            instance_requirements: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSpotFleetPropsMixin.InstanceRequirementsRequestProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            instance_type: typing.Optional[builtins.str] = None,
            priority: typing.Optional[jsii.Number] = None,
            spot_price: typing.Optional[builtins.str] = None,
            subnet_id: typing.Optional[builtins.str] = None,
            weighted_capacity: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Specifies overrides for a launch template.

            :param availability_zone: The Availability Zone in which to launch the instances. For example, ``us-east-2a`` . Either ``AvailabilityZone`` or ``AvailabilityZoneId`` must be specified in the request, but not both.
            :param availability_zone_id: The ID of the Availability Zone in which to launch the instances. For example, ``use2-az1`` . Either ``AvailabilityZone`` or ``AvailabilityZoneId`` must be specified in the request, but not both.
            :param instance_requirements: The instance requirements. When you specify instance requirements, Amazon EC2 will identify instance types with the provided requirements, and then use your On-Demand and Spot allocation strategies to launch instances from these instance types, in the same way as when you specify a list of instance types. .. epigraph:: If you specify ``InstanceRequirements`` , you can't specify ``InstanceType`` .
            :param instance_type: The instance type.
            :param priority: The priority for the launch template override. The highest priority is launched first. If ``OnDemandAllocationStrategy`` is set to ``prioritized`` , Spot Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity. If the Spot ``AllocationStrategy`` is set to ``capacityOptimizedPrioritized`` , Spot Fleet uses priority on a best-effort basis to determine which launch template override to use in fulfilling Spot capacity, but optimizes for capacity first. Valid values are whole numbers starting at ``0`` . The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority. You can set the same priority for different launch template overrides.
            :param spot_price: The maximum price per unit hour that you are willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price. .. epigraph:: If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.
            :param subnet_id: The ID of the subnet in which to launch the instances.
            :param weighted_capacity: The number of units provided by the specified instance type. These are the same units that you chose to set the target capacity in terms of instances, or a performance characteristic such as vCPUs, memory, or I/O. If the target capacity divided by this value is not a whole number, Amazon EC2 rounds the number of instances to the next whole number. If this value is not specified, the default is 1. .. epigraph:: When specifying weights, the price used in the ``lowestPrice`` and ``priceCapacityOptimized`` allocation strategies is per *unit* hour (where the instance price is divided by the specified weight). However, if all the specified weights are above the requested ``TargetCapacity`` , resulting in only 1 instance being launched, the price used is per *instance* hour.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateoverrides.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                launch_template_overrides_property = ec2_mixins.CfnSpotFleetPropsMixin.LaunchTemplateOverridesProperty(
                    availability_zone="availabilityZone",
                    availability_zone_id="availabilityZoneId",
                    instance_requirements=ec2_mixins.CfnSpotFleetPropsMixin.InstanceRequirementsRequestProperty(
                        accelerator_count=ec2_mixins.CfnSpotFleetPropsMixin.AcceleratorCountRequestProperty(
                            max=123,
                            min=123
                        ),
                        accelerator_manufacturers=["acceleratorManufacturers"],
                        accelerator_names=["acceleratorNames"],
                        accelerator_total_memory_mi_b=ec2_mixins.CfnSpotFleetPropsMixin.AcceleratorTotalMemoryMiBRequestProperty(
                            max=123,
                            min=123
                        ),
                        accelerator_types=["acceleratorTypes"],
                        allowed_instance_types=["allowedInstanceTypes"],
                        bare_metal="bareMetal",
                        baseline_ebs_bandwidth_mbps=ec2_mixins.CfnSpotFleetPropsMixin.BaselineEbsBandwidthMbpsRequestProperty(
                            max=123,
                            min=123
                        ),
                        baseline_performance_factors=ec2_mixins.CfnSpotFleetPropsMixin.BaselinePerformanceFactorsRequestProperty(
                            cpu=ec2_mixins.CfnSpotFleetPropsMixin.CpuPerformanceFactorRequestProperty(
                                references=[ec2_mixins.CfnSpotFleetPropsMixin.PerformanceFactorReferenceRequestProperty(
                                    instance_family="instanceFamily"
                                )]
                            )
                        ),
                        burstable_performance="burstablePerformance",
                        cpu_manufacturers=["cpuManufacturers"],
                        excluded_instance_types=["excludedInstanceTypes"],
                        instance_generations=["instanceGenerations"],
                        local_storage="localStorage",
                        local_storage_types=["localStorageTypes"],
                        max_spot_price_as_percentage_of_optimal_on_demand_price=123,
                        memory_gi_bPer_vCpu=ec2_mixins.CfnSpotFleetPropsMixin.MemoryGiBPerVCpuRequestProperty(
                            max=123,
                            min=123
                        ),
                        memory_mi_b=ec2_mixins.CfnSpotFleetPropsMixin.MemoryMiBRequestProperty(
                            max=123,
                            min=123
                        ),
                        network_bandwidth_gbps=ec2_mixins.CfnSpotFleetPropsMixin.NetworkBandwidthGbpsRequestProperty(
                            max=123,
                            min=123
                        ),
                        network_interface_count=ec2_mixins.CfnSpotFleetPropsMixin.NetworkInterfaceCountRequestProperty(
                            max=123,
                            min=123
                        ),
                        on_demand_max_price_percentage_over_lowest_price=123,
                        require_encryption_in_transit=False,
                        require_hibernate_support=False,
                        spot_max_price_percentage_over_lowest_price=123,
                        total_local_storage_gb=ec2_mixins.CfnSpotFleetPropsMixin.TotalLocalStorageGBRequestProperty(
                            max=123,
                            min=123
                        ),
                        v_cpu_count=ec2_mixins.CfnSpotFleetPropsMixin.VCpuCountRangeRequestProperty(
                            max=123,
                            min=123
                        )
                    ),
                    instance_type="instanceType",
                    priority=123,
                    spot_price="spotPrice",
                    subnet_id="subnetId",
                    weighted_capacity=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__b3a64607d59b50bd2cb6c4d5fd37e260ff2b938153fd2140afc087bb871422d2)
                check_type(argname="argument availability_zone", value=availability_zone, expected_type=type_hints["availability_zone"])
                check_type(argname="argument availability_zone_id", value=availability_zone_id, expected_type=type_hints["availability_zone_id"])
                check_type(argname="argument instance_requirements", value=instance_requirements, expected_type=type_hints["instance_requirements"])
                check_type(argname="argument instance_type", value=instance_type, expected_type=type_hints["instance_type"])
                check_type(argname="argument priority", value=priority, expected_type=type_hints["priority"])
                check_type(argname="argument spot_price", value=spot_price, expected_type=type_hints["spot_price"])
                check_type(argname="argument subnet_id", value=subnet_id, expected_type=type_hints["subnet_id"])
                check_type(argname="argument weighted_capacity", value=weighted_capacity, expected_type=type_hints["weighted_capacity"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if availability_zone is not None:
                self._values["availability_zone"] = availability_zone
            if availability_zone_id is not None:
                self._values["availability_zone_id"] = availability_zone_id
            if instance_requirements is not None:
                self._values["instance_requirements"] = instance_requirements
            if instance_type is not None:
                self._values["instance_type"] = instance_type
            if priority is not None:
                self._values["priority"] = priority
            if spot_price is not None:
                self._values["spot_price"] = spot_price
            if subnet_id is not None:
                self._values["subnet_id"] = subnet_id
            if weighted_capacity is not None:
                self._values["weighted_capacity"] = weighted_capacity

        @builtins.property
        def availability_zone(self) -> typing.Optional[builtins.str]:
            '''The Availability Zone in which to launch the instances. For example, ``us-east-2a`` .

            Either ``AvailabilityZone`` or ``AvailabilityZoneId`` must be specified in the request, but not both.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateoverrides.html#cfn-ec2-spotfleet-launchtemplateoverrides-availabilityzone
            '''
            result = self._values.get("availability_zone")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def availability_zone_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the Availability Zone in which to launch the instances. For example, ``use2-az1`` .

            Either ``AvailabilityZone`` or ``AvailabilityZoneId`` must be specified in the request, but not both.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateoverrides.html#cfn-ec2-spotfleet-launchtemplateoverrides-availabilityzoneid
            '''
            result = self._values.get("availability_zone_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def instance_requirements(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.InstanceRequirementsRequestProperty"]]:
            '''The instance requirements.

            When you specify instance requirements, Amazon EC2 will identify instance types with the provided requirements, and then use your On-Demand and Spot allocation strategies to launch instances from these instance types, in the same way as when you specify a list of instance types.
            .. epigraph::

               If you specify ``InstanceRequirements`` , you can't specify ``InstanceType`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateoverrides.html#cfn-ec2-spotfleet-launchtemplateoverrides-instancerequirements
            '''
            result = self._values.get("instance_requirements")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.InstanceRequirementsRequestProperty"]], result)

        @builtins.property
        def instance_type(self) -> typing.Optional[builtins.str]:
            '''The instance type.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateoverrides.html#cfn-ec2-spotfleet-launchtemplateoverrides-instancetype
            '''
            result = self._values.get("instance_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def priority(self) -> typing.Optional[jsii.Number]:
            '''The priority for the launch template override. The highest priority is launched first.

            If ``OnDemandAllocationStrategy`` is set to ``prioritized`` , Spot Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity.

            If the Spot ``AllocationStrategy`` is set to ``capacityOptimizedPrioritized`` , Spot Fleet uses priority on a best-effort basis to determine which launch template override to use in fulfilling Spot capacity, but optimizes for capacity first.

            Valid values are whole numbers starting at ``0`` . The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority. You can set the same priority for different launch template overrides.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateoverrides.html#cfn-ec2-spotfleet-launchtemplateoverrides-priority
            '''
            result = self._values.get("priority")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def spot_price(self) -> typing.Optional[builtins.str]:
            '''The maximum price per unit hour that you are willing to pay for a Spot Instance.

            We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.
            .. epigraph::

               If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateoverrides.html#cfn-ec2-spotfleet-launchtemplateoverrides-spotprice
            '''
            result = self._values.get("spot_price")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def subnet_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the subnet in which to launch the instances.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateoverrides.html#cfn-ec2-spotfleet-launchtemplateoverrides-subnetid
            '''
            result = self._values.get("subnet_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def weighted_capacity(self) -> typing.Optional[jsii.Number]:
            '''The number of units provided by the specified instance type.

            These are the same units that you chose to set the target capacity in terms of instances, or a performance characteristic such as vCPUs, memory, or I/O.

            If the target capacity divided by this value is not a whole number, Amazon EC2 rounds the number of instances to the next whole number. If this value is not specified, the default is 1.
            .. epigraph::

               When specifying weights, the price used in the ``lowestPrice`` and ``priceCapacityOptimized`` allocation strategies is per *unit* hour (where the instance price is divided by the specified weight). However, if all the specified weights are above the requested ``TargetCapacity`` , resulting in only 1 instance being launched, the price used is per *instance* hour.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateoverrides.html#cfn-ec2-spotfleet-launchtemplateoverrides-weightedcapacity
            '''
            result = self._values.get("weighted_capacity")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "LaunchTemplateOverridesProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSpotFleetPropsMixin.LoadBalancersConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "classic_load_balancers_config": "classicLoadBalancersConfig",
            "target_groups_config": "targetGroupsConfig",
        },
    )
    class LoadBalancersConfigProperty:
        def __init__(
            self,
            *,
            classic_load_balancers_config: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSpotFleetPropsMixin.ClassicLoadBalancersConfigProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            target_groups_config: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSpotFleetPropsMixin.TargetGroupsConfigProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Specifies the Classic Load Balancers and target groups to attach to a Spot Fleet request.

            :param classic_load_balancers_config: The Classic Load Balancers.
            :param target_groups_config: The target groups.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-loadbalancersconfig.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                load_balancers_config_property = ec2_mixins.CfnSpotFleetPropsMixin.LoadBalancersConfigProperty(
                    classic_load_balancers_config=ec2_mixins.CfnSpotFleetPropsMixin.ClassicLoadBalancersConfigProperty(
                        classic_load_balancers=[ec2_mixins.CfnSpotFleetPropsMixin.ClassicLoadBalancerProperty(
                            name="name"
                        )]
                    ),
                    target_groups_config=ec2_mixins.CfnSpotFleetPropsMixin.TargetGroupsConfigProperty(
                        target_groups=[ec2_mixins.CfnSpotFleetPropsMixin.TargetGroupProperty(
                            arn="arn"
                        )]
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__49ea85e92adc29df7245f72ff55eccb4d1db4df9ef1b0af7b9bdefa3165b05a9)
                check_type(argname="argument classic_load_balancers_config", value=classic_load_balancers_config, expected_type=type_hints["classic_load_balancers_config"])
                check_type(argname="argument target_groups_config", value=target_groups_config, expected_type=type_hints["target_groups_config"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if classic_load_balancers_config is not None:
                self._values["classic_load_balancers_config"] = classic_load_balancers_config
            if target_groups_config is not None:
                self._values["target_groups_config"] = target_groups_config

        @builtins.property
        def classic_load_balancers_config(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.ClassicLoadBalancersConfigProperty"]]:
            '''The Classic Load Balancers.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-loadbalancersconfig.html#cfn-ec2-spotfleet-loadbalancersconfig-classicloadbalancersconfig
            '''
            result = self._values.get("classic_load_balancers_config")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.ClassicLoadBalancersConfigProperty"]], result)

        @builtins.property
        def target_groups_config(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.TargetGroupsConfigProperty"]]:
            '''The target groups.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-loadbalancersconfig.html#cfn-ec2-spotfleet-loadbalancersconfig-targetgroupsconfig
            '''
            result = self._values.get("target_groups_config")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.TargetGroupsConfigProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "LoadBalancersConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSpotFleetPropsMixin.MemoryGiBPerVCpuRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class MemoryGiBPerVCpuRequestProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum amount of memory per vCPU, in GiB.

            :param max: The maximum amount of memory per vCPU, in GiB. To specify no maximum limit, omit this parameter.
            :param min: The minimum amount of memory per vCPU, in GiB. To specify no minimum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-memorygibpervcpurequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                memory_gi_bPer_vCpu_request_property = ec2_mixins.CfnSpotFleetPropsMixin.MemoryGiBPerVCpuRequestProperty(
                    max=123,
                    min=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__11686429a98363db4d46a8d1f10756c5a7acbcf2a9cc910b31593b90b5c6ebe8)
                check_type(argname="argument max", value=max, expected_type=type_hints["max"])
                check_type(argname="argument min", value=min, expected_type=type_hints["min"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum amount of memory per vCPU, in GiB.

            To specify no maximum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-memorygibpervcpurequest.html#cfn-ec2-spotfleet-memorygibpervcpurequest-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum amount of memory per vCPU, in GiB.

            To specify no minimum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-memorygibpervcpurequest.html#cfn-ec2-spotfleet-memorygibpervcpurequest-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "MemoryGiBPerVCpuRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSpotFleetPropsMixin.MemoryMiBRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class MemoryMiBRequestProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum amount of memory, in MiB.

            :param max: The maximum amount of memory, in MiB. To specify no maximum limit, omit this parameter.
            :param min: The minimum amount of memory, in MiB. To specify no minimum limit, specify ``0`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-memorymibrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                memory_mi_bRequest_property = ec2_mixins.CfnSpotFleetPropsMixin.MemoryMiBRequestProperty(
                    max=123,
                    min=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__d1e2fa5fff6920cc58bed08039649976beccf8b75f95d79b2ba38d7365633a2c)
                check_type(argname="argument max", value=max, expected_type=type_hints["max"])
                check_type(argname="argument min", value=min, expected_type=type_hints["min"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum amount of memory, in MiB.

            To specify no maximum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-memorymibrequest.html#cfn-ec2-spotfleet-memorymibrequest-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum amount of memory, in MiB.

            To specify no minimum limit, specify ``0`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-memorymibrequest.html#cfn-ec2-spotfleet-memorymibrequest-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "MemoryMiBRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSpotFleetPropsMixin.NetworkBandwidthGbpsRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class NetworkBandwidthGbpsRequestProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum amount of baseline network bandwidth, in gigabits per second (Gbps).

            For more information, see `Amazon EC2 instance network bandwidth <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-network-bandwidth.html>`_ in the *Amazon EC2 User Guide* .

            Default: No minimum or maximum limits

            :param max: The maximum amount of network bandwidth, in Gbps. To specify no maximum limit, omit this parameter.
            :param min: The minimum amount of network bandwidth, in Gbps. To specify no minimum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-networkbandwidthgbpsrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                network_bandwidth_gbps_request_property = ec2_mixins.CfnSpotFleetPropsMixin.NetworkBandwidthGbpsRequestProperty(
                    max=123,
                    min=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__af81bfcfde979558236e806980aa5380f4f9da4ce2bf8a9f2592e1ee46490a92)
                check_type(argname="argument max", value=max, expected_type=type_hints["max"])
                check_type(argname="argument min", value=min, expected_type=type_hints["min"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum amount of network bandwidth, in Gbps.

            To specify no maximum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-networkbandwidthgbpsrequest.html#cfn-ec2-spotfleet-networkbandwidthgbpsrequest-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum amount of network bandwidth, in Gbps.

            To specify no minimum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-networkbandwidthgbpsrequest.html#cfn-ec2-spotfleet-networkbandwidthgbpsrequest-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "NetworkBandwidthGbpsRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSpotFleetPropsMixin.NetworkInterfaceCountRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class NetworkInterfaceCountRequestProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum number of network interfaces.

            :param max: The maximum number of network interfaces. To specify no maximum limit, omit this parameter.
            :param min: The minimum number of network interfaces. To specify no minimum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-networkinterfacecountrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                network_interface_count_request_property = ec2_mixins.CfnSpotFleetPropsMixin.NetworkInterfaceCountRequestProperty(
                    max=123,
                    min=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__24b7c82b06cf6240eb761dd6009e321aefecb3347e9d4cc5bca247e691eb129e)
                check_type(argname="argument max", value=max, expected_type=type_hints["max"])
                check_type(argname="argument min", value=min, expected_type=type_hints["min"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum number of network interfaces.

            To specify no maximum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-networkinterfacecountrequest.html#cfn-ec2-spotfleet-networkinterfacecountrequest-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum number of network interfaces.

            To specify no minimum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-networkinterfacecountrequest.html#cfn-ec2-spotfleet-networkinterfacecountrequest-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "NetworkInterfaceCountRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSpotFleetPropsMixin.PerformanceFactorReferenceRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"instance_family": "instanceFamily"},
    )
    class PerformanceFactorReferenceRequestProperty:
        def __init__(
            self,
            *,
            instance_family: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specify an instance family to use as the baseline reference for CPU performance.

            All instance types that match your specified attributes will be compared against the CPU performance of the referenced instance family, regardless of CPU manufacturer or architecture.
            .. epigraph::

               Currently, only one instance family can be specified in the list.

            :param instance_family: The instance family to use as a baseline reference. .. epigraph:: Ensure that you specify the correct value for the instance family. The instance family is everything before the period ( ``.`` ) in the instance type name. For example, in the instance type ``c6i.large`` , the instance family is ``c6i`` , not ``c6`` . For more information, see `Amazon EC2 instance type naming conventions <https://docs.aws.amazon.com/ec2/latest/instancetypes/instance-type-names.html>`_ in *Amazon EC2 Instance Types* . The following instance families are *not supported* for performance protection: - ``c1`` - ``g3`` | ``g3s`` - ``hpc7g`` - ``m1`` | ``m2`` - ``mac1`` | ``mac2`` | ``mac2-m1ultra`` | ``mac2-m2`` | ``mac2-m2pro`` - ``p3dn`` | ``p4d`` | ``p5`` - ``t1`` - ``u-12tb1`` | ``u-18tb1`` | ``u-24tb1`` | ``u-3tb1`` | ``u-6tb1`` | ``u-9tb1`` | ``u7i-12tb`` | ``u7in-16tb`` | ``u7in-24tb`` | ``u7in-32tb`` If you enable performance protection by specifying a supported instance family, the returned instance types will exclude the above unsupported instance families. If you specify an unsupported instance family as a value for baseline performance, the API returns an empty response for `GetInstanceTypesFromInstanceRequirements <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html>`_ and an exception for `CreateFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet.html>`_ , `RequestSpotFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotFleet.html>`_ , `ModifyFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyFleet.html>`_ , and `ModifySpotFleetRequest <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifySpotFleetRequest.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-performancefactorreferencerequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                performance_factor_reference_request_property = ec2_mixins.CfnSpotFleetPropsMixin.PerformanceFactorReferenceRequestProperty(
                    instance_family="instanceFamily"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__b66bd22ec6b05a97963d256c1fc122f7f832427389b677050771b18094c4606f)
                check_type(argname="argument instance_family", value=instance_family, expected_type=type_hints["instance_family"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if instance_family is not None:
                self._values["instance_family"] = instance_family

        @builtins.property
        def instance_family(self) -> typing.Optional[builtins.str]:
            '''The instance family to use as a baseline reference.

            .. epigraph::

               Ensure that you specify the correct value for the instance family. The instance family is everything before the period ( ``.`` ) in the instance type name. For example, in the instance type ``c6i.large`` , the instance family is ``c6i`` , not ``c6`` . For more information, see `Amazon EC2 instance type naming conventions <https://docs.aws.amazon.com/ec2/latest/instancetypes/instance-type-names.html>`_ in *Amazon EC2 Instance Types* .

            The following instance families are *not supported* for performance protection:

            - ``c1``
            - ``g3`` | ``g3s``
            - ``hpc7g``
            - ``m1`` | ``m2``
            - ``mac1`` | ``mac2`` | ``mac2-m1ultra`` | ``mac2-m2`` | ``mac2-m2pro``
            - ``p3dn`` | ``p4d`` | ``p5``
            - ``t1``
            - ``u-12tb1`` | ``u-18tb1`` | ``u-24tb1`` | ``u-3tb1`` | ``u-6tb1`` | ``u-9tb1`` | ``u7i-12tb`` | ``u7in-16tb`` | ``u7in-24tb`` | ``u7in-32tb``

            If you enable performance protection by specifying a supported instance family, the returned instance types will exclude the above unsupported instance families.

            If you specify an unsupported instance family as a value for baseline performance, the API returns an empty response for `GetInstanceTypesFromInstanceRequirements <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html>`_ and an exception for `CreateFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet.html>`_ , `RequestSpotFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotFleet.html>`_ , `ModifyFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyFleet.html>`_ , and `ModifySpotFleetRequest <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifySpotFleetRequest.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-performancefactorreferencerequest.html#cfn-ec2-spotfleet-performancefactorreferencerequest-instancefamily
            '''
            result = self._values.get("instance_family")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PerformanceFactorReferenceRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSpotFleetPropsMixin.PrivateIpAddressSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={"primary": "primary", "private_ip_address": "privateIpAddress"},
    )
    class PrivateIpAddressSpecificationProperty:
        def __init__(
            self,
            *,
            primary: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            private_ip_address: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes a secondary private IPv4 address for a network interface.

            :param primary: Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.
            :param private_ip_address: The private IPv4 address.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-privateipaddressspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                private_ip_address_specification_property = ec2_mixins.CfnSpotFleetPropsMixin.PrivateIpAddressSpecificationProperty(
                    primary=False,
                    private_ip_address="privateIpAddress"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__058c4a3b9295b29299d6c7cfefebb8e884ae4e91e57dd3875b19482034a369d6)
                check_type(argname="argument primary", value=primary, expected_type=type_hints["primary"])
                check_type(argname="argument private_ip_address", value=private_ip_address, expected_type=type_hints["private_ip_address"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if primary is not None:
                self._values["primary"] = primary
            if private_ip_address is not None:
                self._values["private_ip_address"] = private_ip_address

        @builtins.property
        def primary(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether the private IPv4 address is the primary private IPv4 address.

            Only one IPv4 address can be designated as primary.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-privateipaddressspecification.html#cfn-ec2-spotfleet-privateipaddressspecification-primary
            '''
            result = self._values.get("primary")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def private_ip_address(self) -> typing.Optional[builtins.str]:
            '''The private IPv4 address.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-privateipaddressspecification.html#cfn-ec2-spotfleet-privateipaddressspecification-privateipaddress
            '''
            result = self._values.get("private_ip_address")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PrivateIpAddressSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSpotFleetPropsMixin.SpotCapacityRebalanceProperty",
        jsii_struct_bases=[],
        name_mapping={
            "replacement_strategy": "replacementStrategy",
            "termination_delay": "terminationDelay",
        },
    )
    class SpotCapacityRebalanceProperty:
        def __init__(
            self,
            *,
            replacement_strategy: typing.Optional[builtins.str] = None,
            termination_delay: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The Spot Instance replacement strategy to use when Amazon EC2 emits a signal that your Spot Instance is at an elevated risk of being interrupted.

            For more information, see `Capacity rebalancing <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-capacity-rebalance.html>`_ in the *Amazon EC2 User Guide* .

            :param replacement_strategy: The replacement strategy to use. Only available for fleets of type ``maintain`` . ``launch`` - Spot Fleet launches a new replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet. Spot Fleet does not terminate the instances that receive a rebalance notification. You can terminate the old instances, or you can leave them running. You are charged for all instances while they are running. ``launch-before-terminate`` - Spot Fleet launches a new replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet, and then, after a delay that you specify (in ``TerminationDelay`` ), terminates the instances that received a rebalance notification.
            :param termination_delay: The amount of time (in seconds) that Amazon EC2 waits before terminating the old Spot Instance after launching a new replacement Spot Instance. Required when ``ReplacementStrategy`` is set to ``launch-before-terminate`` . Not valid when ``ReplacementStrategy`` is set to ``launch`` . Valid values: Minimum value of ``120`` seconds. Maximum value of ``7200`` seconds.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotcapacityrebalance.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                spot_capacity_rebalance_property = ec2_mixins.CfnSpotFleetPropsMixin.SpotCapacityRebalanceProperty(
                    replacement_strategy="replacementStrategy",
                    termination_delay=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__3877a7ee660dca966e7a74d2803c625b6364ee9ecb866a49975dbd0423c5817d)
                check_type(argname="argument replacement_strategy", value=replacement_strategy, expected_type=type_hints["replacement_strategy"])
                check_type(argname="argument termination_delay", value=termination_delay, expected_type=type_hints["termination_delay"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if replacement_strategy is not None:
                self._values["replacement_strategy"] = replacement_strategy
            if termination_delay is not None:
                self._values["termination_delay"] = termination_delay

        @builtins.property
        def replacement_strategy(self) -> typing.Optional[builtins.str]:
            '''The replacement strategy to use. Only available for fleets of type ``maintain`` .

            ``launch`` - Spot Fleet launches a new replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet. Spot Fleet does not terminate the instances that receive a rebalance notification. You can terminate the old instances, or you can leave them running. You are charged for all instances while they are running.

            ``launch-before-terminate`` - Spot Fleet launches a new replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet, and then, after a delay that you specify (in ``TerminationDelay`` ), terminates the instances that received a rebalance notification.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotcapacityrebalance.html#cfn-ec2-spotfleet-spotcapacityrebalance-replacementstrategy
            '''
            result = self._values.get("replacement_strategy")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def termination_delay(self) -> typing.Optional[jsii.Number]:
            '''The amount of time (in seconds) that Amazon EC2 waits before terminating the old Spot Instance after launching a new replacement Spot Instance.

            Required when ``ReplacementStrategy`` is set to ``launch-before-terminate`` .

            Not valid when ``ReplacementStrategy`` is set to ``launch`` .

            Valid values: Minimum value of ``120`` seconds. Maximum value of ``7200`` seconds.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotcapacityrebalance.html#cfn-ec2-spotfleet-spotcapacityrebalance-terminationdelay
            '''
            result = self._values.get("termination_delay")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SpotCapacityRebalanceProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSpotFleetPropsMixin.SpotFleetLaunchSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "block_device_mappings": "blockDeviceMappings",
            "ebs_optimized": "ebsOptimized",
            "iam_instance_profile": "iamInstanceProfile",
            "image_id": "imageId",
            "instance_requirements": "instanceRequirements",
            "instance_type": "instanceType",
            "kernel_id": "kernelId",
            "key_name": "keyName",
            "monitoring": "monitoring",
            "network_interfaces": "networkInterfaces",
            "placement": "placement",
            "ramdisk_id": "ramdiskId",
            "security_groups": "securityGroups",
            "spot_price": "spotPrice",
            "subnet_id": "subnetId",
            "tag_specifications": "tagSpecifications",
            "user_data": "userData",
            "weighted_capacity": "weightedCapacity",
        },
    )
    class SpotFleetLaunchSpecificationProperty:
        def __init__(
            self,
            *,
            block_device_mappings: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSpotFleetPropsMixin.BlockDeviceMappingProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            ebs_optimized: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            iam_instance_profile: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSpotFleetPropsMixin.IamInstanceProfileSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            image_id: typing.Optional[builtins.str] = None,
            instance_requirements: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSpotFleetPropsMixin.InstanceRequirementsRequestProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            instance_type: typing.Optional[builtins.str] = None,
            kernel_id: typing.Optional[builtins.str] = None,
            key_name: typing.Optional[builtins.str] = None,
            monitoring: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSpotFleetPropsMixin.SpotFleetMonitoringProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            network_interfaces: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSpotFleetPropsMixin.InstanceNetworkInterfaceSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            placement: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSpotFleetPropsMixin.SpotPlacementProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            ramdisk_id: typing.Optional[builtins.str] = None,
            security_groups: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSpotFleetPropsMixin.GroupIdentifierProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            spot_price: typing.Optional[builtins.str] = None,
            subnet_id: typing.Optional[builtins.str] = None,
            tag_specifications: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSpotFleetPropsMixin.SpotFleetTagSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            user_data: typing.Optional[builtins.str] = None,
            weighted_capacity: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Specifies the launch specification for one or more Spot Instances.

            If you include On-Demand capacity in your fleet request, you can't use ``SpotFleetLaunchSpecification`` ; you must use `LaunchTemplateConfig <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateconfig.html>`_ .

            :param block_device_mappings: One or more block devices that are mapped to the Spot Instances. You can't specify both a snapshot ID and an encryption value. This is because only blank volumes can be encrypted on creation. If a snapshot is the basis for a volume, it is not blank and its encryption status is used for the volume encryption status.
            :param ebs_optimized: Indicates whether the instances are optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance. Default: ``false`` Default: - false
            :param iam_instance_profile: The IAM instance profile.
            :param image_id: The ID of the AMI.
            :param instance_requirements: The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with those attributes. .. epigraph:: If you specify ``InstanceRequirements`` , you can't specify ``InstanceType`` .
            :param instance_type: The instance type.
            :param kernel_id: The ID of the kernel.
            :param key_name: The name of the key pair.
            :param monitoring: Enable or disable monitoring for the instances.
            :param network_interfaces: The network interfaces.
            :param placement: The placement information.
            :param ramdisk_id: The ID of the RAM disk. Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, refer to the AWS Resource Center and search for the kernel ID.
            :param security_groups: The security groups. If you specify a network interface, you must specify any security groups as part of the network interface instead of using this parameter.
            :param spot_price: The maximum price per unit hour that you are willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price. .. epigraph:: If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.
            :param subnet_id: The IDs of the subnets in which to launch the instances. To specify multiple subnets, separate them using commas; for example, "subnet-1234abcdeexample1, subnet-0987cdef6example2". If you specify a network interface, you must specify any subnets as part of the network interface instead of using this parameter.
            :param tag_specifications: The tags to apply during creation.
            :param user_data: The base64-encoded user data that instances use when starting up. User data is limited to 16 KB.
            :param weighted_capacity: The number of units provided by the specified instance type. These are the same units that you chose to set the target capacity in terms of instances, or a performance characteristic such as vCPUs, memory, or I/O. If the target capacity divided by this value is not a whole number, Amazon EC2 rounds the number of instances to the next whole number. If this value is not specified, the default is 1. .. epigraph:: When specifying weights, the price used in the ``lowestPrice`` and ``priceCapacityOptimized`` allocation strategies is per *unit* hour (where the instance price is divided by the specified weight). However, if all the specified weights are above the requested ``TargetCapacity`` , resulting in only 1 instance being launched, the price used is per *instance* hour.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                from aws_cdk import CfnTag
                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                spot_fleet_launch_specification_property = ec2_mixins.CfnSpotFleetPropsMixin.SpotFleetLaunchSpecificationProperty(
                    block_device_mappings=[ec2_mixins.CfnSpotFleetPropsMixin.BlockDeviceMappingProperty(
                        device_name="deviceName",
                        ebs=ec2_mixins.CfnSpotFleetPropsMixin.EbsBlockDeviceProperty(
                            delete_on_termination=False,
                            encrypted=False,
                            iops=123,
                            snapshot_id="snapshotId",
                            volume_size=123,
                            volume_type="volumeType"
                        ),
                        no_device="noDevice",
                        virtual_name="virtualName"
                    )],
                    ebs_optimized=False,
                    iam_instance_profile=ec2_mixins.CfnSpotFleetPropsMixin.IamInstanceProfileSpecificationProperty(
                        arn="arn"
                    ),
                    image_id="imageId",
                    instance_requirements=ec2_mixins.CfnSpotFleetPropsMixin.InstanceRequirementsRequestProperty(
                        accelerator_count=ec2_mixins.CfnSpotFleetPropsMixin.AcceleratorCountRequestProperty(
                            max=123,
                            min=123
                        ),
                        accelerator_manufacturers=["acceleratorManufacturers"],
                        accelerator_names=["acceleratorNames"],
                        accelerator_total_memory_mi_b=ec2_mixins.CfnSpotFleetPropsMixin.AcceleratorTotalMemoryMiBRequestProperty(
                            max=123,
                            min=123
                        ),
                        accelerator_types=["acceleratorTypes"],
                        allowed_instance_types=["allowedInstanceTypes"],
                        bare_metal="bareMetal",
                        baseline_ebs_bandwidth_mbps=ec2_mixins.CfnSpotFleetPropsMixin.BaselineEbsBandwidthMbpsRequestProperty(
                            max=123,
                            min=123
                        ),
                        baseline_performance_factors=ec2_mixins.CfnSpotFleetPropsMixin.BaselinePerformanceFactorsRequestProperty(
                            cpu=ec2_mixins.CfnSpotFleetPropsMixin.CpuPerformanceFactorRequestProperty(
                                references=[ec2_mixins.CfnSpotFleetPropsMixin.PerformanceFactorReferenceRequestProperty(
                                    instance_family="instanceFamily"
                                )]
                            )
                        ),
                        burstable_performance="burstablePerformance",
                        cpu_manufacturers=["cpuManufacturers"],
                        excluded_instance_types=["excludedInstanceTypes"],
                        instance_generations=["instanceGenerations"],
                        local_storage="localStorage",
                        local_storage_types=["localStorageTypes"],
                        max_spot_price_as_percentage_of_optimal_on_demand_price=123,
                        memory_gi_bPer_vCpu=ec2_mixins.CfnSpotFleetPropsMixin.MemoryGiBPerVCpuRequestProperty(
                            max=123,
                            min=123
                        ),
                        memory_mi_b=ec2_mixins.CfnSpotFleetPropsMixin.MemoryMiBRequestProperty(
                            max=123,
                            min=123
                        ),
                        network_bandwidth_gbps=ec2_mixins.CfnSpotFleetPropsMixin.NetworkBandwidthGbpsRequestProperty(
                            max=123,
                            min=123
                        ),
                        network_interface_count=ec2_mixins.CfnSpotFleetPropsMixin.NetworkInterfaceCountRequestProperty(
                            max=123,
                            min=123
                        ),
                        on_demand_max_price_percentage_over_lowest_price=123,
                        require_encryption_in_transit=False,
                        require_hibernate_support=False,
                        spot_max_price_percentage_over_lowest_price=123,
                        total_local_storage_gb=ec2_mixins.CfnSpotFleetPropsMixin.TotalLocalStorageGBRequestProperty(
                            max=123,
                            min=123
                        ),
                        v_cpu_count=ec2_mixins.CfnSpotFleetPropsMixin.VCpuCountRangeRequestProperty(
                            max=123,
                            min=123
                        )
                    ),
                    instance_type="instanceType",
                    kernel_id="kernelId",
                    key_name="keyName",
                    monitoring=ec2_mixins.CfnSpotFleetPropsMixin.SpotFleetMonitoringProperty(
                        enabled=False
                    ),
                    network_interfaces=[ec2_mixins.CfnSpotFleetPropsMixin.InstanceNetworkInterfaceSpecificationProperty(
                        associate_public_ip_address=False,
                        delete_on_termination=False,
                        description="description",
                        device_index=123,
                        groups=["groups"],
                        ipv6_address_count=123,
                        ipv6_addresses=[ec2_mixins.CfnSpotFleetPropsMixin.InstanceIpv6AddressProperty(
                            ipv6_address="ipv6Address"
                        )],
                        network_interface_id="networkInterfaceId",
                        private_ip_addresses=[ec2_mixins.CfnSpotFleetPropsMixin.PrivateIpAddressSpecificationProperty(
                            primary=False,
                            private_ip_address="privateIpAddress"
                        )],
                        secondary_private_ip_address_count=123,
                        subnet_id="subnetId"
                    )],
                    placement=ec2_mixins.CfnSpotFleetPropsMixin.SpotPlacementProperty(
                        availability_zone="availabilityZone",
                        availability_zone_id="availabilityZoneId",
                        group_name="groupName",
                        tenancy="tenancy"
                    ),
                    ramdisk_id="ramdiskId",
                    security_groups=[ec2_mixins.CfnSpotFleetPropsMixin.GroupIdentifierProperty(
                        group_id="groupId"
                    )],
                    spot_price="spotPrice",
                    subnet_id="subnetId",
                    tag_specifications=[ec2_mixins.CfnSpotFleetPropsMixin.SpotFleetTagSpecificationProperty(
                        resource_type="resourceType",
                        tags=[CfnTag(
                            key="key",
                            value="value"
                        )]
                    )],
                    user_data="userData",
                    weighted_capacity=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__590a4850e9f8a2e6d3fe03fc10276fcc66c9bc20bdbff4ae9c551fd48a40841a)
                check_type(argname="argument block_device_mappings", value=block_device_mappings, expected_type=type_hints["block_device_mappings"])
                check_type(argname="argument ebs_optimized", value=ebs_optimized, expected_type=type_hints["ebs_optimized"])
                check_type(argname="argument iam_instance_profile", value=iam_instance_profile, expected_type=type_hints["iam_instance_profile"])
                check_type(argname="argument image_id", value=image_id, expected_type=type_hints["image_id"])
                check_type(argname="argument instance_requirements", value=instance_requirements, expected_type=type_hints["instance_requirements"])
                check_type(argname="argument instance_type", value=instance_type, expected_type=type_hints["instance_type"])
                check_type(argname="argument kernel_id", value=kernel_id, expected_type=type_hints["kernel_id"])
                check_type(argname="argument key_name", value=key_name, expected_type=type_hints["key_name"])
                check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
                check_type(argname="argument network_interfaces", value=network_interfaces, expected_type=type_hints["network_interfaces"])
                check_type(argname="argument placement", value=placement, expected_type=type_hints["placement"])
                check_type(argname="argument ramdisk_id", value=ramdisk_id, expected_type=type_hints["ramdisk_id"])
                check_type(argname="argument security_groups", value=security_groups, expected_type=type_hints["security_groups"])
                check_type(argname="argument spot_price", value=spot_price, expected_type=type_hints["spot_price"])
                check_type(argname="argument subnet_id", value=subnet_id, expected_type=type_hints["subnet_id"])
                check_type(argname="argument tag_specifications", value=tag_specifications, expected_type=type_hints["tag_specifications"])
                check_type(argname="argument user_data", value=user_data, expected_type=type_hints["user_data"])
                check_type(argname="argument weighted_capacity", value=weighted_capacity, expected_type=type_hints["weighted_capacity"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if block_device_mappings is not None:
                self._values["block_device_mappings"] = block_device_mappings
            if ebs_optimized is not None:
                self._values["ebs_optimized"] = ebs_optimized
            if iam_instance_profile is not None:
                self._values["iam_instance_profile"] = iam_instance_profile
            if image_id is not None:
                self._values["image_id"] = image_id
            if instance_requirements is not None:
                self._values["instance_requirements"] = instance_requirements
            if instance_type is not None:
                self._values["instance_type"] = instance_type
            if kernel_id is not None:
                self._values["kernel_id"] = kernel_id
            if key_name is not None:
                self._values["key_name"] = key_name
            if monitoring is not None:
                self._values["monitoring"] = monitoring
            if network_interfaces is not None:
                self._values["network_interfaces"] = network_interfaces
            if placement is not None:
                self._values["placement"] = placement
            if ramdisk_id is not None:
                self._values["ramdisk_id"] = ramdisk_id
            if security_groups is not None:
                self._values["security_groups"] = security_groups
            if spot_price is not None:
                self._values["spot_price"] = spot_price
            if subnet_id is not None:
                self._values["subnet_id"] = subnet_id
            if tag_specifications is not None:
                self._values["tag_specifications"] = tag_specifications
            if user_data is not None:
                self._values["user_data"] = user_data
            if weighted_capacity is not None:
                self._values["weighted_capacity"] = weighted_capacity

        @builtins.property
        def block_device_mappings(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.BlockDeviceMappingProperty"]]]]:
            '''One or more block devices that are mapped to the Spot Instances.

            You can't specify both a snapshot ID and an encryption value. This is because only blank volumes can be encrypted on creation. If a snapshot is the basis for a volume, it is not blank and its encryption status is used for the volume encryption status.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-blockdevicemappings
            '''
            result = self._values.get("block_device_mappings")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.BlockDeviceMappingProperty"]]]], result)

        @builtins.property
        def ebs_optimized(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether the instances are optimized for EBS I/O.

            This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.

            Default: ``false``

            :default: - false

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-ebsoptimized
            '''
            result = self._values.get("ebs_optimized")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def iam_instance_profile(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.IamInstanceProfileSpecificationProperty"]]:
            '''The IAM instance profile.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-iaminstanceprofile
            '''
            result = self._values.get("iam_instance_profile")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.IamInstanceProfileSpecificationProperty"]], result)

        @builtins.property
        def image_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the AMI.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-imageid
            '''
            result = self._values.get("image_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def instance_requirements(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.InstanceRequirementsRequestProperty"]]:
            '''The attributes for the instance types.

            When you specify instance attributes, Amazon EC2 will identify instance types with those attributes.
            .. epigraph::

               If you specify ``InstanceRequirements`` , you can't specify ``InstanceType`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-instancerequirements
            '''
            result = self._values.get("instance_requirements")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.InstanceRequirementsRequestProperty"]], result)

        @builtins.property
        def instance_type(self) -> typing.Optional[builtins.str]:
            '''The instance type.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-instancetype
            '''
            result = self._values.get("instance_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def kernel_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the kernel.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-kernelid
            '''
            result = self._values.get("kernel_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def key_name(self) -> typing.Optional[builtins.str]:
            '''The name of the key pair.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-keyname
            '''
            result = self._values.get("key_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def monitoring(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.SpotFleetMonitoringProperty"]]:
            '''Enable or disable monitoring for the instances.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-monitoring
            '''
            result = self._values.get("monitoring")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.SpotFleetMonitoringProperty"]], result)

        @builtins.property
        def network_interfaces(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.InstanceNetworkInterfaceSpecificationProperty"]]]]:
            '''The network interfaces.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-networkinterfaces
            '''
            result = self._values.get("network_interfaces")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.InstanceNetworkInterfaceSpecificationProperty"]]]], result)

        @builtins.property
        def placement(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.SpotPlacementProperty"]]:
            '''The placement information.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-placement
            '''
            result = self._values.get("placement")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.SpotPlacementProperty"]], result)

        @builtins.property
        def ramdisk_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the RAM disk.

            Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, refer to the AWS Resource Center and search for the kernel ID.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-ramdiskid
            '''
            result = self._values.get("ramdisk_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def security_groups(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.GroupIdentifierProperty"]]]]:
            '''The security groups.

            If you specify a network interface, you must specify any security groups as part of the network interface instead of using this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-securitygroups
            '''
            result = self._values.get("security_groups")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.GroupIdentifierProperty"]]]], result)

        @builtins.property
        def spot_price(self) -> typing.Optional[builtins.str]:
            '''The maximum price per unit hour that you are willing to pay for a Spot Instance.

            We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.
            .. epigraph::

               If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-spotprice
            '''
            result = self._values.get("spot_price")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def subnet_id(self) -> typing.Optional[builtins.str]:
            '''The IDs of the subnets in which to launch the instances.

            To specify multiple subnets, separate them using commas; for example, "subnet-1234abcdeexample1, subnet-0987cdef6example2".

            If you specify a network interface, you must specify any subnets as part of the network interface instead of using this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-subnetid
            '''
            result = self._values.get("subnet_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def tag_specifications(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.SpotFleetTagSpecificationProperty"]]]]:
            '''The tags to apply during creation.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-tagspecifications
            '''
            result = self._values.get("tag_specifications")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.SpotFleetTagSpecificationProperty"]]]], result)

        @builtins.property
        def user_data(self) -> typing.Optional[builtins.str]:
            '''The base64-encoded user data that instances use when starting up.

            User data is limited to 16 KB.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-userdata
            '''
            result = self._values.get("user_data")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def weighted_capacity(self) -> typing.Optional[jsii.Number]:
            '''The number of units provided by the specified instance type.

            These are the same units that you chose to set the target capacity in terms of instances, or a performance characteristic such as vCPUs, memory, or I/O.

            If the target capacity divided by this value is not a whole number, Amazon EC2 rounds the number of instances to the next whole number. If this value is not specified, the default is 1.
            .. epigraph::

               When specifying weights, the price used in the ``lowestPrice`` and ``priceCapacityOptimized`` allocation strategies is per *unit* hour (where the instance price is divided by the specified weight). However, if all the specified weights are above the requested ``TargetCapacity`` , resulting in only 1 instance being launched, the price used is per *instance* hour.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-weightedcapacity
            '''
            result = self._values.get("weighted_capacity")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SpotFleetLaunchSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSpotFleetPropsMixin.SpotFleetMonitoringProperty",
        jsii_struct_bases=[],
        name_mapping={"enabled": "enabled"},
    )
    class SpotFleetMonitoringProperty:
        def __init__(
            self,
            *,
            enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        ) -> None:
            '''Describes whether monitoring is enabled.

            :param enabled: Enables monitoring for the instance. Default: ``false`` Default: - false

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetmonitoring.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                spot_fleet_monitoring_property = ec2_mixins.CfnSpotFleetPropsMixin.SpotFleetMonitoringProperty(
                    enabled=False
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__4ba67d212dfaefded8c831e6697d6dc0f148b37b5a0f54626ee8c10cb982fc8e)
                check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if enabled is not None:
                self._values["enabled"] = enabled

        @builtins.property
        def enabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Enables monitoring for the instance.

            Default: ``false``

            :default: - false

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetmonitoring.html#cfn-ec2-spotfleet-spotfleetmonitoring-enabled
            '''
            result = self._values.get("enabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SpotFleetMonitoringProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSpotFleetPropsMixin.SpotFleetRequestConfigDataProperty",
        jsii_struct_bases=[],
        name_mapping={
            "allocation_strategy": "allocationStrategy",
            "context": "context",
            "excess_capacity_termination_policy": "excessCapacityTerminationPolicy",
            "iam_fleet_role": "iamFleetRole",
            "instance_interruption_behavior": "instanceInterruptionBehavior",
            "instance_pools_to_use_count": "instancePoolsToUseCount",
            "launch_specifications": "launchSpecifications",
            "launch_template_configs": "launchTemplateConfigs",
            "load_balancers_config": "loadBalancersConfig",
            "on_demand_allocation_strategy": "onDemandAllocationStrategy",
            "on_demand_max_total_price": "onDemandMaxTotalPrice",
            "on_demand_target_capacity": "onDemandTargetCapacity",
            "replace_unhealthy_instances": "replaceUnhealthyInstances",
            "spot_maintenance_strategies": "spotMaintenanceStrategies",
            "spot_max_total_price": "spotMaxTotalPrice",
            "spot_price": "spotPrice",
            "tag_specifications": "tagSpecifications",
            "target_capacity": "targetCapacity",
            "target_capacity_unit_type": "targetCapacityUnitType",
            "terminate_instances_with_expiration": "terminateInstancesWithExpiration",
            "type": "type",
            "valid_from": "validFrom",
            "valid_until": "validUntil",
        },
    )
    class SpotFleetRequestConfigDataProperty:
        def __init__(
            self,
            *,
            allocation_strategy: typing.Optional[builtins.str] = None,
            context: typing.Optional[builtins.str] = None,
            excess_capacity_termination_policy: typing.Optional[builtins.str] = None,
            iam_fleet_role: typing.Optional[builtins.str] = None,
            instance_interruption_behavior: typing.Optional[builtins.str] = None,
            instance_pools_to_use_count: typing.Optional[jsii.Number] = None,
            launch_specifications: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSpotFleetPropsMixin.SpotFleetLaunchSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            launch_template_configs: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSpotFleetPropsMixin.LaunchTemplateConfigProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            load_balancers_config: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSpotFleetPropsMixin.LoadBalancersConfigProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            on_demand_allocation_strategy: typing.Optional[builtins.str] = None,
            on_demand_max_total_price: typing.Optional[builtins.str] = None,
            on_demand_target_capacity: typing.Optional[jsii.Number] = None,
            replace_unhealthy_instances: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            spot_maintenance_strategies: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSpotFleetPropsMixin.SpotMaintenanceStrategiesProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            spot_max_total_price: typing.Optional[builtins.str] = None,
            spot_price: typing.Optional[builtins.str] = None,
            tag_specifications: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSpotFleetPropsMixin.SpotFleetTagSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            target_capacity: typing.Optional[jsii.Number] = None,
            target_capacity_unit_type: typing.Optional[builtins.str] = None,
            terminate_instances_with_expiration: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            type: typing.Optional[builtins.str] = None,
            valid_from: typing.Optional[builtins.str] = None,
            valid_until: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies the configuration of a Spot Fleet request.

            For more information, see `Spot Fleet <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet.html>`_ in the *Amazon EC2 User Guide* .

            You must specify either ``LaunchSpecifications`` or ``LaunchTemplateConfigs`` .

            :param allocation_strategy: The strategy that determines how to allocate the target Spot Instance capacity across the Spot Instance pools specified by the Spot Fleet launch configuration. For more information, see `Allocation strategies for Spot Instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-allocation-strategy.html>`_ in the *Amazon EC2 User Guide* . - **priceCapacityOptimized (recommended)** - Spot Fleet identifies the pools with the highest capacity availability for the number of instances that are launching. This means that we will request Spot Instances from the pools that we believe have the lowest chance of interruption in the near term. Spot Fleet then requests Spot Instances from the lowest priced of these pools. - **capacityOptimized** - Spot Fleet identifies the pools with the highest capacity availability for the number of instances that are launching. This means that we will request Spot Instances from the pools that we believe have the lowest chance of interruption in the near term. To give certain instance types a higher chance of launching first, use ``capacityOptimizedPrioritized`` . Set a priority for each instance type by using the ``Priority`` parameter for ``LaunchTemplateOverrides`` . You can assign the same priority to different ``LaunchTemplateOverrides`` . EC2 implements the priorities on a best-effort basis, but optimizes for capacity first. ``capacityOptimizedPrioritized`` is supported only if your Spot Fleet uses a launch template. Note that if the ``OnDemandAllocationStrategy`` is set to ``prioritized`` , the same priority is applied when fulfilling On-Demand capacity. - **diversified** - Spot Fleet requests instances from all of the Spot Instance pools that you specify. - **lowestPrice (not recommended)** - > We don't recommend the ``lowestPrice`` allocation strategy because it has the highest risk of interruption for your Spot Instances. Spot Fleet requests instances from the lowest priced Spot Instance pool that has available capacity. If the lowest priced pool doesn't have available capacity, the Spot Instances come from the next lowest priced pool that has available capacity. If a pool runs out of capacity before fulfilling your desired capacity, Spot Fleet will continue to fulfill your request by drawing from the next lowest priced pool. To ensure that your desired capacity is met, you might receive Spot Instances from several pools. Because this strategy only considers instance price and not capacity availability, it might lead to high interruption rates. Default: ``lowestPrice``
            :param context: Reserved.
            :param excess_capacity_termination_policy: Indicates whether running Spot Instances should be terminated if you decrease the target capacity of the Spot Fleet request below the current size of the Spot Fleet. Supported only for fleets of type ``maintain`` .
            :param iam_fleet_role: The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role that grants the Spot Fleet the permission to request, launch, terminate, and tag instances on your behalf. For more information, see `Spot Fleet Prerequisites <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-requests.html#spot-fleet-prerequisites>`_ in the *Amazon EC2 User Guide* . Spot Fleet can terminate Spot Instances on your behalf when you cancel its Spot Fleet request or when the Spot Fleet request expires, if you set ``TerminateInstancesWithExpiration`` .
            :param instance_interruption_behavior: The behavior when a Spot Instance is interrupted. The default is ``terminate`` .
            :param instance_pools_to_use_count: The number of Spot pools across which to allocate your target Spot capacity. Valid only when Spot *AllocationStrategy* is set to ``lowest-price`` . Spot Fleet selects the cheapest Spot pools and evenly allocates your target Spot capacity across the number of Spot pools that you specify. Note that Spot Fleet attempts to draw Spot Instances from the number of pools that you specify on a best effort basis. If a pool runs out of Spot capacity before fulfilling your target capacity, Spot Fleet will continue to fulfill your request by drawing from the next cheapest pool. To ensure that your target capacity is met, you might receive Spot Instances from more than the number of pools that you specified. Similarly, if most of the pools have no Spot capacity, you might receive your full target capacity from fewer than the number of pools that you specified.
            :param launch_specifications: The launch specifications for the Spot Fleet request. If you specify ``LaunchSpecifications`` , you can't specify ``LaunchTemplateConfigs`` .
            :param launch_template_configs: The launch template and overrides. If you specify ``LaunchTemplateConfigs`` , you can't specify ``LaunchSpecifications`` .
            :param load_balancers_config: One or more Classic Load Balancers and target groups to attach to the Spot Fleet request. Spot Fleet registers the running Spot Instances with the specified Classic Load Balancers and target groups. With Network Load Balancers, Spot Fleet cannot register instances that have the following instance types: C1, CC1, CC2, CG1, CG2, CR1, CS1, G1, G2, HI1, HS1, M1, M2, M3, and T1.
            :param on_demand_allocation_strategy: The order of the launch template overrides to use in fulfilling On-Demand capacity. If you specify ``lowestPrice`` , Spot Fleet uses price to determine the order, launching the lowest price first. If you specify ``prioritized`` , Spot Fleet uses the priority that you assign to each Spot Fleet launch template override, launching the highest priority first. If you do not specify a value, Spot Fleet defaults to ``lowestPrice`` .
            :param on_demand_max_total_price: The maximum amount per hour for On-Demand Instances that you're willing to pay. You can use the ``onDemandMaxTotalPrice`` parameter, the ``spotMaxTotalPrice`` parameter, or both parameters to ensure that your fleet cost does not exceed your budget. If you set a maximum price per hour for the On-Demand Instances and Spot Instances in your request, Spot Fleet will launch instances until it reaches the maximum amount you're willing to pay. When the maximum amount you're willing to pay is reached, the fleet stops launching instances even if it hasnt met the target capacity. .. epigraph:: If your fleet includes T instances that are configured as ``unlimited`` , and if their average CPU usage exceeds the baseline utilization, you will incur a charge for surplus credits. The ``onDemandMaxTotalPrice`` does not account for surplus credits, and, if you use surplus credits, your final cost might be higher than what you specified for ``onDemandMaxTotalPrice`` . For more information, see `Surplus credits can incur charges <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-unlimited-mode-concepts.html#unlimited-mode-surplus-credits>`_ in the *Amazon EC2 User Guide* .
            :param on_demand_target_capacity: The number of On-Demand units to request. You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is ``maintain`` , you can specify a target capacity of 0 and add capacity later.
            :param replace_unhealthy_instances: Indicates whether Spot Fleet should replace unhealthy instances.
            :param spot_maintenance_strategies: The strategies for managing your Spot Instances that are at an elevated risk of being interrupted.
            :param spot_max_total_price: The maximum amount per hour for Spot Instances that you're willing to pay. You can use the ``spotMaxTotalPrice`` parameter, the ``onDemandMaxTotalPrice`` parameter, or both parameters to ensure that your fleet cost does not exceed your budget. If you set a maximum price per hour for the On-Demand Instances and Spot Instances in your request, Spot Fleet will launch instances until it reaches the maximum amount you're willing to pay. When the maximum amount you're willing to pay is reached, the fleet stops launching instances even if it hasnt met the target capacity. .. epigraph:: If your fleet includes T instances that are configured as ``unlimited`` , and if their average CPU usage exceeds the baseline utilization, you will incur a charge for surplus credits. The ``spotMaxTotalPrice`` does not account for surplus credits, and, if you use surplus credits, your final cost might be higher than what you specified for ``spotMaxTotalPrice`` . For more information, see `Surplus credits can incur charges <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-unlimited-mode-concepts.html#unlimited-mode-surplus-credits>`_ in the *Amazon EC2 User Guide* .
            :param spot_price: The maximum price per unit hour that you are willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price. .. epigraph:: If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.
            :param tag_specifications: The key-value pair for tagging the Spot Fleet request on creation. The value for ``ResourceType`` must be ``spot-fleet-request`` , otherwise the Spot Fleet request fails. To tag instances at launch, specify the tags in the `launch template <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#create-launch-template>`_ (valid only if you use ``LaunchTemplateConfigs`` ) or in the ``[SpotFleetTagSpecification](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SpotFleetTagSpecification.html)`` (valid only if you use ``LaunchSpecifications`` ). For information about tagging after launch, see `Tag your resources <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#tag-resources>`_ .
            :param target_capacity: The number of units to request for the Spot Fleet. You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is ``maintain`` , you can specify a target capacity of 0 and add capacity later.
            :param target_capacity_unit_type: The unit for the target capacity. You can specify this parameter only when using attribute-based instance type selection. Default: ``units`` (the number of instances)
            :param terminate_instances_with_expiration: Indicates whether running Spot Instances are terminated when the Spot Fleet request expires.
            :param type: The type of request. Indicates whether the Spot Fleet only requests the target capacity or also attempts to maintain it. When this value is ``request`` , the Spot Fleet only places the required requests. It does not attempt to replenish Spot Instances if capacity is diminished, nor does it submit requests in alternative Spot pools if capacity is not available. When this value is ``maintain`` , the Spot Fleet maintains the target capacity. The Spot Fleet places the required requests to meet capacity and automatically replenishes any interrupted instances. Default: ``maintain`` . ``instant`` is listed but is not used by Spot Fleet.
            :param valid_from: The start date and time of the request, in UTC format ( *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z). By default, Amazon EC2 starts fulfilling the request immediately.
            :param valid_until: The end date and time of the request, in UTC format ( *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z). After the end date and time, no new Spot Instance requests are placed or able to fulfill the request. If no value is specified, the Spot Fleet request remains until you cancel it.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html
            :exampleMetadata: fixture=_generated

            Example::

                from aws_cdk import CfnTag, CfnTag
                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                spot_fleet_request_config_data_property = ec2_mixins.CfnSpotFleetPropsMixin.SpotFleetRequestConfigDataProperty(
                    allocation_strategy="allocationStrategy",
                    context="context",
                    excess_capacity_termination_policy="excessCapacityTerminationPolicy",
                    iam_fleet_role="iamFleetRole",
                    instance_interruption_behavior="instanceInterruptionBehavior",
                    instance_pools_to_use_count=123,
                    launch_specifications=[ec2_mixins.CfnSpotFleetPropsMixin.SpotFleetLaunchSpecificationProperty(
                        block_device_mappings=[ec2_mixins.CfnSpotFleetPropsMixin.BlockDeviceMappingProperty(
                            device_name="deviceName",
                            ebs=ec2_mixins.CfnSpotFleetPropsMixin.EbsBlockDeviceProperty(
                                delete_on_termination=False,
                                encrypted=False,
                                iops=123,
                                snapshot_id="snapshotId",
                                volume_size=123,
                                volume_type="volumeType"
                            ),
                            no_device="noDevice",
                            virtual_name="virtualName"
                        )],
                        ebs_optimized=False,
                        iam_instance_profile=ec2_mixins.CfnSpotFleetPropsMixin.IamInstanceProfileSpecificationProperty(
                            arn="arn"
                        ),
                        image_id="imageId",
                        instance_requirements=ec2_mixins.CfnSpotFleetPropsMixin.InstanceRequirementsRequestProperty(
                            accelerator_count=ec2_mixins.CfnSpotFleetPropsMixin.AcceleratorCountRequestProperty(
                                max=123,
                                min=123
                            ),
                            accelerator_manufacturers=["acceleratorManufacturers"],
                            accelerator_names=["acceleratorNames"],
                            accelerator_total_memory_mi_b=ec2_mixins.CfnSpotFleetPropsMixin.AcceleratorTotalMemoryMiBRequestProperty(
                                max=123,
                                min=123
                            ),
                            accelerator_types=["acceleratorTypes"],
                            allowed_instance_types=["allowedInstanceTypes"],
                            bare_metal="bareMetal",
                            baseline_ebs_bandwidth_mbps=ec2_mixins.CfnSpotFleetPropsMixin.BaselineEbsBandwidthMbpsRequestProperty(
                                max=123,
                                min=123
                            ),
                            baseline_performance_factors=ec2_mixins.CfnSpotFleetPropsMixin.BaselinePerformanceFactorsRequestProperty(
                                cpu=ec2_mixins.CfnSpotFleetPropsMixin.CpuPerformanceFactorRequestProperty(
                                    references=[ec2_mixins.CfnSpotFleetPropsMixin.PerformanceFactorReferenceRequestProperty(
                                        instance_family="instanceFamily"
                                    )]
                                )
                            ),
                            burstable_performance="burstablePerformance",
                            cpu_manufacturers=["cpuManufacturers"],
                            excluded_instance_types=["excludedInstanceTypes"],
                            instance_generations=["instanceGenerations"],
                            local_storage="localStorage",
                            local_storage_types=["localStorageTypes"],
                            max_spot_price_as_percentage_of_optimal_on_demand_price=123,
                            memory_gi_bPer_vCpu=ec2_mixins.CfnSpotFleetPropsMixin.MemoryGiBPerVCpuRequestProperty(
                                max=123,
                                min=123
                            ),
                            memory_mi_b=ec2_mixins.CfnSpotFleetPropsMixin.MemoryMiBRequestProperty(
                                max=123,
                                min=123
                            ),
                            network_bandwidth_gbps=ec2_mixins.CfnSpotFleetPropsMixin.NetworkBandwidthGbpsRequestProperty(
                                max=123,
                                min=123
                            ),
                            network_interface_count=ec2_mixins.CfnSpotFleetPropsMixin.NetworkInterfaceCountRequestProperty(
                                max=123,
                                min=123
                            ),
                            on_demand_max_price_percentage_over_lowest_price=123,
                            require_encryption_in_transit=False,
                            require_hibernate_support=False,
                            spot_max_price_percentage_over_lowest_price=123,
                            total_local_storage_gb=ec2_mixins.CfnSpotFleetPropsMixin.TotalLocalStorageGBRequestProperty(
                                max=123,
                                min=123
                            ),
                            v_cpu_count=ec2_mixins.CfnSpotFleetPropsMixin.VCpuCountRangeRequestProperty(
                                max=123,
                                min=123
                            )
                        ),
                        instance_type="instanceType",
                        kernel_id="kernelId",
                        key_name="keyName",
                        monitoring=ec2_mixins.CfnSpotFleetPropsMixin.SpotFleetMonitoringProperty(
                            enabled=False
                        ),
                        network_interfaces=[ec2_mixins.CfnSpotFleetPropsMixin.InstanceNetworkInterfaceSpecificationProperty(
                            associate_public_ip_address=False,
                            delete_on_termination=False,
                            description="description",
                            device_index=123,
                            groups=["groups"],
                            ipv6_address_count=123,
                            ipv6_addresses=[ec2_mixins.CfnSpotFleetPropsMixin.InstanceIpv6AddressProperty(
                                ipv6_address="ipv6Address"
                            )],
                            network_interface_id="networkInterfaceId",
                            private_ip_addresses=[ec2_mixins.CfnSpotFleetPropsMixin.PrivateIpAddressSpecificationProperty(
                                primary=False,
                                private_ip_address="privateIpAddress"
                            )],
                            secondary_private_ip_address_count=123,
                            subnet_id="subnetId"
                        )],
                        placement=ec2_mixins.CfnSpotFleetPropsMixin.SpotPlacementProperty(
                            availability_zone="availabilityZone",
                            availability_zone_id="availabilityZoneId",
                            group_name="groupName",
                            tenancy="tenancy"
                        ),
                        ramdisk_id="ramdiskId",
                        security_groups=[ec2_mixins.CfnSpotFleetPropsMixin.GroupIdentifierProperty(
                            group_id="groupId"
                        )],
                        spot_price="spotPrice",
                        subnet_id="subnetId",
                        tag_specifications=[ec2_mixins.CfnSpotFleetPropsMixin.SpotFleetTagSpecificationProperty(
                            resource_type="resourceType",
                            tags=[CfnTag(
                                key="key",
                                value="value"
                            )]
                        )],
                        user_data="userData",
                        weighted_capacity=123
                    )],
                    launch_template_configs=[ec2_mixins.CfnSpotFleetPropsMixin.LaunchTemplateConfigProperty(
                        launch_template_specification=ec2_mixins.CfnSpotFleetPropsMixin.FleetLaunchTemplateSpecificationProperty(
                            launch_template_id="launchTemplateId",
                            launch_template_name="launchTemplateName",
                            version="version"
                        ),
                        overrides=[ec2_mixins.CfnSpotFleetPropsMixin.LaunchTemplateOverridesProperty(
                            availability_zone="availabilityZone",
                            availability_zone_id="availabilityZoneId",
                            instance_requirements=ec2_mixins.CfnSpotFleetPropsMixin.InstanceRequirementsRequestProperty(
                                accelerator_count=ec2_mixins.CfnSpotFleetPropsMixin.AcceleratorCountRequestProperty(
                                    max=123,
                                    min=123
                                ),
                                accelerator_manufacturers=["acceleratorManufacturers"],
                                accelerator_names=["acceleratorNames"],
                                accelerator_total_memory_mi_b=ec2_mixins.CfnSpotFleetPropsMixin.AcceleratorTotalMemoryMiBRequestProperty(
                                    max=123,
                                    min=123
                                ),
                                accelerator_types=["acceleratorTypes"],
                                allowed_instance_types=["allowedInstanceTypes"],
                                bare_metal="bareMetal",
                                baseline_ebs_bandwidth_mbps=ec2_mixins.CfnSpotFleetPropsMixin.BaselineEbsBandwidthMbpsRequestProperty(
                                    max=123,
                                    min=123
                                ),
                                baseline_performance_factors=ec2_mixins.CfnSpotFleetPropsMixin.BaselinePerformanceFactorsRequestProperty(
                                    cpu=ec2_mixins.CfnSpotFleetPropsMixin.CpuPerformanceFactorRequestProperty(
                                        references=[ec2_mixins.CfnSpotFleetPropsMixin.PerformanceFactorReferenceRequestProperty(
                                            instance_family="instanceFamily"
                                        )]
                                    )
                                ),
                                burstable_performance="burstablePerformance",
                                cpu_manufacturers=["cpuManufacturers"],
                                excluded_instance_types=["excludedInstanceTypes"],
                                instance_generations=["instanceGenerations"],
                                local_storage="localStorage",
                                local_storage_types=["localStorageTypes"],
                                max_spot_price_as_percentage_of_optimal_on_demand_price=123,
                                memory_gi_bPer_vCpu=ec2_mixins.CfnSpotFleetPropsMixin.MemoryGiBPerVCpuRequestProperty(
                                    max=123,
                                    min=123
                                ),
                                memory_mi_b=ec2_mixins.CfnSpotFleetPropsMixin.MemoryMiBRequestProperty(
                                    max=123,
                                    min=123
                                ),
                                network_bandwidth_gbps=ec2_mixins.CfnSpotFleetPropsMixin.NetworkBandwidthGbpsRequestProperty(
                                    max=123,
                                    min=123
                                ),
                                network_interface_count=ec2_mixins.CfnSpotFleetPropsMixin.NetworkInterfaceCountRequestProperty(
                                    max=123,
                                    min=123
                                ),
                                on_demand_max_price_percentage_over_lowest_price=123,
                                require_encryption_in_transit=False,
                                require_hibernate_support=False,
                                spot_max_price_percentage_over_lowest_price=123,
                                total_local_storage_gb=ec2_mixins.CfnSpotFleetPropsMixin.TotalLocalStorageGBRequestProperty(
                                    max=123,
                                    min=123
                                ),
                                v_cpu_count=ec2_mixins.CfnSpotFleetPropsMixin.VCpuCountRangeRequestProperty(
                                    max=123,
                                    min=123
                                )
                            ),
                            instance_type="instanceType",
                            priority=123,
                            spot_price="spotPrice",
                            subnet_id="subnetId",
                            weighted_capacity=123
                        )]
                    )],
                    load_balancers_config=ec2_mixins.CfnSpotFleetPropsMixin.LoadBalancersConfigProperty(
                        classic_load_balancers_config=ec2_mixins.CfnSpotFleetPropsMixin.ClassicLoadBalancersConfigProperty(
                            classic_load_balancers=[ec2_mixins.CfnSpotFleetPropsMixin.ClassicLoadBalancerProperty(
                                name="name"
                            )]
                        ),
                        target_groups_config=ec2_mixins.CfnSpotFleetPropsMixin.TargetGroupsConfigProperty(
                            target_groups=[ec2_mixins.CfnSpotFleetPropsMixin.TargetGroupProperty(
                                arn="arn"
                            )]
                        )
                    ),
                    on_demand_allocation_strategy="onDemandAllocationStrategy",
                    on_demand_max_total_price="onDemandMaxTotalPrice",
                    on_demand_target_capacity=123,
                    replace_unhealthy_instances=False,
                    spot_maintenance_strategies=ec2_mixins.CfnSpotFleetPropsMixin.SpotMaintenanceStrategiesProperty(
                        capacity_rebalance=ec2_mixins.CfnSpotFleetPropsMixin.SpotCapacityRebalanceProperty(
                            replacement_strategy="replacementStrategy",
                            termination_delay=123
                        )
                    ),
                    spot_max_total_price="spotMaxTotalPrice",
                    spot_price="spotPrice",
                    tag_specifications=[ec2_mixins.CfnSpotFleetPropsMixin.SpotFleetTagSpecificationProperty(
                        resource_type="resourceType",
                        tags=[CfnTag(
                            key="key",
                            value="value"
                        )]
                    )],
                    target_capacity=123,
                    target_capacity_unit_type="targetCapacityUnitType",
                    terminate_instances_with_expiration=False,
                    type="type",
                    valid_from="validFrom",
                    valid_until="validUntil"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__b1ec370e55f4f7fd85594edb603fb608fe8b4c2437da2b45e99f14dedd332939)
                check_type(argname="argument allocation_strategy", value=allocation_strategy, expected_type=type_hints["allocation_strategy"])
                check_type(argname="argument context", value=context, expected_type=type_hints["context"])
                check_type(argname="argument excess_capacity_termination_policy", value=excess_capacity_termination_policy, expected_type=type_hints["excess_capacity_termination_policy"])
                check_type(argname="argument iam_fleet_role", value=iam_fleet_role, expected_type=type_hints["iam_fleet_role"])
                check_type(argname="argument instance_interruption_behavior", value=instance_interruption_behavior, expected_type=type_hints["instance_interruption_behavior"])
                check_type(argname="argument instance_pools_to_use_count", value=instance_pools_to_use_count, expected_type=type_hints["instance_pools_to_use_count"])
                check_type(argname="argument launch_specifications", value=launch_specifications, expected_type=type_hints["launch_specifications"])
                check_type(argname="argument launch_template_configs", value=launch_template_configs, expected_type=type_hints["launch_template_configs"])
                check_type(argname="argument load_balancers_config", value=load_balancers_config, expected_type=type_hints["load_balancers_config"])
                check_type(argname="argument on_demand_allocation_strategy", value=on_demand_allocation_strategy, expected_type=type_hints["on_demand_allocation_strategy"])
                check_type(argname="argument on_demand_max_total_price", value=on_demand_max_total_price, expected_type=type_hints["on_demand_max_total_price"])
                check_type(argname="argument on_demand_target_capacity", value=on_demand_target_capacity, expected_type=type_hints["on_demand_target_capacity"])
                check_type(argname="argument replace_unhealthy_instances", value=replace_unhealthy_instances, expected_type=type_hints["replace_unhealthy_instances"])
                check_type(argname="argument spot_maintenance_strategies", value=spot_maintenance_strategies, expected_type=type_hints["spot_maintenance_strategies"])
                check_type(argname="argument spot_max_total_price", value=spot_max_total_price, expected_type=type_hints["spot_max_total_price"])
                check_type(argname="argument spot_price", value=spot_price, expected_type=type_hints["spot_price"])
                check_type(argname="argument tag_specifications", value=tag_specifications, expected_type=type_hints["tag_specifications"])
                check_type(argname="argument target_capacity", value=target_capacity, expected_type=type_hints["target_capacity"])
                check_type(argname="argument target_capacity_unit_type", value=target_capacity_unit_type, expected_type=type_hints["target_capacity_unit_type"])
                check_type(argname="argument terminate_instances_with_expiration", value=terminate_instances_with_expiration, expected_type=type_hints["terminate_instances_with_expiration"])
                check_type(argname="argument type", value=type, expected_type=type_hints["type"])
                check_type(argname="argument valid_from", value=valid_from, expected_type=type_hints["valid_from"])
                check_type(argname="argument valid_until", value=valid_until, expected_type=type_hints["valid_until"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if allocation_strategy is not None:
                self._values["allocation_strategy"] = allocation_strategy
            if context is not None:
                self._values["context"] = context
            if excess_capacity_termination_policy is not None:
                self._values["excess_capacity_termination_policy"] = excess_capacity_termination_policy
            if iam_fleet_role is not None:
                self._values["iam_fleet_role"] = iam_fleet_role
            if instance_interruption_behavior is not None:
                self._values["instance_interruption_behavior"] = instance_interruption_behavior
            if instance_pools_to_use_count is not None:
                self._values["instance_pools_to_use_count"] = instance_pools_to_use_count
            if launch_specifications is not None:
                self._values["launch_specifications"] = launch_specifications
            if launch_template_configs is not None:
                self._values["launch_template_configs"] = launch_template_configs
            if load_balancers_config is not None:
                self._values["load_balancers_config"] = load_balancers_config
            if on_demand_allocation_strategy is not None:
                self._values["on_demand_allocation_strategy"] = on_demand_allocation_strategy
            if on_demand_max_total_price is not None:
                self._values["on_demand_max_total_price"] = on_demand_max_total_price
            if on_demand_target_capacity is not None:
                self._values["on_demand_target_capacity"] = on_demand_target_capacity
            if replace_unhealthy_instances is not None:
                self._values["replace_unhealthy_instances"] = replace_unhealthy_instances
            if spot_maintenance_strategies is not None:
                self._values["spot_maintenance_strategies"] = spot_maintenance_strategies
            if spot_max_total_price is not None:
                self._values["spot_max_total_price"] = spot_max_total_price
            if spot_price is not None:
                self._values["spot_price"] = spot_price
            if tag_specifications is not None:
                self._values["tag_specifications"] = tag_specifications
            if target_capacity is not None:
                self._values["target_capacity"] = target_capacity
            if target_capacity_unit_type is not None:
                self._values["target_capacity_unit_type"] = target_capacity_unit_type
            if terminate_instances_with_expiration is not None:
                self._values["terminate_instances_with_expiration"] = terminate_instances_with_expiration
            if type is not None:
                self._values["type"] = type
            if valid_from is not None:
                self._values["valid_from"] = valid_from
            if valid_until is not None:
                self._values["valid_until"] = valid_until

        @builtins.property
        def allocation_strategy(self) -> typing.Optional[builtins.str]:
            '''The strategy that determines how to allocate the target Spot Instance capacity across the Spot Instance pools specified by the Spot Fleet launch configuration.

            For more information, see `Allocation strategies for Spot Instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-allocation-strategy.html>`_ in the *Amazon EC2 User Guide* .

            - **priceCapacityOptimized (recommended)** - Spot Fleet identifies the pools with the highest capacity availability for the number of instances that are launching. This means that we will request Spot Instances from the pools that we believe have the lowest chance of interruption in the near term. Spot Fleet then requests Spot Instances from the lowest priced of these pools.
            - **capacityOptimized** - Spot Fleet identifies the pools with the highest capacity availability for the number of instances that are launching. This means that we will request Spot Instances from the pools that we believe have the lowest chance of interruption in the near term. To give certain instance types a higher chance of launching first, use ``capacityOptimizedPrioritized`` . Set a priority for each instance type by using the ``Priority`` parameter for ``LaunchTemplateOverrides`` . You can assign the same priority to different ``LaunchTemplateOverrides`` . EC2 implements the priorities on a best-effort basis, but optimizes for capacity first. ``capacityOptimizedPrioritized`` is supported only if your Spot Fleet uses a launch template. Note that if the ``OnDemandAllocationStrategy`` is set to ``prioritized`` , the same priority is applied when fulfilling On-Demand capacity.
            - **diversified** - Spot Fleet requests instances from all of the Spot Instance pools that you specify.
            - **lowestPrice (not recommended)** - > We don't recommend the ``lowestPrice`` allocation strategy because it has the highest risk of interruption for your Spot Instances.

            Spot Fleet requests instances from the lowest priced Spot Instance pool that has available capacity. If the lowest priced pool doesn't have available capacity, the Spot Instances come from the next lowest priced pool that has available capacity. If a pool runs out of capacity before fulfilling your desired capacity, Spot Fleet will continue to fulfill your request by drawing from the next lowest priced pool. To ensure that your desired capacity is met, you might receive Spot Instances from several pools. Because this strategy only considers instance price and not capacity availability, it might lead to high interruption rates.

            Default: ``lowestPrice``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-allocationstrategy
            '''
            result = self._values.get("allocation_strategy")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def context(self) -> typing.Optional[builtins.str]:
            '''Reserved.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-context
            '''
            result = self._values.get("context")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def excess_capacity_termination_policy(self) -> typing.Optional[builtins.str]:
            '''Indicates whether running Spot Instances should be terminated if you decrease the target capacity of the Spot Fleet request below the current size of the Spot Fleet.

            Supported only for fleets of type ``maintain`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-excesscapacityterminationpolicy
            '''
            result = self._values.get("excess_capacity_termination_policy")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def iam_fleet_role(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role that grants the Spot Fleet the permission to request, launch, terminate, and tag instances on your behalf.

            For more information, see `Spot Fleet Prerequisites <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-requests.html#spot-fleet-prerequisites>`_ in the *Amazon EC2 User Guide* . Spot Fleet can terminate Spot Instances on your behalf when you cancel its Spot Fleet request or when the Spot Fleet request expires, if you set ``TerminateInstancesWithExpiration`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-iamfleetrole
            '''
            result = self._values.get("iam_fleet_role")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def instance_interruption_behavior(self) -> typing.Optional[builtins.str]:
            '''The behavior when a Spot Instance is interrupted.

            The default is ``terminate`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-instanceinterruptionbehavior
            '''
            result = self._values.get("instance_interruption_behavior")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def instance_pools_to_use_count(self) -> typing.Optional[jsii.Number]:
            '''The number of Spot pools across which to allocate your target Spot capacity.

            Valid only when Spot *AllocationStrategy* is set to ``lowest-price`` . Spot Fleet selects the cheapest Spot pools and evenly allocates your target Spot capacity across the number of Spot pools that you specify.

            Note that Spot Fleet attempts to draw Spot Instances from the number of pools that you specify on a best effort basis. If a pool runs out of Spot capacity before fulfilling your target capacity, Spot Fleet will continue to fulfill your request by drawing from the next cheapest pool. To ensure that your target capacity is met, you might receive Spot Instances from more than the number of pools that you specified. Similarly, if most of the pools have no Spot capacity, you might receive your full target capacity from fewer than the number of pools that you specified.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-instancepoolstousecount
            '''
            result = self._values.get("instance_pools_to_use_count")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def launch_specifications(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.SpotFleetLaunchSpecificationProperty"]]]]:
            '''The launch specifications for the Spot Fleet request.

            If you specify ``LaunchSpecifications`` , you can't specify ``LaunchTemplateConfigs`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-launchspecifications
            '''
            result = self._values.get("launch_specifications")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.SpotFleetLaunchSpecificationProperty"]]]], result)

        @builtins.property
        def launch_template_configs(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.LaunchTemplateConfigProperty"]]]]:
            '''The launch template and overrides.

            If you specify ``LaunchTemplateConfigs`` , you can't specify ``LaunchSpecifications`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-launchtemplateconfigs
            '''
            result = self._values.get("launch_template_configs")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.LaunchTemplateConfigProperty"]]]], result)

        @builtins.property
        def load_balancers_config(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.LoadBalancersConfigProperty"]]:
            '''One or more Classic Load Balancers and target groups to attach to the Spot Fleet request.

            Spot Fleet registers the running Spot Instances with the specified Classic Load Balancers and target groups.

            With Network Load Balancers, Spot Fleet cannot register instances that have the following instance types: C1, CC1, CC2, CG1, CG2, CR1, CS1, G1, G2, HI1, HS1, M1, M2, M3, and T1.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-loadbalancersconfig
            '''
            result = self._values.get("load_balancers_config")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.LoadBalancersConfigProperty"]], result)

        @builtins.property
        def on_demand_allocation_strategy(self) -> typing.Optional[builtins.str]:
            '''The order of the launch template overrides to use in fulfilling On-Demand capacity.

            If you specify ``lowestPrice`` , Spot Fleet uses price to determine the order, launching the lowest price first. If you specify ``prioritized`` , Spot Fleet uses the priority that you assign to each Spot Fleet launch template override, launching the highest priority first. If you do not specify a value, Spot Fleet defaults to ``lowestPrice`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-ondemandallocationstrategy
            '''
            result = self._values.get("on_demand_allocation_strategy")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def on_demand_max_total_price(self) -> typing.Optional[builtins.str]:
            '''The maximum amount per hour for On-Demand Instances that you're willing to pay.

            You can use the ``onDemandMaxTotalPrice`` parameter, the ``spotMaxTotalPrice`` parameter, or both parameters to ensure that your fleet cost does not exceed your budget. If you set a maximum price per hour for the On-Demand Instances and Spot Instances in your request, Spot Fleet will launch instances until it reaches the maximum amount you're willing to pay. When the maximum amount you're willing to pay is reached, the fleet stops launching instances even if it hasnt met the target capacity.
            .. epigraph::

               If your fleet includes T instances that are configured as ``unlimited`` , and if their average CPU usage exceeds the baseline utilization, you will incur a charge for surplus credits. The ``onDemandMaxTotalPrice`` does not account for surplus credits, and, if you use surplus credits, your final cost might be higher than what you specified for ``onDemandMaxTotalPrice`` . For more information, see `Surplus credits can incur charges <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-unlimited-mode-concepts.html#unlimited-mode-surplus-credits>`_ in the *Amazon EC2 User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-ondemandmaxtotalprice
            '''
            result = self._values.get("on_demand_max_total_price")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def on_demand_target_capacity(self) -> typing.Optional[jsii.Number]:
            '''The number of On-Demand units to request.

            You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is ``maintain`` , you can specify a target capacity of 0 and add capacity later.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-ondemandtargetcapacity
            '''
            result = self._values.get("on_demand_target_capacity")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def replace_unhealthy_instances(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether Spot Fleet should replace unhealthy instances.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-replaceunhealthyinstances
            '''
            result = self._values.get("replace_unhealthy_instances")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def spot_maintenance_strategies(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.SpotMaintenanceStrategiesProperty"]]:
            '''The strategies for managing your Spot Instances that are at an elevated risk of being interrupted.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-spotmaintenancestrategies
            '''
            result = self._values.get("spot_maintenance_strategies")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.SpotMaintenanceStrategiesProperty"]], result)

        @builtins.property
        def spot_max_total_price(self) -> typing.Optional[builtins.str]:
            '''The maximum amount per hour for Spot Instances that you're willing to pay.

            You can use the ``spotMaxTotalPrice`` parameter, the ``onDemandMaxTotalPrice`` parameter, or both parameters to ensure that your fleet cost does not exceed your budget. If you set a maximum price per hour for the On-Demand Instances and Spot Instances in your request, Spot Fleet will launch instances until it reaches the maximum amount you're willing to pay. When the maximum amount you're willing to pay is reached, the fleet stops launching instances even if it hasnt met the target capacity.
            .. epigraph::

               If your fleet includes T instances that are configured as ``unlimited`` , and if their average CPU usage exceeds the baseline utilization, you will incur a charge for surplus credits. The ``spotMaxTotalPrice`` does not account for surplus credits, and, if you use surplus credits, your final cost might be higher than what you specified for ``spotMaxTotalPrice`` . For more information, see `Surplus credits can incur charges <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-unlimited-mode-concepts.html#unlimited-mode-surplus-credits>`_ in the *Amazon EC2 User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-spotmaxtotalprice
            '''
            result = self._values.get("spot_max_total_price")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def spot_price(self) -> typing.Optional[builtins.str]:
            '''The maximum price per unit hour that you are willing to pay for a Spot Instance.

            We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.
            .. epigraph::

               If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-spotprice
            '''
            result = self._values.get("spot_price")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def tag_specifications(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.SpotFleetTagSpecificationProperty"]]]]:
            '''The key-value pair for tagging the Spot Fleet request on creation.

            The value for ``ResourceType`` must be ``spot-fleet-request`` , otherwise the Spot Fleet request fails. To tag instances at launch, specify the tags in the `launch template <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#create-launch-template>`_ (valid only if you use ``LaunchTemplateConfigs`` ) or in the ``[SpotFleetTagSpecification](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SpotFleetTagSpecification.html)`` (valid only if you use ``LaunchSpecifications`` ). For information about tagging after launch, see `Tag your resources <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#tag-resources>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-tagspecifications
            '''
            result = self._values.get("tag_specifications")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.SpotFleetTagSpecificationProperty"]]]], result)

        @builtins.property
        def target_capacity(self) -> typing.Optional[jsii.Number]:
            '''The number of units to request for the Spot Fleet.

            You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is ``maintain`` , you can specify a target capacity of 0 and add capacity later.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-targetcapacity
            '''
            result = self._values.get("target_capacity")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def target_capacity_unit_type(self) -> typing.Optional[builtins.str]:
            '''The unit for the target capacity. You can specify this parameter only when using attribute-based instance type selection.

            Default: ``units`` (the number of instances)

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-targetcapacityunittype
            '''
            result = self._values.get("target_capacity_unit_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def terminate_instances_with_expiration(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether running Spot Instances are terminated when the Spot Fleet request expires.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-terminateinstanceswithexpiration
            '''
            result = self._values.get("terminate_instances_with_expiration")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def type(self) -> typing.Optional[builtins.str]:
            '''The type of request.

            Indicates whether the Spot Fleet only requests the target capacity or also attempts to maintain it. When this value is ``request`` , the Spot Fleet only places the required requests. It does not attempt to replenish Spot Instances if capacity is diminished, nor does it submit requests in alternative Spot pools if capacity is not available. When this value is ``maintain`` , the Spot Fleet maintains the target capacity. The Spot Fleet places the required requests to meet capacity and automatically replenishes any interrupted instances. Default: ``maintain`` . ``instant`` is listed but is not used by Spot Fleet.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def valid_from(self) -> typing.Optional[builtins.str]:
            '''The start date and time of the request, in UTC format ( *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z).

            By default, Amazon EC2 starts fulfilling the request immediately.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-validfrom
            '''
            result = self._values.get("valid_from")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def valid_until(self) -> typing.Optional[builtins.str]:
            '''The end date and time of the request, in UTC format ( *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z).

            After the end date and time, no new Spot Instance requests are placed or able to fulfill the request. If no value is specified, the Spot Fleet request remains until you cancel it.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-validuntil
            '''
            result = self._values.get("valid_until")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SpotFleetRequestConfigDataProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSpotFleetPropsMixin.SpotFleetTagSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={"resource_type": "resourceType", "tags": "tags"},
    )
    class SpotFleetTagSpecificationProperty:
        def __init__(
            self,
            *,
            resource_type: typing.Optional[builtins.str] = None,
            tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''The tags for a Spot Fleet resource.

            :param resource_type: The type of resource. Currently, the only resource type that is supported is ``instance`` . To tag the Spot Fleet request on creation, use the ``TagSpecifications`` parameter in ``[SpotFleetRequestConfigData](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SpotFleetRequestConfigData.html)`` .
            :param tags: The tags.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleettagspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                from aws_cdk import CfnTag
                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                spot_fleet_tag_specification_property = ec2_mixins.CfnSpotFleetPropsMixin.SpotFleetTagSpecificationProperty(
                    resource_type="resourceType",
                    tags=[CfnTag(
                        key="key",
                        value="value"
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__e08f3b3eb4e35ea5e82da817f57426310427be9f0ffc368f6036293cd4b3df2b)
                check_type(argname="argument resource_type", value=resource_type, expected_type=type_hints["resource_type"])
                check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if resource_type is not None:
                self._values["resource_type"] = resource_type
            if tags is not None:
                self._values["tags"] = tags

        @builtins.property
        def resource_type(self) -> typing.Optional[builtins.str]:
            '''The type of resource.

            Currently, the only resource type that is supported is ``instance`` . To tag the Spot Fleet request on creation, use the ``TagSpecifications`` parameter in ``[SpotFleetRequestConfigData](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SpotFleetRequestConfigData.html)`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleettagspecification.html#cfn-ec2-spotfleet-spotfleettagspecification-resourcetype
            '''
            result = self._values.get("resource_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
            '''The tags.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleettagspecification.html#cfn-ec2-spotfleet-spotfleettagspecification-tags
            '''
            result = self._values.get("tags")
            return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SpotFleetTagSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSpotFleetPropsMixin.SpotMaintenanceStrategiesProperty",
        jsii_struct_bases=[],
        name_mapping={"capacity_rebalance": "capacityRebalance"},
    )
    class SpotMaintenanceStrategiesProperty:
        def __init__(
            self,
            *,
            capacity_rebalance: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSpotFleetPropsMixin.SpotCapacityRebalanceProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''The strategies for managing your Spot Instances that are at an elevated risk of being interrupted.

            :param capacity_rebalance: The Spot Instance replacement strategy to use when Amazon EC2 emits a signal that your Spot Instance is at an elevated risk of being interrupted. For more information, see `Capacity rebalancing <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-capacity-rebalance.html>`_ in the *Amazon EC2 User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotmaintenancestrategies.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                spot_maintenance_strategies_property = ec2_mixins.CfnSpotFleetPropsMixin.SpotMaintenanceStrategiesProperty(
                    capacity_rebalance=ec2_mixins.CfnSpotFleetPropsMixin.SpotCapacityRebalanceProperty(
                        replacement_strategy="replacementStrategy",
                        termination_delay=123
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__b3ca4282d9de7eacbbe14fb630b74aa87aad91f70de3e68a8a82038b1a640694)
                check_type(argname="argument capacity_rebalance", value=capacity_rebalance, expected_type=type_hints["capacity_rebalance"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if capacity_rebalance is not None:
                self._values["capacity_rebalance"] = capacity_rebalance

        @builtins.property
        def capacity_rebalance(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.SpotCapacityRebalanceProperty"]]:
            '''The Spot Instance replacement strategy to use when Amazon EC2 emits a signal that your Spot Instance is at an elevated risk of being interrupted.

            For more information, see `Capacity rebalancing <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-capacity-rebalance.html>`_ in the *Amazon EC2 User Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotmaintenancestrategies.html#cfn-ec2-spotfleet-spotmaintenancestrategies-capacityrebalance
            '''
            result = self._values.get("capacity_rebalance")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.SpotCapacityRebalanceProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SpotMaintenanceStrategiesProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSpotFleetPropsMixin.SpotPlacementProperty",
        jsii_struct_bases=[],
        name_mapping={
            "availability_zone": "availabilityZone",
            "availability_zone_id": "availabilityZoneId",
            "group_name": "groupName",
            "tenancy": "tenancy",
        },
    )
    class SpotPlacementProperty:
        def __init__(
            self,
            *,
            availability_zone: typing.Optional[builtins.str] = None,
            availability_zone_id: typing.Optional[builtins.str] = None,
            group_name: typing.Optional[builtins.str] = None,
            tenancy: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes Spot Instance placement.

            :param availability_zone: The Availability Zone. To specify multiple Availability Zones, separate them using commas; for example, "us-west-2a, us-west-2b".
            :param availability_zone_id: The ID of the Availability Zone. For example, ``use2-az1`` . [Spot Fleet only] To specify multiple Availability Zones, separate them using commas; for example, " ``use2-az1`` , ``use2-bz1`` ". Either ``AvailabilityZone`` or ``AvailabilityZoneId`` must be specified in the request, but not both.
            :param group_name: The name of the placement group.
            :param tenancy: The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of ``dedicated`` runs on single-tenant hardware. The ``host`` tenancy is not supported for Spot Instances.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotplacement.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                spot_placement_property = ec2_mixins.CfnSpotFleetPropsMixin.SpotPlacementProperty(
                    availability_zone="availabilityZone",
                    availability_zone_id="availabilityZoneId",
                    group_name="groupName",
                    tenancy="tenancy"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__5a3a2a1f3abc58fdcdf56deba2f376b7701208da8a15036ec33fb568a17bdbbe)
                check_type(argname="argument availability_zone", value=availability_zone, expected_type=type_hints["availability_zone"])
                check_type(argname="argument availability_zone_id", value=availability_zone_id, expected_type=type_hints["availability_zone_id"])
                check_type(argname="argument group_name", value=group_name, expected_type=type_hints["group_name"])
                check_type(argname="argument tenancy", value=tenancy, expected_type=type_hints["tenancy"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if availability_zone is not None:
                self._values["availability_zone"] = availability_zone
            if availability_zone_id is not None:
                self._values["availability_zone_id"] = availability_zone_id
            if group_name is not None:
                self._values["group_name"] = group_name
            if tenancy is not None:
                self._values["tenancy"] = tenancy

        @builtins.property
        def availability_zone(self) -> typing.Optional[builtins.str]:
            '''The Availability Zone.

            To specify multiple Availability Zones, separate them using commas; for example, "us-west-2a, us-west-2b".

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotplacement.html#cfn-ec2-spotfleet-spotplacement-availabilityzone
            '''
            result = self._values.get("availability_zone")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def availability_zone_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the Availability Zone. For example, ``use2-az1`` .

            [Spot Fleet only] To specify multiple Availability Zones, separate them using commas; for example, " ``use2-az1`` , ``use2-bz1`` ".

            Either ``AvailabilityZone`` or ``AvailabilityZoneId`` must be specified in the request, but not both.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotplacement.html#cfn-ec2-spotfleet-spotplacement-availabilityzoneid
            '''
            result = self._values.get("availability_zone_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def group_name(self) -> typing.Optional[builtins.str]:
            '''The name of the placement group.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotplacement.html#cfn-ec2-spotfleet-spotplacement-groupname
            '''
            result = self._values.get("group_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def tenancy(self) -> typing.Optional[builtins.str]:
            '''The tenancy of the instance (if the instance is running in a VPC).

            An instance with a tenancy of ``dedicated`` runs on single-tenant hardware. The ``host`` tenancy is not supported for Spot Instances.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotplacement.html#cfn-ec2-spotfleet-spotplacement-tenancy
            '''
            result = self._values.get("tenancy")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SpotPlacementProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSpotFleetPropsMixin.TargetGroupProperty",
        jsii_struct_bases=[],
        name_mapping={"arn": "arn"},
    )
    class TargetGroupProperty:
        def __init__(self, *, arn: typing.Optional[builtins.str] = None) -> None:
            '''Describes a load balancer target group.

            :param arn: The Amazon Resource Name (ARN) of the target group.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-targetgroup.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                target_group_property = ec2_mixins.CfnSpotFleetPropsMixin.TargetGroupProperty(
                    arn="arn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__92bd05f4e7452f72b949ba3ed0c3aef92434e3c4a85510af4d0a7e462bab2446)
                check_type(argname="argument arn", value=arn, expected_type=type_hints["arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if arn is not None:
                self._values["arn"] = arn

        @builtins.property
        def arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the target group.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-targetgroup.html#cfn-ec2-spotfleet-targetgroup-arn
            '''
            result = self._values.get("arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TargetGroupProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSpotFleetPropsMixin.TargetGroupsConfigProperty",
        jsii_struct_bases=[],
        name_mapping={"target_groups": "targetGroups"},
    )
    class TargetGroupsConfigProperty:
        def __init__(
            self,
            *,
            target_groups: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSpotFleetPropsMixin.TargetGroupProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ) -> None:
            '''Describes the target groups to attach to a Spot Fleet.

            Spot Fleet registers the running Spot Instances with these target groups.

            :param target_groups: One or more target groups.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-targetgroupsconfig.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                target_groups_config_property = ec2_mixins.CfnSpotFleetPropsMixin.TargetGroupsConfigProperty(
                    target_groups=[ec2_mixins.CfnSpotFleetPropsMixin.TargetGroupProperty(
                        arn="arn"
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__128a7e8614c6bf1b26e7074fb3f64b5257df6948d97d0f217f1241a155a229af)
                check_type(argname="argument target_groups", value=target_groups, expected_type=type_hints["target_groups"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if target_groups is not None:
                self._values["target_groups"] = target_groups

        @builtins.property
        def target_groups(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.TargetGroupProperty"]]]]:
            '''One or more target groups.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-targetgroupsconfig.html#cfn-ec2-spotfleet-targetgroupsconfig-targetgroups
            '''
            result = self._values.get("target_groups")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSpotFleetPropsMixin.TargetGroupProperty"]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TargetGroupsConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSpotFleetPropsMixin.TotalLocalStorageGBRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class TotalLocalStorageGBRequestProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum amount of total local storage, in GB.

            :param max: The maximum amount of total local storage, in GB. To specify no maximum limit, omit this parameter.
            :param min: The minimum amount of total local storage, in GB. To specify no minimum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-totallocalstoragegbrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                total_local_storage_gBRequest_property = ec2_mixins.CfnSpotFleetPropsMixin.TotalLocalStorageGBRequestProperty(
                    max=123,
                    min=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__6cd5026f702085387dfd1a05ed4853dd4dbfdcfd6fe76ddcf663fc1e2f33006c)
                check_type(argname="argument max", value=max, expected_type=type_hints["max"])
                check_type(argname="argument min", value=min, expected_type=type_hints["min"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum amount of total local storage, in GB.

            To specify no maximum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-totallocalstoragegbrequest.html#cfn-ec2-spotfleet-totallocalstoragegbrequest-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum amount of total local storage, in GB.

            To specify no minimum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-totallocalstoragegbrequest.html#cfn-ec2-spotfleet-totallocalstoragegbrequest-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TotalLocalStorageGBRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSpotFleetPropsMixin.VCpuCountRangeRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class VCpuCountRangeRequestProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum number of vCPUs.

            :param max: The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
            :param min: The minimum number of vCPUs. To specify no minimum limit, specify ``0`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-vcpucountrangerequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                v_cpu_count_range_request_property = ec2_mixins.CfnSpotFleetPropsMixin.VCpuCountRangeRequestProperty(
                    max=123,
                    min=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__b0a82c744bd8760d1b438d02963d61fde3f52c42068d1e221b027444481e6dcf)
                check_type(argname="argument max", value=max, expected_type=type_hints["max"])
                check_type(argname="argument min", value=min, expected_type=type_hints["min"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum number of vCPUs.

            To specify no maximum limit, omit this parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-vcpucountrangerequest.html#cfn-ec2-spotfleet-vcpucountrangerequest-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum number of vCPUs.

            To specify no minimum limit, specify ``0`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-vcpucountrangerequest.html#cfn-ec2-spotfleet-vcpucountrangerequest-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "VCpuCountRangeRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSubnetCidrBlockMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "ipv6_cidr_block": "ipv6CidrBlock",
        "ipv6_ipam_pool_id": "ipv6IpamPoolId",
        "ipv6_netmask_length": "ipv6NetmaskLength",
        "subnet_id": "subnetId",
    },
)
class CfnSubnetCidrBlockMixinProps:
    def __init__(
        self,
        *,
        ipv6_cidr_block: typing.Optional[builtins.str] = None,
        ipv6_ipam_pool_id: typing.Optional[builtins.str] = None,
        ipv6_netmask_length: typing.Optional[jsii.Number] = None,
        subnet_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnSubnetCidrBlockPropsMixin.

        :param ipv6_cidr_block: The IPv6 network range for the subnet, in CIDR notation.
        :param ipv6_ipam_pool_id: An IPv6 IPAM pool ID for the subnet.
        :param ipv6_netmask_length: An IPv6 netmask length for the subnet.
        :param subnet_id: The ID of the subnet.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetcidrblock.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_subnet_cidr_block_mixin_props = ec2_mixins.CfnSubnetCidrBlockMixinProps(
                ipv6_cidr_block="ipv6CidrBlock",
                ipv6_ipam_pool_id="ipv6IpamPoolId",
                ipv6_netmask_length=123,
                subnet_id="subnetId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c05c7b9ee0dc80bf0a91d1b37bd02bff47f969d1ef733fc9dbd2e3a2b4f861ad)
            check_type(argname="argument ipv6_cidr_block", value=ipv6_cidr_block, expected_type=type_hints["ipv6_cidr_block"])
            check_type(argname="argument ipv6_ipam_pool_id", value=ipv6_ipam_pool_id, expected_type=type_hints["ipv6_ipam_pool_id"])
            check_type(argname="argument ipv6_netmask_length", value=ipv6_netmask_length, expected_type=type_hints["ipv6_netmask_length"])
            check_type(argname="argument subnet_id", value=subnet_id, expected_type=type_hints["subnet_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if ipv6_cidr_block is not None:
            self._values["ipv6_cidr_block"] = ipv6_cidr_block
        if ipv6_ipam_pool_id is not None:
            self._values["ipv6_ipam_pool_id"] = ipv6_ipam_pool_id
        if ipv6_netmask_length is not None:
            self._values["ipv6_netmask_length"] = ipv6_netmask_length
        if subnet_id is not None:
            self._values["subnet_id"] = subnet_id

    @builtins.property
    def ipv6_cidr_block(self) -> typing.Optional[builtins.str]:
        '''The IPv6 network range for the subnet, in CIDR notation.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetcidrblock.html#cfn-ec2-subnetcidrblock-ipv6cidrblock
        '''
        result = self._values.get("ipv6_cidr_block")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ipv6_ipam_pool_id(self) -> typing.Optional[builtins.str]:
        '''An IPv6 IPAM pool ID for the subnet.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetcidrblock.html#cfn-ec2-subnetcidrblock-ipv6ipampoolid
        '''
        result = self._values.get("ipv6_ipam_pool_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ipv6_netmask_length(self) -> typing.Optional[jsii.Number]:
        '''An IPv6 netmask length for the subnet.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetcidrblock.html#cfn-ec2-subnetcidrblock-ipv6netmasklength
        '''
        result = self._values.get("ipv6_netmask_length")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def subnet_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the subnet.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetcidrblock.html#cfn-ec2-subnetcidrblock-subnetid
        '''
        result = self._values.get("subnet_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnSubnetCidrBlockMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnSubnetCidrBlockPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSubnetCidrBlockPropsMixin",
):
    '''Associates a CIDR block with your subnet.

    You can associate a single IPv6 CIDR block with your subnet.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetcidrblock.html
    :cloudformationResource: AWS::EC2::SubnetCidrBlock
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_subnet_cidr_block_props_mixin = ec2_mixins.CfnSubnetCidrBlockPropsMixin(ec2_mixins.CfnSubnetCidrBlockMixinProps(
            ipv6_cidr_block="ipv6CidrBlock",
            ipv6_ipam_pool_id="ipv6IpamPoolId",
            ipv6_netmask_length=123,
            subnet_id="subnetId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnSubnetCidrBlockMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::SubnetCidrBlock``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__89ed88def6856b14ed205ebd7fa4e48efe4ff61f6ecf299987d19776462ce3c2)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0df00c1cdb2ca1aab7675ca08ffb2ac6d635a0aedb62507f021d5c15d7e6af5c)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d1c35cf9405dcacebb4d348b23087b9187d7ae5e491b9e08b5b553806a67a597)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnSubnetCidrBlockMixinProps":
        return typing.cast("CfnSubnetCidrBlockMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSubnetMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "assign_ipv6_address_on_creation": "assignIpv6AddressOnCreation",
        "availability_zone": "availabilityZone",
        "availability_zone_id": "availabilityZoneId",
        "cidr_block": "cidrBlock",
        "enable_dns64": "enableDns64",
        "enable_lni_at_device_index": "enableLniAtDeviceIndex",
        "ipv4_ipam_pool_id": "ipv4IpamPoolId",
        "ipv4_netmask_length": "ipv4NetmaskLength",
        "ipv6_cidr_block": "ipv6CidrBlock",
        "ipv6_ipam_pool_id": "ipv6IpamPoolId",
        "ipv6_native": "ipv6Native",
        "ipv6_netmask_length": "ipv6NetmaskLength",
        "map_public_ip_on_launch": "mapPublicIpOnLaunch",
        "outpost_arn": "outpostArn",
        "private_dns_name_options_on_launch": "privateDnsNameOptionsOnLaunch",
        "tags": "tags",
        "vpc_id": "vpcId",
    },
)
class CfnSubnetMixinProps:
    def __init__(
        self,
        *,
        assign_ipv6_address_on_creation: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        availability_zone: typing.Optional[builtins.str] = None,
        availability_zone_id: typing.Optional[builtins.str] = None,
        cidr_block: typing.Optional[builtins.str] = None,
        enable_dns64: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        enable_lni_at_device_index: typing.Optional[jsii.Number] = None,
        ipv4_ipam_pool_id: typing.Optional[builtins.str] = None,
        ipv4_netmask_length: typing.Optional[jsii.Number] = None,
        ipv6_cidr_block: typing.Optional[builtins.str] = None,
        ipv6_ipam_pool_id: typing.Optional[builtins.str] = None,
        ipv6_native: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        ipv6_netmask_length: typing.Optional[jsii.Number] = None,
        map_public_ip_on_launch: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        outpost_arn: typing.Optional[builtins.str] = None,
        private_dns_name_options_on_launch: typing.Any = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        vpc_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnSubnetPropsMixin.

        :param assign_ipv6_address_on_creation: Indicates whether a network interface created in this subnet receives an IPv6 address. The default value is ``false`` . If you specify ``AssignIpv6AddressOnCreation`` , you must also specify an IPv6 CIDR block.
        :param availability_zone: The Availability Zone of the subnet. If you update this property, you must also update the ``CidrBlock`` property.
        :param availability_zone_id: The AZ ID of the subnet.
        :param cidr_block: The IPv4 CIDR block assigned to the subnet. If you update this property, we create a new subnet, and then delete the existing one.
        :param enable_dns64: Indicates whether DNS queries made to the Amazon-provided DNS Resolver in this subnet should return synthetic IPv6 addresses for IPv4-only destinations. .. epigraph:: You must first configure a NAT gateway in a public subnet (separate from the subnet containing the IPv6-only workloads). For example, the subnet containing the NAT gateway should have a ``0.0.0.0/0`` route pointing to the internet gateway. For more information, see `Configure DNS64 and NAT64 <https://docs.aws.amazon.com/vpc/latest/userguide/nat-gateway-nat64-dns64.html#nat-gateway-nat64-dns64-walkthrough>`_ in the *Amazon Virtual Private Cloud User Guide* .
        :param enable_lni_at_device_index: Indicates the device position for local network interfaces in this subnet. For example, ``1`` indicates local network interfaces in this subnet are the secondary network interface (eth1).
        :param ipv4_ipam_pool_id: An IPv4 IPAM pool ID for the subnet.
        :param ipv4_netmask_length: An IPv4 netmask length for the subnet.
        :param ipv6_cidr_block: The IPv6 CIDR block. If you specify ``AssignIpv6AddressOnCreation`` , you must also specify an IPv6 CIDR block.
        :param ipv6_ipam_pool_id: An IPv6 IPAM pool ID for the subnet.
        :param ipv6_native: Indicates whether this is an IPv6 only subnet. For more information, see `Subnet basics <https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html#subnet-basics>`_ in the *Amazon Virtual Private Cloud User Guide* .
        :param ipv6_netmask_length: An IPv6 netmask length for the subnet.
        :param map_public_ip_on_launch: Indicates whether instances launched in this subnet receive a public IPv4 address. The default value is ``false`` . AWS charges for all public IPv4 addresses, including public IPv4 addresses associated with running instances and Elastic IP addresses. For more information, see the *Public IPv4 Address* tab on the `VPC pricing page <https://docs.aws.amazon.com/vpc/pricing/>`_ .
        :param outpost_arn: The Amazon Resource Name (ARN) of the Outpost.
        :param private_dns_name_options_on_launch: The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries to the instances should be handled. For more information, see `Amazon EC2 instance hostname types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html>`_ in the *Amazon Elastic Compute Cloud User Guide* . Available options: - EnableResourceNameDnsAAAARecord (true | false) - EnableResourceNameDnsARecord (true | false) - HostnameType (ip-name | resource-name)
        :param tags: Any tags assigned to the subnet.
        :param vpc_id: The ID of the VPC the subnet is in. If you update this property, you must also update the ``CidrBlock`` property.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            # private_dns_name_options_on_launch: Any
            
            cfn_subnet_mixin_props = ec2_mixins.CfnSubnetMixinProps(
                assign_ipv6_address_on_creation=False,
                availability_zone="availabilityZone",
                availability_zone_id="availabilityZoneId",
                cidr_block="cidrBlock",
                enable_dns64=False,
                enable_lni_at_device_index=123,
                ipv4_ipam_pool_id="ipv4IpamPoolId",
                ipv4_netmask_length=123,
                ipv6_cidr_block="ipv6CidrBlock",
                ipv6_ipam_pool_id="ipv6IpamPoolId",
                ipv6_native=False,
                ipv6_netmask_length=123,
                map_public_ip_on_launch=False,
                outpost_arn="outpostArn",
                private_dns_name_options_on_launch=private_dns_name_options_on_launch,
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                vpc_id="vpcId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__771798dee7e8266a793c3f1fac5bf867741a2f20c8b91b6cca8759f8bd31c0f0)
            check_type(argname="argument assign_ipv6_address_on_creation", value=assign_ipv6_address_on_creation, expected_type=type_hints["assign_ipv6_address_on_creation"])
            check_type(argname="argument availability_zone", value=availability_zone, expected_type=type_hints["availability_zone"])
            check_type(argname="argument availability_zone_id", value=availability_zone_id, expected_type=type_hints["availability_zone_id"])
            check_type(argname="argument cidr_block", value=cidr_block, expected_type=type_hints["cidr_block"])
            check_type(argname="argument enable_dns64", value=enable_dns64, expected_type=type_hints["enable_dns64"])
            check_type(argname="argument enable_lni_at_device_index", value=enable_lni_at_device_index, expected_type=type_hints["enable_lni_at_device_index"])
            check_type(argname="argument ipv4_ipam_pool_id", value=ipv4_ipam_pool_id, expected_type=type_hints["ipv4_ipam_pool_id"])
            check_type(argname="argument ipv4_netmask_length", value=ipv4_netmask_length, expected_type=type_hints["ipv4_netmask_length"])
            check_type(argname="argument ipv6_cidr_block", value=ipv6_cidr_block, expected_type=type_hints["ipv6_cidr_block"])
            check_type(argname="argument ipv6_ipam_pool_id", value=ipv6_ipam_pool_id, expected_type=type_hints["ipv6_ipam_pool_id"])
            check_type(argname="argument ipv6_native", value=ipv6_native, expected_type=type_hints["ipv6_native"])
            check_type(argname="argument ipv6_netmask_length", value=ipv6_netmask_length, expected_type=type_hints["ipv6_netmask_length"])
            check_type(argname="argument map_public_ip_on_launch", value=map_public_ip_on_launch, expected_type=type_hints["map_public_ip_on_launch"])
            check_type(argname="argument outpost_arn", value=outpost_arn, expected_type=type_hints["outpost_arn"])
            check_type(argname="argument private_dns_name_options_on_launch", value=private_dns_name_options_on_launch, expected_type=type_hints["private_dns_name_options_on_launch"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument vpc_id", value=vpc_id, expected_type=type_hints["vpc_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if assign_ipv6_address_on_creation is not None:
            self._values["assign_ipv6_address_on_creation"] = assign_ipv6_address_on_creation
        if availability_zone is not None:
            self._values["availability_zone"] = availability_zone
        if availability_zone_id is not None:
            self._values["availability_zone_id"] = availability_zone_id
        if cidr_block is not None:
            self._values["cidr_block"] = cidr_block
        if enable_dns64 is not None:
            self._values["enable_dns64"] = enable_dns64
        if enable_lni_at_device_index is not None:
            self._values["enable_lni_at_device_index"] = enable_lni_at_device_index
        if ipv4_ipam_pool_id is not None:
            self._values["ipv4_ipam_pool_id"] = ipv4_ipam_pool_id
        if ipv4_netmask_length is not None:
            self._values["ipv4_netmask_length"] = ipv4_netmask_length
        if ipv6_cidr_block is not None:
            self._values["ipv6_cidr_block"] = ipv6_cidr_block
        if ipv6_ipam_pool_id is not None:
            self._values["ipv6_ipam_pool_id"] = ipv6_ipam_pool_id
        if ipv6_native is not None:
            self._values["ipv6_native"] = ipv6_native
        if ipv6_netmask_length is not None:
            self._values["ipv6_netmask_length"] = ipv6_netmask_length
        if map_public_ip_on_launch is not None:
            self._values["map_public_ip_on_launch"] = map_public_ip_on_launch
        if outpost_arn is not None:
            self._values["outpost_arn"] = outpost_arn
        if private_dns_name_options_on_launch is not None:
            self._values["private_dns_name_options_on_launch"] = private_dns_name_options_on_launch
        if tags is not None:
            self._values["tags"] = tags
        if vpc_id is not None:
            self._values["vpc_id"] = vpc_id

    @builtins.property
    def assign_ipv6_address_on_creation(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Indicates whether a network interface created in this subnet receives an IPv6 address. The default value is ``false`` .

        If you specify ``AssignIpv6AddressOnCreation`` , you must also specify an IPv6 CIDR block.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-assignipv6addressoncreation
        '''
        result = self._values.get("assign_ipv6_address_on_creation")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def availability_zone(self) -> typing.Optional[builtins.str]:
        '''The Availability Zone of the subnet.

        If you update this property, you must also update the ``CidrBlock`` property.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-availabilityzone
        '''
        result = self._values.get("availability_zone")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def availability_zone_id(self) -> typing.Optional[builtins.str]:
        '''The AZ ID of the subnet.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-availabilityzoneid
        '''
        result = self._values.get("availability_zone_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def cidr_block(self) -> typing.Optional[builtins.str]:
        '''The IPv4 CIDR block assigned to the subnet.

        If you update this property, we create a new subnet, and then delete the existing one.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-cidrblock
        '''
        result = self._values.get("cidr_block")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_dns64(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Indicates whether DNS queries made to the Amazon-provided DNS Resolver in this subnet should return synthetic IPv6 addresses for IPv4-only destinations.

        .. epigraph::

           You must first configure a NAT gateway in a public subnet (separate from the subnet containing the IPv6-only workloads). For example, the subnet containing the NAT gateway should have a ``0.0.0.0/0`` route pointing to the internet gateway. For more information, see `Configure DNS64 and NAT64 <https://docs.aws.amazon.com/vpc/latest/userguide/nat-gateway-nat64-dns64.html#nat-gateway-nat64-dns64-walkthrough>`_ in the *Amazon Virtual Private Cloud User Guide* .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-enabledns64
        '''
        result = self._values.get("enable_dns64")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def enable_lni_at_device_index(self) -> typing.Optional[jsii.Number]:
        '''Indicates the device position for local network interfaces in this subnet.

        For example, ``1`` indicates local network interfaces in this subnet are the secondary network interface (eth1).

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-enablelniatdeviceindex
        '''
        result = self._values.get("enable_lni_at_device_index")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def ipv4_ipam_pool_id(self) -> typing.Optional[builtins.str]:
        '''An IPv4 IPAM pool ID for the subnet.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-ipv4ipampoolid
        '''
        result = self._values.get("ipv4_ipam_pool_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ipv4_netmask_length(self) -> typing.Optional[jsii.Number]:
        '''An IPv4 netmask length for the subnet.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-ipv4netmasklength
        '''
        result = self._values.get("ipv4_netmask_length")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def ipv6_cidr_block(self) -> typing.Optional[builtins.str]:
        '''The IPv6 CIDR block.

        If you specify ``AssignIpv6AddressOnCreation`` , you must also specify an IPv6 CIDR block.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-ipv6cidrblock
        '''
        result = self._values.get("ipv6_cidr_block")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ipv6_ipam_pool_id(self) -> typing.Optional[builtins.str]:
        '''An IPv6 IPAM pool ID for the subnet.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-ipv6ipampoolid
        '''
        result = self._values.get("ipv6_ipam_pool_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ipv6_native(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Indicates whether this is an IPv6 only subnet.

        For more information, see `Subnet basics <https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html#subnet-basics>`_ in the *Amazon Virtual Private Cloud User Guide* .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-ipv6native
        '''
        result = self._values.get("ipv6_native")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def ipv6_netmask_length(self) -> typing.Optional[jsii.Number]:
        '''An IPv6 netmask length for the subnet.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-ipv6netmasklength
        '''
        result = self._values.get("ipv6_netmask_length")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def map_public_ip_on_launch(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Indicates whether instances launched in this subnet receive a public IPv4 address. The default value is ``false`` .

        AWS charges for all public IPv4 addresses, including public IPv4 addresses associated with running instances and Elastic IP addresses. For more information, see the *Public IPv4 Address* tab on the `VPC pricing page <https://docs.aws.amazon.com/vpc/pricing/>`_ .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-mappubliciponlaunch
        '''
        result = self._values.get("map_public_ip_on_launch")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def outpost_arn(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the Outpost.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-outpostarn
        '''
        result = self._values.get("outpost_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def private_dns_name_options_on_launch(self) -> typing.Any:
        '''The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries to the instances should be handled.

        For more information, see `Amazon EC2 instance hostname types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .

        Available options:

        - EnableResourceNameDnsAAAARecord (true | false)
        - EnableResourceNameDnsARecord (true | false)
        - HostnameType (ip-name | resource-name)

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-privatednsnameoptionsonlaunch
        '''
        result = self._values.get("private_dns_name_options_on_launch")
        return typing.cast(typing.Any, result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''Any tags assigned to the subnet.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def vpc_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the VPC the subnet is in.

        If you update this property, you must also update the ``CidrBlock`` property.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-vpcid
        '''
        result = self._values.get("vpc_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnSubnetMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSubnetNetworkAclAssociationMixinProps",
    jsii_struct_bases=[],
    name_mapping={"network_acl_id": "networkAclId", "subnet_id": "subnetId"},
)
class CfnSubnetNetworkAclAssociationMixinProps:
    def __init__(
        self,
        *,
        network_acl_id: typing.Optional[builtins.str] = None,
        subnet_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnSubnetNetworkAclAssociationPropsMixin.

        :param network_acl_id: The ID of the network ACL.
        :param subnet_id: The ID of the subnet.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetnetworkaclassociation.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_subnet_network_acl_association_mixin_props = ec2_mixins.CfnSubnetNetworkAclAssociationMixinProps(
                network_acl_id="networkAclId",
                subnet_id="subnetId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a9329e7e6beb773cd9c72e9bc20f0d3c268f21197aa72d1ba622e147d8ba73db)
            check_type(argname="argument network_acl_id", value=network_acl_id, expected_type=type_hints["network_acl_id"])
            check_type(argname="argument subnet_id", value=subnet_id, expected_type=type_hints["subnet_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if network_acl_id is not None:
            self._values["network_acl_id"] = network_acl_id
        if subnet_id is not None:
            self._values["subnet_id"] = subnet_id

    @builtins.property
    def network_acl_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the network ACL.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetnetworkaclassociation.html#cfn-ec2-subnetnetworkaclassociation-networkaclid
        '''
        result = self._values.get("network_acl_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def subnet_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the subnet.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetnetworkaclassociation.html#cfn-ec2-subnetnetworkaclassociation-subnetid
        '''
        result = self._values.get("subnet_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnSubnetNetworkAclAssociationMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnSubnetNetworkAclAssociationPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSubnetNetworkAclAssociationPropsMixin",
):
    '''Associates a subnet with a network ACL. For more information, see `ReplaceNetworkAclAssociation <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/ApiReference-query-ReplaceNetworkAclAssociation.html>`_ in the *Amazon EC2 API Reference* .

    When ``AWS::EC2::SubnetNetworkAclAssociation`` resources are created during create or update operations, AWS CloudFormation adopts existing resources that share the same key properties (the properties that contribute to uniquely identify the resource). However, if the operation fails and rolls back, AWS CloudFormation deletes the previously out-of-band resources. You can protect against this behavior by using ``Retain`` deletion policies. For more information, see `DeletionPolicy Attribute <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html>`_ .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetnetworkaclassociation.html
    :cloudformationResource: AWS::EC2::SubnetNetworkAclAssociation
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_subnet_network_acl_association_props_mixin = ec2_mixins.CfnSubnetNetworkAclAssociationPropsMixin(ec2_mixins.CfnSubnetNetworkAclAssociationMixinProps(
            network_acl_id="networkAclId",
            subnet_id="subnetId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnSubnetNetworkAclAssociationMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::SubnetNetworkAclAssociation``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0bbc188eec434567d74789ca31308b5acf269e8aa334322d20c8206ed818ab0e)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0f1028b0deacb0d57bdfeb3dc75573879fdadfbde1da32db66f631b0cadb33a4)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3f39e6b95cf61bd3c683c7679b24f0f138cf935a3d9d7053450e33d7629a846a)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnSubnetNetworkAclAssociationMixinProps":
        return typing.cast("CfnSubnetNetworkAclAssociationMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.implements(_IMixin_11e4b965)
class CfnSubnetPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSubnetPropsMixin",
):
    '''Specifies a subnet for the specified VPC.

    For an IPv4 only subnet, specify an IPv4 CIDR block. If the VPC has an IPv6 CIDR block, you can create an IPv6 only subnet or a dual stack subnet instead. For an IPv6 only subnet, specify an IPv6 CIDR block. For a dual stack subnet, specify both an IPv4 CIDR block and an IPv6 CIDR block.

    For more information, see `Subnets for your VPC <https://docs.aws.amazon.com/vpc/latest/userguide/configure-subnets.html>`_ in the *Amazon VPC User Guide* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html
    :cloudformationResource: AWS::EC2::Subnet
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        # private_dns_name_options_on_launch: Any
        
        cfn_subnet_props_mixin = ec2_mixins.CfnSubnetPropsMixin(ec2_mixins.CfnSubnetMixinProps(
            assign_ipv6_address_on_creation=False,
            availability_zone="availabilityZone",
            availability_zone_id="availabilityZoneId",
            cidr_block="cidrBlock",
            enable_dns64=False,
            enable_lni_at_device_index=123,
            ipv4_ipam_pool_id="ipv4IpamPoolId",
            ipv4_netmask_length=123,
            ipv6_cidr_block="ipv6CidrBlock",
            ipv6_ipam_pool_id="ipv6IpamPoolId",
            ipv6_native=False,
            ipv6_netmask_length=123,
            map_public_ip_on_launch=False,
            outpost_arn="outpostArn",
            private_dns_name_options_on_launch=private_dns_name_options_on_launch,
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            vpc_id="vpcId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnSubnetMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::Subnet``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__59f8a2469aad8a8da9e708c435e6c9e09a4ea8fb547a875cd5904f6f11038012)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d976942109b59c9440e60ebd509d45ea96029cda6bbb4fe21b8fdbdc57608304)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__049073d365e1102a1b0df677d9b8f3936814159d4158bdc4dd2e718bc464be51)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnSubnetMixinProps":
        return typing.cast("CfnSubnetMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSubnetPropsMixin.BlockPublicAccessStatesProperty",
        jsii_struct_bases=[],
        name_mapping={"internet_gateway_block_mode": "internetGatewayBlockMode"},
    )
    class BlockPublicAccessStatesProperty:
        def __init__(
            self,
            *,
            internet_gateway_block_mode: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies the state of VPC Block Public Access (BPA).

            :param internet_gateway_block_mode: The mode of VPC BPA. - ``off`` : VPC BPA is not enabled and traffic is allowed to and from internet gateways and egress-only internet gateways in this Region. - ``block-bidirectional`` : Block all traffic to and from internet gateways and egress-only internet gateways in this Region (except for excluded VPCs and subnets). - ``block-ingress`` : Block all internet traffic to the VPCs in this Region (except for VPCs or subnets which are excluded). Only traffic to and from NAT gateways and egress-only internet gateways is allowed because these gateways only allow outbound connections to be established.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-subnet-blockpublicaccessstates.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                block_public_access_states_property = ec2_mixins.CfnSubnetPropsMixin.BlockPublicAccessStatesProperty(
                    internet_gateway_block_mode="internetGatewayBlockMode"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__b534f85b7681a8198f45e9f1c7aff3fed785c4dece139cf5271c0781ffa58aa4)
                check_type(argname="argument internet_gateway_block_mode", value=internet_gateway_block_mode, expected_type=type_hints["internet_gateway_block_mode"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if internet_gateway_block_mode is not None:
                self._values["internet_gateway_block_mode"] = internet_gateway_block_mode

        @builtins.property
        def internet_gateway_block_mode(self) -> typing.Optional[builtins.str]:
            '''The mode of VPC BPA.

            - ``off`` : VPC BPA is not enabled and traffic is allowed to and from internet gateways and egress-only internet gateways in this Region.
            - ``block-bidirectional`` : Block all traffic to and from internet gateways and egress-only internet gateways in this Region (except for excluded VPCs and subnets).
            - ``block-ingress`` : Block all internet traffic to the VPCs in this Region (except for VPCs or subnets which are excluded). Only traffic to and from NAT gateways and egress-only internet gateways is allowed because these gateways only allow outbound connections to be established.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-subnet-blockpublicaccessstates.html#cfn-ec2-subnet-blockpublicaccessstates-internetgatewayblockmode
            '''
            result = self._values.get("internet_gateway_block_mode")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "BlockPublicAccessStatesProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSubnetPropsMixin.PrivateDnsNameOptionsOnLaunchProperty",
        jsii_struct_bases=[],
        name_mapping={
            "enable_resource_name_dns_aaaa_record": "enableResourceNameDnsAaaaRecord",
            "enable_resource_name_dns_a_record": "enableResourceNameDnsARecord",
            "hostname_type": "hostnameType",
        },
    )
    class PrivateDnsNameOptionsOnLaunchProperty:
        def __init__(
            self,
            *,
            enable_resource_name_dns_aaaa_record: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            enable_resource_name_dns_a_record: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            hostname_type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies the options for instance hostnames.

            :param enable_resource_name_dns_aaaa_record: Indicates whether to respond to DNS queries for instance hostname with DNS AAAA records.
            :param enable_resource_name_dns_a_record: Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
            :param hostname_type: The type of hostname for EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-subnet-privatednsnameoptionsonlaunch.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                private_dns_name_options_on_launch_property = ec2_mixins.CfnSubnetPropsMixin.PrivateDnsNameOptionsOnLaunchProperty(
                    enable_resource_name_dns_aaaa_record=False,
                    enable_resource_name_dns_aRecord=False,
                    hostname_type="hostnameType"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__07e13c208916d0a3bf09054385b09dd01702f6abab7341f485d1c9716654dd4c)
                check_type(argname="argument enable_resource_name_dns_aaaa_record", value=enable_resource_name_dns_aaaa_record, expected_type=type_hints["enable_resource_name_dns_aaaa_record"])
                check_type(argname="argument enable_resource_name_dns_a_record", value=enable_resource_name_dns_a_record, expected_type=type_hints["enable_resource_name_dns_a_record"])
                check_type(argname="argument hostname_type", value=hostname_type, expected_type=type_hints["hostname_type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if enable_resource_name_dns_aaaa_record is not None:
                self._values["enable_resource_name_dns_aaaa_record"] = enable_resource_name_dns_aaaa_record
            if enable_resource_name_dns_a_record is not None:
                self._values["enable_resource_name_dns_a_record"] = enable_resource_name_dns_a_record
            if hostname_type is not None:
                self._values["hostname_type"] = hostname_type

        @builtins.property
        def enable_resource_name_dns_aaaa_record(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether to respond to DNS queries for instance hostname with DNS AAAA records.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-subnet-privatednsnameoptionsonlaunch.html#cfn-ec2-subnet-privatednsnameoptionsonlaunch-enableresourcenamednsaaaarecord
            '''
            result = self._values.get("enable_resource_name_dns_aaaa_record")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def enable_resource_name_dns_a_record(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether to respond to DNS queries for instance hostnames with DNS A records.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-subnet-privatednsnameoptionsonlaunch.html#cfn-ec2-subnet-privatednsnameoptionsonlaunch-enableresourcenamednsarecord
            '''
            result = self._values.get("enable_resource_name_dns_a_record")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def hostname_type(self) -> typing.Optional[builtins.str]:
            '''The type of hostname for EC2 instances.

            For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-subnet-privatednsnameoptionsonlaunch.html#cfn-ec2-subnet-privatednsnameoptionsonlaunch-hostnametype
            '''
            result = self._values.get("hostname_type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PrivateDnsNameOptionsOnLaunchProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSubnetRouteTableAssociationMixinProps",
    jsii_struct_bases=[],
    name_mapping={"route_table_id": "routeTableId", "subnet_id": "subnetId"},
)
class CfnSubnetRouteTableAssociationMixinProps:
    def __init__(
        self,
        *,
        route_table_id: typing.Optional[builtins.str] = None,
        subnet_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnSubnetRouteTableAssociationPropsMixin.

        :param route_table_id: The ID of the route table. The physical ID changes when the route table ID is changed.
        :param subnet_id: The ID of the subnet.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetroutetableassociation.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_subnet_route_table_association_mixin_props = ec2_mixins.CfnSubnetRouteTableAssociationMixinProps(
                route_table_id="routeTableId",
                subnet_id="subnetId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2ceb2a5b65d7fa8dedbe8791bd3e994b77986328fd61aa30dd1f878bcdae0e41)
            check_type(argname="argument route_table_id", value=route_table_id, expected_type=type_hints["route_table_id"])
            check_type(argname="argument subnet_id", value=subnet_id, expected_type=type_hints["subnet_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if route_table_id is not None:
            self._values["route_table_id"] = route_table_id
        if subnet_id is not None:
            self._values["subnet_id"] = subnet_id

    @builtins.property
    def route_table_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the route table.

        The physical ID changes when the route table ID is changed.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetroutetableassociation.html#cfn-ec2-subnetroutetableassociation-routetableid
        '''
        result = self._values.get("route_table_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def subnet_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the subnet.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetroutetableassociation.html#cfn-ec2-subnetroutetableassociation-subnetid
        '''
        result = self._values.get("subnet_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnSubnetRouteTableAssociationMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnSubnetRouteTableAssociationPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnSubnetRouteTableAssociationPropsMixin",
):
    '''Associates a subnet with a route table.

    The subnet and route table must be in the same VPC. This association causes traffic originating from the subnet to be routed according to the routes in the route table. A route table can be associated with multiple subnets. To create a route table, see `AWS::EC2::RouteTable <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routetable.html>`_ .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetroutetableassociation.html
    :cloudformationResource: AWS::EC2::SubnetRouteTableAssociation
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_subnet_route_table_association_props_mixin = ec2_mixins.CfnSubnetRouteTableAssociationPropsMixin(ec2_mixins.CfnSubnetRouteTableAssociationMixinProps(
            route_table_id="routeTableId",
            subnet_id="subnetId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnSubnetRouteTableAssociationMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::SubnetRouteTableAssociation``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7f4b887eb791e565652bd3bae7db9022115f3e131149383527fa8d928a9ab161)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ca1b6ef0ab384a858aafe026e5d39714d33c0cf646fd53423fbb6f337d2b980e)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__30376dc42fa5525fcb65864fe936efb8f867ea2cdcc664aad92af8b8aa229ee6)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnSubnetRouteTableAssociationMixinProps":
        return typing.cast("CfnSubnetRouteTableAssociationMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTrafficMirrorFilterMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "description": "description",
        "network_services": "networkServices",
        "tags": "tags",
    },
)
class CfnTrafficMirrorFilterMixinProps:
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        network_services: typing.Optional[typing.Sequence[builtins.str]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnTrafficMirrorFilterPropsMixin.

        :param description: The description of the Traffic Mirror filter.
        :param network_services: The network service traffic that is associated with the Traffic Mirror filter. Valid values are ``amazon-dns`` .
        :param tags: The tags to assign to a Traffic Mirror filter.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilter.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_traffic_mirror_filter_mixin_props = ec2_mixins.CfnTrafficMirrorFilterMixinProps(
                description="description",
                network_services=["networkServices"],
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9ff677402d4737eedcda1bbd25d225e2b429b785e9913de2586b9e15b564e69a)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument network_services", value=network_services, expected_type=type_hints["network_services"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if description is not None:
            self._values["description"] = description
        if network_services is not None:
            self._values["network_services"] = network_services
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''The description of the Traffic Mirror filter.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilter.html#cfn-ec2-trafficmirrorfilter-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def network_services(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The network service traffic that is associated with the Traffic Mirror filter.

        Valid values are ``amazon-dns`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilter.html#cfn-ec2-trafficmirrorfilter-networkservices
        '''
        result = self._values.get("network_services")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags to assign to a Traffic Mirror filter.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilter.html#cfn-ec2-trafficmirrorfilter-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnTrafficMirrorFilterMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnTrafficMirrorFilterPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTrafficMirrorFilterPropsMixin",
):
    '''Specifies a Traffic Mirror filter.

    A Traffic Mirror filter is a set of rules that defines the traffic to mirror.

    By default, no traffic is mirrored. To mirror traffic, use `AWS::EC2::TrafficMirrorFilterRule <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html>`_ to add Traffic Mirror rules to the filter. The rules you add define what traffic gets mirrored.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilter.html
    :cloudformationResource: AWS::EC2::TrafficMirrorFilter
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_traffic_mirror_filter_props_mixin = ec2_mixins.CfnTrafficMirrorFilterPropsMixin(ec2_mixins.CfnTrafficMirrorFilterMixinProps(
            description="description",
            network_services=["networkServices"],
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnTrafficMirrorFilterMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::TrafficMirrorFilter``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f95d90b81d5b8e15ed6c91f2af8cda71b9fe03f76ad3a25821ac0031618863a4)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__52c0218d2c5f26ebd4653730975815450cfd6f603793bffa3533c4ee616e4c3c)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d3732dd7678f733ddae3cb7134912c741425cbe54bba83225c98d5f0bcc66eae)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnTrafficMirrorFilterMixinProps":
        return typing.cast("CfnTrafficMirrorFilterMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTrafficMirrorFilterRuleMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "description": "description",
        "destination_cidr_block": "destinationCidrBlock",
        "destination_port_range": "destinationPortRange",
        "protocol": "protocol",
        "rule_action": "ruleAction",
        "rule_number": "ruleNumber",
        "source_cidr_block": "sourceCidrBlock",
        "source_port_range": "sourcePortRange",
        "tags": "tags",
        "traffic_direction": "trafficDirection",
        "traffic_mirror_filter_id": "trafficMirrorFilterId",
    },
)
class CfnTrafficMirrorFilterRuleMixinProps:
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        destination_cidr_block: typing.Optional[builtins.str] = None,
        destination_port_range: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTrafficMirrorFilterRulePropsMixin.TrafficMirrorPortRangeProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        protocol: typing.Optional[jsii.Number] = None,
        rule_action: typing.Optional[builtins.str] = None,
        rule_number: typing.Optional[jsii.Number] = None,
        source_cidr_block: typing.Optional[builtins.str] = None,
        source_port_range: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTrafficMirrorFilterRulePropsMixin.TrafficMirrorPortRangeProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        traffic_direction: typing.Optional[builtins.str] = None,
        traffic_mirror_filter_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnTrafficMirrorFilterRulePropsMixin.

        :param description: The description of the Traffic Mirror rule.
        :param destination_cidr_block: The destination CIDR block to assign to the Traffic Mirror rule.
        :param destination_port_range: The destination port range.
        :param protocol: The protocol, for example UDP, to assign to the Traffic Mirror rule. For information about the protocol value, see `Protocol Numbers <https://docs.aws.amazon.com/https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml>`_ on the Internet Assigned Numbers Authority (IANA) website.
        :param rule_action: The action to take on the filtered traffic.
        :param rule_number: The number of the Traffic Mirror rule. This number must be unique for each Traffic Mirror rule in a given direction. The rules are processed in ascending order by rule number.
        :param source_cidr_block: The source CIDR block to assign to the Traffic Mirror rule.
        :param source_port_range: The source port range.
        :param tags: Tags on Traffic Mirroring filter rules.
        :param traffic_direction: The type of traffic.
        :param traffic_mirror_filter_id: The ID of the filter that this rule is associated with.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_traffic_mirror_filter_rule_mixin_props = ec2_mixins.CfnTrafficMirrorFilterRuleMixinProps(
                description="description",
                destination_cidr_block="destinationCidrBlock",
                destination_port_range=ec2_mixins.CfnTrafficMirrorFilterRulePropsMixin.TrafficMirrorPortRangeProperty(
                    from_port=123,
                    to_port=123
                ),
                protocol=123,
                rule_action="ruleAction",
                rule_number=123,
                source_cidr_block="sourceCidrBlock",
                source_port_range=ec2_mixins.CfnTrafficMirrorFilterRulePropsMixin.TrafficMirrorPortRangeProperty(
                    from_port=123,
                    to_port=123
                ),
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                traffic_direction="trafficDirection",
                traffic_mirror_filter_id="trafficMirrorFilterId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__53844a1e97754bc769828633ccee88b7e03ee5632bfc0f9428826192f7381135)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument destination_cidr_block", value=destination_cidr_block, expected_type=type_hints["destination_cidr_block"])
            check_type(argname="argument destination_port_range", value=destination_port_range, expected_type=type_hints["destination_port_range"])
            check_type(argname="argument protocol", value=protocol, expected_type=type_hints["protocol"])
            check_type(argname="argument rule_action", value=rule_action, expected_type=type_hints["rule_action"])
            check_type(argname="argument rule_number", value=rule_number, expected_type=type_hints["rule_number"])
            check_type(argname="argument source_cidr_block", value=source_cidr_block, expected_type=type_hints["source_cidr_block"])
            check_type(argname="argument source_port_range", value=source_port_range, expected_type=type_hints["source_port_range"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument traffic_direction", value=traffic_direction, expected_type=type_hints["traffic_direction"])
            check_type(argname="argument traffic_mirror_filter_id", value=traffic_mirror_filter_id, expected_type=type_hints["traffic_mirror_filter_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if description is not None:
            self._values["description"] = description
        if destination_cidr_block is not None:
            self._values["destination_cidr_block"] = destination_cidr_block
        if destination_port_range is not None:
            self._values["destination_port_range"] = destination_port_range
        if protocol is not None:
            self._values["protocol"] = protocol
        if rule_action is not None:
            self._values["rule_action"] = rule_action
        if rule_number is not None:
            self._values["rule_number"] = rule_number
        if source_cidr_block is not None:
            self._values["source_cidr_block"] = source_cidr_block
        if source_port_range is not None:
            self._values["source_port_range"] = source_port_range
        if tags is not None:
            self._values["tags"] = tags
        if traffic_direction is not None:
            self._values["traffic_direction"] = traffic_direction
        if traffic_mirror_filter_id is not None:
            self._values["traffic_mirror_filter_id"] = traffic_mirror_filter_id

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''The description of the Traffic Mirror rule.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def destination_cidr_block(self) -> typing.Optional[builtins.str]:
        '''The destination CIDR block to assign to the Traffic Mirror rule.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-destinationcidrblock
        '''
        result = self._values.get("destination_cidr_block")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def destination_port_range(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTrafficMirrorFilterRulePropsMixin.TrafficMirrorPortRangeProperty"]]:
        '''The destination port range.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-destinationportrange
        '''
        result = self._values.get("destination_port_range")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTrafficMirrorFilterRulePropsMixin.TrafficMirrorPortRangeProperty"]], result)

    @builtins.property
    def protocol(self) -> typing.Optional[jsii.Number]:
        '''The protocol, for example UDP, to assign to the Traffic Mirror rule.

        For information about the protocol value, see `Protocol Numbers <https://docs.aws.amazon.com/https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml>`_ on the Internet Assigned Numbers Authority (IANA) website.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-protocol
        '''
        result = self._values.get("protocol")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def rule_action(self) -> typing.Optional[builtins.str]:
        '''The action to take on the filtered traffic.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-ruleaction
        '''
        result = self._values.get("rule_action")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def rule_number(self) -> typing.Optional[jsii.Number]:
        '''The number of the Traffic Mirror rule.

        This number must be unique for each Traffic Mirror rule in a given direction. The rules are processed in ascending order by rule number.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-rulenumber
        '''
        result = self._values.get("rule_number")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def source_cidr_block(self) -> typing.Optional[builtins.str]:
        '''The source CIDR block to assign to the Traffic Mirror rule.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-sourcecidrblock
        '''
        result = self._values.get("source_cidr_block")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def source_port_range(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTrafficMirrorFilterRulePropsMixin.TrafficMirrorPortRangeProperty"]]:
        '''The source port range.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-sourceportrange
        '''
        result = self._values.get("source_port_range")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTrafficMirrorFilterRulePropsMixin.TrafficMirrorPortRangeProperty"]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''Tags on Traffic Mirroring filter rules.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def traffic_direction(self) -> typing.Optional[builtins.str]:
        '''The type of traffic.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-trafficdirection
        '''
        result = self._values.get("traffic_direction")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def traffic_mirror_filter_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the filter that this rule is associated with.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-trafficmirrorfilterid
        '''
        result = self._values.get("traffic_mirror_filter_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnTrafficMirrorFilterRuleMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnTrafficMirrorFilterRulePropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTrafficMirrorFilterRulePropsMixin",
):
    '''Creates a Traffic Mirror filter rule.

    A Traffic Mirror rule defines the Traffic Mirror source traffic to mirror.

    You need the Traffic Mirror filter ID when you create the rule.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html
    :cloudformationResource: AWS::EC2::TrafficMirrorFilterRule
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_traffic_mirror_filter_rule_props_mixin = ec2_mixins.CfnTrafficMirrorFilterRulePropsMixin(ec2_mixins.CfnTrafficMirrorFilterRuleMixinProps(
            description="description",
            destination_cidr_block="destinationCidrBlock",
            destination_port_range=ec2_mixins.CfnTrafficMirrorFilterRulePropsMixin.TrafficMirrorPortRangeProperty(
                from_port=123,
                to_port=123
            ),
            protocol=123,
            rule_action="ruleAction",
            rule_number=123,
            source_cidr_block="sourceCidrBlock",
            source_port_range=ec2_mixins.CfnTrafficMirrorFilterRulePropsMixin.TrafficMirrorPortRangeProperty(
                from_port=123,
                to_port=123
            ),
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            traffic_direction="trafficDirection",
            traffic_mirror_filter_id="trafficMirrorFilterId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnTrafficMirrorFilterRuleMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::TrafficMirrorFilterRule``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a1e71646a6aae164f10e21421243dd1eba9397f02c12321907678b9b9b84ebcc)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d0788a004a1029aa94d3770a0bf7f9727b9170bc0ae2950082dcbb0a220e3bbf)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1ed0c8a342ace0d0199af7492d39144ef758fc5aa9419a39a8db5ce71e9dc5eb)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnTrafficMirrorFilterRuleMixinProps":
        return typing.cast("CfnTrafficMirrorFilterRuleMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTrafficMirrorFilterRulePropsMixin.TrafficMirrorPortRangeProperty",
        jsii_struct_bases=[],
        name_mapping={"from_port": "fromPort", "to_port": "toPort"},
    )
    class TrafficMirrorPortRangeProperty:
        def __init__(
            self,
            *,
            from_port: typing.Optional[jsii.Number] = None,
            to_port: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Describes the Traffic Mirror port range.

            :param from_port: The start of the Traffic Mirror port range. This applies to the TCP and UDP protocols.
            :param to_port: The end of the Traffic Mirror port range. This applies to the TCP and UDP protocols.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrorfilterrule-trafficmirrorportrange.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                traffic_mirror_port_range_property = ec2_mixins.CfnTrafficMirrorFilterRulePropsMixin.TrafficMirrorPortRangeProperty(
                    from_port=123,
                    to_port=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__8a0c8752d8e57bea74a0499dbbdd6cff6a361dbaf57ecbfbf40d79b8cc361ca9)
                check_type(argname="argument from_port", value=from_port, expected_type=type_hints["from_port"])
                check_type(argname="argument to_port", value=to_port, expected_type=type_hints["to_port"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if from_port is not None:
                self._values["from_port"] = from_port
            if to_port is not None:
                self._values["to_port"] = to_port

        @builtins.property
        def from_port(self) -> typing.Optional[jsii.Number]:
            '''The start of the Traffic Mirror port range.

            This applies to the TCP and UDP protocols.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrorfilterrule-trafficmirrorportrange.html#cfn-ec2-trafficmirrorfilterrule-trafficmirrorportrange-fromport
            '''
            result = self._values.get("from_port")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def to_port(self) -> typing.Optional[jsii.Number]:
            '''The end of the Traffic Mirror port range.

            This applies to the TCP and UDP protocols.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrorfilterrule-trafficmirrorportrange.html#cfn-ec2-trafficmirrorfilterrule-trafficmirrorportrange-toport
            '''
            result = self._values.get("to_port")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TrafficMirrorPortRangeProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTrafficMirrorSessionMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "description": "description",
        "network_interface_id": "networkInterfaceId",
        "owner_id": "ownerId",
        "packet_length": "packetLength",
        "session_number": "sessionNumber",
        "tags": "tags",
        "traffic_mirror_filter_id": "trafficMirrorFilterId",
        "traffic_mirror_target_id": "trafficMirrorTargetId",
        "virtual_network_id": "virtualNetworkId",
    },
)
class CfnTrafficMirrorSessionMixinProps:
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        network_interface_id: typing.Optional[builtins.str] = None,
        owner_id: typing.Optional[builtins.str] = None,
        packet_length: typing.Optional[jsii.Number] = None,
        session_number: typing.Optional[jsii.Number] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        traffic_mirror_filter_id: typing.Optional[builtins.str] = None,
        traffic_mirror_target_id: typing.Optional[builtins.str] = None,
        virtual_network_id: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Properties for CfnTrafficMirrorSessionPropsMixin.

        :param description: The description of the Traffic Mirror session.
        :param network_interface_id: The ID of the source network interface.
        :param owner_id: The ID of the account that owns the Traffic Mirror session.
        :param packet_length: The number of bytes in each packet to mirror. These are bytes after the VXLAN header. Do not specify this parameter when you want to mirror the entire packet. To mirror a subset of the packet, set this to the length (in bytes) that you want to mirror. For example, if you set this value to 100, then the first 100 bytes that meet the filter criteria are copied to the target. If you do not want to mirror the entire packet, use the ``PacketLength`` parameter to specify the number of bytes in each packet to mirror. For sessions with Network Load Balancer (NLB) Traffic Mirror targets the default ``PacketLength`` will be set to 8500. Valid values are 1-8500. Setting a ``PacketLength`` greater than 8500 will result in an error response.
        :param session_number: The session number determines the order in which sessions are evaluated when an interface is used by multiple sessions. The first session with a matching filter is the one that mirrors the packets. Valid values are 1-32766.
        :param tags: The tags to assign to a Traffic Mirror session.
        :param traffic_mirror_filter_id: The ID of the Traffic Mirror filter.
        :param traffic_mirror_target_id: The ID of the Traffic Mirror target.
        :param virtual_network_id: The VXLAN ID for the Traffic Mirror session. For more information about the VXLAN protocol, see `RFC 7348 <https://docs.aws.amazon.com/https://datatracker.ietf.org/doc/html/rfc7348>`_ . If you do not specify a ``VirtualNetworkId`` , an account-wide unique ID is chosen at random.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_traffic_mirror_session_mixin_props = ec2_mixins.CfnTrafficMirrorSessionMixinProps(
                description="description",
                network_interface_id="networkInterfaceId",
                owner_id="ownerId",
                packet_length=123,
                session_number=123,
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                traffic_mirror_filter_id="trafficMirrorFilterId",
                traffic_mirror_target_id="trafficMirrorTargetId",
                virtual_network_id=123
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3a4aeebe11b7fbc88937ec497a7c269e6214c98bf400709cdd06b42bca7e08fd)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument network_interface_id", value=network_interface_id, expected_type=type_hints["network_interface_id"])
            check_type(argname="argument owner_id", value=owner_id, expected_type=type_hints["owner_id"])
            check_type(argname="argument packet_length", value=packet_length, expected_type=type_hints["packet_length"])
            check_type(argname="argument session_number", value=session_number, expected_type=type_hints["session_number"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument traffic_mirror_filter_id", value=traffic_mirror_filter_id, expected_type=type_hints["traffic_mirror_filter_id"])
            check_type(argname="argument traffic_mirror_target_id", value=traffic_mirror_target_id, expected_type=type_hints["traffic_mirror_target_id"])
            check_type(argname="argument virtual_network_id", value=virtual_network_id, expected_type=type_hints["virtual_network_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if description is not None:
            self._values["description"] = description
        if network_interface_id is not None:
            self._values["network_interface_id"] = network_interface_id
        if owner_id is not None:
            self._values["owner_id"] = owner_id
        if packet_length is not None:
            self._values["packet_length"] = packet_length
        if session_number is not None:
            self._values["session_number"] = session_number
        if tags is not None:
            self._values["tags"] = tags
        if traffic_mirror_filter_id is not None:
            self._values["traffic_mirror_filter_id"] = traffic_mirror_filter_id
        if traffic_mirror_target_id is not None:
            self._values["traffic_mirror_target_id"] = traffic_mirror_target_id
        if virtual_network_id is not None:
            self._values["virtual_network_id"] = virtual_network_id

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''The description of the Traffic Mirror session.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def network_interface_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the source network interface.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-networkinterfaceid
        '''
        result = self._values.get("network_interface_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def owner_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the account that owns the Traffic Mirror session.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-ownerid
        '''
        result = self._values.get("owner_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def packet_length(self) -> typing.Optional[jsii.Number]:
        '''The number of bytes in each packet to mirror.

        These are bytes after the VXLAN header. Do not specify this parameter when you want to mirror the entire packet. To mirror a subset of the packet, set this to the length (in bytes) that you want to mirror. For example, if you set this value to 100, then the first 100 bytes that meet the filter criteria are copied to the target.

        If you do not want to mirror the entire packet, use the ``PacketLength`` parameter to specify the number of bytes in each packet to mirror.

        For sessions with Network Load Balancer (NLB) Traffic Mirror targets the default ``PacketLength`` will be set to 8500. Valid values are 1-8500. Setting a ``PacketLength`` greater than 8500 will result in an error response.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-packetlength
        '''
        result = self._values.get("packet_length")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def session_number(self) -> typing.Optional[jsii.Number]:
        '''The session number determines the order in which sessions are evaluated when an interface is used by multiple sessions.

        The first session with a matching filter is the one that mirrors the packets.

        Valid values are 1-32766.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-sessionnumber
        '''
        result = self._values.get("session_number")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags to assign to a Traffic Mirror session.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def traffic_mirror_filter_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the Traffic Mirror filter.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-trafficmirrorfilterid
        '''
        result = self._values.get("traffic_mirror_filter_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def traffic_mirror_target_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the Traffic Mirror target.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-trafficmirrortargetid
        '''
        result = self._values.get("traffic_mirror_target_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def virtual_network_id(self) -> typing.Optional[jsii.Number]:
        '''The VXLAN ID for the Traffic Mirror session.

        For more information about the VXLAN protocol, see `RFC 7348 <https://docs.aws.amazon.com/https://datatracker.ietf.org/doc/html/rfc7348>`_ . If you do not specify a ``VirtualNetworkId`` , an account-wide unique ID is chosen at random.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-virtualnetworkid
        '''
        result = self._values.get("virtual_network_id")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnTrafficMirrorSessionMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnTrafficMirrorSessionPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTrafficMirrorSessionPropsMixin",
):
    '''Creates a Traffic Mirror session.

    A Traffic Mirror session actively copies packets from a Traffic Mirror source to a Traffic Mirror target. Create a filter, and then assign it to the session to define a subset of the traffic to mirror, for example all TCP traffic.

    The Traffic Mirror source and the Traffic Mirror target (monitoring appliances) can be in the same VPC, or in a different VPC connected via VPC peering or a transit gateway.

    By default, no traffic is mirrored. Use `AWS::EC2::TrafficMirrorFilterRule <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html>`_ to specify filter rules that specify the traffic to mirror.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html
    :cloudformationResource: AWS::EC2::TrafficMirrorSession
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_traffic_mirror_session_props_mixin = ec2_mixins.CfnTrafficMirrorSessionPropsMixin(ec2_mixins.CfnTrafficMirrorSessionMixinProps(
            description="description",
            network_interface_id="networkInterfaceId",
            owner_id="ownerId",
            packet_length=123,
            session_number=123,
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            traffic_mirror_filter_id="trafficMirrorFilterId",
            traffic_mirror_target_id="trafficMirrorTargetId",
            virtual_network_id=123
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnTrafficMirrorSessionMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::TrafficMirrorSession``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1ef3915bae29f93280652433ee0d270502109724f2164f810556d056966b1588)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__52708850da0c8e9021563f0d623e2a8587407f68f82aad2fbe805c863b93b0d6)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bc85e1a832cf1b014a0f43c075a572bdf0fa900570e959f076270c38b01b2fc0)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnTrafficMirrorSessionMixinProps":
        return typing.cast("CfnTrafficMirrorSessionMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTrafficMirrorTargetMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "description": "description",
        "gateway_load_balancer_endpoint_id": "gatewayLoadBalancerEndpointId",
        "network_interface_id": "networkInterfaceId",
        "network_load_balancer_arn": "networkLoadBalancerArn",
        "tags": "tags",
    },
)
class CfnTrafficMirrorTargetMixinProps:
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        gateway_load_balancer_endpoint_id: typing.Optional[builtins.str] = None,
        network_interface_id: typing.Optional[builtins.str] = None,
        network_load_balancer_arn: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnTrafficMirrorTargetPropsMixin.

        :param description: The description of the Traffic Mirror target.
        :param gateway_load_balancer_endpoint_id: The ID of the Gateway Load Balancer endpoint.
        :param network_interface_id: The network interface ID that is associated with the target.
        :param network_load_balancer_arn: The Amazon Resource Name (ARN) of the Network Load Balancer that is associated with the target.
        :param tags: The tags to assign to the Traffic Mirror target.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_traffic_mirror_target_mixin_props = ec2_mixins.CfnTrafficMirrorTargetMixinProps(
                description="description",
                gateway_load_balancer_endpoint_id="gatewayLoadBalancerEndpointId",
                network_interface_id="networkInterfaceId",
                network_load_balancer_arn="networkLoadBalancerArn",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bd8b70d6f10941440da8e9816f2fb1e1aaa2d1fcf2b2c97eb14a680c2a120189)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument gateway_load_balancer_endpoint_id", value=gateway_load_balancer_endpoint_id, expected_type=type_hints["gateway_load_balancer_endpoint_id"])
            check_type(argname="argument network_interface_id", value=network_interface_id, expected_type=type_hints["network_interface_id"])
            check_type(argname="argument network_load_balancer_arn", value=network_load_balancer_arn, expected_type=type_hints["network_load_balancer_arn"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if description is not None:
            self._values["description"] = description
        if gateway_load_balancer_endpoint_id is not None:
            self._values["gateway_load_balancer_endpoint_id"] = gateway_load_balancer_endpoint_id
        if network_interface_id is not None:
            self._values["network_interface_id"] = network_interface_id
        if network_load_balancer_arn is not None:
            self._values["network_load_balancer_arn"] = network_load_balancer_arn
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''The description of the Traffic Mirror target.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html#cfn-ec2-trafficmirrortarget-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def gateway_load_balancer_endpoint_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the Gateway Load Balancer endpoint.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html#cfn-ec2-trafficmirrortarget-gatewayloadbalancerendpointid
        '''
        result = self._values.get("gateway_load_balancer_endpoint_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def network_interface_id(self) -> typing.Optional[builtins.str]:
        '''The network interface ID that is associated with the target.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html#cfn-ec2-trafficmirrortarget-networkinterfaceid
        '''
        result = self._values.get("network_interface_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def network_load_balancer_arn(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the Network Load Balancer that is associated with the target.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html#cfn-ec2-trafficmirrortarget-networkloadbalancerarn
        '''
        result = self._values.get("network_load_balancer_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags to assign to the Traffic Mirror target.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html#cfn-ec2-trafficmirrortarget-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnTrafficMirrorTargetMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnTrafficMirrorTargetPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTrafficMirrorTargetPropsMixin",
):
    '''Specifies a target for your Traffic Mirror session.

    A Traffic Mirror target is the destination for mirrored traffic. The Traffic Mirror source and the Traffic Mirror target (monitoring appliances) can be in the same VPC, or in different VPCs connected via VPC peering or a transit gateway.

    A Traffic Mirror target can be a network interface, a Network Load Balancer, or a Gateway Load Balancer endpoint.

    To use the target in a Traffic Mirror session, use `AWS::EC2::TrafficMirrorSession <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html>`_ .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html
    :cloudformationResource: AWS::EC2::TrafficMirrorTarget
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_traffic_mirror_target_props_mixin = ec2_mixins.CfnTrafficMirrorTargetPropsMixin(ec2_mixins.CfnTrafficMirrorTargetMixinProps(
            description="description",
            gateway_load_balancer_endpoint_id="gatewayLoadBalancerEndpointId",
            network_interface_id="networkInterfaceId",
            network_load_balancer_arn="networkLoadBalancerArn",
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnTrafficMirrorTargetMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::TrafficMirrorTarget``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__84f4d3c6913140ac4781fd420af9ea1879c04995def0a3f0155b2bf35347df35)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5c2c9cb7dd214acd9777b62a42e0816acbbcd85c1d06486ff681e0925dd7a344)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5e978cb9223bf8caebd43f1c526856bebf51262ecd86b3418c920552df02b462)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnTrafficMirrorTargetMixinProps":
        return typing.cast("CfnTrafficMirrorTargetMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTransitGatewayAttachmentMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "options": "options",
        "subnet_ids": "subnetIds",
        "tags": "tags",
        "transit_gateway_id": "transitGatewayId",
        "vpc_id": "vpcId",
    },
)
class CfnTransitGatewayAttachmentMixinProps:
    def __init__(
        self,
        *,
        options: typing.Any = None,
        subnet_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        transit_gateway_id: typing.Optional[builtins.str] = None,
        vpc_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnTransitGatewayAttachmentPropsMixin.

        :param options: The VPC attachment options.
        :param subnet_ids: The IDs of one or more subnets. You can specify only one subnet per Availability Zone. You must specify at least one subnet, but we recommend that you specify two subnets for better availability. The transit gateway uses one IP address from each specified subnet.
        :param tags: The tags for the attachment.
        :param transit_gateway_id: The ID of the transit gateway.
        :param vpc_id: The ID of the VPC.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            # options: Any
            
            cfn_transit_gateway_attachment_mixin_props = ec2_mixins.CfnTransitGatewayAttachmentMixinProps(
                options=options,
                subnet_ids=["subnetIds"],
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                transit_gateway_id="transitGatewayId",
                vpc_id="vpcId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__66b1674979a5d87427e5ab508a97598886cd5ed3521192281fc173069d361e41)
            check_type(argname="argument options", value=options, expected_type=type_hints["options"])
            check_type(argname="argument subnet_ids", value=subnet_ids, expected_type=type_hints["subnet_ids"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument transit_gateway_id", value=transit_gateway_id, expected_type=type_hints["transit_gateway_id"])
            check_type(argname="argument vpc_id", value=vpc_id, expected_type=type_hints["vpc_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if options is not None:
            self._values["options"] = options
        if subnet_ids is not None:
            self._values["subnet_ids"] = subnet_ids
        if tags is not None:
            self._values["tags"] = tags
        if transit_gateway_id is not None:
            self._values["transit_gateway_id"] = transit_gateway_id
        if vpc_id is not None:
            self._values["vpc_id"] = vpc_id

    @builtins.property
    def options(self) -> typing.Any:
        '''The VPC attachment options.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html#cfn-ec2-transitgatewayattachment-options
        '''
        result = self._values.get("options")
        return typing.cast(typing.Any, result)

    @builtins.property
    def subnet_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The IDs of one or more subnets.

        You can specify only one subnet per Availability Zone. You must specify at least one subnet, but we recommend that you specify two subnets for better availability. The transit gateway uses one IP address from each specified subnet.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html#cfn-ec2-transitgatewayattachment-subnetids
        '''
        result = self._values.get("subnet_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags for the attachment.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html#cfn-ec2-transitgatewayattachment-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def transit_gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the transit gateway.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html#cfn-ec2-transitgatewayattachment-transitgatewayid
        '''
        result = self._values.get("transit_gateway_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpc_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the VPC.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html#cfn-ec2-transitgatewayattachment-vpcid
        '''
        result = self._values.get("vpc_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnTransitGatewayAttachmentMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnTransitGatewayAttachmentPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTransitGatewayAttachmentPropsMixin",
):
    '''Attaches a VPC to a transit gateway.

    If you attach a VPC with a CIDR range that overlaps the CIDR range of a VPC that is already attached, the new VPC CIDR range is not propagated to the default propagation route table.

    To send VPC traffic to an attached transit gateway, add a route to the VPC route table using `AWS::EC2::Route <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html>`_ .

    To update tags for a VPC attachment after creation without replacing the attachment, use `AWS::EC2::TransitGatewayVpcAttachment <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html>`_ instead.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html
    :cloudformationResource: AWS::EC2::TransitGatewayAttachment
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        # options: Any
        
        cfn_transit_gateway_attachment_props_mixin = ec2_mixins.CfnTransitGatewayAttachmentPropsMixin(ec2_mixins.CfnTransitGatewayAttachmentMixinProps(
            options=options,
            subnet_ids=["subnetIds"],
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            transit_gateway_id="transitGatewayId",
            vpc_id="vpcId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnTransitGatewayAttachmentMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::TransitGatewayAttachment``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__feb3392659ab813f1c84b53ef60d90b1d2fad0238792e934344cffcbb6c3f943)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7f9f4bf9b8235b64c7358b24ad286d90632cb7f23a2d625f9c5d36d1ed81f068)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__531d75a42bed048789a602eaf4dc2a1ef43e59a599915933597da6d31b7e8ddd)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnTransitGatewayAttachmentMixinProps":
        return typing.cast("CfnTransitGatewayAttachmentMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTransitGatewayAttachmentPropsMixin.OptionsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "appliance_mode_support": "applianceModeSupport",
            "dns_support": "dnsSupport",
            "ipv6_support": "ipv6Support",
            "security_group_referencing_support": "securityGroupReferencingSupport",
        },
    )
    class OptionsProperty:
        def __init__(
            self,
            *,
            appliance_mode_support: typing.Optional[builtins.str] = None,
            dns_support: typing.Optional[builtins.str] = None,
            ipv6_support: typing.Optional[builtins.str] = None,
            security_group_referencing_support: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes the VPC attachment options.

            :param appliance_mode_support: Enable or disable appliance mode support. The default is ``disable`` .
            :param dns_support: Enable or disable DNS support. The default is ``disable`` .
            :param ipv6_support: Enable or disable IPv6 support. The default is ``disable`` .
            :param security_group_referencing_support: Enables you to reference a security group across VPCs attached to a transit gateway (TGW). Use this option to simplify security group management and control of instance-to-instance traffic across VPCs that are connected by transit gateway. You can also use this option to migrate from VPC peering (which was the only option that supported security group referencing) to transit gateways (which now also support security group referencing). This option is disabled by default and there are no additional costs to use this feature. For important information about this feature, see `Create a transit gateway <https://docs.aws.amazon.com/vpc/latest/tgw/tgw-transit-gateways.html#create-tgw>`_ in the *AWS Transit Gateway Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayattachment-options.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                options_property = ec2_mixins.CfnTransitGatewayAttachmentPropsMixin.OptionsProperty(
                    appliance_mode_support="applianceModeSupport",
                    dns_support="dnsSupport",
                    ipv6_support="ipv6Support",
                    security_group_referencing_support="securityGroupReferencingSupport"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__c7676a9419e73b003af1c40e50eb49773519c9b614906d0b3d4c5c4aa2ff0182)
                check_type(argname="argument appliance_mode_support", value=appliance_mode_support, expected_type=type_hints["appliance_mode_support"])
                check_type(argname="argument dns_support", value=dns_support, expected_type=type_hints["dns_support"])
                check_type(argname="argument ipv6_support", value=ipv6_support, expected_type=type_hints["ipv6_support"])
                check_type(argname="argument security_group_referencing_support", value=security_group_referencing_support, expected_type=type_hints["security_group_referencing_support"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if appliance_mode_support is not None:
                self._values["appliance_mode_support"] = appliance_mode_support
            if dns_support is not None:
                self._values["dns_support"] = dns_support
            if ipv6_support is not None:
                self._values["ipv6_support"] = ipv6_support
            if security_group_referencing_support is not None:
                self._values["security_group_referencing_support"] = security_group_referencing_support

        @builtins.property
        def appliance_mode_support(self) -> typing.Optional[builtins.str]:
            '''Enable or disable appliance mode support.

            The default is ``disable`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayattachment-options.html#cfn-ec2-transitgatewayattachment-options-appliancemodesupport
            '''
            result = self._values.get("appliance_mode_support")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def dns_support(self) -> typing.Optional[builtins.str]:
            '''Enable or disable DNS support.

            The default is ``disable`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayattachment-options.html#cfn-ec2-transitgatewayattachment-options-dnssupport
            '''
            result = self._values.get("dns_support")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def ipv6_support(self) -> typing.Optional[builtins.str]:
            '''Enable or disable IPv6 support.

            The default is ``disable`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayattachment-options.html#cfn-ec2-transitgatewayattachment-options-ipv6support
            '''
            result = self._values.get("ipv6_support")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def security_group_referencing_support(self) -> typing.Optional[builtins.str]:
            '''Enables you to reference a security group across VPCs attached to a transit gateway (TGW).

            Use this option to simplify security group management and control of instance-to-instance traffic across VPCs that are connected by transit gateway. You can also use this option to migrate from VPC peering (which was the only option that supported security group referencing) to transit gateways (which now also support security group referencing). This option is disabled by default and there are no additional costs to use this feature.

            For important information about this feature, see `Create a transit gateway <https://docs.aws.amazon.com/vpc/latest/tgw/tgw-transit-gateways.html#create-tgw>`_ in the *AWS Transit Gateway Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayattachment-options.html#cfn-ec2-transitgatewayattachment-options-securitygroupreferencingsupport
            '''
            result = self._values.get("security_group_referencing_support")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "OptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTransitGatewayConnectMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "options": "options",
        "tags": "tags",
        "transport_transit_gateway_attachment_id": "transportTransitGatewayAttachmentId",
    },
)
class CfnTransitGatewayConnectMixinProps:
    def __init__(
        self,
        *,
        options: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTransitGatewayConnectPropsMixin.TransitGatewayConnectOptionsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        transport_transit_gateway_attachment_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnTransitGatewayConnectPropsMixin.

        :param options: The Connect attachment options. - protocol (gre)
        :param tags: The tags for the attachment.
        :param transport_transit_gateway_attachment_id: The ID of the attachment from which the Connect attachment was created.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayconnect.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_transit_gateway_connect_mixin_props = ec2_mixins.CfnTransitGatewayConnectMixinProps(
                options=ec2_mixins.CfnTransitGatewayConnectPropsMixin.TransitGatewayConnectOptionsProperty(
                    protocol="protocol"
                ),
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                transport_transit_gateway_attachment_id="transportTransitGatewayAttachmentId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a421f1f5a7d087a17f854e565d94071332727d4d626f076ad964e99bb88d3f1f)
            check_type(argname="argument options", value=options, expected_type=type_hints["options"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument transport_transit_gateway_attachment_id", value=transport_transit_gateway_attachment_id, expected_type=type_hints["transport_transit_gateway_attachment_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if options is not None:
            self._values["options"] = options
        if tags is not None:
            self._values["tags"] = tags
        if transport_transit_gateway_attachment_id is not None:
            self._values["transport_transit_gateway_attachment_id"] = transport_transit_gateway_attachment_id

    @builtins.property
    def options(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTransitGatewayConnectPropsMixin.TransitGatewayConnectOptionsProperty"]]:
        '''The Connect attachment options.

        - protocol (gre)

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayconnect.html#cfn-ec2-transitgatewayconnect-options
        '''
        result = self._values.get("options")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTransitGatewayConnectPropsMixin.TransitGatewayConnectOptionsProperty"]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags for the attachment.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayconnect.html#cfn-ec2-transitgatewayconnect-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def transport_transit_gateway_attachment_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the attachment from which the Connect attachment was created.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayconnect.html#cfn-ec2-transitgatewayconnect-transporttransitgatewayattachmentid
        '''
        result = self._values.get("transport_transit_gateway_attachment_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnTransitGatewayConnectMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTransitGatewayConnectPeerMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "connect_peer_configuration": "connectPeerConfiguration",
        "tags": "tags",
        "transit_gateway_attachment_id": "transitGatewayAttachmentId",
    },
)
class CfnTransitGatewayConnectPeerMixinProps:
    def __init__(
        self,
        *,
        connect_peer_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTransitGatewayConnectPeerPropsMixin.TransitGatewayConnectPeerConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        transit_gateway_attachment_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnTransitGatewayConnectPeerPropsMixin.

        :param connect_peer_configuration: The Connect peer details.
        :param tags: The tags for the Connect peer.
        :param transit_gateway_attachment_id: The ID of the Connect attachment.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayconnectpeer.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_transit_gateway_connect_peer_mixin_props = ec2_mixins.CfnTransitGatewayConnectPeerMixinProps(
                connect_peer_configuration=ec2_mixins.CfnTransitGatewayConnectPeerPropsMixin.TransitGatewayConnectPeerConfigurationProperty(
                    bgp_configurations=[ec2_mixins.CfnTransitGatewayConnectPeerPropsMixin.TransitGatewayAttachmentBgpConfigurationProperty(
                        bgp_status="bgpStatus",
                        peer_address="peerAddress",
                        peer_asn=123,
                        transit_gateway_address="transitGatewayAddress",
                        transit_gateway_asn=123
                    )],
                    inside_cidr_blocks=["insideCidrBlocks"],
                    peer_address="peerAddress",
                    protocol="protocol",
                    transit_gateway_address="transitGatewayAddress"
                ),
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                transit_gateway_attachment_id="transitGatewayAttachmentId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5572c10bd69825252985ec68d17f1639d84347d3747593b596d258c37379054c)
            check_type(argname="argument connect_peer_configuration", value=connect_peer_configuration, expected_type=type_hints["connect_peer_configuration"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument transit_gateway_attachment_id", value=transit_gateway_attachment_id, expected_type=type_hints["transit_gateway_attachment_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if connect_peer_configuration is not None:
            self._values["connect_peer_configuration"] = connect_peer_configuration
        if tags is not None:
            self._values["tags"] = tags
        if transit_gateway_attachment_id is not None:
            self._values["transit_gateway_attachment_id"] = transit_gateway_attachment_id

    @builtins.property
    def connect_peer_configuration(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTransitGatewayConnectPeerPropsMixin.TransitGatewayConnectPeerConfigurationProperty"]]:
        '''The Connect peer details.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayconnectpeer.html#cfn-ec2-transitgatewayconnectpeer-connectpeerconfiguration
        '''
        result = self._values.get("connect_peer_configuration")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTransitGatewayConnectPeerPropsMixin.TransitGatewayConnectPeerConfigurationProperty"]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags for the Connect peer.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayconnectpeer.html#cfn-ec2-transitgatewayconnectpeer-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def transit_gateway_attachment_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the Connect attachment.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayconnectpeer.html#cfn-ec2-transitgatewayconnectpeer-transitgatewayattachmentid
        '''
        result = self._values.get("transit_gateway_attachment_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnTransitGatewayConnectPeerMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnTransitGatewayConnectPeerPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTransitGatewayConnectPeerPropsMixin",
):
    '''Describes a transit gateway Connect peer.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayconnectpeer.html
    :cloudformationResource: AWS::EC2::TransitGatewayConnectPeer
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_transit_gateway_connect_peer_props_mixin = ec2_mixins.CfnTransitGatewayConnectPeerPropsMixin(ec2_mixins.CfnTransitGatewayConnectPeerMixinProps(
            connect_peer_configuration=ec2_mixins.CfnTransitGatewayConnectPeerPropsMixin.TransitGatewayConnectPeerConfigurationProperty(
                bgp_configurations=[ec2_mixins.CfnTransitGatewayConnectPeerPropsMixin.TransitGatewayAttachmentBgpConfigurationProperty(
                    bgp_status="bgpStatus",
                    peer_address="peerAddress",
                    peer_asn=123,
                    transit_gateway_address="transitGatewayAddress",
                    transit_gateway_asn=123
                )],
                inside_cidr_blocks=["insideCidrBlocks"],
                peer_address="peerAddress",
                protocol="protocol",
                transit_gateway_address="transitGatewayAddress"
            ),
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            transit_gateway_attachment_id="transitGatewayAttachmentId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnTransitGatewayConnectPeerMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::TransitGatewayConnectPeer``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c796b3f9c936b625b1f3463d365920c8f89319c4e84b4237703aa71d3f543183)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fc0d7196c0f811ec671ff9c052b55b322bd54fd2bd43c3c40252f41ca509dcf9)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c9cee46f7f4119c441f48169a2a4f5b9125976fab2f9c39f5ed2b0a6c68dca4a)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnTransitGatewayConnectPeerMixinProps":
        return typing.cast("CfnTransitGatewayConnectPeerMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTransitGatewayConnectPeerPropsMixin.TransitGatewayAttachmentBgpConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "bgp_status": "bgpStatus",
            "peer_address": "peerAddress",
            "peer_asn": "peerAsn",
            "transit_gateway_address": "transitGatewayAddress",
            "transit_gateway_asn": "transitGatewayAsn",
        },
    )
    class TransitGatewayAttachmentBgpConfigurationProperty:
        def __init__(
            self,
            *,
            bgp_status: typing.Optional[builtins.str] = None,
            peer_address: typing.Optional[builtins.str] = None,
            peer_asn: typing.Optional[jsii.Number] = None,
            transit_gateway_address: typing.Optional[builtins.str] = None,
            transit_gateway_asn: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The BGP configuration information.

            :param bgp_status: The BGP status.
            :param peer_address: The interior BGP peer IP address for the appliance.
            :param peer_asn: The peer Autonomous System Number (ASN).
            :param transit_gateway_address: The interior BGP peer IP address for the transit gateway.
            :param transit_gateway_asn: The transit gateway Autonomous System Number (ASN).

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayconnectpeer-transitgatewayattachmentbgpconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                transit_gateway_attachment_bgp_configuration_property = ec2_mixins.CfnTransitGatewayConnectPeerPropsMixin.TransitGatewayAttachmentBgpConfigurationProperty(
                    bgp_status="bgpStatus",
                    peer_address="peerAddress",
                    peer_asn=123,
                    transit_gateway_address="transitGatewayAddress",
                    transit_gateway_asn=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__35d4a18eb834ecda51f1114fb8390e50bfdb3bd509007469d70a611676250907)
                check_type(argname="argument bgp_status", value=bgp_status, expected_type=type_hints["bgp_status"])
                check_type(argname="argument peer_address", value=peer_address, expected_type=type_hints["peer_address"])
                check_type(argname="argument peer_asn", value=peer_asn, expected_type=type_hints["peer_asn"])
                check_type(argname="argument transit_gateway_address", value=transit_gateway_address, expected_type=type_hints["transit_gateway_address"])
                check_type(argname="argument transit_gateway_asn", value=transit_gateway_asn, expected_type=type_hints["transit_gateway_asn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if bgp_status is not None:
                self._values["bgp_status"] = bgp_status
            if peer_address is not None:
                self._values["peer_address"] = peer_address
            if peer_asn is not None:
                self._values["peer_asn"] = peer_asn
            if transit_gateway_address is not None:
                self._values["transit_gateway_address"] = transit_gateway_address
            if transit_gateway_asn is not None:
                self._values["transit_gateway_asn"] = transit_gateway_asn

        @builtins.property
        def bgp_status(self) -> typing.Optional[builtins.str]:
            '''The BGP status.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayconnectpeer-transitgatewayattachmentbgpconfiguration.html#cfn-ec2-transitgatewayconnectpeer-transitgatewayattachmentbgpconfiguration-bgpstatus
            '''
            result = self._values.get("bgp_status")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def peer_address(self) -> typing.Optional[builtins.str]:
            '''The interior BGP peer IP address for the appliance.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayconnectpeer-transitgatewayattachmentbgpconfiguration.html#cfn-ec2-transitgatewayconnectpeer-transitgatewayattachmentbgpconfiguration-peeraddress
            '''
            result = self._values.get("peer_address")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def peer_asn(self) -> typing.Optional[jsii.Number]:
            '''The peer Autonomous System Number (ASN).

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayconnectpeer-transitgatewayattachmentbgpconfiguration.html#cfn-ec2-transitgatewayconnectpeer-transitgatewayattachmentbgpconfiguration-peerasn
            '''
            result = self._values.get("peer_asn")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def transit_gateway_address(self) -> typing.Optional[builtins.str]:
            '''The interior BGP peer IP address for the transit gateway.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayconnectpeer-transitgatewayattachmentbgpconfiguration.html#cfn-ec2-transitgatewayconnectpeer-transitgatewayattachmentbgpconfiguration-transitgatewayaddress
            '''
            result = self._values.get("transit_gateway_address")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def transit_gateway_asn(self) -> typing.Optional[jsii.Number]:
            '''The transit gateway Autonomous System Number (ASN).

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayconnectpeer-transitgatewayattachmentbgpconfiguration.html#cfn-ec2-transitgatewayconnectpeer-transitgatewayattachmentbgpconfiguration-transitgatewayasn
            '''
            result = self._values.get("transit_gateway_asn")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TransitGatewayAttachmentBgpConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTransitGatewayConnectPeerPropsMixin.TransitGatewayConnectPeerConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "bgp_configurations": "bgpConfigurations",
            "inside_cidr_blocks": "insideCidrBlocks",
            "peer_address": "peerAddress",
            "protocol": "protocol",
            "transit_gateway_address": "transitGatewayAddress",
        },
    )
    class TransitGatewayConnectPeerConfigurationProperty:
        def __init__(
            self,
            *,
            bgp_configurations: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTransitGatewayConnectPeerPropsMixin.TransitGatewayAttachmentBgpConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            inside_cidr_blocks: typing.Optional[typing.Sequence[builtins.str]] = None,
            peer_address: typing.Optional[builtins.str] = None,
            protocol: typing.Optional[builtins.str] = None,
            transit_gateway_address: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes the Connect peer details.

            :param bgp_configurations: The BGP configuration details.
            :param inside_cidr_blocks: The range of interior BGP peer IP addresses.
            :param peer_address: The Connect peer IP address on the appliance side of the tunnel.
            :param protocol: The tunnel protocol.
            :param transit_gateway_address: The Connect peer IP address on the transit gateway side of the tunnel.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayconnectpeer-transitgatewayconnectpeerconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                transit_gateway_connect_peer_configuration_property = ec2_mixins.CfnTransitGatewayConnectPeerPropsMixin.TransitGatewayConnectPeerConfigurationProperty(
                    bgp_configurations=[ec2_mixins.CfnTransitGatewayConnectPeerPropsMixin.TransitGatewayAttachmentBgpConfigurationProperty(
                        bgp_status="bgpStatus",
                        peer_address="peerAddress",
                        peer_asn=123,
                        transit_gateway_address="transitGatewayAddress",
                        transit_gateway_asn=123
                    )],
                    inside_cidr_blocks=["insideCidrBlocks"],
                    peer_address="peerAddress",
                    protocol="protocol",
                    transit_gateway_address="transitGatewayAddress"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__259b5818f377e940acedf1832400b8afa7b53a4ecd9571c2ff53374b05f9f442)
                check_type(argname="argument bgp_configurations", value=bgp_configurations, expected_type=type_hints["bgp_configurations"])
                check_type(argname="argument inside_cidr_blocks", value=inside_cidr_blocks, expected_type=type_hints["inside_cidr_blocks"])
                check_type(argname="argument peer_address", value=peer_address, expected_type=type_hints["peer_address"])
                check_type(argname="argument protocol", value=protocol, expected_type=type_hints["protocol"])
                check_type(argname="argument transit_gateway_address", value=transit_gateway_address, expected_type=type_hints["transit_gateway_address"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if bgp_configurations is not None:
                self._values["bgp_configurations"] = bgp_configurations
            if inside_cidr_blocks is not None:
                self._values["inside_cidr_blocks"] = inside_cidr_blocks
            if peer_address is not None:
                self._values["peer_address"] = peer_address
            if protocol is not None:
                self._values["protocol"] = protocol
            if transit_gateway_address is not None:
                self._values["transit_gateway_address"] = transit_gateway_address

        @builtins.property
        def bgp_configurations(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTransitGatewayConnectPeerPropsMixin.TransitGatewayAttachmentBgpConfigurationProperty"]]]]:
            '''The BGP configuration details.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayconnectpeer-transitgatewayconnectpeerconfiguration.html#cfn-ec2-transitgatewayconnectpeer-transitgatewayconnectpeerconfiguration-bgpconfigurations
            '''
            result = self._values.get("bgp_configurations")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTransitGatewayConnectPeerPropsMixin.TransitGatewayAttachmentBgpConfigurationProperty"]]]], result)

        @builtins.property
        def inside_cidr_blocks(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The range of interior BGP peer IP addresses.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayconnectpeer-transitgatewayconnectpeerconfiguration.html#cfn-ec2-transitgatewayconnectpeer-transitgatewayconnectpeerconfiguration-insidecidrblocks
            '''
            result = self._values.get("inside_cidr_blocks")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def peer_address(self) -> typing.Optional[builtins.str]:
            '''The Connect peer IP address on the appliance side of the tunnel.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayconnectpeer-transitgatewayconnectpeerconfiguration.html#cfn-ec2-transitgatewayconnectpeer-transitgatewayconnectpeerconfiguration-peeraddress
            '''
            result = self._values.get("peer_address")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def protocol(self) -> typing.Optional[builtins.str]:
            '''The tunnel protocol.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayconnectpeer-transitgatewayconnectpeerconfiguration.html#cfn-ec2-transitgatewayconnectpeer-transitgatewayconnectpeerconfiguration-protocol
            '''
            result = self._values.get("protocol")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def transit_gateway_address(self) -> typing.Optional[builtins.str]:
            '''The Connect peer IP address on the transit gateway side of the tunnel.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayconnectpeer-transitgatewayconnectpeerconfiguration.html#cfn-ec2-transitgatewayconnectpeer-transitgatewayconnectpeerconfiguration-transitgatewayaddress
            '''
            result = self._values.get("transit_gateway_address")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TransitGatewayConnectPeerConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.implements(_IMixin_11e4b965)
class CfnTransitGatewayConnectPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTransitGatewayConnectPropsMixin",
):
    '''Creates a Connect attachment from a specified transit gateway attachment.

    A Connect attachment is a GRE-based tunnel attachment that you can use to establish a connection between a transit gateway and an appliance.

    A Connect attachment uses an existing VPC or AWS Direct Connect attachment as the underlying transport mechanism.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayconnect.html
    :cloudformationResource: AWS::EC2::TransitGatewayConnect
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_transit_gateway_connect_props_mixin = ec2_mixins.CfnTransitGatewayConnectPropsMixin(ec2_mixins.CfnTransitGatewayConnectMixinProps(
            options=ec2_mixins.CfnTransitGatewayConnectPropsMixin.TransitGatewayConnectOptionsProperty(
                protocol="protocol"
            ),
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            transport_transit_gateway_attachment_id="transportTransitGatewayAttachmentId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnTransitGatewayConnectMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::TransitGatewayConnect``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__436486e704255d0ddaf235b28986a31522aefaaffcbd8f737d91e178a9e7e188)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__254b168971e4e9d8108333fd2081a2cbcf741d31a99fbd5fbe0babf7a7dfc529)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__aefa54b0f198dfd336f7e10374732f1846fe63783757a683cb2a593a45fc83a2)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnTransitGatewayConnectMixinProps":
        return typing.cast("CfnTransitGatewayConnectMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTransitGatewayConnectPropsMixin.TransitGatewayConnectOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={"protocol": "protocol"},
    )
    class TransitGatewayConnectOptionsProperty:
        def __init__(self, *, protocol: typing.Optional[builtins.str] = None) -> None:
            '''Describes the Connect attachment options.

            :param protocol: The tunnel protocol.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayconnect-transitgatewayconnectoptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                transit_gateway_connect_options_property = ec2_mixins.CfnTransitGatewayConnectPropsMixin.TransitGatewayConnectOptionsProperty(
                    protocol="protocol"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__062a1ebfe6d2917213f502964e2c725c0a6a7a5b885a4f4444c3d669aab27948)
                check_type(argname="argument protocol", value=protocol, expected_type=type_hints["protocol"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if protocol is not None:
                self._values["protocol"] = protocol

        @builtins.property
        def protocol(self) -> typing.Optional[builtins.str]:
            '''The tunnel protocol.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayconnect-transitgatewayconnectoptions.html#cfn-ec2-transitgatewayconnect-transitgatewayconnectoptions-protocol
            '''
            result = self._values.get("protocol")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TransitGatewayConnectOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTransitGatewayMeteringPolicyEntryMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "destination_cidr_block": "destinationCidrBlock",
        "destination_port_range": "destinationPortRange",
        "destination_transit_gateway_attachment_id": "destinationTransitGatewayAttachmentId",
        "destination_transit_gateway_attachment_type": "destinationTransitGatewayAttachmentType",
        "metered_account": "meteredAccount",
        "policy_rule_number": "policyRuleNumber",
        "protocol": "protocol",
        "source_cidr_block": "sourceCidrBlock",
        "source_port_range": "sourcePortRange",
        "source_transit_gateway_attachment_id": "sourceTransitGatewayAttachmentId",
        "source_transit_gateway_attachment_type": "sourceTransitGatewayAttachmentType",
        "transit_gateway_metering_policy_id": "transitGatewayMeteringPolicyId",
    },
)
class CfnTransitGatewayMeteringPolicyEntryMixinProps:
    def __init__(
        self,
        *,
        destination_cidr_block: typing.Optional[builtins.str] = None,
        destination_port_range: typing.Optional[builtins.str] = None,
        destination_transit_gateway_attachment_id: typing.Optional[builtins.str] = None,
        destination_transit_gateway_attachment_type: typing.Optional[builtins.str] = None,
        metered_account: typing.Optional[builtins.str] = None,
        policy_rule_number: typing.Optional[jsii.Number] = None,
        protocol: typing.Optional[builtins.str] = None,
        source_cidr_block: typing.Optional[builtins.str] = None,
        source_port_range: typing.Optional[builtins.str] = None,
        source_transit_gateway_attachment_id: typing.Optional[builtins.str] = None,
        source_transit_gateway_attachment_type: typing.Optional[builtins.str] = None,
        transit_gateway_metering_policy_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnTransitGatewayMeteringPolicyEntryPropsMixin.

        :param destination_cidr_block: Describes an IPv4 CIDR block.
        :param destination_port_range: Describes a range of ports.
        :param destination_transit_gateway_attachment_id: The ID of the source attachment through which traffic leaves a transit gateway.
        :param destination_transit_gateway_attachment_type: 
        :param metered_account: The AWS account ID to which the metered traffic is attributed.
        :param policy_rule_number: The rule number of the metering policy entry.
        :param protocol: The protocol of the traffic.
        :param source_cidr_block: Describes an IPv4 CIDR block.
        :param source_port_range: Describes a range of ports.
        :param source_transit_gateway_attachment_id: The ID of the source attachment through which traffic enters a transit gateway.
        :param source_transit_gateway_attachment_type: 
        :param transit_gateway_metering_policy_id: The ID of the transit gateway metering policy for which the entry is being created.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymeteringpolicyentry.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_transit_gateway_metering_policy_entry_mixin_props = ec2_mixins.CfnTransitGatewayMeteringPolicyEntryMixinProps(
                destination_cidr_block="destinationCidrBlock",
                destination_port_range="destinationPortRange",
                destination_transit_gateway_attachment_id="destinationTransitGatewayAttachmentId",
                destination_transit_gateway_attachment_type="destinationTransitGatewayAttachmentType",
                metered_account="meteredAccount",
                policy_rule_number=123,
                protocol="protocol",
                source_cidr_block="sourceCidrBlock",
                source_port_range="sourcePortRange",
                source_transit_gateway_attachment_id="sourceTransitGatewayAttachmentId",
                source_transit_gateway_attachment_type="sourceTransitGatewayAttachmentType",
                transit_gateway_metering_policy_id="transitGatewayMeteringPolicyId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dfec8e5a3a3fd9308edfbcdce4d6b6b3f6b096c55a368fe924ac09ceb49dee02)
            check_type(argname="argument destination_cidr_block", value=destination_cidr_block, expected_type=type_hints["destination_cidr_block"])
            check_type(argname="argument destination_port_range", value=destination_port_range, expected_type=type_hints["destination_port_range"])
            check_type(argname="argument destination_transit_gateway_attachment_id", value=destination_transit_gateway_attachment_id, expected_type=type_hints["destination_transit_gateway_attachment_id"])
            check_type(argname="argument destination_transit_gateway_attachment_type", value=destination_transit_gateway_attachment_type, expected_type=type_hints["destination_transit_gateway_attachment_type"])
            check_type(argname="argument metered_account", value=metered_account, expected_type=type_hints["metered_account"])
            check_type(argname="argument policy_rule_number", value=policy_rule_number, expected_type=type_hints["policy_rule_number"])
            check_type(argname="argument protocol", value=protocol, expected_type=type_hints["protocol"])
            check_type(argname="argument source_cidr_block", value=source_cidr_block, expected_type=type_hints["source_cidr_block"])
            check_type(argname="argument source_port_range", value=source_port_range, expected_type=type_hints["source_port_range"])
            check_type(argname="argument source_transit_gateway_attachment_id", value=source_transit_gateway_attachment_id, expected_type=type_hints["source_transit_gateway_attachment_id"])
            check_type(argname="argument source_transit_gateway_attachment_type", value=source_transit_gateway_attachment_type, expected_type=type_hints["source_transit_gateway_attachment_type"])
            check_type(argname="argument transit_gateway_metering_policy_id", value=transit_gateway_metering_policy_id, expected_type=type_hints["transit_gateway_metering_policy_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if destination_cidr_block is not None:
            self._values["destination_cidr_block"] = destination_cidr_block
        if destination_port_range is not None:
            self._values["destination_port_range"] = destination_port_range
        if destination_transit_gateway_attachment_id is not None:
            self._values["destination_transit_gateway_attachment_id"] = destination_transit_gateway_attachment_id
        if destination_transit_gateway_attachment_type is not None:
            self._values["destination_transit_gateway_attachment_type"] = destination_transit_gateway_attachment_type
        if metered_account is not None:
            self._values["metered_account"] = metered_account
        if policy_rule_number is not None:
            self._values["policy_rule_number"] = policy_rule_number
        if protocol is not None:
            self._values["protocol"] = protocol
        if source_cidr_block is not None:
            self._values["source_cidr_block"] = source_cidr_block
        if source_port_range is not None:
            self._values["source_port_range"] = source_port_range
        if source_transit_gateway_attachment_id is not None:
            self._values["source_transit_gateway_attachment_id"] = source_transit_gateway_attachment_id
        if source_transit_gateway_attachment_type is not None:
            self._values["source_transit_gateway_attachment_type"] = source_transit_gateway_attachment_type
        if transit_gateway_metering_policy_id is not None:
            self._values["transit_gateway_metering_policy_id"] = transit_gateway_metering_policy_id

    @builtins.property
    def destination_cidr_block(self) -> typing.Optional[builtins.str]:
        '''Describes an IPv4 CIDR block.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymeteringpolicyentry.html#cfn-ec2-transitgatewaymeteringpolicyentry-destinationcidrblock
        '''
        result = self._values.get("destination_cidr_block")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def destination_port_range(self) -> typing.Optional[builtins.str]:
        '''Describes a range of ports.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymeteringpolicyentry.html#cfn-ec2-transitgatewaymeteringpolicyentry-destinationportrange
        '''
        result = self._values.get("destination_port_range")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def destination_transit_gateway_attachment_id(
        self,
    ) -> typing.Optional[builtins.str]:
        '''The ID of the source attachment through which traffic leaves a transit gateway.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymeteringpolicyentry.html#cfn-ec2-transitgatewaymeteringpolicyentry-destinationtransitgatewayattachmentid
        '''
        result = self._values.get("destination_transit_gateway_attachment_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def destination_transit_gateway_attachment_type(
        self,
    ) -> typing.Optional[builtins.str]:
        '''
        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymeteringpolicyentry.html#cfn-ec2-transitgatewaymeteringpolicyentry-destinationtransitgatewayattachmenttype
        '''
        result = self._values.get("destination_transit_gateway_attachment_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def metered_account(self) -> typing.Optional[builtins.str]:
        '''The AWS account ID to which the metered traffic is attributed.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymeteringpolicyentry.html#cfn-ec2-transitgatewaymeteringpolicyentry-meteredaccount
        '''
        result = self._values.get("metered_account")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def policy_rule_number(self) -> typing.Optional[jsii.Number]:
        '''The rule number of the metering policy entry.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymeteringpolicyentry.html#cfn-ec2-transitgatewaymeteringpolicyentry-policyrulenumber
        '''
        result = self._values.get("policy_rule_number")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def protocol(self) -> typing.Optional[builtins.str]:
        '''The protocol of the traffic.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymeteringpolicyentry.html#cfn-ec2-transitgatewaymeteringpolicyentry-protocol
        '''
        result = self._values.get("protocol")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def source_cidr_block(self) -> typing.Optional[builtins.str]:
        '''Describes an IPv4 CIDR block.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymeteringpolicyentry.html#cfn-ec2-transitgatewaymeteringpolicyentry-sourcecidrblock
        '''
        result = self._values.get("source_cidr_block")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def source_port_range(self) -> typing.Optional[builtins.str]:
        '''Describes a range of ports.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymeteringpolicyentry.html#cfn-ec2-transitgatewaymeteringpolicyentry-sourceportrange
        '''
        result = self._values.get("source_port_range")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def source_transit_gateway_attachment_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the source attachment through which traffic enters a transit gateway.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymeteringpolicyentry.html#cfn-ec2-transitgatewaymeteringpolicyentry-sourcetransitgatewayattachmentid
        '''
        result = self._values.get("source_transit_gateway_attachment_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def source_transit_gateway_attachment_type(self) -> typing.Optional[builtins.str]:
        '''
        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymeteringpolicyentry.html#cfn-ec2-transitgatewaymeteringpolicyentry-sourcetransitgatewayattachmenttype
        '''
        result = self._values.get("source_transit_gateway_attachment_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def transit_gateway_metering_policy_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the transit gateway metering policy for which the entry is being created.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymeteringpolicyentry.html#cfn-ec2-transitgatewaymeteringpolicyentry-transitgatewaymeteringpolicyid
        '''
        result = self._values.get("transit_gateway_metering_policy_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnTransitGatewayMeteringPolicyEntryMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnTransitGatewayMeteringPolicyEntryPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTransitGatewayMeteringPolicyEntryPropsMixin",
):
    '''Creates an entry in a transit gateway metering policy to define traffic measurement rules.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymeteringpolicyentry.html
    :cloudformationResource: AWS::EC2::TransitGatewayMeteringPolicyEntry
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_transit_gateway_metering_policy_entry_props_mixin = ec2_mixins.CfnTransitGatewayMeteringPolicyEntryPropsMixin(ec2_mixins.CfnTransitGatewayMeteringPolicyEntryMixinProps(
            destination_cidr_block="destinationCidrBlock",
            destination_port_range="destinationPortRange",
            destination_transit_gateway_attachment_id="destinationTransitGatewayAttachmentId",
            destination_transit_gateway_attachment_type="destinationTransitGatewayAttachmentType",
            metered_account="meteredAccount",
            policy_rule_number=123,
            protocol="protocol",
            source_cidr_block="sourceCidrBlock",
            source_port_range="sourcePortRange",
            source_transit_gateway_attachment_id="sourceTransitGatewayAttachmentId",
            source_transit_gateway_attachment_type="sourceTransitGatewayAttachmentType",
            transit_gateway_metering_policy_id="transitGatewayMeteringPolicyId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnTransitGatewayMeteringPolicyEntryMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::TransitGatewayMeteringPolicyEntry``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1c5486d68a10b7bdf3feb329c2977068a535c3efe0a59e2f6eaca28d32edce01)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__faf39b958d056eeb58b1e73eea0857162b49ee5f3d93a040c17a6e1deba4c932)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__883c459e2c40b59ee2aceb34c9ec52c9532768d8ef5a4c3fcb229052834f01bc)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnTransitGatewayMeteringPolicyEntryMixinProps":
        return typing.cast("CfnTransitGatewayMeteringPolicyEntryMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTransitGatewayMeteringPolicyMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "middlebox_attachment_ids": "middleboxAttachmentIds",
        "tags": "tags",
        "transit_gateway_id": "transitGatewayId",
    },
)
class CfnTransitGatewayMeteringPolicyMixinProps:
    def __init__(
        self,
        *,
        middlebox_attachment_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        transit_gateway_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnTransitGatewayMeteringPolicyPropsMixin.

        :param middlebox_attachment_ids: The IDs of the middlebox attachments associated with the metering policy.
        :param tags: The tags assigned to the transit gateway metering policy.
        :param transit_gateway_id: The ID of the transit gateway associated with the metering policy.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymeteringpolicy.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_transit_gateway_metering_policy_mixin_props = ec2_mixins.CfnTransitGatewayMeteringPolicyMixinProps(
                middlebox_attachment_ids=["middleboxAttachmentIds"],
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                transit_gateway_id="transitGatewayId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5837c538c737659c1bc37f08df3cc2d5f46d4ab8f7cfe3aa0e33f2173bbdfcb8)
            check_type(argname="argument middlebox_attachment_ids", value=middlebox_attachment_ids, expected_type=type_hints["middlebox_attachment_ids"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument transit_gateway_id", value=transit_gateway_id, expected_type=type_hints["transit_gateway_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if middlebox_attachment_ids is not None:
            self._values["middlebox_attachment_ids"] = middlebox_attachment_ids
        if tags is not None:
            self._values["tags"] = tags
        if transit_gateway_id is not None:
            self._values["transit_gateway_id"] = transit_gateway_id

    @builtins.property
    def middlebox_attachment_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The IDs of the middlebox attachments associated with the metering policy.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymeteringpolicy.html#cfn-ec2-transitgatewaymeteringpolicy-middleboxattachmentids
        '''
        result = self._values.get("middlebox_attachment_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags assigned to the transit gateway metering policy.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymeteringpolicy.html#cfn-ec2-transitgatewaymeteringpolicy-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def transit_gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the transit gateway associated with the metering policy.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymeteringpolicy.html#cfn-ec2-transitgatewaymeteringpolicy-transitgatewayid
        '''
        result = self._values.get("transit_gateway_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnTransitGatewayMeteringPolicyMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnTransitGatewayMeteringPolicyPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTransitGatewayMeteringPolicyPropsMixin",
):
    '''Describes a transit gateway metering policy.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymeteringpolicy.html
    :cloudformationResource: AWS::EC2::TransitGatewayMeteringPolicy
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_transit_gateway_metering_policy_props_mixin = ec2_mixins.CfnTransitGatewayMeteringPolicyPropsMixin(ec2_mixins.CfnTransitGatewayMeteringPolicyMixinProps(
            middlebox_attachment_ids=["middleboxAttachmentIds"],
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            transit_gateway_id="transitGatewayId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnTransitGatewayMeteringPolicyMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::TransitGatewayMeteringPolicy``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bad7870e3fa7e0fea9b98497268f34f4497615553145c0bf871a27daa31a8cb5)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d8cece32e4f1e152330ef6ad200ec54ee4da4a4ae76876a7fe11efbcfdb4d3a0)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2acbf5cf3cc4069ecfdf89c6a2ddd171b42e45e470fb92a1f248e9ecb1c9cb25)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnTransitGatewayMeteringPolicyMixinProps":
        return typing.cast("CfnTransitGatewayMeteringPolicyMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTransitGatewayMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "amazon_side_asn": "amazonSideAsn",
        "association_default_route_table_id": "associationDefaultRouteTableId",
        "auto_accept_shared_attachments": "autoAcceptSharedAttachments",
        "default_route_table_association": "defaultRouteTableAssociation",
        "default_route_table_propagation": "defaultRouteTablePropagation",
        "description": "description",
        "dns_support": "dnsSupport",
        "encryption_support": "encryptionSupport",
        "multicast_support": "multicastSupport",
        "propagation_default_route_table_id": "propagationDefaultRouteTableId",
        "security_group_referencing_support": "securityGroupReferencingSupport",
        "tags": "tags",
        "transit_gateway_cidr_blocks": "transitGatewayCidrBlocks",
        "vpn_ecmp_support": "vpnEcmpSupport",
    },
)
class CfnTransitGatewayMixinProps:
    def __init__(
        self,
        *,
        amazon_side_asn: typing.Optional[jsii.Number] = None,
        association_default_route_table_id: typing.Optional[builtins.str] = None,
        auto_accept_shared_attachments: typing.Optional[builtins.str] = None,
        default_route_table_association: typing.Optional[builtins.str] = None,
        default_route_table_propagation: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        dns_support: typing.Optional[builtins.str] = None,
        encryption_support: typing.Optional[builtins.str] = None,
        multicast_support: typing.Optional[builtins.str] = None,
        propagation_default_route_table_id: typing.Optional[builtins.str] = None,
        security_group_referencing_support: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        transit_gateway_cidr_blocks: typing.Optional[typing.Sequence[builtins.str]] = None,
        vpn_ecmp_support: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnTransitGatewayPropsMixin.

        :param amazon_side_asn: A private Autonomous System Number (ASN) for the Amazon side of a BGP session. The range is 64512 to 65534 for 16-bit ASNs. The default is 64512.
        :param association_default_route_table_id: The ID of the default association route table.
        :param auto_accept_shared_attachments: Enable or disable automatic acceptance of attachment requests. Disabled by default.
        :param default_route_table_association: Enable or disable automatic association with the default association route table. Enabled by default. If ``DefaultRouteTableAssociation`` is set to enable, AWS Transit Gateway will create the default transit gateway route table.
        :param default_route_table_propagation: Enable or disable automatic propagation of routes to the default propagation route table. Enabled by default. If ``DefaultRouteTablePropagation`` is set to enable, AWS Transit Gateway will create the default transit gateway route table.
        :param description: The description of the transit gateway.
        :param dns_support: Enable or disable DNS support. Enabled by default.
        :param encryption_support: Enable or disable encryption support. Disabled by default.
        :param multicast_support: Indicates whether multicast is enabled on the transit gateway.
        :param propagation_default_route_table_id: The ID of the default propagation route table.
        :param security_group_referencing_support: Enables you to reference a security group across VPCs attached to a transit gateway (TGW). Use this option to simplify security group management and control of instance-to-instance traffic across VPCs that are connected by transit gateway. You can also use this option to migrate from VPC peering (which was the only option that supported security group referencing) to transit gateways (which now also support security group referencing). This option is disabled by default and there are no additional costs to use this feature. For important information about this feature, see `Create a transit gateway <https://docs.aws.amazon.com/vpc/latest/tgw/tgw-transit-gateways.html#create-tgw>`_ in the *AWS Transit Gateway Guide* .
        :param tags: The tags for the transit gateway.
        :param transit_gateway_cidr_blocks: The transit gateway CIDR blocks.
        :param vpn_ecmp_support: Enable or disable Equal Cost Multipath Protocol support. Enabled by default.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_transit_gateway_mixin_props = ec2_mixins.CfnTransitGatewayMixinProps(
                amazon_side_asn=123,
                association_default_route_table_id="associationDefaultRouteTableId",
                auto_accept_shared_attachments="autoAcceptSharedAttachments",
                default_route_table_association="defaultRouteTableAssociation",
                default_route_table_propagation="defaultRouteTablePropagation",
                description="description",
                dns_support="dnsSupport",
                encryption_support="encryptionSupport",
                multicast_support="multicastSupport",
                propagation_default_route_table_id="propagationDefaultRouteTableId",
                security_group_referencing_support="securityGroupReferencingSupport",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                transit_gateway_cidr_blocks=["transitGatewayCidrBlocks"],
                vpn_ecmp_support="vpnEcmpSupport"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d8faa244d705b8f04cbc8c43fd4190155541b670d1ef7cca2675c798d5465ddf)
            check_type(argname="argument amazon_side_asn", value=amazon_side_asn, expected_type=type_hints["amazon_side_asn"])
            check_type(argname="argument association_default_route_table_id", value=association_default_route_table_id, expected_type=type_hints["association_default_route_table_id"])
            check_type(argname="argument auto_accept_shared_attachments", value=auto_accept_shared_attachments, expected_type=type_hints["auto_accept_shared_attachments"])
            check_type(argname="argument default_route_table_association", value=default_route_table_association, expected_type=type_hints["default_route_table_association"])
            check_type(argname="argument default_route_table_propagation", value=default_route_table_propagation, expected_type=type_hints["default_route_table_propagation"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument dns_support", value=dns_support, expected_type=type_hints["dns_support"])
            check_type(argname="argument encryption_support", value=encryption_support, expected_type=type_hints["encryption_support"])
            check_type(argname="argument multicast_support", value=multicast_support, expected_type=type_hints["multicast_support"])
            check_type(argname="argument propagation_default_route_table_id", value=propagation_default_route_table_id, expected_type=type_hints["propagation_default_route_table_id"])
            check_type(argname="argument security_group_referencing_support", value=security_group_referencing_support, expected_type=type_hints["security_group_referencing_support"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument transit_gateway_cidr_blocks", value=transit_gateway_cidr_blocks, expected_type=type_hints["transit_gateway_cidr_blocks"])
            check_type(argname="argument vpn_ecmp_support", value=vpn_ecmp_support, expected_type=type_hints["vpn_ecmp_support"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if amazon_side_asn is not None:
            self._values["amazon_side_asn"] = amazon_side_asn
        if association_default_route_table_id is not None:
            self._values["association_default_route_table_id"] = association_default_route_table_id
        if auto_accept_shared_attachments is not None:
            self._values["auto_accept_shared_attachments"] = auto_accept_shared_attachments
        if default_route_table_association is not None:
            self._values["default_route_table_association"] = default_route_table_association
        if default_route_table_propagation is not None:
            self._values["default_route_table_propagation"] = default_route_table_propagation
        if description is not None:
            self._values["description"] = description
        if dns_support is not None:
            self._values["dns_support"] = dns_support
        if encryption_support is not None:
            self._values["encryption_support"] = encryption_support
        if multicast_support is not None:
            self._values["multicast_support"] = multicast_support
        if propagation_default_route_table_id is not None:
            self._values["propagation_default_route_table_id"] = propagation_default_route_table_id
        if security_group_referencing_support is not None:
            self._values["security_group_referencing_support"] = security_group_referencing_support
        if tags is not None:
            self._values["tags"] = tags
        if transit_gateway_cidr_blocks is not None:
            self._values["transit_gateway_cidr_blocks"] = transit_gateway_cidr_blocks
        if vpn_ecmp_support is not None:
            self._values["vpn_ecmp_support"] = vpn_ecmp_support

    @builtins.property
    def amazon_side_asn(self) -> typing.Optional[jsii.Number]:
        '''A private Autonomous System Number (ASN) for the Amazon side of a BGP session.

        The range is 64512 to 65534 for 16-bit ASNs. The default is 64512.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-amazonsideasn
        '''
        result = self._values.get("amazon_side_asn")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def association_default_route_table_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the default association route table.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-associationdefaultroutetableid
        '''
        result = self._values.get("association_default_route_table_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def auto_accept_shared_attachments(self) -> typing.Optional[builtins.str]:
        '''Enable or disable automatic acceptance of attachment requests.

        Disabled by default.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-autoacceptsharedattachments
        '''
        result = self._values.get("auto_accept_shared_attachments")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def default_route_table_association(self) -> typing.Optional[builtins.str]:
        '''Enable or disable automatic association with the default association route table.

        Enabled by default. If ``DefaultRouteTableAssociation`` is set to enable, AWS Transit Gateway will create the default transit gateway route table.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-defaultroutetableassociation
        '''
        result = self._values.get("default_route_table_association")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def default_route_table_propagation(self) -> typing.Optional[builtins.str]:
        '''Enable or disable automatic propagation of routes to the default propagation route table.

        Enabled by default. If ``DefaultRouteTablePropagation`` is set to enable, AWS Transit Gateway will create the default transit gateway route table.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-defaultroutetablepropagation
        '''
        result = self._values.get("default_route_table_propagation")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''The description of the transit gateway.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def dns_support(self) -> typing.Optional[builtins.str]:
        '''Enable or disable DNS support.

        Enabled by default.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-dnssupport
        '''
        result = self._values.get("dns_support")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def encryption_support(self) -> typing.Optional[builtins.str]:
        '''Enable or disable encryption support.

        Disabled by default.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-encryptionsupport
        '''
        result = self._values.get("encryption_support")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def multicast_support(self) -> typing.Optional[builtins.str]:
        '''Indicates whether multicast is enabled on the transit gateway.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-multicastsupport
        '''
        result = self._values.get("multicast_support")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def propagation_default_route_table_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the default propagation route table.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-propagationdefaultroutetableid
        '''
        result = self._values.get("propagation_default_route_table_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def security_group_referencing_support(self) -> typing.Optional[builtins.str]:
        '''Enables you to reference a security group across VPCs attached to a transit gateway (TGW).

        Use this option to simplify security group management and control of instance-to-instance traffic across VPCs that are connected by transit gateway. You can also use this option to migrate from VPC peering (which was the only option that supported security group referencing) to transit gateways (which now also support security group referencing). This option is disabled by default and there are no additional costs to use this feature.

        For important information about this feature, see `Create a transit gateway <https://docs.aws.amazon.com/vpc/latest/tgw/tgw-transit-gateways.html#create-tgw>`_ in the *AWS Transit Gateway Guide* .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-securitygroupreferencingsupport
        '''
        result = self._values.get("security_group_referencing_support")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags for the transit gateway.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def transit_gateway_cidr_blocks(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The transit gateway CIDR blocks.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-transitgatewaycidrblocks
        '''
        result = self._values.get("transit_gateway_cidr_blocks")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def vpn_ecmp_support(self) -> typing.Optional[builtins.str]:
        '''Enable or disable Equal Cost Multipath Protocol support.

        Enabled by default.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-vpnecmpsupport
        '''
        result = self._values.get("vpn_ecmp_support")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnTransitGatewayMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTransitGatewayMulticastDomainAssociationMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "subnet_id": "subnetId",
        "transit_gateway_attachment_id": "transitGatewayAttachmentId",
        "transit_gateway_multicast_domain_id": "transitGatewayMulticastDomainId",
    },
)
class CfnTransitGatewayMulticastDomainAssociationMixinProps:
    def __init__(
        self,
        *,
        subnet_id: typing.Optional[builtins.str] = None,
        transit_gateway_attachment_id: typing.Optional[builtins.str] = None,
        transit_gateway_multicast_domain_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnTransitGatewayMulticastDomainAssociationPropsMixin.

        :param subnet_id: The IDs of the subnets to associate with the transit gateway multicast domain.
        :param transit_gateway_attachment_id: The ID of the transit gateway attachment.
        :param transit_gateway_multicast_domain_id: The ID of the transit gateway multicast domain.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomainassociation.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_transit_gateway_multicast_domain_association_mixin_props = ec2_mixins.CfnTransitGatewayMulticastDomainAssociationMixinProps(
                subnet_id="subnetId",
                transit_gateway_attachment_id="transitGatewayAttachmentId",
                transit_gateway_multicast_domain_id="transitGatewayMulticastDomainId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cfd7ec3a33d6a52b74a914bde55eac2f9f35145134d4b20245c74fef4f38240e)
            check_type(argname="argument subnet_id", value=subnet_id, expected_type=type_hints["subnet_id"])
            check_type(argname="argument transit_gateway_attachment_id", value=transit_gateway_attachment_id, expected_type=type_hints["transit_gateway_attachment_id"])
            check_type(argname="argument transit_gateway_multicast_domain_id", value=transit_gateway_multicast_domain_id, expected_type=type_hints["transit_gateway_multicast_domain_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if subnet_id is not None:
            self._values["subnet_id"] = subnet_id
        if transit_gateway_attachment_id is not None:
            self._values["transit_gateway_attachment_id"] = transit_gateway_attachment_id
        if transit_gateway_multicast_domain_id is not None:
            self._values["transit_gateway_multicast_domain_id"] = transit_gateway_multicast_domain_id

    @builtins.property
    def subnet_id(self) -> typing.Optional[builtins.str]:
        '''The IDs of the subnets to associate with the transit gateway multicast domain.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomainassociation.html#cfn-ec2-transitgatewaymulticastdomainassociation-subnetid
        '''
        result = self._values.get("subnet_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def transit_gateway_attachment_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the transit gateway attachment.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomainassociation.html#cfn-ec2-transitgatewaymulticastdomainassociation-transitgatewayattachmentid
        '''
        result = self._values.get("transit_gateway_attachment_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def transit_gateway_multicast_domain_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the transit gateway multicast domain.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomainassociation.html#cfn-ec2-transitgatewaymulticastdomainassociation-transitgatewaymulticastdomainid
        '''
        result = self._values.get("transit_gateway_multicast_domain_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnTransitGatewayMulticastDomainAssociationMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnTransitGatewayMulticastDomainAssociationPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTransitGatewayMulticastDomainAssociationPropsMixin",
):
    '''Associates the specified subnets and transit gateway attachments with the specified transit gateway multicast domain.

    The transit gateway attachment must be in the available state before you can add a resource.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomainassociation.html
    :cloudformationResource: AWS::EC2::TransitGatewayMulticastDomainAssociation
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_transit_gateway_multicast_domain_association_props_mixin = ec2_mixins.CfnTransitGatewayMulticastDomainAssociationPropsMixin(ec2_mixins.CfnTransitGatewayMulticastDomainAssociationMixinProps(
            subnet_id="subnetId",
            transit_gateway_attachment_id="transitGatewayAttachmentId",
            transit_gateway_multicast_domain_id="transitGatewayMulticastDomainId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnTransitGatewayMulticastDomainAssociationMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::TransitGatewayMulticastDomainAssociation``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__29eb5b80c6dd8d914dfbc13eb1967882781a698ba03603ab6fb7df60b8233e77)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0113753f527f08d6dc9dcb672fc597fe40af7a5d65bc3ab457a9b3a2d307b8d8)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__19492ab313f9d17cc5ed725236325cb7e2a4e960100acdd74a8161ed7f7201ba)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnTransitGatewayMulticastDomainAssociationMixinProps":
        return typing.cast("CfnTransitGatewayMulticastDomainAssociationMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTransitGatewayMulticastDomainMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "options": "options",
        "tags": "tags",
        "transit_gateway_id": "transitGatewayId",
    },
)
class CfnTransitGatewayMulticastDomainMixinProps:
    def __init__(
        self,
        *,
        options: typing.Any = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        transit_gateway_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnTransitGatewayMulticastDomainPropsMixin.

        :param options: The options for the transit gateway multicast domain. - AutoAcceptSharedAssociations (enable | disable) - Igmpv2Support (enable | disable) - StaticSourcesSupport (enable | disable)
        :param tags: The tags for the transit gateway multicast domain.
        :param transit_gateway_id: The ID of the transit gateway.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomain.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            # options: Any
            
            cfn_transit_gateway_multicast_domain_mixin_props = ec2_mixins.CfnTransitGatewayMulticastDomainMixinProps(
                options=options,
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                transit_gateway_id="transitGatewayId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6fe210755118d419d255748b8aa8d4666cbe43f57ed9866a1f3403e380b4176d)
            check_type(argname="argument options", value=options, expected_type=type_hints["options"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument transit_gateway_id", value=transit_gateway_id, expected_type=type_hints["transit_gateway_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if options is not None:
            self._values["options"] = options
        if tags is not None:
            self._values["tags"] = tags
        if transit_gateway_id is not None:
            self._values["transit_gateway_id"] = transit_gateway_id

    @builtins.property
    def options(self) -> typing.Any:
        '''The options for the transit gateway multicast domain.

        - AutoAcceptSharedAssociations (enable | disable)
        - Igmpv2Support (enable | disable)
        - StaticSourcesSupport (enable | disable)

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomain.html#cfn-ec2-transitgatewaymulticastdomain-options
        '''
        result = self._values.get("options")
        return typing.cast(typing.Any, result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags for the transit gateway multicast domain.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomain.html#cfn-ec2-transitgatewaymulticastdomain-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def transit_gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the transit gateway.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomain.html#cfn-ec2-transitgatewaymulticastdomain-transitgatewayid
        '''
        result = self._values.get("transit_gateway_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnTransitGatewayMulticastDomainMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnTransitGatewayMulticastDomainPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTransitGatewayMulticastDomainPropsMixin",
):
    '''Creates a multicast domain using the specified transit gateway.

    The transit gateway must be in the available state before you create a domain.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomain.html
    :cloudformationResource: AWS::EC2::TransitGatewayMulticastDomain
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        # options: Any
        
        cfn_transit_gateway_multicast_domain_props_mixin = ec2_mixins.CfnTransitGatewayMulticastDomainPropsMixin(ec2_mixins.CfnTransitGatewayMulticastDomainMixinProps(
            options=options,
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            transit_gateway_id="transitGatewayId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnTransitGatewayMulticastDomainMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::TransitGatewayMulticastDomain``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__39c25bb1802bf005ca5c8a974cb270f8fb5ffccef53ab6aed3beebd284056959)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7ebe9297fca248b90daa695cd71bec28bf8bb49321f9f707fbc77e564a1426c3)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__03f79e2689372361c9bb54e391eee52cd4d6708cbdd21a70603129d92c64d659)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnTransitGatewayMulticastDomainMixinProps":
        return typing.cast("CfnTransitGatewayMulticastDomainMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTransitGatewayMulticastDomainPropsMixin.OptionsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "auto_accept_shared_associations": "autoAcceptSharedAssociations",
            "igmpv2_support": "igmpv2Support",
            "static_sources_support": "staticSourcesSupport",
        },
    )
    class OptionsProperty:
        def __init__(
            self,
            *,
            auto_accept_shared_associations: typing.Optional[builtins.str] = None,
            igmpv2_support: typing.Optional[builtins.str] = None,
            static_sources_support: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The options for the transit gateway multicast domain.

            :param auto_accept_shared_associations: Indicates whether to automatically accept cross-account subnet associations that are associated with the transit gateway multicast domain.
            :param igmpv2_support: Specify whether to enable Internet Group Management Protocol (IGMP) version 2 for the transit gateway multicast domain.
            :param static_sources_support: Specify whether to enable support for statically configuring multicast group sources for a domain.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaymulticastdomain-options.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                options_property = ec2_mixins.CfnTransitGatewayMulticastDomainPropsMixin.OptionsProperty(
                    auto_accept_shared_associations="autoAcceptSharedAssociations",
                    igmpv2_support="igmpv2Support",
                    static_sources_support="staticSourcesSupport"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__6bb60b7351f1225e250f3805ebeff0d2ceae255073fa9b9d6bdc94a4c0265ec1)
                check_type(argname="argument auto_accept_shared_associations", value=auto_accept_shared_associations, expected_type=type_hints["auto_accept_shared_associations"])
                check_type(argname="argument igmpv2_support", value=igmpv2_support, expected_type=type_hints["igmpv2_support"])
                check_type(argname="argument static_sources_support", value=static_sources_support, expected_type=type_hints["static_sources_support"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if auto_accept_shared_associations is not None:
                self._values["auto_accept_shared_associations"] = auto_accept_shared_associations
            if igmpv2_support is not None:
                self._values["igmpv2_support"] = igmpv2_support
            if static_sources_support is not None:
                self._values["static_sources_support"] = static_sources_support

        @builtins.property
        def auto_accept_shared_associations(self) -> typing.Optional[builtins.str]:
            '''Indicates whether to automatically accept cross-account subnet associations that are associated with the transit gateway multicast domain.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaymulticastdomain-options.html#cfn-ec2-transitgatewaymulticastdomain-options-autoacceptsharedassociations
            '''
            result = self._values.get("auto_accept_shared_associations")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def igmpv2_support(self) -> typing.Optional[builtins.str]:
            '''Specify whether to enable Internet Group Management Protocol (IGMP) version 2 for the transit gateway multicast domain.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaymulticastdomain-options.html#cfn-ec2-transitgatewaymulticastdomain-options-igmpv2support
            '''
            result = self._values.get("igmpv2_support")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def static_sources_support(self) -> typing.Optional[builtins.str]:
            '''Specify whether to enable support for statically configuring multicast group sources for a domain.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaymulticastdomain-options.html#cfn-ec2-transitgatewaymulticastdomain-options-staticsourcessupport
            '''
            result = self._values.get("static_sources_support")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "OptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTransitGatewayMulticastGroupMemberMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "group_ip_address": "groupIpAddress",
        "network_interface_id": "networkInterfaceId",
        "transit_gateway_multicast_domain_id": "transitGatewayMulticastDomainId",
    },
)
class CfnTransitGatewayMulticastGroupMemberMixinProps:
    def __init__(
        self,
        *,
        group_ip_address: typing.Optional[builtins.str] = None,
        network_interface_id: typing.Optional[builtins.str] = None,
        transit_gateway_multicast_domain_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnTransitGatewayMulticastGroupMemberPropsMixin.

        :param group_ip_address: The IP address assigned to the transit gateway multicast group.
        :param network_interface_id: The group members' network interface IDs to register with the transit gateway multicast group.
        :param transit_gateway_multicast_domain_id: The ID of the transit gateway multicast domain.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupmember.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_transit_gateway_multicast_group_member_mixin_props = ec2_mixins.CfnTransitGatewayMulticastGroupMemberMixinProps(
                group_ip_address="groupIpAddress",
                network_interface_id="networkInterfaceId",
                transit_gateway_multicast_domain_id="transitGatewayMulticastDomainId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__afdeadd200b6c7cb8d041d27c9db457e938a4c08f30b5de462537169cd7a0621)
            check_type(argname="argument group_ip_address", value=group_ip_address, expected_type=type_hints["group_ip_address"])
            check_type(argname="argument network_interface_id", value=network_interface_id, expected_type=type_hints["network_interface_id"])
            check_type(argname="argument transit_gateway_multicast_domain_id", value=transit_gateway_multicast_domain_id, expected_type=type_hints["transit_gateway_multicast_domain_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if group_ip_address is not None:
            self._values["group_ip_address"] = group_ip_address
        if network_interface_id is not None:
            self._values["network_interface_id"] = network_interface_id
        if transit_gateway_multicast_domain_id is not None:
            self._values["transit_gateway_multicast_domain_id"] = transit_gateway_multicast_domain_id

    @builtins.property
    def group_ip_address(self) -> typing.Optional[builtins.str]:
        '''The IP address assigned to the transit gateway multicast group.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupmember.html#cfn-ec2-transitgatewaymulticastgroupmember-groupipaddress
        '''
        result = self._values.get("group_ip_address")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def network_interface_id(self) -> typing.Optional[builtins.str]:
        '''The group members' network interface IDs to register with the transit gateway multicast group.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupmember.html#cfn-ec2-transitgatewaymulticastgroupmember-networkinterfaceid
        '''
        result = self._values.get("network_interface_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def transit_gateway_multicast_domain_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the transit gateway multicast domain.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupmember.html#cfn-ec2-transitgatewaymulticastgroupmember-transitgatewaymulticastdomainid
        '''
        result = self._values.get("transit_gateway_multicast_domain_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnTransitGatewayMulticastGroupMemberMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnTransitGatewayMulticastGroupMemberPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTransitGatewayMulticastGroupMemberPropsMixin",
):
    '''Registers members (network interfaces) with the transit gateway multicast group.

    A member is a network interface associated with a supported EC2 instance that receives multicast traffic. For information about supported instances, see `Multicast Consideration <https://docs.aws.amazon.com/vpc/latest/tgw/transit-gateway-limits.html#multicast-limits>`_ in *Amazon VPC Transit Gateways* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupmember.html
    :cloudformationResource: AWS::EC2::TransitGatewayMulticastGroupMember
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_transit_gateway_multicast_group_member_props_mixin = ec2_mixins.CfnTransitGatewayMulticastGroupMemberPropsMixin(ec2_mixins.CfnTransitGatewayMulticastGroupMemberMixinProps(
            group_ip_address="groupIpAddress",
            network_interface_id="networkInterfaceId",
            transit_gateway_multicast_domain_id="transitGatewayMulticastDomainId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnTransitGatewayMulticastGroupMemberMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::TransitGatewayMulticastGroupMember``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__24cee9eab2caa8fc039b5b54d0f3870b0205fdf9da18972b997efdf30cb8d189)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__54d0eafd4606dffd74414872b6dce3cfb968c6e10059a6d46984562017680590)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__abc60d97d6b206afb8ab1937a32cf1267832733152622db340bef31173c5085c)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnTransitGatewayMulticastGroupMemberMixinProps":
        return typing.cast("CfnTransitGatewayMulticastGroupMemberMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTransitGatewayMulticastGroupSourceMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "group_ip_address": "groupIpAddress",
        "network_interface_id": "networkInterfaceId",
        "transit_gateway_multicast_domain_id": "transitGatewayMulticastDomainId",
    },
)
class CfnTransitGatewayMulticastGroupSourceMixinProps:
    def __init__(
        self,
        *,
        group_ip_address: typing.Optional[builtins.str] = None,
        network_interface_id: typing.Optional[builtins.str] = None,
        transit_gateway_multicast_domain_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnTransitGatewayMulticastGroupSourcePropsMixin.

        :param group_ip_address: The IP address assigned to the transit gateway multicast group.
        :param network_interface_id: The group sources' network interface IDs to register with the transit gateway multicast group.
        :param transit_gateway_multicast_domain_id: The ID of the transit gateway multicast domain.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupsource.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_transit_gateway_multicast_group_source_mixin_props = ec2_mixins.CfnTransitGatewayMulticastGroupSourceMixinProps(
                group_ip_address="groupIpAddress",
                network_interface_id="networkInterfaceId",
                transit_gateway_multicast_domain_id="transitGatewayMulticastDomainId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c00c2686dbddd535910594c09a058e130181a174b62a239c625cb9eb3661ff80)
            check_type(argname="argument group_ip_address", value=group_ip_address, expected_type=type_hints["group_ip_address"])
            check_type(argname="argument network_interface_id", value=network_interface_id, expected_type=type_hints["network_interface_id"])
            check_type(argname="argument transit_gateway_multicast_domain_id", value=transit_gateway_multicast_domain_id, expected_type=type_hints["transit_gateway_multicast_domain_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if group_ip_address is not None:
            self._values["group_ip_address"] = group_ip_address
        if network_interface_id is not None:
            self._values["network_interface_id"] = network_interface_id
        if transit_gateway_multicast_domain_id is not None:
            self._values["transit_gateway_multicast_domain_id"] = transit_gateway_multicast_domain_id

    @builtins.property
    def group_ip_address(self) -> typing.Optional[builtins.str]:
        '''The IP address assigned to the transit gateway multicast group.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupsource.html#cfn-ec2-transitgatewaymulticastgroupsource-groupipaddress
        '''
        result = self._values.get("group_ip_address")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def network_interface_id(self) -> typing.Optional[builtins.str]:
        '''The group sources' network interface IDs to register with the transit gateway multicast group.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupsource.html#cfn-ec2-transitgatewaymulticastgroupsource-networkinterfaceid
        '''
        result = self._values.get("network_interface_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def transit_gateway_multicast_domain_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the transit gateway multicast domain.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupsource.html#cfn-ec2-transitgatewaymulticastgroupsource-transitgatewaymulticastdomainid
        '''
        result = self._values.get("transit_gateway_multicast_domain_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnTransitGatewayMulticastGroupSourceMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnTransitGatewayMulticastGroupSourcePropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTransitGatewayMulticastGroupSourcePropsMixin",
):
    '''Registers sources (network interfaces) with the specified transit gateway multicast domain.

    A multicast source is a network interface attached to a supported instance that sends multicast traffic. For information about supported instances, see `Multicast Considerations <https://docs.aws.amazon.com/vpc/latest/tgw/transit-gateway-limits.html#multicast-limits>`_ in *Amazon VPC Transit Gateways* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupsource.html
    :cloudformationResource: AWS::EC2::TransitGatewayMulticastGroupSource
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_transit_gateway_multicast_group_source_props_mixin = ec2_mixins.CfnTransitGatewayMulticastGroupSourcePropsMixin(ec2_mixins.CfnTransitGatewayMulticastGroupSourceMixinProps(
            group_ip_address="groupIpAddress",
            network_interface_id="networkInterfaceId",
            transit_gateway_multicast_domain_id="transitGatewayMulticastDomainId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnTransitGatewayMulticastGroupSourceMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::TransitGatewayMulticastGroupSource``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4a8e33049cdafd33da47bfcde28e559057f05fd0c62fe02a52a495321599d32a)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a23049a9cee3ed6b5eb1a8fe2cf623365b949a9b94c23ee089101ae121c9731d)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7ddb2bff178a0929e372216d3d58706b068c59ed1a50c42eaec5de9b74d9e1e2)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnTransitGatewayMulticastGroupSourceMixinProps":
        return typing.cast("CfnTransitGatewayMulticastGroupSourceMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTransitGatewayPeeringAttachmentMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "peer_account_id": "peerAccountId",
        "peer_region": "peerRegion",
        "peer_transit_gateway_id": "peerTransitGatewayId",
        "tags": "tags",
        "transit_gateway_id": "transitGatewayId",
    },
)
class CfnTransitGatewayPeeringAttachmentMixinProps:
    def __init__(
        self,
        *,
        peer_account_id: typing.Optional[builtins.str] = None,
        peer_region: typing.Optional[builtins.str] = None,
        peer_transit_gateway_id: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        transit_gateway_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnTransitGatewayPeeringAttachmentPropsMixin.

        :param peer_account_id: The ID of the AWS account that owns the transit gateway.
        :param peer_region: The Region where the transit gateway that you want to create the peer for is located.
        :param peer_transit_gateway_id: The ID of the transit gateway in the PeerRegion.
        :param tags: The tags for the transit gateway peering attachment.
        :param transit_gateway_id: The ID of the transit gateway peering attachment.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_transit_gateway_peering_attachment_mixin_props = ec2_mixins.CfnTransitGatewayPeeringAttachmentMixinProps(
                peer_account_id="peerAccountId",
                peer_region="peerRegion",
                peer_transit_gateway_id="peerTransitGatewayId",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                transit_gateway_id="transitGatewayId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d31ffa147e1e7b5b766037944e74f3bfc55b5f7e70e2dbeef51eca493dcdbf2c)
            check_type(argname="argument peer_account_id", value=peer_account_id, expected_type=type_hints["peer_account_id"])
            check_type(argname="argument peer_region", value=peer_region, expected_type=type_hints["peer_region"])
            check_type(argname="argument peer_transit_gateway_id", value=peer_transit_gateway_id, expected_type=type_hints["peer_transit_gateway_id"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument transit_gateway_id", value=transit_gateway_id, expected_type=type_hints["transit_gateway_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if peer_account_id is not None:
            self._values["peer_account_id"] = peer_account_id
        if peer_region is not None:
            self._values["peer_region"] = peer_region
        if peer_transit_gateway_id is not None:
            self._values["peer_transit_gateway_id"] = peer_transit_gateway_id
        if tags is not None:
            self._values["tags"] = tags
        if transit_gateway_id is not None:
            self._values["transit_gateway_id"] = transit_gateway_id

    @builtins.property
    def peer_account_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the AWS account that owns the transit gateway.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-peeraccountid
        '''
        result = self._values.get("peer_account_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def peer_region(self) -> typing.Optional[builtins.str]:
        '''The Region where the transit gateway that you want to create the peer for is located.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-peerregion
        '''
        result = self._values.get("peer_region")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def peer_transit_gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the transit gateway in the PeerRegion.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-peertransitgatewayid
        '''
        result = self._values.get("peer_transit_gateway_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags for the transit gateway peering attachment.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def transit_gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the transit gateway peering attachment.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-transitgatewayid
        '''
        result = self._values.get("transit_gateway_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnTransitGatewayPeeringAttachmentMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnTransitGatewayPeeringAttachmentPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTransitGatewayPeeringAttachmentPropsMixin",
):
    '''Requests a transit gateway peering attachment between the specified transit gateway (requester) and a peer transit gateway (accepter).

    The peer transit gateway can be in your account or a different AWS account .

    After you create the peering attachment, the owner of the accepter transit gateway must accept the attachment request.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html
    :cloudformationResource: AWS::EC2::TransitGatewayPeeringAttachment
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_transit_gateway_peering_attachment_props_mixin = ec2_mixins.CfnTransitGatewayPeeringAttachmentPropsMixin(ec2_mixins.CfnTransitGatewayPeeringAttachmentMixinProps(
            peer_account_id="peerAccountId",
            peer_region="peerRegion",
            peer_transit_gateway_id="peerTransitGatewayId",
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            transit_gateway_id="transitGatewayId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnTransitGatewayPeeringAttachmentMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::TransitGatewayPeeringAttachment``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__daa37515a3ed6ce3bfa75522d5ec472ed1213f3de0a0acbc70128a73372dec6f)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__534af58b9a1dc1a96ddef6f404832f93722eecc32faeabbbdb259ae819dc6c5c)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bd0e439cd040c764c200dc86bbf76068e959be5694e218be02f3c9df1d85e793)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnTransitGatewayPeeringAttachmentMixinProps":
        return typing.cast("CfnTransitGatewayPeeringAttachmentMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTransitGatewayPeeringAttachmentPropsMixin.PeeringAttachmentStatusProperty",
        jsii_struct_bases=[],
        name_mapping={"code": "code", "message": "message"},
    )
    class PeeringAttachmentStatusProperty:
        def __init__(
            self,
            *,
            code: typing.Optional[builtins.str] = None,
            message: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The status of the transit gateway peering attachment.

            :param code: The status code.
            :param message: The status message, if applicable.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaypeeringattachment-peeringattachmentstatus.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                peering_attachment_status_property = ec2_mixins.CfnTransitGatewayPeeringAttachmentPropsMixin.PeeringAttachmentStatusProperty(
                    code="code",
                    message="message"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__b6b7a424b10036ae8e91a67ef29fb58b71e74fcd40c9b8f7b153683c89a5f12e)
                check_type(argname="argument code", value=code, expected_type=type_hints["code"])
                check_type(argname="argument message", value=message, expected_type=type_hints["message"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if code is not None:
                self._values["code"] = code
            if message is not None:
                self._values["message"] = message

        @builtins.property
        def code(self) -> typing.Optional[builtins.str]:
            '''The status code.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaypeeringattachment-peeringattachmentstatus.html#cfn-ec2-transitgatewaypeeringattachment-peeringattachmentstatus-code
            '''
            result = self._values.get("code")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def message(self) -> typing.Optional[builtins.str]:
            '''The status message, if applicable.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaypeeringattachment-peeringattachmentstatus.html#cfn-ec2-transitgatewaypeeringattachment-peeringattachmentstatus-message
            '''
            result = self._values.get("message")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PeeringAttachmentStatusProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.implements(_IMixin_11e4b965)
class CfnTransitGatewayPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTransitGatewayPropsMixin",
):
    '''Specifies a transit gateway.

    You can use a transit gateway to interconnect your virtual private clouds (VPC) and on-premises networks. After the transit gateway enters the ``available`` state, you can attach your VPCs and VPN connections to the transit gateway.

    To attach your VPCs, use `AWS::EC2::TransitGatewayAttachment <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html>`_ .

    To attach a VPN connection, use `AWS::EC2::CustomerGateway <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customer-gateway.html>`_ to create a customer gateway and specify the ID of the customer gateway and the ID of the transit gateway in a call to `AWS::EC2::VPNConnection <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpn-connection.html>`_ .

    When you create a transit gateway, we create a default transit gateway route table and use it as the default association route table and the default propagation route table. You can use `AWS::EC2::TransitGatewayRouteTable <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html>`_ to create additional transit gateway route tables. If you disable automatic route propagation, we do not create a default transit gateway route table. You can use `AWS::EC2::TransitGatewayRouteTablePropagation <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetablepropagation.html>`_ to propagate routes from a resource attachment to a transit gateway route table. If you disable automatic associations, you can use `AWS::EC2::TransitGatewayRouteTableAssociation <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetableassociation.html>`_ to associate a resource attachment with a transit gateway route table.

    To create a transit gateway with ``EncryptionSupport`` enabled through CloudFormation, you will need the ``ec2:ModifyTransitGateway`` Identity and Access Management (IAM) permission. For more information, see ``ModifyTransitGateway`` in `Actions, resources, and condition keys for Amazon EC2 <https://docs.aws.amazon.com/service-authorization/latest/reference/list_amazonec2.html#amazonec2-actions-as->`_ of the *Identify and Access Management Service Authorization Reference* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html
    :cloudformationResource: AWS::EC2::TransitGateway
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_transit_gateway_props_mixin = ec2_mixins.CfnTransitGatewayPropsMixin(ec2_mixins.CfnTransitGatewayMixinProps(
            amazon_side_asn=123,
            association_default_route_table_id="associationDefaultRouteTableId",
            auto_accept_shared_attachments="autoAcceptSharedAttachments",
            default_route_table_association="defaultRouteTableAssociation",
            default_route_table_propagation="defaultRouteTablePropagation",
            description="description",
            dns_support="dnsSupport",
            encryption_support="encryptionSupport",
            multicast_support="multicastSupport",
            propagation_default_route_table_id="propagationDefaultRouteTableId",
            security_group_referencing_support="securityGroupReferencingSupport",
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            transit_gateway_cidr_blocks=["transitGatewayCidrBlocks"],
            vpn_ecmp_support="vpnEcmpSupport"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnTransitGatewayMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::TransitGateway``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__99b01d146274e3ea2e886453c93fb4839388bc60006eb0879459475cac975a2c)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b448f1c7bc72679a7e83ae0032a9fd27ede6fb463c22e79502419b91cc798f08)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3197d6db2ae61ea2ff782114a7728d491747c4e6667f7f7e67a6a9f02a3b3bf5)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnTransitGatewayMixinProps":
        return typing.cast("CfnTransitGatewayMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTransitGatewayRouteMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "blackhole": "blackhole",
        "destination_cidr_block": "destinationCidrBlock",
        "transit_gateway_attachment_id": "transitGatewayAttachmentId",
        "transit_gateway_route_table_id": "transitGatewayRouteTableId",
    },
)
class CfnTransitGatewayRouteMixinProps:
    def __init__(
        self,
        *,
        blackhole: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        destination_cidr_block: typing.Optional[builtins.str] = None,
        transit_gateway_attachment_id: typing.Optional[builtins.str] = None,
        transit_gateway_route_table_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnTransitGatewayRoutePropsMixin.

        :param blackhole: Indicates whether to drop traffic that matches this route.
        :param destination_cidr_block: The CIDR block used for destination matches.
        :param transit_gateway_attachment_id: The ID of the attachment.
        :param transit_gateway_route_table_id: The ID of the transit gateway route table.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_transit_gateway_route_mixin_props = ec2_mixins.CfnTransitGatewayRouteMixinProps(
                blackhole=False,
                destination_cidr_block="destinationCidrBlock",
                transit_gateway_attachment_id="transitGatewayAttachmentId",
                transit_gateway_route_table_id="transitGatewayRouteTableId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__37b59112ae227a05bd5fb38b79ebe8797ef771ea1c0dd7a16c0c4ec297ec2130)
            check_type(argname="argument blackhole", value=blackhole, expected_type=type_hints["blackhole"])
            check_type(argname="argument destination_cidr_block", value=destination_cidr_block, expected_type=type_hints["destination_cidr_block"])
            check_type(argname="argument transit_gateway_attachment_id", value=transit_gateway_attachment_id, expected_type=type_hints["transit_gateway_attachment_id"])
            check_type(argname="argument transit_gateway_route_table_id", value=transit_gateway_route_table_id, expected_type=type_hints["transit_gateway_route_table_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if blackhole is not None:
            self._values["blackhole"] = blackhole
        if destination_cidr_block is not None:
            self._values["destination_cidr_block"] = destination_cidr_block
        if transit_gateway_attachment_id is not None:
            self._values["transit_gateway_attachment_id"] = transit_gateway_attachment_id
        if transit_gateway_route_table_id is not None:
            self._values["transit_gateway_route_table_id"] = transit_gateway_route_table_id

    @builtins.property
    def blackhole(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Indicates whether to drop traffic that matches this route.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html#cfn-ec2-transitgatewayroute-blackhole
        '''
        result = self._values.get("blackhole")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def destination_cidr_block(self) -> typing.Optional[builtins.str]:
        '''The CIDR block used for destination matches.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html#cfn-ec2-transitgatewayroute-destinationcidrblock
        '''
        result = self._values.get("destination_cidr_block")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def transit_gateway_attachment_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the attachment.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html#cfn-ec2-transitgatewayroute-transitgatewayattachmentid
        '''
        result = self._values.get("transit_gateway_attachment_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def transit_gateway_route_table_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the transit gateway route table.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html#cfn-ec2-transitgatewayroute-transitgatewayroutetableid
        '''
        result = self._values.get("transit_gateway_route_table_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnTransitGatewayRouteMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnTransitGatewayRoutePropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTransitGatewayRoutePropsMixin",
):
    '''Specifies a static route for a transit gateway route table.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html
    :cloudformationResource: AWS::EC2::TransitGatewayRoute
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_transit_gateway_route_props_mixin = ec2_mixins.CfnTransitGatewayRoutePropsMixin(ec2_mixins.CfnTransitGatewayRouteMixinProps(
            blackhole=False,
            destination_cidr_block="destinationCidrBlock",
            transit_gateway_attachment_id="transitGatewayAttachmentId",
            transit_gateway_route_table_id="transitGatewayRouteTableId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnTransitGatewayRouteMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::TransitGatewayRoute``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fb03427bfd8102835f463d8ec7c5f98843dec12f464eb08d0d2e88753a308bb0)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9a8c840d296a60a0fdfeaf0ef68f1b654cdef7723b5ec664d7013722169848a6)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__559f237aabbd05028edf0dc901ab5cc6e1e4d77b910977d95e4702d6afae5410)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnTransitGatewayRouteMixinProps":
        return typing.cast("CfnTransitGatewayRouteMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTransitGatewayRouteTableAssociationMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "transit_gateway_attachment_id": "transitGatewayAttachmentId",
        "transit_gateway_route_table_id": "transitGatewayRouteTableId",
    },
)
class CfnTransitGatewayRouteTableAssociationMixinProps:
    def __init__(
        self,
        *,
        transit_gateway_attachment_id: typing.Optional[builtins.str] = None,
        transit_gateway_route_table_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnTransitGatewayRouteTableAssociationPropsMixin.

        :param transit_gateway_attachment_id: The ID of the attachment.
        :param transit_gateway_route_table_id: The ID of the route table for the transit gateway.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetableassociation.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_transit_gateway_route_table_association_mixin_props = ec2_mixins.CfnTransitGatewayRouteTableAssociationMixinProps(
                transit_gateway_attachment_id="transitGatewayAttachmentId",
                transit_gateway_route_table_id="transitGatewayRouteTableId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c62a8711ce5ac4927f2aaf1c8a1781c7a2975399fbfa5d3183807dbe15607ae0)
            check_type(argname="argument transit_gateway_attachment_id", value=transit_gateway_attachment_id, expected_type=type_hints["transit_gateway_attachment_id"])
            check_type(argname="argument transit_gateway_route_table_id", value=transit_gateway_route_table_id, expected_type=type_hints["transit_gateway_route_table_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if transit_gateway_attachment_id is not None:
            self._values["transit_gateway_attachment_id"] = transit_gateway_attachment_id
        if transit_gateway_route_table_id is not None:
            self._values["transit_gateway_route_table_id"] = transit_gateway_route_table_id

    @builtins.property
    def transit_gateway_attachment_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the attachment.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetableassociation.html#cfn-ec2-transitgatewayroutetableassociation-transitgatewayattachmentid
        '''
        result = self._values.get("transit_gateway_attachment_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def transit_gateway_route_table_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the route table for the transit gateway.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetableassociation.html#cfn-ec2-transitgatewayroutetableassociation-transitgatewayroutetableid
        '''
        result = self._values.get("transit_gateway_route_table_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnTransitGatewayRouteTableAssociationMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnTransitGatewayRouteTableAssociationPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTransitGatewayRouteTableAssociationPropsMixin",
):
    '''Associates the specified attachment with the specified transit gateway route table.

    You can associate one route table with an attachment.

    Before you can update the route table associated with an attachment, you must disassociate the transit gateway route table that is currently associated with the attachment. First update the stack to remove the associated transit gateway route table, and then update the stack with the ID of the new transit gateway route table to associate. In addition, the attachment must be in an ``available`` state; otherwise, the request will return an error.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetableassociation.html
    :cloudformationResource: AWS::EC2::TransitGatewayRouteTableAssociation
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_transit_gateway_route_table_association_props_mixin = ec2_mixins.CfnTransitGatewayRouteTableAssociationPropsMixin(ec2_mixins.CfnTransitGatewayRouteTableAssociationMixinProps(
            transit_gateway_attachment_id="transitGatewayAttachmentId",
            transit_gateway_route_table_id="transitGatewayRouteTableId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnTransitGatewayRouteTableAssociationMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::TransitGatewayRouteTableAssociation``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__77388eca20ce8172ef79145a6dc85d0731f653f5ad59821becdb9b30bcc82d20)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0c7592b111d5c68e5e5f874e5c9972b4cb74c7845300e2bcfc8904525806b6e5)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8d4b15a32d672c840996d4a8eaf164f3bb3ae3310a3e0510c39951768e427f98)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnTransitGatewayRouteTableAssociationMixinProps":
        return typing.cast("CfnTransitGatewayRouteTableAssociationMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTransitGatewayRouteTableMixinProps",
    jsii_struct_bases=[],
    name_mapping={"tags": "tags", "transit_gateway_id": "transitGatewayId"},
)
class CfnTransitGatewayRouteTableMixinProps:
    def __init__(
        self,
        *,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        transit_gateway_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnTransitGatewayRouteTablePropsMixin.

        :param tags: Any tags assigned to the route table.
        :param transit_gateway_id: The ID of the transit gateway.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_transit_gateway_route_table_mixin_props = ec2_mixins.CfnTransitGatewayRouteTableMixinProps(
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                transit_gateway_id="transitGatewayId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2e3bfeed4cab4d1ed31b52a1027e8d1b2d61a2a1f055c5bffd6689a3d628a32d)
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument transit_gateway_id", value=transit_gateway_id, expected_type=type_hints["transit_gateway_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if tags is not None:
            self._values["tags"] = tags
        if transit_gateway_id is not None:
            self._values["transit_gateway_id"] = transit_gateway_id

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''Any tags assigned to the route table.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html#cfn-ec2-transitgatewayroutetable-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def transit_gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the transit gateway.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html#cfn-ec2-transitgatewayroutetable-transitgatewayid
        '''
        result = self._values.get("transit_gateway_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnTransitGatewayRouteTableMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTransitGatewayRouteTablePropagationMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "transit_gateway_attachment_id": "transitGatewayAttachmentId",
        "transit_gateway_route_table_id": "transitGatewayRouteTableId",
    },
)
class CfnTransitGatewayRouteTablePropagationMixinProps:
    def __init__(
        self,
        *,
        transit_gateway_attachment_id: typing.Optional[builtins.str] = None,
        transit_gateway_route_table_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnTransitGatewayRouteTablePropagationPropsMixin.

        :param transit_gateway_attachment_id: The ID of the attachment.
        :param transit_gateway_route_table_id: The ID of the propagation route table.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetablepropagation.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_transit_gateway_route_table_propagation_mixin_props = ec2_mixins.CfnTransitGatewayRouteTablePropagationMixinProps(
                transit_gateway_attachment_id="transitGatewayAttachmentId",
                transit_gateway_route_table_id="transitGatewayRouteTableId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6862d94d883d80c4799ea6da18cd54a3fd34d7efad2e5a6ac9fbb6cc099c7443)
            check_type(argname="argument transit_gateway_attachment_id", value=transit_gateway_attachment_id, expected_type=type_hints["transit_gateway_attachment_id"])
            check_type(argname="argument transit_gateway_route_table_id", value=transit_gateway_route_table_id, expected_type=type_hints["transit_gateway_route_table_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if transit_gateway_attachment_id is not None:
            self._values["transit_gateway_attachment_id"] = transit_gateway_attachment_id
        if transit_gateway_route_table_id is not None:
            self._values["transit_gateway_route_table_id"] = transit_gateway_route_table_id

    @builtins.property
    def transit_gateway_attachment_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the attachment.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetablepropagation.html#cfn-ec2-transitgatewayroutetablepropagation-transitgatewayattachmentid
        '''
        result = self._values.get("transit_gateway_attachment_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def transit_gateway_route_table_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the propagation route table.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetablepropagation.html#cfn-ec2-transitgatewayroutetablepropagation-transitgatewayroutetableid
        '''
        result = self._values.get("transit_gateway_route_table_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnTransitGatewayRouteTablePropagationMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnTransitGatewayRouteTablePropagationPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTransitGatewayRouteTablePropagationPropsMixin",
):
    '''Enables the specified attachment to propagate routes to the specified propagation route table.

    For more information about enabling transit gateway route propagation, see `EnableTransitGatewayRouteTablePropagation <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_EnableTransitGatewayRouteTablePropagation.html>`_ in the *Amazon EC2 API Reference* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetablepropagation.html
    :cloudformationResource: AWS::EC2::TransitGatewayRouteTablePropagation
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_transit_gateway_route_table_propagation_props_mixin = ec2_mixins.CfnTransitGatewayRouteTablePropagationPropsMixin(ec2_mixins.CfnTransitGatewayRouteTablePropagationMixinProps(
            transit_gateway_attachment_id="transitGatewayAttachmentId",
            transit_gateway_route_table_id="transitGatewayRouteTableId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnTransitGatewayRouteTablePropagationMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::TransitGatewayRouteTablePropagation``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a43fd9adf557da26c7e22b8048e8c03b3dcbd41282180821f7f301fce9fe6a80)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b2e8a1062725b76c30304e082b6f52cf7b96bb441083368797e84882f100b280)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5f91dce607325b1640590c030e9294eb67e669693cf43b928f0786dce9b385ca)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnTransitGatewayRouteTablePropagationMixinProps":
        return typing.cast("CfnTransitGatewayRouteTablePropagationMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.implements(_IMixin_11e4b965)
class CfnTransitGatewayRouteTablePropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTransitGatewayRouteTablePropsMixin",
):
    '''Specifies a route table for a transit gateway.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html
    :cloudformationResource: AWS::EC2::TransitGatewayRouteTable
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_transit_gateway_route_table_props_mixin = ec2_mixins.CfnTransitGatewayRouteTablePropsMixin(ec2_mixins.CfnTransitGatewayRouteTableMixinProps(
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            transit_gateway_id="transitGatewayId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnTransitGatewayRouteTableMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::TransitGatewayRouteTable``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b0f5c75e699056727935d96d57159b4a7ddb400085f70cba4e5877b8f5bcf277)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b3a5eb9101667d4b7d35c0368d7ee50558cd6dd5dc31f0a785a5014f01545ecd)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d2914e74b9510af1136c660897a0d1821e67cbbf1baf572f6f99877b3e64c893)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnTransitGatewayRouteTableMixinProps":
        return typing.cast("CfnTransitGatewayRouteTableMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTransitGatewayVpcAttachmentMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "add_subnet_ids": "addSubnetIds",
        "options": "options",
        "remove_subnet_ids": "removeSubnetIds",
        "subnet_ids": "subnetIds",
        "tags": "tags",
        "transit_gateway_id": "transitGatewayId",
        "vpc_id": "vpcId",
    },
)
class CfnTransitGatewayVpcAttachmentMixinProps:
    def __init__(
        self,
        *,
        add_subnet_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        options: typing.Any = None,
        remove_subnet_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        subnet_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        transit_gateway_id: typing.Optional[builtins.str] = None,
        vpc_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnTransitGatewayVpcAttachmentPropsMixin.

        :param add_subnet_ids: The IDs of one or more subnets to add. You can specify at most one subnet per Availability Zone.
        :param options: The VPC attachment options.
        :param remove_subnet_ids: The IDs of one or more subnets to remove.
        :param subnet_ids: The IDs of the subnets.
        :param tags: The tags for the VPC attachment.
        :param transit_gateway_id: The ID of the transit gateway.
        :param vpc_id: The ID of the VPC.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            # options: Any
            
            cfn_transit_gateway_vpc_attachment_mixin_props = ec2_mixins.CfnTransitGatewayVpcAttachmentMixinProps(
                add_subnet_ids=["addSubnetIds"],
                options=options,
                remove_subnet_ids=["removeSubnetIds"],
                subnet_ids=["subnetIds"],
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                transit_gateway_id="transitGatewayId",
                vpc_id="vpcId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0ff8c07cdfa2dcce447879c858756044631c5a5c6d685b2c7383d797630fe8ff)
            check_type(argname="argument add_subnet_ids", value=add_subnet_ids, expected_type=type_hints["add_subnet_ids"])
            check_type(argname="argument options", value=options, expected_type=type_hints["options"])
            check_type(argname="argument remove_subnet_ids", value=remove_subnet_ids, expected_type=type_hints["remove_subnet_ids"])
            check_type(argname="argument subnet_ids", value=subnet_ids, expected_type=type_hints["subnet_ids"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument transit_gateway_id", value=transit_gateway_id, expected_type=type_hints["transit_gateway_id"])
            check_type(argname="argument vpc_id", value=vpc_id, expected_type=type_hints["vpc_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if add_subnet_ids is not None:
            self._values["add_subnet_ids"] = add_subnet_ids
        if options is not None:
            self._values["options"] = options
        if remove_subnet_ids is not None:
            self._values["remove_subnet_ids"] = remove_subnet_ids
        if subnet_ids is not None:
            self._values["subnet_ids"] = subnet_ids
        if tags is not None:
            self._values["tags"] = tags
        if transit_gateway_id is not None:
            self._values["transit_gateway_id"] = transit_gateway_id
        if vpc_id is not None:
            self._values["vpc_id"] = vpc_id

    @builtins.property
    def add_subnet_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The IDs of one or more subnets to add.

        You can specify at most one subnet per Availability Zone.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-addsubnetids
        '''
        result = self._values.get("add_subnet_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def options(self) -> typing.Any:
        '''The VPC attachment options.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-options
        '''
        result = self._values.get("options")
        return typing.cast(typing.Any, result)

    @builtins.property
    def remove_subnet_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The IDs of one or more subnets to remove.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-removesubnetids
        '''
        result = self._values.get("remove_subnet_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def subnet_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The IDs of the subnets.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-subnetids
        '''
        result = self._values.get("subnet_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags for the VPC attachment.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def transit_gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the transit gateway.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-transitgatewayid
        '''
        result = self._values.get("transit_gateway_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpc_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the VPC.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-vpcid
        '''
        result = self._values.get("vpc_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnTransitGatewayVpcAttachmentMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnTransitGatewayVpcAttachmentPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTransitGatewayVpcAttachmentPropsMixin",
):
    '''Specifies a VPC attachment.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html
    :cloudformationResource: AWS::EC2::TransitGatewayVpcAttachment
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        # options: Any
        
        cfn_transit_gateway_vpc_attachment_props_mixin = ec2_mixins.CfnTransitGatewayVpcAttachmentPropsMixin(ec2_mixins.CfnTransitGatewayVpcAttachmentMixinProps(
            add_subnet_ids=["addSubnetIds"],
            options=options,
            remove_subnet_ids=["removeSubnetIds"],
            subnet_ids=["subnetIds"],
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            transit_gateway_id="transitGatewayId",
            vpc_id="vpcId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnTransitGatewayVpcAttachmentMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::TransitGatewayVpcAttachment``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8388609bf434ff15ea27c7892eecc060de483d97ccab63f68b823cc0a48fecf7)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1bb789e27a0a5dee2eae55c3b878134f4d1c7505914f076b93aab1e35829b387)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9c974e3e4cab73dd75d253c2a8bfd147d95d9659e8aa1897b692c6501f04f63b)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnTransitGatewayVpcAttachmentMixinProps":
        return typing.cast("CfnTransitGatewayVpcAttachmentMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnTransitGatewayVpcAttachmentPropsMixin.OptionsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "appliance_mode_support": "applianceModeSupport",
            "dns_support": "dnsSupport",
            "ipv6_support": "ipv6Support",
            "security_group_referencing_support": "securityGroupReferencingSupport",
        },
    )
    class OptionsProperty:
        def __init__(
            self,
            *,
            appliance_mode_support: typing.Optional[builtins.str] = None,
            dns_support: typing.Optional[builtins.str] = None,
            ipv6_support: typing.Optional[builtins.str] = None,
            security_group_referencing_support: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes the VPC attachment options.

            :param appliance_mode_support: Enable or disable appliance mode support. The default is ``disable`` .
            :param dns_support: Enable or disable DNS support. The default is ``disable`` .
            :param ipv6_support: Enable or disable IPv6 support. The default is ``disable`` .
            :param security_group_referencing_support: Enables you to reference a security group across VPCs attached to a transit gateway (TGW). Use this option to simplify security group management and control of instance-to-instance traffic across VPCs that are connected by transit gateway. You can also use this option to migrate from VPC peering (which was the only option that supported security group referencing) to transit gateways (which now also support security group referencing). This option is disabled by default and there are no additional costs to use this feature. For important information about this feature, see `Create a transit gateway <https://docs.aws.amazon.com/vpc/latest/tgw/tgw-transit-gateways.html#create-tgw>`_ in the *AWS Transit Gateway Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayvpcattachment-options.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                options_property = ec2_mixins.CfnTransitGatewayVpcAttachmentPropsMixin.OptionsProperty(
                    appliance_mode_support="applianceModeSupport",
                    dns_support="dnsSupport",
                    ipv6_support="ipv6Support",
                    security_group_referencing_support="securityGroupReferencingSupport"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__fce0195e9aefe8f4e8eff0561ea402cab82ba8bb74e16fabcdcebe70642c1282)
                check_type(argname="argument appliance_mode_support", value=appliance_mode_support, expected_type=type_hints["appliance_mode_support"])
                check_type(argname="argument dns_support", value=dns_support, expected_type=type_hints["dns_support"])
                check_type(argname="argument ipv6_support", value=ipv6_support, expected_type=type_hints["ipv6_support"])
                check_type(argname="argument security_group_referencing_support", value=security_group_referencing_support, expected_type=type_hints["security_group_referencing_support"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if appliance_mode_support is not None:
                self._values["appliance_mode_support"] = appliance_mode_support
            if dns_support is not None:
                self._values["dns_support"] = dns_support
            if ipv6_support is not None:
                self._values["ipv6_support"] = ipv6_support
            if security_group_referencing_support is not None:
                self._values["security_group_referencing_support"] = security_group_referencing_support

        @builtins.property
        def appliance_mode_support(self) -> typing.Optional[builtins.str]:
            '''Enable or disable appliance mode support.

            The default is ``disable`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayvpcattachment-options.html#cfn-ec2-transitgatewayvpcattachment-options-appliancemodesupport
            '''
            result = self._values.get("appliance_mode_support")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def dns_support(self) -> typing.Optional[builtins.str]:
            '''Enable or disable DNS support.

            The default is ``disable`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayvpcattachment-options.html#cfn-ec2-transitgatewayvpcattachment-options-dnssupport
            '''
            result = self._values.get("dns_support")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def ipv6_support(self) -> typing.Optional[builtins.str]:
            '''Enable or disable IPv6 support.

            The default is ``disable`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayvpcattachment-options.html#cfn-ec2-transitgatewayvpcattachment-options-ipv6support
            '''
            result = self._values.get("ipv6_support")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def security_group_referencing_support(self) -> typing.Optional[builtins.str]:
            '''Enables you to reference a security group across VPCs attached to a transit gateway (TGW).

            Use this option to simplify security group management and control of instance-to-instance traffic across VPCs that are connected by transit gateway. You can also use this option to migrate from VPC peering (which was the only option that supported security group referencing) to transit gateways (which now also support security group referencing). This option is disabled by default and there are no additional costs to use this feature.

            For important information about this feature, see `Create a transit gateway <https://docs.aws.amazon.com/vpc/latest/tgw/tgw-transit-gateways.html#create-tgw>`_ in the *AWS Transit Gateway Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayvpcattachment-options.html#cfn-ec2-transitgatewayvpcattachment-options-securitygroupreferencingsupport
            '''
            result = self._values.get("security_group_referencing_support")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "OptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPCBlockPublicAccessExclusionMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "internet_gateway_exclusion_mode": "internetGatewayExclusionMode",
        "subnet_id": "subnetId",
        "tags": "tags",
        "vpc_id": "vpcId",
    },
)
class CfnVPCBlockPublicAccessExclusionMixinProps:
    def __init__(
        self,
        *,
        internet_gateway_exclusion_mode: typing.Optional[builtins.str] = None,
        subnet_id: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        vpc_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnVPCBlockPublicAccessExclusionPropsMixin.

        :param internet_gateway_exclusion_mode: The desired VPC Block Public Access mode for a specific VPC or subnet exclusion. - ``allow-bidirectional`` : Allow all internet traffic to and from the excluded VPCs and subnets. - ``allow-egress`` : Allow outbound internet traffic from the excluded VPCs and subnets. Block inbound internet traffic to the excluded VPCs and subnets. Only applies when VPC Block Public Access is set to ``block-bidirectional`` .
        :param subnet_id: The ID of the subnet you want to exclude. Required only if you don't specify VpcId.
        :param tags: An array of key-value pairs to apply to this resource.
        :param vpc_id: The ID of the VPC you want to exclude. Required only if you don't specify SubnetId.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcblockpublicaccessexclusion.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_vPCBlock_public_access_exclusion_mixin_props = ec2_mixins.CfnVPCBlockPublicAccessExclusionMixinProps(
                internet_gateway_exclusion_mode="internetGatewayExclusionMode",
                subnet_id="subnetId",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                vpc_id="vpcId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2462f2371f9976d39e27d934a8c71e50e0e41bf36e0ed7a8b0a58838ec393aa5)
            check_type(argname="argument internet_gateway_exclusion_mode", value=internet_gateway_exclusion_mode, expected_type=type_hints["internet_gateway_exclusion_mode"])
            check_type(argname="argument subnet_id", value=subnet_id, expected_type=type_hints["subnet_id"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument vpc_id", value=vpc_id, expected_type=type_hints["vpc_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if internet_gateway_exclusion_mode is not None:
            self._values["internet_gateway_exclusion_mode"] = internet_gateway_exclusion_mode
        if subnet_id is not None:
            self._values["subnet_id"] = subnet_id
        if tags is not None:
            self._values["tags"] = tags
        if vpc_id is not None:
            self._values["vpc_id"] = vpc_id

    @builtins.property
    def internet_gateway_exclusion_mode(self) -> typing.Optional[builtins.str]:
        '''The desired VPC Block Public Access mode for a specific VPC or subnet exclusion.

        - ``allow-bidirectional`` : Allow all internet traffic to and from the excluded VPCs and subnets.
        - ``allow-egress`` : Allow outbound internet traffic from the excluded VPCs and subnets. Block inbound internet traffic to the excluded VPCs and subnets. Only applies when VPC Block Public Access is set to ``block-bidirectional`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcblockpublicaccessexclusion.html#cfn-ec2-vpcblockpublicaccessexclusion-internetgatewayexclusionmode
        '''
        result = self._values.get("internet_gateway_exclusion_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def subnet_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the subnet you want to exclude.

        Required only if you don't specify VpcId.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcblockpublicaccessexclusion.html#cfn-ec2-vpcblockpublicaccessexclusion-subnetid
        '''
        result = self._values.get("subnet_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''An array of key-value pairs to apply to this resource.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcblockpublicaccessexclusion.html#cfn-ec2-vpcblockpublicaccessexclusion-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def vpc_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the VPC you want to exclude.

        Required only if you don't specify SubnetId.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcblockpublicaccessexclusion.html#cfn-ec2-vpcblockpublicaccessexclusion-vpcid
        '''
        result = self._values.get("vpc_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnVPCBlockPublicAccessExclusionMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnVPCBlockPublicAccessExclusionPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPCBlockPublicAccessExclusionPropsMixin",
):
    '''Create a VPC Block Public Access (BPA) exclusion.

    A VPC BPA exclusion is a mode that can be applied to a single VPC or subnet that exempts it from the accounts BPA mode and will allow bidirectional or egress-only access. You can create BPA exclusions for VPCs and subnets even when BPA is not enabled on the account to ensure that there is no traffic disruption to the exclusions when VPC BPA is turned on. To learn more about VPC BPA, see `Block public access to VPCs and subnets <https://docs.aws.amazon.com/vpc/latest/userguide/security-vpc-bpa.html>`_ in the *Amazon VPC User Guide* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcblockpublicaccessexclusion.html
    :cloudformationResource: AWS::EC2::VPCBlockPublicAccessExclusion
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_vPCBlock_public_access_exclusion_props_mixin = ec2_mixins.CfnVPCBlockPublicAccessExclusionPropsMixin(ec2_mixins.CfnVPCBlockPublicAccessExclusionMixinProps(
            internet_gateway_exclusion_mode="internetGatewayExclusionMode",
            subnet_id="subnetId",
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            vpc_id="vpcId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnVPCBlockPublicAccessExclusionMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::VPCBlockPublicAccessExclusion``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0b33c36cb443589e1b1d91fbca135d7190a23c3a01f9f32035736983732edad2)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4f44dadd5ef35c404c22e16f970ca4af8a756f50136704849691d7d8f8f63b53)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f72f461191175accb04457b0065b1b85d48b80bd91a7dab6d48f256c8b533353)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnVPCBlockPublicAccessExclusionMixinProps":
        return typing.cast("CfnVPCBlockPublicAccessExclusionMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPCBlockPublicAccessOptionsMixinProps",
    jsii_struct_bases=[],
    name_mapping={"internet_gateway_block_mode": "internetGatewayBlockMode"},
)
class CfnVPCBlockPublicAccessOptionsMixinProps:
    def __init__(
        self,
        *,
        internet_gateway_block_mode: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnVPCBlockPublicAccessOptionsPropsMixin.

        :param internet_gateway_block_mode: The desired VPC Block Public Access mode for internet gateways in your account. We do not allow you to create this resource type in an "off" mode since off is the default value. - ``block-bidirectional`` : Block all traffic to and from internet gateways and egress-only internet gateways in this Region (except for excluded VPCs and subnets). - ``block-ingress`` : Block all internet traffic to the VPCs in this Region (except for VPCs or subnets which are excluded). Only traffic to and from NAT gateways and egress-only internet gateways is allowed because these gateways only allow outbound connections to be established.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcblockpublicaccessoptions.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_vPCBlock_public_access_options_mixin_props = ec2_mixins.CfnVPCBlockPublicAccessOptionsMixinProps(
                internet_gateway_block_mode="internetGatewayBlockMode"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b2202abd4805207696b1d333fb54a66e2a44b6eab0a70410f00c2973a42d6b7a)
            check_type(argname="argument internet_gateway_block_mode", value=internet_gateway_block_mode, expected_type=type_hints["internet_gateway_block_mode"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if internet_gateway_block_mode is not None:
            self._values["internet_gateway_block_mode"] = internet_gateway_block_mode

    @builtins.property
    def internet_gateway_block_mode(self) -> typing.Optional[builtins.str]:
        '''The desired VPC Block Public Access mode for internet gateways in your account.

        We do not allow you to create this resource type in an "off" mode since off is the default value.

        - ``block-bidirectional`` : Block all traffic to and from internet gateways and egress-only internet gateways in this Region (except for excluded VPCs and subnets).
        - ``block-ingress`` : Block all internet traffic to the VPCs in this Region (except for VPCs or subnets which are excluded). Only traffic to and from NAT gateways and egress-only internet gateways is allowed because these gateways only allow outbound connections to be established.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcblockpublicaccessoptions.html#cfn-ec2-vpcblockpublicaccessoptions-internetgatewayblockmode
        '''
        result = self._values.get("internet_gateway_block_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnVPCBlockPublicAccessOptionsMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnVPCBlockPublicAccessOptionsPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPCBlockPublicAccessOptionsPropsMixin",
):
    '''VPC Block Public Access (BPA) enables you to block resources in VPCs and subnets that you own in a Region from reaching or being reached from the internet through internet gateways and egress-only internet gateways.

    To learn more about VPC BPA, see `Block public access to VPCs and subnets <https://docs.aws.amazon.com/vpc/latest/userguide/security-vpc-bpa.html>`_ in the *Amazon VPC User Guide* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcblockpublicaccessoptions.html
    :cloudformationResource: AWS::EC2::VPCBlockPublicAccessOptions
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_vPCBlock_public_access_options_props_mixin = ec2_mixins.CfnVPCBlockPublicAccessOptionsPropsMixin(ec2_mixins.CfnVPCBlockPublicAccessOptionsMixinProps(
            internet_gateway_block_mode="internetGatewayBlockMode"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnVPCBlockPublicAccessOptionsMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::VPCBlockPublicAccessOptions``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b269b067c01263243b7246eb108a608f1723c6a81da06fbf607b02e5de0f585e)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4e31ffe2ebd46af975ed424c636462c891b393e9fd94c97b485b80b1303c1aed)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0df69515c2758726c9de3723736f82004424304ff5889cf5e3b309b93be638cb)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnVPCBlockPublicAccessOptionsMixinProps":
        return typing.cast("CfnVPCBlockPublicAccessOptionsMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPCCidrBlockMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "amazon_provided_ipv6_cidr_block": "amazonProvidedIpv6CidrBlock",
        "cidr_block": "cidrBlock",
        "ipv4_ipam_pool_id": "ipv4IpamPoolId",
        "ipv4_netmask_length": "ipv4NetmaskLength",
        "ipv6_cidr_block": "ipv6CidrBlock",
        "ipv6_cidr_block_network_border_group": "ipv6CidrBlockNetworkBorderGroup",
        "ipv6_ipam_pool_id": "ipv6IpamPoolId",
        "ipv6_netmask_length": "ipv6NetmaskLength",
        "ipv6_pool": "ipv6Pool",
        "vpc_id": "vpcId",
    },
)
class CfnVPCCidrBlockMixinProps:
    def __init__(
        self,
        *,
        amazon_provided_ipv6_cidr_block: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        cidr_block: typing.Optional[builtins.str] = None,
        ipv4_ipam_pool_id: typing.Optional[builtins.str] = None,
        ipv4_netmask_length: typing.Optional[jsii.Number] = None,
        ipv6_cidr_block: typing.Optional[builtins.str] = None,
        ipv6_cidr_block_network_border_group: typing.Optional[builtins.str] = None,
        ipv6_ipam_pool_id: typing.Optional[builtins.str] = None,
        ipv6_netmask_length: typing.Optional[jsii.Number] = None,
        ipv6_pool: typing.Optional[builtins.str] = None,
        vpc_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnVPCCidrBlockPropsMixin.

        :param amazon_provided_ipv6_cidr_block: Requests an Amazon-provided IPv6 CIDR block with a /56 prefix length for the VPC. You cannot specify the range of IPv6 addresses or the size of the CIDR block.
        :param cidr_block: An IPv4 CIDR block to associate with the VPC.
        :param ipv4_ipam_pool_id: Associate a CIDR allocated from an IPv4 IPAM pool to a VPC. For more information about Amazon VPC IP Address Manager (IPAM), see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .
        :param ipv4_netmask_length: The netmask length of the IPv4 CIDR you would like to associate from an Amazon VPC IP Address Manager (IPAM) pool. For more information about IPAM, see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .
        :param ipv6_cidr_block: An IPv6 CIDR block from the IPv6 address pool. You must also specify ``Ipv6Pool`` in the request. To let Amazon choose the IPv6 CIDR block for you, omit this parameter.
        :param ipv6_cidr_block_network_border_group: The name of the location from which we advertise the IPV6 CIDR block. Use this parameter to limit the CIDR block to this location. You must set ``AmazonProvidedIpv6CidrBlock`` to ``true`` to use this parameter. You can have one IPv6 CIDR block association per network border group.
        :param ipv6_ipam_pool_id: Associates a CIDR allocated from an IPv6 IPAM pool to a VPC. For more information about Amazon VPC IP Address Manager (IPAM), see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .
        :param ipv6_netmask_length: The netmask length of the IPv6 CIDR you would like to associate from an Amazon VPC IP Address Manager (IPAM) pool. For more information about IPAM, see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .
        :param ipv6_pool: The ID of an IPv6 address pool from which to allocate the IPv6 CIDR block.
        :param vpc_id: The ID of the VPC.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_vPCCidr_block_mixin_props = ec2_mixins.CfnVPCCidrBlockMixinProps(
                amazon_provided_ipv6_cidr_block=False,
                cidr_block="cidrBlock",
                ipv4_ipam_pool_id="ipv4IpamPoolId",
                ipv4_netmask_length=123,
                ipv6_cidr_block="ipv6CidrBlock",
                ipv6_cidr_block_network_border_group="ipv6CidrBlockNetworkBorderGroup",
                ipv6_ipam_pool_id="ipv6IpamPoolId",
                ipv6_netmask_length=123,
                ipv6_pool="ipv6Pool",
                vpc_id="vpcId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cedc65c831e938332ea4497119893e59a8cbeb73ac6549d57b68114fa80a6ba7)
            check_type(argname="argument amazon_provided_ipv6_cidr_block", value=amazon_provided_ipv6_cidr_block, expected_type=type_hints["amazon_provided_ipv6_cidr_block"])
            check_type(argname="argument cidr_block", value=cidr_block, expected_type=type_hints["cidr_block"])
            check_type(argname="argument ipv4_ipam_pool_id", value=ipv4_ipam_pool_id, expected_type=type_hints["ipv4_ipam_pool_id"])
            check_type(argname="argument ipv4_netmask_length", value=ipv4_netmask_length, expected_type=type_hints["ipv4_netmask_length"])
            check_type(argname="argument ipv6_cidr_block", value=ipv6_cidr_block, expected_type=type_hints["ipv6_cidr_block"])
            check_type(argname="argument ipv6_cidr_block_network_border_group", value=ipv6_cidr_block_network_border_group, expected_type=type_hints["ipv6_cidr_block_network_border_group"])
            check_type(argname="argument ipv6_ipam_pool_id", value=ipv6_ipam_pool_id, expected_type=type_hints["ipv6_ipam_pool_id"])
            check_type(argname="argument ipv6_netmask_length", value=ipv6_netmask_length, expected_type=type_hints["ipv6_netmask_length"])
            check_type(argname="argument ipv6_pool", value=ipv6_pool, expected_type=type_hints["ipv6_pool"])
            check_type(argname="argument vpc_id", value=vpc_id, expected_type=type_hints["vpc_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if amazon_provided_ipv6_cidr_block is not None:
            self._values["amazon_provided_ipv6_cidr_block"] = amazon_provided_ipv6_cidr_block
        if cidr_block is not None:
            self._values["cidr_block"] = cidr_block
        if ipv4_ipam_pool_id is not None:
            self._values["ipv4_ipam_pool_id"] = ipv4_ipam_pool_id
        if ipv4_netmask_length is not None:
            self._values["ipv4_netmask_length"] = ipv4_netmask_length
        if ipv6_cidr_block is not None:
            self._values["ipv6_cidr_block"] = ipv6_cidr_block
        if ipv6_cidr_block_network_border_group is not None:
            self._values["ipv6_cidr_block_network_border_group"] = ipv6_cidr_block_network_border_group
        if ipv6_ipam_pool_id is not None:
            self._values["ipv6_ipam_pool_id"] = ipv6_ipam_pool_id
        if ipv6_netmask_length is not None:
            self._values["ipv6_netmask_length"] = ipv6_netmask_length
        if ipv6_pool is not None:
            self._values["ipv6_pool"] = ipv6_pool
        if vpc_id is not None:
            self._values["vpc_id"] = vpc_id

    @builtins.property
    def amazon_provided_ipv6_cidr_block(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Requests an Amazon-provided IPv6 CIDR block with a /56 prefix length for the VPC.

        You cannot specify the range of IPv6 addresses or the size of the CIDR block.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-amazonprovidedipv6cidrblock
        '''
        result = self._values.get("amazon_provided_ipv6_cidr_block")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def cidr_block(self) -> typing.Optional[builtins.str]:
        '''An IPv4 CIDR block to associate with the VPC.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-cidrblock
        '''
        result = self._values.get("cidr_block")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ipv4_ipam_pool_id(self) -> typing.Optional[builtins.str]:
        '''Associate a CIDR allocated from an IPv4 IPAM pool to a VPC.

        For more information about Amazon VPC IP Address Manager (IPAM), see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv4ipampoolid
        '''
        result = self._values.get("ipv4_ipam_pool_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ipv4_netmask_length(self) -> typing.Optional[jsii.Number]:
        '''The netmask length of the IPv4 CIDR you would like to associate from an Amazon VPC IP Address Manager (IPAM) pool.

        For more information about IPAM, see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv4netmasklength
        '''
        result = self._values.get("ipv4_netmask_length")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def ipv6_cidr_block(self) -> typing.Optional[builtins.str]:
        '''An IPv6 CIDR block from the IPv6 address pool. You must also specify ``Ipv6Pool`` in the request.

        To let Amazon choose the IPv6 CIDR block for you, omit this parameter.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv6cidrblock
        '''
        result = self._values.get("ipv6_cidr_block")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ipv6_cidr_block_network_border_group(self) -> typing.Optional[builtins.str]:
        '''The name of the location from which we advertise the IPV6 CIDR block.

        Use this parameter to limit the CIDR block to this location.

        You must set ``AmazonProvidedIpv6CidrBlock`` to ``true`` to use this parameter.

        You can have one IPv6 CIDR block association per network border group.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv6cidrblocknetworkbordergroup
        '''
        result = self._values.get("ipv6_cidr_block_network_border_group")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ipv6_ipam_pool_id(self) -> typing.Optional[builtins.str]:
        '''Associates a CIDR allocated from an IPv6 IPAM pool to a VPC.

        For more information about Amazon VPC IP Address Manager (IPAM), see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv6ipampoolid
        '''
        result = self._values.get("ipv6_ipam_pool_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ipv6_netmask_length(self) -> typing.Optional[jsii.Number]:
        '''The netmask length of the IPv6 CIDR you would like to associate from an Amazon VPC IP Address Manager (IPAM) pool.

        For more information about IPAM, see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv6netmasklength
        '''
        result = self._values.get("ipv6_netmask_length")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def ipv6_pool(self) -> typing.Optional[builtins.str]:
        '''The ID of an IPv6 address pool from which to allocate the IPv6 CIDR block.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv6pool
        '''
        result = self._values.get("ipv6_pool")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpc_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the VPC.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-vpcid
        '''
        result = self._values.get("vpc_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnVPCCidrBlockMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnVPCCidrBlockPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPCCidrBlockPropsMixin",
):
    '''Associates a CIDR block with your VPC.

    A VPC must have an associated IPv4 CIDR block. You can optionally associate additional IPv4 CIDR blocks with a VPC. You can optionally associate an IPv6 CIDR block with a VPC. You can request an Amazon-provided IPv6 CIDR block from Amazon's pool of IPv6 addresses, or an IPv6 CIDR block from an IPv6 address pool that you provisioned through bring your own IP addresses (BYOIP).

    For more information, see `VPC CIDR blocks <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-cidr-blocks.html>`_ in the *Amazon VPC User Guide* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html
    :cloudformationResource: AWS::EC2::VPCCidrBlock
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_vPCCidr_block_props_mixin = ec2_mixins.CfnVPCCidrBlockPropsMixin(ec2_mixins.CfnVPCCidrBlockMixinProps(
            amazon_provided_ipv6_cidr_block=False,
            cidr_block="cidrBlock",
            ipv4_ipam_pool_id="ipv4IpamPoolId",
            ipv4_netmask_length=123,
            ipv6_cidr_block="ipv6CidrBlock",
            ipv6_cidr_block_network_border_group="ipv6CidrBlockNetworkBorderGroup",
            ipv6_ipam_pool_id="ipv6IpamPoolId",
            ipv6_netmask_length=123,
            ipv6_pool="ipv6Pool",
            vpc_id="vpcId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnVPCCidrBlockMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::VPCCidrBlock``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b6d9b5615428faedd42b7c8d0ea790427ca9773250958803c98c7aba4542b517)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b239738bf54ef21fe8a7e11ffb1a17d79f93913552a1207bffe8787f0649356b)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ab7b2fef379165a8df78f5c4d0135192261e3f90b9aa16b4399527d64f1cd7e5)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnVPCCidrBlockMixinProps":
        return typing.cast("CfnVPCCidrBlockMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPCDHCPOptionsAssociationMixinProps",
    jsii_struct_bases=[],
    name_mapping={"dhcp_options_id": "dhcpOptionsId", "vpc_id": "vpcId"},
)
class CfnVPCDHCPOptionsAssociationMixinProps:
    def __init__(
        self,
        *,
        dhcp_options_id: typing.Optional[builtins.str] = None,
        vpc_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnVPCDHCPOptionsAssociationPropsMixin.

        :param dhcp_options_id: The ID of the DHCP options set, or ``default`` to associate no DHCP options with the VPC.
        :param vpc_id: The ID of the VPC.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcdhcpoptionsassociation.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_vPCDHCPOptions_association_mixin_props = ec2_mixins.CfnVPCDHCPOptionsAssociationMixinProps(
                dhcp_options_id="dhcpOptionsId",
                vpc_id="vpcId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__980c7775cd7004fe2f3481bc54743c4fa1978913ca3bdeae60560583c6ef597d)
            check_type(argname="argument dhcp_options_id", value=dhcp_options_id, expected_type=type_hints["dhcp_options_id"])
            check_type(argname="argument vpc_id", value=vpc_id, expected_type=type_hints["vpc_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if dhcp_options_id is not None:
            self._values["dhcp_options_id"] = dhcp_options_id
        if vpc_id is not None:
            self._values["vpc_id"] = vpc_id

    @builtins.property
    def dhcp_options_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the DHCP options set, or ``default`` to associate no DHCP options with the VPC.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcdhcpoptionsassociation.html#cfn-ec2-vpcdhcpoptionsassociation-dhcpoptionsid
        '''
        result = self._values.get("dhcp_options_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpc_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the VPC.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcdhcpoptionsassociation.html#cfn-ec2-vpcdhcpoptionsassociation-vpcid
        '''
        result = self._values.get("vpc_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnVPCDHCPOptionsAssociationMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnVPCDHCPOptionsAssociationPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPCDHCPOptionsAssociationPropsMixin",
):
    '''Associates a set of DHCP options with a VPC, or associates no DHCP options with the VPC.

    After you associate the options with the VPC, any existing instances and all new instances that you launch in that VPC use the options. You don't need to restart or relaunch the instances. They automatically pick up the changes within a few hours, depending on how frequently the instance renews its DHCP lease. You can explicitly renew the lease using the operating system on the instance.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcdhcpoptionsassociation.html
    :cloudformationResource: AWS::EC2::VPCDHCPOptionsAssociation
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_vPCDHCPOptions_association_props_mixin = ec2_mixins.CfnVPCDHCPOptionsAssociationPropsMixin(ec2_mixins.CfnVPCDHCPOptionsAssociationMixinProps(
            dhcp_options_id="dhcpOptionsId",
            vpc_id="vpcId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnVPCDHCPOptionsAssociationMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::VPCDHCPOptionsAssociation``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eee4a0e40fbfd617f61a84677475de97f3a67a459f2bcfaf12e997480fb62aaf)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c050e40460c90d92e714d5339aa1bde0a5451e203efed6a370f5b991e4e8876e)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__170c8e8c19d0872dc3ec9ebccbf427dfb8f61a30cf8fd3e6740fe4c42fc97b47)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnVPCDHCPOptionsAssociationMixinProps":
        return typing.cast("CfnVPCDHCPOptionsAssociationMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPCEncryptionControlMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "egress_only_internet_gateway_exclusion_input": "egressOnlyInternetGatewayExclusionInput",
        "elastic_file_system_exclusion_input": "elasticFileSystemExclusionInput",
        "internet_gateway_exclusion_input": "internetGatewayExclusionInput",
        "lambda_exclusion_input": "lambdaExclusionInput",
        "mode": "mode",
        "nat_gateway_exclusion_input": "natGatewayExclusionInput",
        "tags": "tags",
        "virtual_private_gateway_exclusion_input": "virtualPrivateGatewayExclusionInput",
        "vpc_id": "vpcId",
        "vpc_lattice_exclusion_input": "vpcLatticeExclusionInput",
        "vpc_peering_exclusion_input": "vpcPeeringExclusionInput",
    },
)
class CfnVPCEncryptionControlMixinProps:
    def __init__(
        self,
        *,
        egress_only_internet_gateway_exclusion_input: typing.Optional[builtins.str] = None,
        elastic_file_system_exclusion_input: typing.Optional[builtins.str] = None,
        internet_gateway_exclusion_input: typing.Optional[builtins.str] = None,
        lambda_exclusion_input: typing.Optional[builtins.str] = None,
        mode: typing.Optional[builtins.str] = None,
        nat_gateway_exclusion_input: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        virtual_private_gateway_exclusion_input: typing.Optional[builtins.str] = None,
        vpc_id: typing.Optional[builtins.str] = None,
        vpc_lattice_exclusion_input: typing.Optional[builtins.str] = None,
        vpc_peering_exclusion_input: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnVPCEncryptionControlPropsMixin.

        :param egress_only_internet_gateway_exclusion_input: Specifies whether to exclude egress-only internet gateway traffic from encryption enforcement.
        :param elastic_file_system_exclusion_input: Specifies whether to exclude Elastic File System traffic from encryption enforcement.
        :param internet_gateway_exclusion_input: Specifies whether to exclude internet gateway traffic from encryption enforcement.
        :param lambda_exclusion_input: Specifies whether to exclude Lambda function traffic from encryption enforcement.
        :param mode: The encryption mode for the VPC Encryption Control configuration.
        :param nat_gateway_exclusion_input: Specifies whether to exclude NAT gateway traffic from encryption enforcement.
        :param tags: The tags assigned to the VPC Encryption Control configuration.
        :param virtual_private_gateway_exclusion_input: Specifies whether to exclude virtual private gateway traffic from encryption enforcement.
        :param vpc_id: The ID of the VPC for which to create the encryption control configuration.
        :param vpc_lattice_exclusion_input: Specifies whether to exclude VPC Lattice traffic from encryption enforcement.
        :param vpc_peering_exclusion_input: Specifies whether to exclude VPC peering connection traffic from encryption enforcement.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcencryptioncontrol.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_vPCEncryption_control_mixin_props = ec2_mixins.CfnVPCEncryptionControlMixinProps(
                egress_only_internet_gateway_exclusion_input="egressOnlyInternetGatewayExclusionInput",
                elastic_file_system_exclusion_input="elasticFileSystemExclusionInput",
                internet_gateway_exclusion_input="internetGatewayExclusionInput",
                lambda_exclusion_input="lambdaExclusionInput",
                mode="mode",
                nat_gateway_exclusion_input="natGatewayExclusionInput",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                virtual_private_gateway_exclusion_input="virtualPrivateGatewayExclusionInput",
                vpc_id="vpcId",
                vpc_lattice_exclusion_input="vpcLatticeExclusionInput",
                vpc_peering_exclusion_input="vpcPeeringExclusionInput"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dd66031af79bba638475a35c56d5370532c56e5a4c5fb9eb0da7bcd75070a5b4)
            check_type(argname="argument egress_only_internet_gateway_exclusion_input", value=egress_only_internet_gateway_exclusion_input, expected_type=type_hints["egress_only_internet_gateway_exclusion_input"])
            check_type(argname="argument elastic_file_system_exclusion_input", value=elastic_file_system_exclusion_input, expected_type=type_hints["elastic_file_system_exclusion_input"])
            check_type(argname="argument internet_gateway_exclusion_input", value=internet_gateway_exclusion_input, expected_type=type_hints["internet_gateway_exclusion_input"])
            check_type(argname="argument lambda_exclusion_input", value=lambda_exclusion_input, expected_type=type_hints["lambda_exclusion_input"])
            check_type(argname="argument mode", value=mode, expected_type=type_hints["mode"])
            check_type(argname="argument nat_gateway_exclusion_input", value=nat_gateway_exclusion_input, expected_type=type_hints["nat_gateway_exclusion_input"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument virtual_private_gateway_exclusion_input", value=virtual_private_gateway_exclusion_input, expected_type=type_hints["virtual_private_gateway_exclusion_input"])
            check_type(argname="argument vpc_id", value=vpc_id, expected_type=type_hints["vpc_id"])
            check_type(argname="argument vpc_lattice_exclusion_input", value=vpc_lattice_exclusion_input, expected_type=type_hints["vpc_lattice_exclusion_input"])
            check_type(argname="argument vpc_peering_exclusion_input", value=vpc_peering_exclusion_input, expected_type=type_hints["vpc_peering_exclusion_input"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if egress_only_internet_gateway_exclusion_input is not None:
            self._values["egress_only_internet_gateway_exclusion_input"] = egress_only_internet_gateway_exclusion_input
        if elastic_file_system_exclusion_input is not None:
            self._values["elastic_file_system_exclusion_input"] = elastic_file_system_exclusion_input
        if internet_gateway_exclusion_input is not None:
            self._values["internet_gateway_exclusion_input"] = internet_gateway_exclusion_input
        if lambda_exclusion_input is not None:
            self._values["lambda_exclusion_input"] = lambda_exclusion_input
        if mode is not None:
            self._values["mode"] = mode
        if nat_gateway_exclusion_input is not None:
            self._values["nat_gateway_exclusion_input"] = nat_gateway_exclusion_input
        if tags is not None:
            self._values["tags"] = tags
        if virtual_private_gateway_exclusion_input is not None:
            self._values["virtual_private_gateway_exclusion_input"] = virtual_private_gateway_exclusion_input
        if vpc_id is not None:
            self._values["vpc_id"] = vpc_id
        if vpc_lattice_exclusion_input is not None:
            self._values["vpc_lattice_exclusion_input"] = vpc_lattice_exclusion_input
        if vpc_peering_exclusion_input is not None:
            self._values["vpc_peering_exclusion_input"] = vpc_peering_exclusion_input

    @builtins.property
    def egress_only_internet_gateway_exclusion_input(
        self,
    ) -> typing.Optional[builtins.str]:
        '''Specifies whether to exclude egress-only internet gateway traffic from encryption enforcement.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcencryptioncontrol.html#cfn-ec2-vpcencryptioncontrol-egressonlyinternetgatewayexclusioninput
        '''
        result = self._values.get("egress_only_internet_gateway_exclusion_input")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def elastic_file_system_exclusion_input(self) -> typing.Optional[builtins.str]:
        '''Specifies whether to exclude Elastic File System traffic from encryption enforcement.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcencryptioncontrol.html#cfn-ec2-vpcencryptioncontrol-elasticfilesystemexclusioninput
        '''
        result = self._values.get("elastic_file_system_exclusion_input")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def internet_gateway_exclusion_input(self) -> typing.Optional[builtins.str]:
        '''Specifies whether to exclude internet gateway traffic from encryption enforcement.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcencryptioncontrol.html#cfn-ec2-vpcencryptioncontrol-internetgatewayexclusioninput
        '''
        result = self._values.get("internet_gateway_exclusion_input")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def lambda_exclusion_input(self) -> typing.Optional[builtins.str]:
        '''Specifies whether to exclude Lambda function traffic from encryption enforcement.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcencryptioncontrol.html#cfn-ec2-vpcencryptioncontrol-lambdaexclusioninput
        '''
        result = self._values.get("lambda_exclusion_input")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def mode(self) -> typing.Optional[builtins.str]:
        '''The encryption mode for the VPC Encryption Control configuration.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcencryptioncontrol.html#cfn-ec2-vpcencryptioncontrol-mode
        '''
        result = self._values.get("mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def nat_gateway_exclusion_input(self) -> typing.Optional[builtins.str]:
        '''Specifies whether to exclude NAT gateway traffic from encryption enforcement.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcencryptioncontrol.html#cfn-ec2-vpcencryptioncontrol-natgatewayexclusioninput
        '''
        result = self._values.get("nat_gateway_exclusion_input")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags assigned to the VPC Encryption Control configuration.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcencryptioncontrol.html#cfn-ec2-vpcencryptioncontrol-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def virtual_private_gateway_exclusion_input(self) -> typing.Optional[builtins.str]:
        '''Specifies whether to exclude virtual private gateway traffic from encryption enforcement.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcencryptioncontrol.html#cfn-ec2-vpcencryptioncontrol-virtualprivategatewayexclusioninput
        '''
        result = self._values.get("virtual_private_gateway_exclusion_input")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpc_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the VPC for which to create the encryption control configuration.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcencryptioncontrol.html#cfn-ec2-vpcencryptioncontrol-vpcid
        '''
        result = self._values.get("vpc_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpc_lattice_exclusion_input(self) -> typing.Optional[builtins.str]:
        '''Specifies whether to exclude VPC Lattice traffic from encryption enforcement.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcencryptioncontrol.html#cfn-ec2-vpcencryptioncontrol-vpclatticeexclusioninput
        '''
        result = self._values.get("vpc_lattice_exclusion_input")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpc_peering_exclusion_input(self) -> typing.Optional[builtins.str]:
        '''Specifies whether to exclude VPC peering connection traffic from encryption enforcement.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcencryptioncontrol.html#cfn-ec2-vpcencryptioncontrol-vpcpeeringexclusioninput
        '''
        result = self._values.get("vpc_peering_exclusion_input")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnVPCEncryptionControlMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnVPCEncryptionControlPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPCEncryptionControlPropsMixin",
):
    '''Describes the configuration and state of VPC encryption controls.

    For more information, see `Enforce VPC encryption in transit <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-encryption-controls.html>`_ in the *Amazon VPC User Guide* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcencryptioncontrol.html
    :cloudformationResource: AWS::EC2::VPCEncryptionControl
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_vPCEncryption_control_props_mixin = ec2_mixins.CfnVPCEncryptionControlPropsMixin(ec2_mixins.CfnVPCEncryptionControlMixinProps(
            egress_only_internet_gateway_exclusion_input="egressOnlyInternetGatewayExclusionInput",
            elastic_file_system_exclusion_input="elasticFileSystemExclusionInput",
            internet_gateway_exclusion_input="internetGatewayExclusionInput",
            lambda_exclusion_input="lambdaExclusionInput",
            mode="mode",
            nat_gateway_exclusion_input="natGatewayExclusionInput",
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            virtual_private_gateway_exclusion_input="virtualPrivateGatewayExclusionInput",
            vpc_id="vpcId",
            vpc_lattice_exclusion_input="vpcLatticeExclusionInput",
            vpc_peering_exclusion_input="vpcPeeringExclusionInput"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnVPCEncryptionControlMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::VPCEncryptionControl``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__934db54e0e0debd1212bc8914636c6058ddd17302af1742db94e0cfa7b56663b)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4c9937ad1ecd79b9fe1d4af47bcef2252a9fa2471e6f48a5ec8820b969359b83)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3d343fc1ad331171425769a475e5aa31defdae5ea8b97d6a0173ba09e3976228)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnVPCEncryptionControlMixinProps":
        return typing.cast("CfnVPCEncryptionControlMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPCEncryptionControlPropsMixin.ResourceExclusionsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "egress_only_internet_gateway": "egressOnlyInternetGateway",
            "elastic_file_system": "elasticFileSystem",
            "internet_gateway": "internetGateway",
            "lambda_": "lambda",
            "nat_gateway": "natGateway",
            "virtual_private_gateway": "virtualPrivateGateway",
            "vpc_lattice": "vpcLattice",
            "vpc_peering": "vpcPeering",
        },
    )
    class ResourceExclusionsProperty:
        def __init__(
            self,
            *,
            egress_only_internet_gateway: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnVPCEncryptionControlPropsMixin.VpcEncryptionControlExclusionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            elastic_file_system: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnVPCEncryptionControlPropsMixin.VpcEncryptionControlExclusionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            internet_gateway: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnVPCEncryptionControlPropsMixin.VpcEncryptionControlExclusionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            lambda_: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnVPCEncryptionControlPropsMixin.VpcEncryptionControlExclusionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            nat_gateway: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnVPCEncryptionControlPropsMixin.VpcEncryptionControlExclusionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            virtual_private_gateway: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnVPCEncryptionControlPropsMixin.VpcEncryptionControlExclusionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            vpc_lattice: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnVPCEncryptionControlPropsMixin.VpcEncryptionControlExclusionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            vpc_peering: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnVPCEncryptionControlPropsMixin.VpcEncryptionControlExclusionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Information about resource exclusions for the VPC Encryption Control configuration.

            :param egress_only_internet_gateway: Specifies whether to exclude egress-only internet gateway traffic from encryption enforcement.
            :param elastic_file_system: Specifies whether to exclude Elastic File System traffic from encryption enforcement.
            :param internet_gateway: Specifies whether to exclude internet gateway traffic from encryption enforcement.
            :param lambda_: Specifies whether to exclude Lambda function traffic from encryption enforcement.
            :param nat_gateway: Specifies whether to exclude NAT gateway traffic from encryption enforcement.
            :param virtual_private_gateway: Specifies whether to exclude virtual private gateway traffic from encryption enforcement.
            :param vpc_lattice: Specifies whether to exclude VPC Lattice traffic from encryption enforcement.
            :param vpc_peering: Specifies whether to exclude VPC peering connection traffic from encryption enforcement.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpcencryptioncontrol-resourceexclusions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                resource_exclusions_property = ec2_mixins.CfnVPCEncryptionControlPropsMixin.ResourceExclusionsProperty(
                    egress_only_internet_gateway=ec2_mixins.CfnVPCEncryptionControlPropsMixin.VpcEncryptionControlExclusionProperty(
                        state="state",
                        state_message="stateMessage"
                    ),
                    elastic_file_system=ec2_mixins.CfnVPCEncryptionControlPropsMixin.VpcEncryptionControlExclusionProperty(
                        state="state",
                        state_message="stateMessage"
                    ),
                    internet_gateway=ec2_mixins.CfnVPCEncryptionControlPropsMixin.VpcEncryptionControlExclusionProperty(
                        state="state",
                        state_message="stateMessage"
                    ),
                    lambda_=ec2_mixins.CfnVPCEncryptionControlPropsMixin.VpcEncryptionControlExclusionProperty(
                        state="state",
                        state_message="stateMessage"
                    ),
                    nat_gateway=ec2_mixins.CfnVPCEncryptionControlPropsMixin.VpcEncryptionControlExclusionProperty(
                        state="state",
                        state_message="stateMessage"
                    ),
                    virtual_private_gateway=ec2_mixins.CfnVPCEncryptionControlPropsMixin.VpcEncryptionControlExclusionProperty(
                        state="state",
                        state_message="stateMessage"
                    ),
                    vpc_lattice=ec2_mixins.CfnVPCEncryptionControlPropsMixin.VpcEncryptionControlExclusionProperty(
                        state="state",
                        state_message="stateMessage"
                    ),
                    vpc_peering=ec2_mixins.CfnVPCEncryptionControlPropsMixin.VpcEncryptionControlExclusionProperty(
                        state="state",
                        state_message="stateMessage"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__efa550c9c9bc1b33892f97305c641aa0eaad112c61487138db4847777bb189f9)
                check_type(argname="argument egress_only_internet_gateway", value=egress_only_internet_gateway, expected_type=type_hints["egress_only_internet_gateway"])
                check_type(argname="argument elastic_file_system", value=elastic_file_system, expected_type=type_hints["elastic_file_system"])
                check_type(argname="argument internet_gateway", value=internet_gateway, expected_type=type_hints["internet_gateway"])
                check_type(argname="argument lambda_", value=lambda_, expected_type=type_hints["lambda_"])
                check_type(argname="argument nat_gateway", value=nat_gateway, expected_type=type_hints["nat_gateway"])
                check_type(argname="argument virtual_private_gateway", value=virtual_private_gateway, expected_type=type_hints["virtual_private_gateway"])
                check_type(argname="argument vpc_lattice", value=vpc_lattice, expected_type=type_hints["vpc_lattice"])
                check_type(argname="argument vpc_peering", value=vpc_peering, expected_type=type_hints["vpc_peering"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if egress_only_internet_gateway is not None:
                self._values["egress_only_internet_gateway"] = egress_only_internet_gateway
            if elastic_file_system is not None:
                self._values["elastic_file_system"] = elastic_file_system
            if internet_gateway is not None:
                self._values["internet_gateway"] = internet_gateway
            if lambda_ is not None:
                self._values["lambda_"] = lambda_
            if nat_gateway is not None:
                self._values["nat_gateway"] = nat_gateway
            if virtual_private_gateway is not None:
                self._values["virtual_private_gateway"] = virtual_private_gateway
            if vpc_lattice is not None:
                self._values["vpc_lattice"] = vpc_lattice
            if vpc_peering is not None:
                self._values["vpc_peering"] = vpc_peering

        @builtins.property
        def egress_only_internet_gateway(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVPCEncryptionControlPropsMixin.VpcEncryptionControlExclusionProperty"]]:
            '''Specifies whether to exclude egress-only internet gateway traffic from encryption enforcement.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpcencryptioncontrol-resourceexclusions.html#cfn-ec2-vpcencryptioncontrol-resourceexclusions-egressonlyinternetgateway
            '''
            result = self._values.get("egress_only_internet_gateway")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVPCEncryptionControlPropsMixin.VpcEncryptionControlExclusionProperty"]], result)

        @builtins.property
        def elastic_file_system(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVPCEncryptionControlPropsMixin.VpcEncryptionControlExclusionProperty"]]:
            '''Specifies whether to exclude Elastic File System traffic from encryption enforcement.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpcencryptioncontrol-resourceexclusions.html#cfn-ec2-vpcencryptioncontrol-resourceexclusions-elasticfilesystem
            '''
            result = self._values.get("elastic_file_system")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVPCEncryptionControlPropsMixin.VpcEncryptionControlExclusionProperty"]], result)

        @builtins.property
        def internet_gateway(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVPCEncryptionControlPropsMixin.VpcEncryptionControlExclusionProperty"]]:
            '''Specifies whether to exclude internet gateway traffic from encryption enforcement.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpcencryptioncontrol-resourceexclusions.html#cfn-ec2-vpcencryptioncontrol-resourceexclusions-internetgateway
            '''
            result = self._values.get("internet_gateway")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVPCEncryptionControlPropsMixin.VpcEncryptionControlExclusionProperty"]], result)

        @builtins.property
        def lambda_(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVPCEncryptionControlPropsMixin.VpcEncryptionControlExclusionProperty"]]:
            '''Specifies whether to exclude Lambda function traffic from encryption enforcement.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpcencryptioncontrol-resourceexclusions.html#cfn-ec2-vpcencryptioncontrol-resourceexclusions-lambda
            '''
            result = self._values.get("lambda_")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVPCEncryptionControlPropsMixin.VpcEncryptionControlExclusionProperty"]], result)

        @builtins.property
        def nat_gateway(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVPCEncryptionControlPropsMixin.VpcEncryptionControlExclusionProperty"]]:
            '''Specifies whether to exclude NAT gateway traffic from encryption enforcement.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpcencryptioncontrol-resourceexclusions.html#cfn-ec2-vpcencryptioncontrol-resourceexclusions-natgateway
            '''
            result = self._values.get("nat_gateway")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVPCEncryptionControlPropsMixin.VpcEncryptionControlExclusionProperty"]], result)

        @builtins.property
        def virtual_private_gateway(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVPCEncryptionControlPropsMixin.VpcEncryptionControlExclusionProperty"]]:
            '''Specifies whether to exclude virtual private gateway traffic from encryption enforcement.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpcencryptioncontrol-resourceexclusions.html#cfn-ec2-vpcencryptioncontrol-resourceexclusions-virtualprivategateway
            '''
            result = self._values.get("virtual_private_gateway")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVPCEncryptionControlPropsMixin.VpcEncryptionControlExclusionProperty"]], result)

        @builtins.property
        def vpc_lattice(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVPCEncryptionControlPropsMixin.VpcEncryptionControlExclusionProperty"]]:
            '''Specifies whether to exclude VPC Lattice traffic from encryption enforcement.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpcencryptioncontrol-resourceexclusions.html#cfn-ec2-vpcencryptioncontrol-resourceexclusions-vpclattice
            '''
            result = self._values.get("vpc_lattice")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVPCEncryptionControlPropsMixin.VpcEncryptionControlExclusionProperty"]], result)

        @builtins.property
        def vpc_peering(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVPCEncryptionControlPropsMixin.VpcEncryptionControlExclusionProperty"]]:
            '''Specifies whether to exclude VPC peering connection traffic from encryption enforcement.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpcencryptioncontrol-resourceexclusions.html#cfn-ec2-vpcencryptioncontrol-resourceexclusions-vpcpeering
            '''
            result = self._values.get("vpc_peering")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVPCEncryptionControlPropsMixin.VpcEncryptionControlExclusionProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ResourceExclusionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPCEncryptionControlPropsMixin.VpcEncryptionControlExclusionProperty",
        jsii_struct_bases=[],
        name_mapping={"state": "state", "state_message": "stateMessage"},
    )
    class VpcEncryptionControlExclusionProperty:
        def __init__(
            self,
            *,
            state: typing.Optional[builtins.str] = None,
            state_message: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes an exclusion configuration for VPC Encryption Control.

            For more information, see `Enforce VPC encryption in transit <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-encryption-controls.html>`_ in the *Amazon VPC User Guide* .

            :param state: The current state of the exclusion configuration.
            :param state_message: A message providing additional information about the exclusion state.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpcencryptioncontrol-vpcencryptioncontrolexclusion.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                vpc_encryption_control_exclusion_property = ec2_mixins.CfnVPCEncryptionControlPropsMixin.VpcEncryptionControlExclusionProperty(
                    state="state",
                    state_message="stateMessage"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__fa688b8af7f397e7d507108114f733b491e61b8a8a8fb26859b200a1644c765f)
                check_type(argname="argument state", value=state, expected_type=type_hints["state"])
                check_type(argname="argument state_message", value=state_message, expected_type=type_hints["state_message"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if state is not None:
                self._values["state"] = state
            if state_message is not None:
                self._values["state_message"] = state_message

        @builtins.property
        def state(self) -> typing.Optional[builtins.str]:
            '''The current state of the exclusion configuration.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpcencryptioncontrol-vpcencryptioncontrolexclusion.html#cfn-ec2-vpcencryptioncontrol-vpcencryptioncontrolexclusion-state
            '''
            result = self._values.get("state")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def state_message(self) -> typing.Optional[builtins.str]:
            '''A message providing additional information about the exclusion state.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpcencryptioncontrol-vpcencryptioncontrolexclusion.html#cfn-ec2-vpcencryptioncontrol-vpcencryptioncontrolexclusion-statemessage
            '''
            result = self._values.get("state_message")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "VpcEncryptionControlExclusionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPCEndpointConnectionNotificationMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "connection_events": "connectionEvents",
        "connection_notification_arn": "connectionNotificationArn",
        "service_id": "serviceId",
        "vpc_endpoint_id": "vpcEndpointId",
    },
)
class CfnVPCEndpointConnectionNotificationMixinProps:
    def __init__(
        self,
        *,
        connection_events: typing.Optional[typing.Sequence[builtins.str]] = None,
        connection_notification_arn: typing.Optional[builtins.str] = None,
        service_id: typing.Optional[builtins.str] = None,
        vpc_endpoint_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnVPCEndpointConnectionNotificationPropsMixin.

        :param connection_events: The endpoint events for which to receive notifications. Valid values are ``Accept`` , ``Connect`` , ``Delete`` , and ``Reject`` .
        :param connection_notification_arn: The ARN of the SNS topic for the notifications.
        :param service_id: The ID of the endpoint service.
        :param vpc_endpoint_id: The ID of the endpoint.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_vPCEndpoint_connection_notification_mixin_props = ec2_mixins.CfnVPCEndpointConnectionNotificationMixinProps(
                connection_events=["connectionEvents"],
                connection_notification_arn="connectionNotificationArn",
                service_id="serviceId",
                vpc_endpoint_id="vpcEndpointId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d9588faac6a411b49b45b24ec3e436a51d57660390621568fe3355504514cda1)
            check_type(argname="argument connection_events", value=connection_events, expected_type=type_hints["connection_events"])
            check_type(argname="argument connection_notification_arn", value=connection_notification_arn, expected_type=type_hints["connection_notification_arn"])
            check_type(argname="argument service_id", value=service_id, expected_type=type_hints["service_id"])
            check_type(argname="argument vpc_endpoint_id", value=vpc_endpoint_id, expected_type=type_hints["vpc_endpoint_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if connection_events is not None:
            self._values["connection_events"] = connection_events
        if connection_notification_arn is not None:
            self._values["connection_notification_arn"] = connection_notification_arn
        if service_id is not None:
            self._values["service_id"] = service_id
        if vpc_endpoint_id is not None:
            self._values["vpc_endpoint_id"] = vpc_endpoint_id

    @builtins.property
    def connection_events(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The endpoint events for which to receive notifications.

        Valid values are ``Accept`` , ``Connect`` , ``Delete`` , and ``Reject`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html#cfn-ec2-vpcendpointconnectionnotification-connectionevents
        '''
        result = self._values.get("connection_events")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def connection_notification_arn(self) -> typing.Optional[builtins.str]:
        '''The ARN of the SNS topic for the notifications.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html#cfn-ec2-vpcendpointconnectionnotification-connectionnotificationarn
        '''
        result = self._values.get("connection_notification_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def service_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the endpoint service.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html#cfn-ec2-vpcendpointconnectionnotification-serviceid
        '''
        result = self._values.get("service_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpc_endpoint_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the endpoint.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html#cfn-ec2-vpcendpointconnectionnotification-vpcendpointid
        '''
        result = self._values.get("vpc_endpoint_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnVPCEndpointConnectionNotificationMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnVPCEndpointConnectionNotificationPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPCEndpointConnectionNotificationPropsMixin",
):
    '''Specifies a connection notification for a VPC endpoint or VPC endpoint service.

    A connection notification notifies you of specific endpoint events. You must create an SNS topic to receive notifications. For more information, see `Create a Topic <https://docs.aws.amazon.com/sns/latest/dg/CreateTopic.html>`_ in the *Amazon Simple Notification Service Developer Guide* .

    You can create a connection notification for interface endpoints only.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html
    :cloudformationResource: AWS::EC2::VPCEndpointConnectionNotification
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_vPCEndpoint_connection_notification_props_mixin = ec2_mixins.CfnVPCEndpointConnectionNotificationPropsMixin(ec2_mixins.CfnVPCEndpointConnectionNotificationMixinProps(
            connection_events=["connectionEvents"],
            connection_notification_arn="connectionNotificationArn",
            service_id="serviceId",
            vpc_endpoint_id="vpcEndpointId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnVPCEndpointConnectionNotificationMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::VPCEndpointConnectionNotification``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__66546bad18e895482ab5e0c2ac2da77a8414fcf1bbd83a604be08742fe656531)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f3a313135eb427e9a9acb68da999f3b125fb0965f99a17dd6ee69d0317e343cd)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5fb8722945c3726e2f569edd714d373388f891f55d3673ac93e49ffcfba569e3)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnVPCEndpointConnectionNotificationMixinProps":
        return typing.cast("CfnVPCEndpointConnectionNotificationMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPCEndpointMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "dns_options": "dnsOptions",
        "ip_address_type": "ipAddressType",
        "policy_document": "policyDocument",
        "private_dns_enabled": "privateDnsEnabled",
        "resource_configuration_arn": "resourceConfigurationArn",
        "route_table_ids": "routeTableIds",
        "security_group_ids": "securityGroupIds",
        "service_name": "serviceName",
        "service_network_arn": "serviceNetworkArn",
        "service_region": "serviceRegion",
        "subnet_ids": "subnetIds",
        "tags": "tags",
        "vpc_endpoint_type": "vpcEndpointType",
        "vpc_id": "vpcId",
    },
)
class CfnVPCEndpointMixinProps:
    def __init__(
        self,
        *,
        dns_options: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnVPCEndpointPropsMixin.DnsOptionsSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ip_address_type: typing.Optional[builtins.str] = None,
        policy_document: typing.Any = None,
        private_dns_enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        resource_configuration_arn: typing.Optional[builtins.str] = None,
        route_table_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        security_group_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        service_name: typing.Optional[builtins.str] = None,
        service_network_arn: typing.Optional[builtins.str] = None,
        service_region: typing.Optional[builtins.str] = None,
        subnet_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        vpc_endpoint_type: typing.Optional[builtins.str] = None,
        vpc_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnVPCEndpointPropsMixin.

        :param dns_options: Describes the DNS options for an endpoint.
        :param ip_address_type: The supported IP address types.
        :param policy_document: An endpoint policy, which controls access to the service from the VPC. The default endpoint policy allows full access to the service. Endpoint policies are supported only for gateway and interface endpoints. For CloudFormation templates in YAML, you can provide the policy in JSON or YAML format. For example, if you have a JSON policy, you can convert it to YAML before including it in the YAML template, and AWS CloudFormation converts the policy to JSON format before calling the API actions for AWS PrivateLink . Alternatively, you can include the JSON directly in the YAML, as shown in the following ``Properties`` section: ``Properties: VpcEndpointType: 'Interface' ServiceName: !Sub 'com.amazonaws.${AWS::Region}.logs' PolicyDocument: '{ "Version":"2012-10-17", "Statement": [{ "Effect":"Allow", "Principal":"*", "Action":["logs:Describe*","logs:Get*","logs:List*","logs:FilterLogEvents"], "Resource":"*" }] }'``
        :param private_dns_enabled: Indicate whether to associate a private hosted zone with the specified VPC. The private hosted zone contains a record set for the default public DNS name for the service for the Region (for example, ``kinesis.us-east-1.amazonaws.com`` ), which resolves to the private IP addresses of the endpoint network interfaces in the VPC. This enables you to make requests to the default public DNS name for the service instead of the public DNS names that are automatically generated by the VPC endpoint service. To use a private hosted zone, you must set the following VPC attributes to ``true`` : ``enableDnsHostnames`` and ``enableDnsSupport`` . This property is supported only for interface endpoints. Default: ``false``
        :param resource_configuration_arn: The Amazon Resource Name (ARN) of the resource configuration.
        :param route_table_ids: The IDs of the route tables. Routing is supported only for gateway endpoints.
        :param security_group_ids: The IDs of the security groups to associate with the endpoint network interfaces. If this parameter is not specified, we use the default security group for the VPC. Security groups are supported only for interface endpoints.
        :param service_name: The name of the endpoint service.
        :param service_network_arn: The Amazon Resource Name (ARN) of the service network.
        :param service_region: Describes a Region.
        :param subnet_ids: The IDs of the subnets in which to create endpoint network interfaces. You must specify this property for an interface endpoint or a Gateway Load Balancer endpoint. You can't specify this property for a gateway endpoint. For a Gateway Load Balancer endpoint, you can specify only one subnet.
        :param tags: The tags to associate with the endpoint.
        :param vpc_endpoint_type: The type of endpoint. Default: Gateway
        :param vpc_id: The ID of the VPC.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            # policy_document: Any
            
            cfn_vPCEndpoint_mixin_props = ec2_mixins.CfnVPCEndpointMixinProps(
                dns_options=ec2_mixins.CfnVPCEndpointPropsMixin.DnsOptionsSpecificationProperty(
                    dns_record_ip_type="dnsRecordIpType",
                    private_dns_only_for_inbound_resolver_endpoint="privateDnsOnlyForInboundResolverEndpoint",
                    private_dns_preference="privateDnsPreference",
                    private_dns_specified_domains=["privateDnsSpecifiedDomains"]
                ),
                ip_address_type="ipAddressType",
                policy_document=policy_document,
                private_dns_enabled=False,
                resource_configuration_arn="resourceConfigurationArn",
                route_table_ids=["routeTableIds"],
                security_group_ids=["securityGroupIds"],
                service_name="serviceName",
                service_network_arn="serviceNetworkArn",
                service_region="serviceRegion",
                subnet_ids=["subnetIds"],
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                vpc_endpoint_type="vpcEndpointType",
                vpc_id="vpcId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6cccf8c658131dd6b41cdea1ded8eb1eb3e32f26b92b9fe97e9069cbc8fcba8b)
            check_type(argname="argument dns_options", value=dns_options, expected_type=type_hints["dns_options"])
            check_type(argname="argument ip_address_type", value=ip_address_type, expected_type=type_hints["ip_address_type"])
            check_type(argname="argument policy_document", value=policy_document, expected_type=type_hints["policy_document"])
            check_type(argname="argument private_dns_enabled", value=private_dns_enabled, expected_type=type_hints["private_dns_enabled"])
            check_type(argname="argument resource_configuration_arn", value=resource_configuration_arn, expected_type=type_hints["resource_configuration_arn"])
            check_type(argname="argument route_table_ids", value=route_table_ids, expected_type=type_hints["route_table_ids"])
            check_type(argname="argument security_group_ids", value=security_group_ids, expected_type=type_hints["security_group_ids"])
            check_type(argname="argument service_name", value=service_name, expected_type=type_hints["service_name"])
            check_type(argname="argument service_network_arn", value=service_network_arn, expected_type=type_hints["service_network_arn"])
            check_type(argname="argument service_region", value=service_region, expected_type=type_hints["service_region"])
            check_type(argname="argument subnet_ids", value=subnet_ids, expected_type=type_hints["subnet_ids"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument vpc_endpoint_type", value=vpc_endpoint_type, expected_type=type_hints["vpc_endpoint_type"])
            check_type(argname="argument vpc_id", value=vpc_id, expected_type=type_hints["vpc_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if dns_options is not None:
            self._values["dns_options"] = dns_options
        if ip_address_type is not None:
            self._values["ip_address_type"] = ip_address_type
        if policy_document is not None:
            self._values["policy_document"] = policy_document
        if private_dns_enabled is not None:
            self._values["private_dns_enabled"] = private_dns_enabled
        if resource_configuration_arn is not None:
            self._values["resource_configuration_arn"] = resource_configuration_arn
        if route_table_ids is not None:
            self._values["route_table_ids"] = route_table_ids
        if security_group_ids is not None:
            self._values["security_group_ids"] = security_group_ids
        if service_name is not None:
            self._values["service_name"] = service_name
        if service_network_arn is not None:
            self._values["service_network_arn"] = service_network_arn
        if service_region is not None:
            self._values["service_region"] = service_region
        if subnet_ids is not None:
            self._values["subnet_ids"] = subnet_ids
        if tags is not None:
            self._values["tags"] = tags
        if vpc_endpoint_type is not None:
            self._values["vpc_endpoint_type"] = vpc_endpoint_type
        if vpc_id is not None:
            self._values["vpc_id"] = vpc_id

    @builtins.property
    def dns_options(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVPCEndpointPropsMixin.DnsOptionsSpecificationProperty"]]:
        '''Describes the DNS options for an endpoint.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-dnsoptions
        '''
        result = self._values.get("dns_options")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVPCEndpointPropsMixin.DnsOptionsSpecificationProperty"]], result)

    @builtins.property
    def ip_address_type(self) -> typing.Optional[builtins.str]:
        '''The supported IP address types.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-ipaddresstype
        '''
        result = self._values.get("ip_address_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def policy_document(self) -> typing.Any:
        '''An endpoint policy, which controls access to the service from the VPC.

        The default endpoint policy allows full access to the service. Endpoint policies are supported only for gateway and interface endpoints.

        For CloudFormation templates in YAML, you can provide the policy in JSON or YAML format. For example, if you have a JSON policy, you can convert it to YAML before including it in the YAML template, and AWS CloudFormation converts the policy to JSON format before calling the API actions for AWS PrivateLink . Alternatively, you can include the JSON directly in the YAML, as shown in the following ``Properties`` section:

        ``Properties: VpcEndpointType: 'Interface' ServiceName: !Sub 'com.amazonaws.${AWS::Region}.logs' PolicyDocument: '{ "Version":"2012-10-17",  "Statement": [{ "Effect":"Allow", "Principal":"*", "Action":["logs:Describe*","logs:Get*","logs:List*","logs:FilterLogEvents"], "Resource":"*" }] }'``

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-policydocument
        '''
        result = self._values.get("policy_document")
        return typing.cast(typing.Any, result)

    @builtins.property
    def private_dns_enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Indicate whether to associate a private hosted zone with the specified VPC.

        The private hosted zone contains a record set for the default public DNS name for the service for the Region (for example, ``kinesis.us-east-1.amazonaws.com`` ), which resolves to the private IP addresses of the endpoint network interfaces in the VPC. This enables you to make requests to the default public DNS name for the service instead of the public DNS names that are automatically generated by the VPC endpoint service.

        To use a private hosted zone, you must set the following VPC attributes to ``true`` : ``enableDnsHostnames`` and ``enableDnsSupport`` .

        This property is supported only for interface endpoints.

        Default: ``false``

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-privatednsenabled
        '''
        result = self._values.get("private_dns_enabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def resource_configuration_arn(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the resource configuration.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-resourceconfigurationarn
        '''
        result = self._values.get("resource_configuration_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def route_table_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The IDs of the route tables.

        Routing is supported only for gateway endpoints.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-routetableids
        '''
        result = self._values.get("route_table_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def security_group_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The IDs of the security groups to associate with the endpoint network interfaces.

        If this parameter is not specified, we use the default security group for the VPC. Security groups are supported only for interface endpoints.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-securitygroupids
        '''
        result = self._values.get("security_group_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def service_name(self) -> typing.Optional[builtins.str]:
        '''The name of the endpoint service.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-servicename
        '''
        result = self._values.get("service_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def service_network_arn(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the service network.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-servicenetworkarn
        '''
        result = self._values.get("service_network_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def service_region(self) -> typing.Optional[builtins.str]:
        '''Describes a Region.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-serviceregion
        '''
        result = self._values.get("service_region")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def subnet_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The IDs of the subnets in which to create endpoint network interfaces.

        You must specify this property for an interface endpoint or a Gateway Load Balancer endpoint. You can't specify this property for a gateway endpoint. For a Gateway Load Balancer endpoint, you can specify only one subnet.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-subnetids
        '''
        result = self._values.get("subnet_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags to associate with the endpoint.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def vpc_endpoint_type(self) -> typing.Optional[builtins.str]:
        '''The type of endpoint.

        Default: Gateway

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-vpcendpointtype
        '''
        result = self._values.get("vpc_endpoint_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpc_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the VPC.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-vpcid
        '''
        result = self._values.get("vpc_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnVPCEndpointMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnVPCEndpointPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPCEndpointPropsMixin",
):
    '''Specifies a VPC endpoint.

    A VPC endpoint provides a private connection between your VPC and an endpoint service. You can use an endpoint service provided by AWS , an AWS Marketplace Partner, or another AWS accounts in your organization. For more information, see the `AWS PrivateLink User Guide <https://docs.aws.amazon.com/vpc/latest/privatelink/>`_ .

    An endpoint of type ``Interface`` establishes connections between the subnets in your VPC and an AWS service , your own service, or a service hosted by another AWS account . With an interface VPC endpoint, you specify the subnets in which to create the endpoint and the security groups to associate with the endpoint network interfaces.

    An endpoint of type ``gateway`` serves as a target for a route in your route table for traffic destined for Amazon S3 or DynamoDB . You can specify an endpoint policy for the endpoint, which controls access to the service from your VPC. You can also specify the VPC route tables that use the endpoint. For more information about connectivity to Amazon S3 , see `Why can't I connect to an S3 bucket using a gateway VPC endpoint? <https://docs.aws.amazon.com/premiumsupport/knowledge-center/connect-s3-vpc-endpoint>`_

    An endpoint of type ``GatewayLoadBalancer`` provides private connectivity between your VPC and virtual appliances from a service provider.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html
    :cloudformationResource: AWS::EC2::VPCEndpoint
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        # policy_document: Any
        
        cfn_vPCEndpoint_props_mixin = ec2_mixins.CfnVPCEndpointPropsMixin(ec2_mixins.CfnVPCEndpointMixinProps(
            dns_options=ec2_mixins.CfnVPCEndpointPropsMixin.DnsOptionsSpecificationProperty(
                dns_record_ip_type="dnsRecordIpType",
                private_dns_only_for_inbound_resolver_endpoint="privateDnsOnlyForInboundResolverEndpoint",
                private_dns_preference="privateDnsPreference",
                private_dns_specified_domains=["privateDnsSpecifiedDomains"]
            ),
            ip_address_type="ipAddressType",
            policy_document=policy_document,
            private_dns_enabled=False,
            resource_configuration_arn="resourceConfigurationArn",
            route_table_ids=["routeTableIds"],
            security_group_ids=["securityGroupIds"],
            service_name="serviceName",
            service_network_arn="serviceNetworkArn",
            service_region="serviceRegion",
            subnet_ids=["subnetIds"],
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            vpc_endpoint_type="vpcEndpointType",
            vpc_id="vpcId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnVPCEndpointMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::VPCEndpoint``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__88126a5d8e2eb8ff0a196420b78d273237a21bfafcaa023aec77e01f855c31b7)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__83fd60be923b061afad18cf3a6f024e85650d2a3a62a518745705bd1ec032765)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__28aad4c42483c04e533b0d58ad2ef7b2414c8cdf83820ba27d321e499fc5f290)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnVPCEndpointMixinProps":
        return typing.cast("CfnVPCEndpointMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPCEndpointPropsMixin.DnsOptionsSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "dns_record_ip_type": "dnsRecordIpType",
            "private_dns_only_for_inbound_resolver_endpoint": "privateDnsOnlyForInboundResolverEndpoint",
            "private_dns_preference": "privateDnsPreference",
            "private_dns_specified_domains": "privateDnsSpecifiedDomains",
        },
    )
    class DnsOptionsSpecificationProperty:
        def __init__(
            self,
            *,
            dns_record_ip_type: typing.Optional[builtins.str] = None,
            private_dns_only_for_inbound_resolver_endpoint: typing.Optional[builtins.str] = None,
            private_dns_preference: typing.Optional[builtins.str] = None,
            private_dns_specified_domains: typing.Optional[typing.Sequence[builtins.str]] = None,
        ) -> None:
            '''Describes the DNS options for an endpoint.

            :param dns_record_ip_type: The DNS records created for the endpoint.
            :param private_dns_only_for_inbound_resolver_endpoint: Indicates whether to enable private DNS only for inbound endpoints. This option is available only for services that support both gateway and interface endpoints. It routes traffic that originates from the VPC to the gateway endpoint and traffic that originates from on-premises to the interface endpoint.
            :param private_dns_preference: The preference for which private domains have a private hosted zone created for and associated with the specified VPC. Only supported when private DNS is enabled and when the VPC endpoint type is ServiceNetwork or Resource.
            :param private_dns_specified_domains: Indicates which of the private domains to create private hosted zones for and associate with the specified VPC. Only supported when private DNS is enabled and the private DNS preference is ``VERIFIED_DOMAINS_AND_SPECIFIED_DOMAINS`` or ``SPECIFIED_DOMAINS_ONLY`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpcendpoint-dnsoptionsspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                dns_options_specification_property = ec2_mixins.CfnVPCEndpointPropsMixin.DnsOptionsSpecificationProperty(
                    dns_record_ip_type="dnsRecordIpType",
                    private_dns_only_for_inbound_resolver_endpoint="privateDnsOnlyForInboundResolverEndpoint",
                    private_dns_preference="privateDnsPreference",
                    private_dns_specified_domains=["privateDnsSpecifiedDomains"]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__575afcdf1fa1620b498d8ef4d67f4720ed4abc05d8cfb37239525e6c5176765c)
                check_type(argname="argument dns_record_ip_type", value=dns_record_ip_type, expected_type=type_hints["dns_record_ip_type"])
                check_type(argname="argument private_dns_only_for_inbound_resolver_endpoint", value=private_dns_only_for_inbound_resolver_endpoint, expected_type=type_hints["private_dns_only_for_inbound_resolver_endpoint"])
                check_type(argname="argument private_dns_preference", value=private_dns_preference, expected_type=type_hints["private_dns_preference"])
                check_type(argname="argument private_dns_specified_domains", value=private_dns_specified_domains, expected_type=type_hints["private_dns_specified_domains"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if dns_record_ip_type is not None:
                self._values["dns_record_ip_type"] = dns_record_ip_type
            if private_dns_only_for_inbound_resolver_endpoint is not None:
                self._values["private_dns_only_for_inbound_resolver_endpoint"] = private_dns_only_for_inbound_resolver_endpoint
            if private_dns_preference is not None:
                self._values["private_dns_preference"] = private_dns_preference
            if private_dns_specified_domains is not None:
                self._values["private_dns_specified_domains"] = private_dns_specified_domains

        @builtins.property
        def dns_record_ip_type(self) -> typing.Optional[builtins.str]:
            '''The DNS records created for the endpoint.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpcendpoint-dnsoptionsspecification.html#cfn-ec2-vpcendpoint-dnsoptionsspecification-dnsrecordiptype
            '''
            result = self._values.get("dns_record_ip_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def private_dns_only_for_inbound_resolver_endpoint(
            self,
        ) -> typing.Optional[builtins.str]:
            '''Indicates whether to enable private DNS only for inbound endpoints.

            This option is available only for services that support both gateway and interface endpoints. It routes traffic that originates from the VPC to the gateway endpoint and traffic that originates from on-premises to the interface endpoint.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpcendpoint-dnsoptionsspecification.html#cfn-ec2-vpcendpoint-dnsoptionsspecification-privatednsonlyforinboundresolverendpoint
            '''
            result = self._values.get("private_dns_only_for_inbound_resolver_endpoint")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def private_dns_preference(self) -> typing.Optional[builtins.str]:
            '''The preference for which private domains have a private hosted zone created for and associated with the specified VPC.

            Only supported when private DNS is enabled and when the VPC endpoint type is ServiceNetwork or Resource.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpcendpoint-dnsoptionsspecification.html#cfn-ec2-vpcendpoint-dnsoptionsspecification-privatednspreference
            '''
            result = self._values.get("private_dns_preference")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def private_dns_specified_domains(
            self,
        ) -> typing.Optional[typing.List[builtins.str]]:
            '''Indicates which of the private domains to create private hosted zones for and associate with the specified VPC.

            Only supported when private DNS is enabled and the private DNS preference is ``VERIFIED_DOMAINS_AND_SPECIFIED_DOMAINS`` or ``SPECIFIED_DOMAINS_ONLY`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpcendpoint-dnsoptionsspecification.html#cfn-ec2-vpcendpoint-dnsoptionsspecification-privatednsspecifieddomains
            '''
            result = self._values.get("private_dns_specified_domains")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "DnsOptionsSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPCEndpointServiceMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "acceptance_required": "acceptanceRequired",
        "contributor_insights_enabled": "contributorInsightsEnabled",
        "gateway_load_balancer_arns": "gatewayLoadBalancerArns",
        "network_load_balancer_arns": "networkLoadBalancerArns",
        "payer_responsibility": "payerResponsibility",
        "supported_ip_address_types": "supportedIpAddressTypes",
        "supported_regions": "supportedRegions",
        "tags": "tags",
    },
)
class CfnVPCEndpointServiceMixinProps:
    def __init__(
        self,
        *,
        acceptance_required: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        contributor_insights_enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        gateway_load_balancer_arns: typing.Optional[typing.Sequence[builtins.str]] = None,
        network_load_balancer_arns: typing.Optional[typing.Sequence[builtins.str]] = None,
        payer_responsibility: typing.Optional[builtins.str] = None,
        supported_ip_address_types: typing.Optional[typing.Sequence[builtins.str]] = None,
        supported_regions: typing.Optional[typing.Sequence[builtins.str]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnVPCEndpointServicePropsMixin.

        :param acceptance_required: Indicates whether requests from service consumers to create an endpoint to your service must be accepted.
        :param contributor_insights_enabled: Indicates whether to enable the built-in Contributor Insights rules provided by AWS PrivateLink .
        :param gateway_load_balancer_arns: The Amazon Resource Names (ARNs) of the Gateway Load Balancers.
        :param network_load_balancer_arns: The Amazon Resource Names (ARNs) of the Network Load Balancers.
        :param payer_responsibility: The entity that is responsible for the endpoint costs. The default is the endpoint owner. If you set the payer responsibility to the service owner, you cannot set it back to the endpoint owner.
        :param supported_ip_address_types: The supported IP address types. The possible values are ``ipv4`` and ``ipv6`` .
        :param supported_regions: The Regions from which service consumers can access the service.
        :param tags: The tags to associate with the service.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_vPCEndpoint_service_mixin_props = ec2_mixins.CfnVPCEndpointServiceMixinProps(
                acceptance_required=False,
                contributor_insights_enabled=False,
                gateway_load_balancer_arns=["gatewayLoadBalancerArns"],
                network_load_balancer_arns=["networkLoadBalancerArns"],
                payer_responsibility="payerResponsibility",
                supported_ip_address_types=["supportedIpAddressTypes"],
                supported_regions=["supportedRegions"],
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__44ad1e43431863b774297acd3c0cc85b653f53a9b6aed46627ce5f88b3c8b83d)
            check_type(argname="argument acceptance_required", value=acceptance_required, expected_type=type_hints["acceptance_required"])
            check_type(argname="argument contributor_insights_enabled", value=contributor_insights_enabled, expected_type=type_hints["contributor_insights_enabled"])
            check_type(argname="argument gateway_load_balancer_arns", value=gateway_load_balancer_arns, expected_type=type_hints["gateway_load_balancer_arns"])
            check_type(argname="argument network_load_balancer_arns", value=network_load_balancer_arns, expected_type=type_hints["network_load_balancer_arns"])
            check_type(argname="argument payer_responsibility", value=payer_responsibility, expected_type=type_hints["payer_responsibility"])
            check_type(argname="argument supported_ip_address_types", value=supported_ip_address_types, expected_type=type_hints["supported_ip_address_types"])
            check_type(argname="argument supported_regions", value=supported_regions, expected_type=type_hints["supported_regions"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if acceptance_required is not None:
            self._values["acceptance_required"] = acceptance_required
        if contributor_insights_enabled is not None:
            self._values["contributor_insights_enabled"] = contributor_insights_enabled
        if gateway_load_balancer_arns is not None:
            self._values["gateway_load_balancer_arns"] = gateway_load_balancer_arns
        if network_load_balancer_arns is not None:
            self._values["network_load_balancer_arns"] = network_load_balancer_arns
        if payer_responsibility is not None:
            self._values["payer_responsibility"] = payer_responsibility
        if supported_ip_address_types is not None:
            self._values["supported_ip_address_types"] = supported_ip_address_types
        if supported_regions is not None:
            self._values["supported_regions"] = supported_regions
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def acceptance_required(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Indicates whether requests from service consumers to create an endpoint to your service must be accepted.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html#cfn-ec2-vpcendpointservice-acceptancerequired
        '''
        result = self._values.get("acceptance_required")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def contributor_insights_enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Indicates whether to enable the built-in Contributor Insights rules provided by AWS PrivateLink .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html#cfn-ec2-vpcendpointservice-contributorinsightsenabled
        '''
        result = self._values.get("contributor_insights_enabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def gateway_load_balancer_arns(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The Amazon Resource Names (ARNs) of the Gateway Load Balancers.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html#cfn-ec2-vpcendpointservice-gatewayloadbalancerarns
        '''
        result = self._values.get("gateway_load_balancer_arns")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def network_load_balancer_arns(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The Amazon Resource Names (ARNs) of the Network Load Balancers.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html#cfn-ec2-vpcendpointservice-networkloadbalancerarns
        '''
        result = self._values.get("network_load_balancer_arns")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def payer_responsibility(self) -> typing.Optional[builtins.str]:
        '''The entity that is responsible for the endpoint costs.

        The default is the endpoint owner. If you set the payer responsibility to the service owner, you cannot set it back to the endpoint owner.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html#cfn-ec2-vpcendpointservice-payerresponsibility
        '''
        result = self._values.get("payer_responsibility")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def supported_ip_address_types(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The supported IP address types.

        The possible values are ``ipv4`` and ``ipv6`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html#cfn-ec2-vpcendpointservice-supportedipaddresstypes
        '''
        result = self._values.get("supported_ip_address_types")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def supported_regions(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The Regions from which service consumers can access the service.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html#cfn-ec2-vpcendpointservice-supportedregions
        '''
        result = self._values.get("supported_regions")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags to associate with the service.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html#cfn-ec2-vpcendpointservice-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnVPCEndpointServiceMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPCEndpointServicePermissionsMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "allowed_principals": "allowedPrincipals",
        "service_id": "serviceId",
    },
)
class CfnVPCEndpointServicePermissionsMixinProps:
    def __init__(
        self,
        *,
        allowed_principals: typing.Optional[typing.Sequence[builtins.str]] = None,
        service_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnVPCEndpointServicePermissionsPropsMixin.

        :param allowed_principals: The Amazon Resource Names (ARN) of one or more principals (for example, users, IAM roles, and AWS accounts ). Permissions are granted to the principals in this list. To grant permissions to all principals, specify an asterisk (*). Permissions are revoked for principals not in this list. If the list is empty, then all permissions are revoked.
        :param service_id: The ID of the service.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservicepermissions.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_vPCEndpoint_service_permissions_mixin_props = ec2_mixins.CfnVPCEndpointServicePermissionsMixinProps(
                allowed_principals=["allowedPrincipals"],
                service_id="serviceId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dd4359405a6d0f4c1e02a52e7ffe260e68f1e2db81827a191d429338ed6e54ba)
            check_type(argname="argument allowed_principals", value=allowed_principals, expected_type=type_hints["allowed_principals"])
            check_type(argname="argument service_id", value=service_id, expected_type=type_hints["service_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if allowed_principals is not None:
            self._values["allowed_principals"] = allowed_principals
        if service_id is not None:
            self._values["service_id"] = service_id

    @builtins.property
    def allowed_principals(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The Amazon Resource Names (ARN) of one or more principals (for example, users, IAM roles, and AWS accounts ).

        Permissions are granted to the principals in this list. To grant permissions to all principals, specify an asterisk (*). Permissions are revoked for principals not in this list. If the list is empty, then all permissions are revoked.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservicepermissions.html#cfn-ec2-vpcendpointservicepermissions-allowedprincipals
        '''
        result = self._values.get("allowed_principals")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def service_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the service.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservicepermissions.html#cfn-ec2-vpcendpointservicepermissions-serviceid
        '''
        result = self._values.get("service_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnVPCEndpointServicePermissionsMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnVPCEndpointServicePermissionsPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPCEndpointServicePermissionsPropsMixin",
):
    '''Grant or revoke permissions for service consumers (users, IAM roles, and AWS accounts) to connect to a VPC endpoint service.

    If you grant permissions to all principals, the service is public. Any users who know the name of a public service can send a request to attach an endpoint. If the service does not require manual approval, attachments are automatically approved.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservicepermissions.html
    :cloudformationResource: AWS::EC2::VPCEndpointServicePermissions
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_vPCEndpoint_service_permissions_props_mixin = ec2_mixins.CfnVPCEndpointServicePermissionsPropsMixin(ec2_mixins.CfnVPCEndpointServicePermissionsMixinProps(
            allowed_principals=["allowedPrincipals"],
            service_id="serviceId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnVPCEndpointServicePermissionsMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::VPCEndpointServicePermissions``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ad0f457242983a8b5eafeaf399e4b0f351040d8e424bcc06c880dc8a8d54dc7a)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__02c380eaea9c7d3fb917e65ced0ff422ce9b3122319fe5c332ed6106409ef53f)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9788c6b35a7be1b4d710749ba90b5536ff818ec46c45328fdc1fda31465af45f)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnVPCEndpointServicePermissionsMixinProps":
        return typing.cast("CfnVPCEndpointServicePermissionsMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.implements(_IMixin_11e4b965)
class CfnVPCEndpointServicePropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPCEndpointServicePropsMixin",
):
    '''Creates a VPC endpoint service configuration to which service consumers ( AWS accounts, users, and IAM roles) can connect.

    To create an endpoint service configuration, you must first create one of the following for your service:

    - A `Network Load Balancer <https://docs.aws.amazon.com/elasticloadbalancing/latest/network/introduction.html>`_ . Service consumers connect to your service using an interface endpoint.
    - A `Gateway Load Balancer <https://docs.aws.amazon.com/elasticloadbalancing/latest/gateway/introduction.html>`_ . Service consumers connect to your service using a Gateway Load Balancer endpoint.

    For more information, see the `AWS PrivateLink User Guide <https://docs.aws.amazon.com/vpc/latest/privatelink/>`_ .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html
    :cloudformationResource: AWS::EC2::VPCEndpointService
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_vPCEndpoint_service_props_mixin = ec2_mixins.CfnVPCEndpointServicePropsMixin(ec2_mixins.CfnVPCEndpointServiceMixinProps(
            acceptance_required=False,
            contributor_insights_enabled=False,
            gateway_load_balancer_arns=["gatewayLoadBalancerArns"],
            network_load_balancer_arns=["networkLoadBalancerArns"],
            payer_responsibility="payerResponsibility",
            supported_ip_address_types=["supportedIpAddressTypes"],
            supported_regions=["supportedRegions"],
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnVPCEndpointServiceMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::VPCEndpointService``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__689b0481d86c58487fe3ef4f1a7f074848b9b33e06fb782661b5785dbadc997c)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8cefdfa5611fde6514c1d03b826934abc8300c30d0e89e5b33e67c332af70a4c)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2c2af0d5ecd883ee9e273b123356a26a5e411374748c9b0b0c177acf96483e43)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnVPCEndpointServiceMixinProps":
        return typing.cast("CfnVPCEndpointServiceMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPCGatewayAttachmentMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "internet_gateway_id": "internetGatewayId",
        "vpc_id": "vpcId",
        "vpn_gateway_id": "vpnGatewayId",
    },
)
class CfnVPCGatewayAttachmentMixinProps:
    def __init__(
        self,
        *,
        internet_gateway_id: typing.Optional[builtins.str] = None,
        vpc_id: typing.Optional[builtins.str] = None,
        vpn_gateway_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnVPCGatewayAttachmentPropsMixin.

        :param internet_gateway_id: The ID of the internet gateway. You must specify either ``InternetGatewayId`` or ``VpnGatewayId`` , but not both.
        :param vpc_id: The ID of the VPC.
        :param vpn_gateway_id: The ID of the virtual private gateway. You must specify either ``InternetGatewayId`` or ``VpnGatewayId`` , but not both.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcgatewayattachment.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_vPCGateway_attachment_mixin_props = ec2_mixins.CfnVPCGatewayAttachmentMixinProps(
                internet_gateway_id="internetGatewayId",
                vpc_id="vpcId",
                vpn_gateway_id="vpnGatewayId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9a4ba044e87002a7c0c608a9b889ae40b46e726bab31c5769898591ed9bfc99a)
            check_type(argname="argument internet_gateway_id", value=internet_gateway_id, expected_type=type_hints["internet_gateway_id"])
            check_type(argname="argument vpc_id", value=vpc_id, expected_type=type_hints["vpc_id"])
            check_type(argname="argument vpn_gateway_id", value=vpn_gateway_id, expected_type=type_hints["vpn_gateway_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if internet_gateway_id is not None:
            self._values["internet_gateway_id"] = internet_gateway_id
        if vpc_id is not None:
            self._values["vpc_id"] = vpc_id
        if vpn_gateway_id is not None:
            self._values["vpn_gateway_id"] = vpn_gateway_id

    @builtins.property
    def internet_gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the internet gateway.

        You must specify either ``InternetGatewayId`` or ``VpnGatewayId`` , but not both.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcgatewayattachment.html#cfn-ec2-vpcgatewayattachment-internetgatewayid
        '''
        result = self._values.get("internet_gateway_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpc_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the VPC.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcgatewayattachment.html#cfn-ec2-vpcgatewayattachment-vpcid
        '''
        result = self._values.get("vpc_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpn_gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the virtual private gateway.

        You must specify either ``InternetGatewayId`` or ``VpnGatewayId`` , but not both.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcgatewayattachment.html#cfn-ec2-vpcgatewayattachment-vpngatewayid
        '''
        result = self._values.get("vpn_gateway_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnVPCGatewayAttachmentMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnVPCGatewayAttachmentPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPCGatewayAttachmentPropsMixin",
):
    '''Attaches an internet gateway, or a virtual private gateway to a VPC, enabling connectivity between the internet and the VPC.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcgatewayattachment.html
    :cloudformationResource: AWS::EC2::VPCGatewayAttachment
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_vPCGateway_attachment_props_mixin = ec2_mixins.CfnVPCGatewayAttachmentPropsMixin(ec2_mixins.CfnVPCGatewayAttachmentMixinProps(
            internet_gateway_id="internetGatewayId",
            vpc_id="vpcId",
            vpn_gateway_id="vpnGatewayId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnVPCGatewayAttachmentMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::VPCGatewayAttachment``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6ed02ed6645da599d56f634156bdcdca36ee81e6fd3ffa96adad2d0e83fb17e8)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6a681442ff5652f81d5b37cd410701f9fd5198a74e0f0e652bc68ba7fd32b25c)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__358e2a6a9835424bef3b4c17e717ec15f639a6a6711bd1a6c90f0cc6c4554705)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnVPCGatewayAttachmentMixinProps":
        return typing.cast("CfnVPCGatewayAttachmentMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.implements(_IMixin_11e4b965)
class CfnVPCLogsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPCLogsMixin",
):
    '''Specifies a virtual private cloud (VPC).

    A VPC must have an associated IPv4 CIDR block. You can specify an IPv4 CIDR block or an IPAM-allocated IPv4 CIDR block. To associate an IPv6 CIDR block with the VPC, see `AWS::EC2::VPCCidrBlock <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html>`_ .

    For more information, see `Virtual private clouds (VPC) <https://docs.aws.amazon.com/vpc/latest/userguide/configure-your-vpc.html>`_ in the *Amazon VPC User Guide* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html
    :cloudformationResource: AWS::EC2::VPC
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import aws_logs as logs
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        # logs_delivery: logs.ILogsDelivery
        
        cfn_vPCLogs_mixin = ec2_mixins.CfnVPCLogsMixin("logType", logs_delivery)
    '''

    def __init__(
        self,
        log_type: builtins.str,
        log_delivery: "_ILogsDelivery_0d3c9e29",
    ) -> None:
        '''Create a mixin to enable vended logs for ``AWS::EC2::VPC``.

        :param log_type: Type of logs that are getting vended.
        :param log_delivery: Object in charge of setting up the delivery source, delivery destination, and delivery connection.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c887737e6727e3b16b8ac6538e1fc7d512b67d7a6e88a3a8d55f6bdb1bc2cf69)
            check_type(argname="argument log_type", value=log_type, expected_type=type_hints["log_type"])
            check_type(argname="argument log_delivery", value=log_delivery, expected_type=type_hints["log_delivery"])
        jsii.create(self.__class__, self, [log_type, log_delivery])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        resource: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply vended logs configuration to the construct.

        :param resource: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2d340aa09c1d4740786b10583283e670e3385659d850c72e307cfce7f4b57111)
            check_type(argname="argument resource", value=resource, expected_type=type_hints["resource"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [resource]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct (has vendedLogs property).

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f2d89c70adb4839231da02fd8662b5c1a1aaff9a33627b917996c39b671375e5)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROUTE53_RESOLVER_QUERY_LOGS")
    def ROUTE53_RESOLVER_QUERY_LOGS(cls) -> "CfnVPCRoute53ResolverQueryLogs":
        return typing.cast("CfnVPCRoute53ResolverQueryLogs", jsii.sget(cls, "ROUTE53_RESOLVER_QUERY_LOGS"))

    @builtins.property
    @jsii.member(jsii_name="logDelivery")
    def _log_delivery(self) -> "_ILogsDelivery_0d3c9e29":
        return typing.cast("_ILogsDelivery_0d3c9e29", jsii.get(self, "logDelivery"))

    @builtins.property
    @jsii.member(jsii_name="logType")
    def _log_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "logType"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPCMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "cidr_block": "cidrBlock",
        "enable_dns_hostnames": "enableDnsHostnames",
        "enable_dns_support": "enableDnsSupport",
        "instance_tenancy": "instanceTenancy",
        "ipv4_ipam_pool_id": "ipv4IpamPoolId",
        "ipv4_netmask_length": "ipv4NetmaskLength",
        "tags": "tags",
    },
)
class CfnVPCMixinProps:
    def __init__(
        self,
        *,
        cidr_block: typing.Optional[builtins.str] = None,
        enable_dns_hostnames: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        enable_dns_support: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        instance_tenancy: typing.Optional[builtins.str] = None,
        ipv4_ipam_pool_id: typing.Optional[builtins.str] = None,
        ipv4_netmask_length: typing.Optional[jsii.Number] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnVPCPropsMixin.

        :param cidr_block: The IPv4 network range for the VPC, in CIDR notation. For example, ``10.0.0.0/16`` . We modify the specified CIDR block to its canonical form; for example, if you specify ``100.68.0.18/18`` , we modify it to ``100.68.0.0/18`` . You must specify either ``CidrBlock`` or ``Ipv4IpamPoolId`` .
        :param enable_dns_hostnames: Indicates whether the instances launched in the VPC get DNS hostnames. If enabled, instances in the VPC get DNS hostnames; otherwise, they do not. Disabled by default for nondefault VPCs. For more information, see `DNS attributes in your VPC <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-dns.html#vpc-dns-support>`_ . You can only enable DNS hostnames if you've enabled DNS support.
        :param enable_dns_support: Indicates whether the DNS resolution is supported for the VPC. If enabled, queries to the Amazon provided DNS server at the 169.254.169.253 IP address, or the reserved IP address at the base of the VPC network range "plus two" succeed. If disabled, the Amazon provided DNS service in the VPC that resolves public DNS hostnames to IP addresses is not enabled. Enabled by default. For more information, see `DNS attributes in your VPC <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-dns.html#vpc-dns-support>`_ .
        :param instance_tenancy: The allowed tenancy of instances launched into the VPC. - ``default`` : An instance launched into the VPC runs on shared hardware by default, unless you explicitly specify a different tenancy during instance launch. - ``dedicated`` : An instance launched into the VPC runs on dedicated hardware by default, unless you explicitly specify a tenancy of ``host`` during instance launch. You cannot specify a tenancy of ``default`` during instance launch. Updating ``InstanceTenancy`` requires no replacement only if you are updating its value from ``dedicated`` to ``default`` . Updating ``InstanceTenancy`` from ``default`` to ``dedicated`` requires replacement.
        :param ipv4_ipam_pool_id: The ID of an IPv4 IPAM pool you want to use for allocating this VPC's CIDR. For more information, see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* . You must specify either ``CidrBlock`` or ``Ipv4IpamPoolId`` .
        :param ipv4_netmask_length: The netmask length of the IPv4 CIDR you want to allocate to this VPC from an Amazon VPC IP Address Manager (IPAM) pool. For more information about IPAM, see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .
        :param tags: The tags for the VPC.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_vPCMixin_props = ec2_mixins.CfnVPCMixinProps(
                cidr_block="cidrBlock",
                enable_dns_hostnames=False,
                enable_dns_support=False,
                instance_tenancy="instanceTenancy",
                ipv4_ipam_pool_id="ipv4IpamPoolId",
                ipv4_netmask_length=123,
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5e7af0352cc50c2d189bac2a54e6e8b54f9451d43dca90873527483c374d63c2)
            check_type(argname="argument cidr_block", value=cidr_block, expected_type=type_hints["cidr_block"])
            check_type(argname="argument enable_dns_hostnames", value=enable_dns_hostnames, expected_type=type_hints["enable_dns_hostnames"])
            check_type(argname="argument enable_dns_support", value=enable_dns_support, expected_type=type_hints["enable_dns_support"])
            check_type(argname="argument instance_tenancy", value=instance_tenancy, expected_type=type_hints["instance_tenancy"])
            check_type(argname="argument ipv4_ipam_pool_id", value=ipv4_ipam_pool_id, expected_type=type_hints["ipv4_ipam_pool_id"])
            check_type(argname="argument ipv4_netmask_length", value=ipv4_netmask_length, expected_type=type_hints["ipv4_netmask_length"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if cidr_block is not None:
            self._values["cidr_block"] = cidr_block
        if enable_dns_hostnames is not None:
            self._values["enable_dns_hostnames"] = enable_dns_hostnames
        if enable_dns_support is not None:
            self._values["enable_dns_support"] = enable_dns_support
        if instance_tenancy is not None:
            self._values["instance_tenancy"] = instance_tenancy
        if ipv4_ipam_pool_id is not None:
            self._values["ipv4_ipam_pool_id"] = ipv4_ipam_pool_id
        if ipv4_netmask_length is not None:
            self._values["ipv4_netmask_length"] = ipv4_netmask_length
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def cidr_block(self) -> typing.Optional[builtins.str]:
        '''The IPv4 network range for the VPC, in CIDR notation.

        For example, ``10.0.0.0/16`` . We modify the specified CIDR block to its canonical form; for example, if you specify ``100.68.0.18/18`` , we modify it to ``100.68.0.0/18`` .

        You must specify either ``CidrBlock`` or ``Ipv4IpamPoolId`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-cidrblock
        '''
        result = self._values.get("cidr_block")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_dns_hostnames(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Indicates whether the instances launched in the VPC get DNS hostnames.

        If enabled, instances in the VPC get DNS hostnames; otherwise, they do not. Disabled by default for nondefault VPCs. For more information, see `DNS attributes in your VPC <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-dns.html#vpc-dns-support>`_ .

        You can only enable DNS hostnames if you've enabled DNS support.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-enablednshostnames
        '''
        result = self._values.get("enable_dns_hostnames")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def enable_dns_support(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Indicates whether the DNS resolution is supported for the VPC.

        If enabled, queries to the Amazon provided DNS server at the 169.254.169.253 IP address, or the reserved IP address at the base of the VPC network range "plus two" succeed. If disabled, the Amazon provided DNS service in the VPC that resolves public DNS hostnames to IP addresses is not enabled. Enabled by default. For more information, see `DNS attributes in your VPC <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-dns.html#vpc-dns-support>`_ .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-enablednssupport
        '''
        result = self._values.get("enable_dns_support")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def instance_tenancy(self) -> typing.Optional[builtins.str]:
        '''The allowed tenancy of instances launched into the VPC.

        - ``default`` : An instance launched into the VPC runs on shared hardware by default, unless you explicitly specify a different tenancy during instance launch.
        - ``dedicated`` : An instance launched into the VPC runs on dedicated hardware by default, unless you explicitly specify a tenancy of ``host`` during instance launch. You cannot specify a tenancy of ``default`` during instance launch.

        Updating ``InstanceTenancy`` requires no replacement only if you are updating its value from ``dedicated`` to ``default`` . Updating ``InstanceTenancy`` from ``default`` to ``dedicated`` requires replacement.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-instancetenancy
        '''
        result = self._values.get("instance_tenancy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ipv4_ipam_pool_id(self) -> typing.Optional[builtins.str]:
        '''The ID of an IPv4 IPAM pool you want to use for allocating this VPC's CIDR.

        For more information, see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .

        You must specify either ``CidrBlock`` or ``Ipv4IpamPoolId`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-ipv4ipampoolid
        '''
        result = self._values.get("ipv4_ipam_pool_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ipv4_netmask_length(self) -> typing.Optional[jsii.Number]:
        '''The netmask length of the IPv4 CIDR you want to allocate to this VPC from an Amazon VPC IP Address Manager (IPAM) pool.

        For more information about IPAM, see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-ipv4netmasklength
        '''
        result = self._values.get("ipv4_netmask_length")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags for the VPC.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnVPCMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPCPeeringConnectionMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "peer_owner_id": "peerOwnerId",
        "peer_region": "peerRegion",
        "peer_role_arn": "peerRoleArn",
        "peer_vpc_id": "peerVpcId",
        "tags": "tags",
        "vpc_id": "vpcId",
    },
)
class CfnVPCPeeringConnectionMixinProps:
    def __init__(
        self,
        *,
        peer_owner_id: typing.Optional[builtins.str] = None,
        peer_region: typing.Optional[builtins.str] = None,
        peer_role_arn: typing.Optional[builtins.str] = None,
        peer_vpc_id: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        vpc_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnVPCPeeringConnectionPropsMixin.

        :param peer_owner_id: The AWS account ID of the owner of the accepter VPC. Default: Your AWS account ID
        :param peer_region: The Region code for the accepter VPC, if the accepter VPC is located in a Region other than the Region in which you make the request. Default: The Region in which you make the request.
        :param peer_role_arn: The Amazon Resource Name (ARN) of the VPC peer role for the peering connection in another AWS account. This is required when you are peering a VPC in a different AWS account.
        :param peer_vpc_id: The ID of the VPC with which you are creating the VPC peering connection. You must specify this parameter in the request.
        :param tags: Any tags assigned to the resource.
        :param vpc_id: The ID of the VPC.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_vPCPeering_connection_mixin_props = ec2_mixins.CfnVPCPeeringConnectionMixinProps(
                peer_owner_id="peerOwnerId",
                peer_region="peerRegion",
                peer_role_arn="peerRoleArn",
                peer_vpc_id="peerVpcId",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                vpc_id="vpcId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e71139fb6d9dde758b7eaed23f54799a2814446825ab7339143cd3eb53a2d2c2)
            check_type(argname="argument peer_owner_id", value=peer_owner_id, expected_type=type_hints["peer_owner_id"])
            check_type(argname="argument peer_region", value=peer_region, expected_type=type_hints["peer_region"])
            check_type(argname="argument peer_role_arn", value=peer_role_arn, expected_type=type_hints["peer_role_arn"])
            check_type(argname="argument peer_vpc_id", value=peer_vpc_id, expected_type=type_hints["peer_vpc_id"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument vpc_id", value=vpc_id, expected_type=type_hints["vpc_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if peer_owner_id is not None:
            self._values["peer_owner_id"] = peer_owner_id
        if peer_region is not None:
            self._values["peer_region"] = peer_region
        if peer_role_arn is not None:
            self._values["peer_role_arn"] = peer_role_arn
        if peer_vpc_id is not None:
            self._values["peer_vpc_id"] = peer_vpc_id
        if tags is not None:
            self._values["tags"] = tags
        if vpc_id is not None:
            self._values["vpc_id"] = vpc_id

    @builtins.property
    def peer_owner_id(self) -> typing.Optional[builtins.str]:
        '''The AWS account ID of the owner of the accepter VPC.

        Default: Your AWS account ID

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-peerownerid
        '''
        result = self._values.get("peer_owner_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def peer_region(self) -> typing.Optional[builtins.str]:
        '''The Region code for the accepter VPC, if the accepter VPC is located in a Region other than the Region in which you make the request.

        Default: The Region in which you make the request.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-peerregion
        '''
        result = self._values.get("peer_region")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def peer_role_arn(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the VPC peer role for the peering connection in another AWS account.

        This is required when you are peering a VPC in a different AWS account.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-peerrolearn
        '''
        result = self._values.get("peer_role_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def peer_vpc_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the VPC with which you are creating the VPC peering connection.

        You must specify this parameter in the request.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-peervpcid
        '''
        result = self._values.get("peer_vpc_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''Any tags assigned to the resource.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def vpc_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the VPC.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-vpcid
        '''
        result = self._values.get("vpc_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnVPCPeeringConnectionMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnVPCPeeringConnectionPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPCPeeringConnectionPropsMixin",
):
    '''Requests a VPC peering connection between two VPCs: a requester VPC that you own and an accepter VPC with which to create the connection.

    The accepter VPC can belong to a different AWS account and can be in a different Region than the requester VPC.

    The requester VPC and accepter VPC cannot have overlapping CIDR blocks. If you create a VPC peering connection request between VPCs with overlapping CIDR blocks, the VPC peering connection has a status of ``failed`` .

    If the VPCs belong to different accounts, the acceptor account must have a role that allows the requester account to accept the VPC peering connection. For an example, see `Walkthrough: Peer with a VPC in another AWS account <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/peer-with-vpc-in-another-account.html>`_ .

    If the requester and acceptor VPCs are in the same account, the peering request is accepted without a peering role.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html
    :cloudformationResource: AWS::EC2::VPCPeeringConnection
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_vPCPeering_connection_props_mixin = ec2_mixins.CfnVPCPeeringConnectionPropsMixin(ec2_mixins.CfnVPCPeeringConnectionMixinProps(
            peer_owner_id="peerOwnerId",
            peer_region="peerRegion",
            peer_role_arn="peerRoleArn",
            peer_vpc_id="peerVpcId",
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            vpc_id="vpcId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnVPCPeeringConnectionMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::VPCPeeringConnection``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__91ed3695f9baf55b0e377156e0dbfee88e003a17d1810ef17bf440eed25eb001)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__edc96c257152d84f56584a22779ff28c5161a8810b210f200b731d30db3a9360)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__79cd33221ee69aa836462862aaeb17477304bff88eb3bcb83034bd79e6b65ac8)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnVPCPeeringConnectionMixinProps":
        return typing.cast("CfnVPCPeeringConnectionMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.implements(_IMixin_11e4b965)
class CfnVPCPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPCPropsMixin",
):
    '''Specifies a virtual private cloud (VPC).

    A VPC must have an associated IPv4 CIDR block. You can specify an IPv4 CIDR block or an IPAM-allocated IPv4 CIDR block. To associate an IPv6 CIDR block with the VPC, see `AWS::EC2::VPCCidrBlock <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html>`_ .

    For more information, see `Virtual private clouds (VPC) <https://docs.aws.amazon.com/vpc/latest/userguide/configure-your-vpc.html>`_ in the *Amazon VPC User Guide* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html
    :cloudformationResource: AWS::EC2::VPC
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_vPCProps_mixin = ec2_mixins.CfnVPCPropsMixin(ec2_mixins.CfnVPCMixinProps(
            cidr_block="cidrBlock",
            enable_dns_hostnames=False,
            enable_dns_support=False,
            instance_tenancy="instanceTenancy",
            ipv4_ipam_pool_id="ipv4IpamPoolId",
            ipv4_netmask_length=123,
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnVPCMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::VPC``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c3261f3455a7b2b764b6d6f9a0a38471743d6edee7d915b6a868e3d139586fab)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f006ddf20f05acca08417b3e6434ae3b2b8d42e706338c8490d56646bbb9ec06)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__01f583f83612274f80e96c0f0a43924803392879106e242a2e339650e9095e32)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnVPCMixinProps":
        return typing.cast("CfnVPCMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


class CfnVPCRoute53ResolverQueryLogs(
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPCRoute53ResolverQueryLogs",
):
    '''Builder for CfnVPCLogsMixin to generate ROUTE53_RESOLVER_QUERY_LOGS for CfnVPC.

    :cloudformationResource: AWS::EC2::VPC
    :logType: ROUTE53_RESOLVER_QUERY_LOGS
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_vPCRoute53_resolver_query_logs = ec2_mixins.CfnVPCRoute53ResolverQueryLogs()
    '''

    def __init__(self) -> None:
        '''
        :stability: experimental
        '''
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="toFirehose")
    def to_firehose(
        self,
        delivery_stream: "_aws_cdk_interfaces_aws_kinesisfirehose_ceddda9d.IDeliveryStreamRef",
    ) -> "CfnVPCLogsMixin":
        '''Send logs to a Firehose Delivery Stream.

        :param delivery_stream: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1ca4b568a71338f3c7febfbfdaa32660bcde709925defef7af2bf63e9dcff93e)
            check_type(argname="argument delivery_stream", value=delivery_stream, expected_type=type_hints["delivery_stream"])
        return typing.cast("CfnVPCLogsMixin", jsii.invoke(self, "toFirehose", [delivery_stream]))

    @jsii.member(jsii_name="toLogGroup")
    def to_log_group(
        self,
        log_group: "_aws_cdk_interfaces_aws_logs_ceddda9d.ILogGroupRef",
    ) -> "CfnVPCLogsMixin":
        '''Send logs to a CloudWatch Log Group.

        :param log_group: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1db7e0342b08f126a3d7da6d9626995ea548898b70250c986a5d3b069704ed9b)
            check_type(argname="argument log_group", value=log_group, expected_type=type_hints["log_group"])
        return typing.cast("CfnVPCLogsMixin", jsii.invoke(self, "toLogGroup", [log_group]))

    @jsii.member(jsii_name="toS3")
    def to_s3(
        self,
        bucket: "_aws_cdk_interfaces_aws_s3_ceddda9d.IBucketRef",
    ) -> "CfnVPCLogsMixin":
        '''Send logs to an S3 Bucket.

        :param bucket: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__996b4cc3fed52d55989f54f04abafdf6602b02765140574ab2fa594ce76048a8)
            check_type(argname="argument bucket", value=bucket, expected_type=type_hints["bucket"])
        return typing.cast("CfnVPCLogsMixin", jsii.invoke(self, "toS3", [bucket]))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPNConcentratorMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "tags": "tags",
        "transit_gateway_id": "transitGatewayId",
        "type": "type",
    },
)
class CfnVPNConcentratorMixinProps:
    def __init__(
        self,
        *,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        transit_gateway_id: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnVPNConcentratorPropsMixin.

        :param tags: Any tags assigned to the VPN concentrator.
        :param transit_gateway_id: The ID of the transit gateway associated with the VPN concentrator.
        :param type: The type of VPN concentrator.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconcentrator.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_vPNConcentrator_mixin_props = ec2_mixins.CfnVPNConcentratorMixinProps(
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                transit_gateway_id="transitGatewayId",
                type="type"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e9797ad390530f78befc7925a282e5f08c292a54376983270220e1f9af3e93fa)
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument transit_gateway_id", value=transit_gateway_id, expected_type=type_hints["transit_gateway_id"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if tags is not None:
            self._values["tags"] = tags
        if transit_gateway_id is not None:
            self._values["transit_gateway_id"] = transit_gateway_id
        if type is not None:
            self._values["type"] = type

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''Any tags assigned to the VPN concentrator.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconcentrator.html#cfn-ec2-vpnconcentrator-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def transit_gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the transit gateway associated with the VPN concentrator.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconcentrator.html#cfn-ec2-vpnconcentrator-transitgatewayid
        '''
        result = self._values.get("transit_gateway_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''The type of VPN concentrator.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconcentrator.html#cfn-ec2-vpnconcentrator-type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnVPNConcentratorMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnVPNConcentratorPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPNConcentratorPropsMixin",
):
    '''Describes a VPN concentrator.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconcentrator.html
    :cloudformationResource: AWS::EC2::VPNConcentrator
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_vPNConcentrator_props_mixin = ec2_mixins.CfnVPNConcentratorPropsMixin(ec2_mixins.CfnVPNConcentratorMixinProps(
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            transit_gateway_id="transitGatewayId",
            type="type"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnVPNConcentratorMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::VPNConcentrator``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__746ae50d15fdd1db12665eecd9cf88e9f4cbe9d684c175735e3574fb97bc0bc8)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ef34dcd3dc41aa5e08478b2e3b84d3769d76627181f4444ea69cc7802f184862)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__487c8c35fe9689d4c536dfca80f1adb6fb6915a19bdc420a7ac092c1f06bd291)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnVPNConcentratorMixinProps":
        return typing.cast("CfnVPNConcentratorMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


class CfnVPNConnectionConnectionLogs(
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPNConnectionConnectionLogs",
):
    '''Builder for CfnVPNConnectionLogsMixin to generate CONNECTION_LOGS for CfnVPNConnection.

    :cloudformationResource: AWS::EC2::VPNConnection
    :logType: CONNECTION_LOGS
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_vPNConnection_connection_logs = ec2_mixins.CfnVPNConnectionConnectionLogs()
    '''

    def __init__(self) -> None:
        '''
        :stability: experimental
        '''
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="toFirehose")
    def to_firehose(
        self,
        delivery_stream: "_aws_cdk_interfaces_aws_kinesisfirehose_ceddda9d.IDeliveryStreamRef",
    ) -> "CfnVPNConnectionLogsMixin":
        '''Send logs to a Firehose Delivery Stream.

        :param delivery_stream: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0714b7ed6595a643ea3885a2bedf04f9357303454c4affc9a3fdc10377c732f1)
            check_type(argname="argument delivery_stream", value=delivery_stream, expected_type=type_hints["delivery_stream"])
        return typing.cast("CfnVPNConnectionLogsMixin", jsii.invoke(self, "toFirehose", [delivery_stream]))

    @jsii.member(jsii_name="toLogGroup")
    def to_log_group(
        self,
        log_group: "_aws_cdk_interfaces_aws_logs_ceddda9d.ILogGroupRef",
    ) -> "CfnVPNConnectionLogsMixin":
        '''Send logs to a CloudWatch Log Group.

        :param log_group: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__39bc7d8b12a17004e39a23a0d8bbd8a88236ef91b8537b8f147bddd516fda175)
            check_type(argname="argument log_group", value=log_group, expected_type=type_hints["log_group"])
        return typing.cast("CfnVPNConnectionLogsMixin", jsii.invoke(self, "toLogGroup", [log_group]))

    @jsii.member(jsii_name="toS3")
    def to_s3(
        self,
        bucket: "_aws_cdk_interfaces_aws_s3_ceddda9d.IBucketRef",
    ) -> "CfnVPNConnectionLogsMixin":
        '''Send logs to an S3 Bucket.

        :param bucket: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d0b3873bd6c3a456c0da217041ae01157cc50e3d845dec1841c6ef1a016d16e6)
            check_type(argname="argument bucket", value=bucket, expected_type=type_hints["bucket"])
        return typing.cast("CfnVPNConnectionLogsMixin", jsii.invoke(self, "toS3", [bucket]))


class CfnVPNConnectionEventLogs(
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPNConnectionEventLogs",
):
    '''Builder for CfnVPNConnectionLogsMixin to generate EVENT_LOGS for CfnVPNConnection.

    :cloudformationResource: AWS::EC2::VPNConnection
    :logType: EVENT_LOGS
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_vPNConnection_event_logs = ec2_mixins.CfnVPNConnectionEventLogs()
    '''

    def __init__(self) -> None:
        '''
        :stability: experimental
        '''
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="toFirehose")
    def to_firehose(
        self,
        delivery_stream: "_aws_cdk_interfaces_aws_kinesisfirehose_ceddda9d.IDeliveryStreamRef",
    ) -> "CfnVPNConnectionLogsMixin":
        '''Send logs to a Firehose Delivery Stream.

        :param delivery_stream: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dc8632c324459312ee0a9390bbc08e46022375cc1cf328bd0d787ea33834020a)
            check_type(argname="argument delivery_stream", value=delivery_stream, expected_type=type_hints["delivery_stream"])
        return typing.cast("CfnVPNConnectionLogsMixin", jsii.invoke(self, "toFirehose", [delivery_stream]))

    @jsii.member(jsii_name="toLogGroup")
    def to_log_group(
        self,
        log_group: "_aws_cdk_interfaces_aws_logs_ceddda9d.ILogGroupRef",
    ) -> "CfnVPNConnectionLogsMixin":
        '''Send logs to a CloudWatch Log Group.

        :param log_group: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__451c99afcbc205eab7eea65b7e4d1a7dea586391acf5bb4e346cb6bb9fd4d292)
            check_type(argname="argument log_group", value=log_group, expected_type=type_hints["log_group"])
        return typing.cast("CfnVPNConnectionLogsMixin", jsii.invoke(self, "toLogGroup", [log_group]))

    @jsii.member(jsii_name="toS3")
    def to_s3(
        self,
        bucket: "_aws_cdk_interfaces_aws_s3_ceddda9d.IBucketRef",
    ) -> "CfnVPNConnectionLogsMixin":
        '''Send logs to an S3 Bucket.

        :param bucket: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__317fbbc6872359002d35ad4f0480f2e397891ae2a57c1ef50d9db91437d7877a)
            check_type(argname="argument bucket", value=bucket, expected_type=type_hints["bucket"])
        return typing.cast("CfnVPNConnectionLogsMixin", jsii.invoke(self, "toS3", [bucket]))


@jsii.implements(_IMixin_11e4b965)
class CfnVPNConnectionLogsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPNConnectionLogsMixin",
):
    '''Specifies a VPN connection between a virtual private gateway and a VPN customer gateway or a transit gateway and a VPN customer gateway.

    To specify a VPN connection between a transit gateway and customer gateway, use the ``TransitGatewayId`` and ``CustomerGatewayId`` properties.

    To specify a VPN connection between a virtual private gateway and customer gateway, use the ``VpnGatewayId`` and ``CustomerGatewayId`` properties.

    For more information, see `AWS Site-to-Site VPN <https://docs.aws.amazon.com/vpn/latest/s2svpn/VPC_VPN.html>`_ in the *AWS Site-to-Site VPN User Guide* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html
    :cloudformationResource: AWS::EC2::VPNConnection
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import aws_logs as logs
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        # logs_delivery: logs.ILogsDelivery
        
        cfn_vPNConnection_logs_mixin = ec2_mixins.CfnVPNConnectionLogsMixin("logType", logs_delivery)
    '''

    def __init__(
        self,
        log_type: builtins.str,
        log_delivery: "_ILogsDelivery_0d3c9e29",
    ) -> None:
        '''Create a mixin to enable vended logs for ``AWS::EC2::VPNConnection``.

        :param log_type: Type of logs that are getting vended.
        :param log_delivery: Object in charge of setting up the delivery source, delivery destination, and delivery connection.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ce9eac90a24fb3cdf1c98803227fb3bbe2a17fe078982123de1a2d76a7c2ce11)
            check_type(argname="argument log_type", value=log_type, expected_type=type_hints["log_type"])
            check_type(argname="argument log_delivery", value=log_delivery, expected_type=type_hints["log_delivery"])
        jsii.create(self.__class__, self, [log_type, log_delivery])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        resource: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply vended logs configuration to the construct.

        :param resource: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__08bf6c65d68079aa41bf6ac20bf557fe4e3e4f206271bce9ec0c13d770c23dfa)
            check_type(argname="argument resource", value=resource, expected_type=type_hints["resource"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [resource]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct (has vendedLogs property).

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f6109783d1dae3a50b20367a7f158e2dc9aeefa1cc9cc390e5b25713ecc06928)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CONNECTION_LOGS")
    def CONNECTION_LOGS(cls) -> "CfnVPNConnectionConnectionLogs":
        return typing.cast("CfnVPNConnectionConnectionLogs", jsii.sget(cls, "CONNECTION_LOGS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="EVENT_LOGS")
    def EVENT_LOGS(cls) -> "CfnVPNConnectionEventLogs":
        return typing.cast("CfnVPNConnectionEventLogs", jsii.sget(cls, "EVENT_LOGS"))

    @builtins.property
    @jsii.member(jsii_name="logDelivery")
    def _log_delivery(self) -> "_ILogsDelivery_0d3c9e29":
        return typing.cast("_ILogsDelivery_0d3c9e29", jsii.get(self, "logDelivery"))

    @builtins.property
    @jsii.member(jsii_name="logType")
    def _log_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "logType"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPNConnectionMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "customer_gateway_id": "customerGatewayId",
        "enable_acceleration": "enableAcceleration",
        "local_ipv4_network_cidr": "localIpv4NetworkCidr",
        "local_ipv6_network_cidr": "localIpv6NetworkCidr",
        "outside_ip_address_type": "outsideIpAddressType",
        "pre_shared_key_storage": "preSharedKeyStorage",
        "remote_ipv4_network_cidr": "remoteIpv4NetworkCidr",
        "remote_ipv6_network_cidr": "remoteIpv6NetworkCidr",
        "static_routes_only": "staticRoutesOnly",
        "tags": "tags",
        "transit_gateway_id": "transitGatewayId",
        "transport_transit_gateway_attachment_id": "transportTransitGatewayAttachmentId",
        "tunnel_bandwidth": "tunnelBandwidth",
        "tunnel_inside_ip_version": "tunnelInsideIpVersion",
        "type": "type",
        "vpn_concentrator_id": "vpnConcentratorId",
        "vpn_gateway_id": "vpnGatewayId",
        "vpn_tunnel_options_specifications": "vpnTunnelOptionsSpecifications",
    },
)
class CfnVPNConnectionMixinProps:
    def __init__(
        self,
        *,
        customer_gateway_id: typing.Optional[builtins.str] = None,
        enable_acceleration: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        local_ipv4_network_cidr: typing.Optional[builtins.str] = None,
        local_ipv6_network_cidr: typing.Optional[builtins.str] = None,
        outside_ip_address_type: typing.Optional[builtins.str] = None,
        pre_shared_key_storage: typing.Optional[builtins.str] = None,
        remote_ipv4_network_cidr: typing.Optional[builtins.str] = None,
        remote_ipv6_network_cidr: typing.Optional[builtins.str] = None,
        static_routes_only: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        transit_gateway_id: typing.Optional[builtins.str] = None,
        transport_transit_gateway_attachment_id: typing.Optional[builtins.str] = None,
        tunnel_bandwidth: typing.Optional[builtins.str] = None,
        tunnel_inside_ip_version: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
        vpn_concentrator_id: typing.Optional[builtins.str] = None,
        vpn_gateway_id: typing.Optional[builtins.str] = None,
        vpn_tunnel_options_specifications: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnVPNConnectionPropsMixin.VpnTunnelOptionsSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
    ) -> None:
        '''Properties for CfnVPNConnectionPropsMixin.

        :param customer_gateway_id: The ID of the customer gateway at your end of the VPN connection.
        :param enable_acceleration: Indicate whether to enable acceleration for the VPN connection. Default: ``false``
        :param local_ipv4_network_cidr: The IPv4 CIDR on the customer gateway (on-premises) side of the VPN connection. Default: ``0.0.0.0/0``
        :param local_ipv6_network_cidr: The IPv6 CIDR on the customer gateway (on-premises) side of the VPN connection. Default: ``::/0``
        :param outside_ip_address_type: The type of IP address assigned to the outside interface of the customer gateway device. Valid values: ``PrivateIpv4`` | ``PublicIpv4`` | ``Ipv6`` Default: ``PublicIpv4``
        :param pre_shared_key_storage: Describes the storage location for an instance store-backed AMI.
        :param remote_ipv4_network_cidr: The IPv4 CIDR on the AWS side of the VPN connection. Default: ``0.0.0.0/0``
        :param remote_ipv6_network_cidr: The IPv6 CIDR on the AWS side of the VPN connection. Default: ``::/0``
        :param static_routes_only: Indicates whether the VPN connection uses static routes only. Static routes must be used for devices that don't support BGP. If you are creating a VPN connection for a device that does not support Border Gateway Protocol (BGP), you must specify ``true`` .
        :param tags: Any tags assigned to the VPN connection.
        :param transit_gateway_id: The ID of the transit gateway associated with the VPN connection. You must specify either ``TransitGatewayId`` or ``VpnGatewayId`` , but not both.
        :param transport_transit_gateway_attachment_id: The transit gateway attachment ID to use for the VPN tunnel. Required if ``OutsideIpAddressType`` is set to ``PrivateIpv4`` .
        :param tunnel_bandwidth: The desired bandwidth specification for the VPN tunnel, used when creating or modifying VPN connection options to set the tunnel's throughput capacity. ``standard`` supports up to 1.25 Gbps per tunnel, while ``large`` supports up to 5 Gbps per tunnel. The default value is ``standard`` . Existing VPN connections without a bandwidth setting will automatically default to ``standard`` . Default: - "standard"
        :param tunnel_inside_ip_version: Indicate whether the VPN tunnels process IPv4 or IPv6 traffic. Default: ``ipv4``
        :param type: The type of VPN connection.
        :param vpn_concentrator_id: The ID of the VPN concentrator to associate with the VPN connection.
        :param vpn_gateway_id: The ID of the virtual private gateway at the AWS side of the VPN connection. You must specify either ``TransitGatewayId`` or ``VpnGatewayId`` , but not both.
        :param vpn_tunnel_options_specifications: The tunnel options for the VPN connection.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_vPNConnection_mixin_props = ec2_mixins.CfnVPNConnectionMixinProps(
                customer_gateway_id="customerGatewayId",
                enable_acceleration=False,
                local_ipv4_network_cidr="localIpv4NetworkCidr",
                local_ipv6_network_cidr="localIpv6NetworkCidr",
                outside_ip_address_type="outsideIpAddressType",
                pre_shared_key_storage="preSharedKeyStorage",
                remote_ipv4_network_cidr="remoteIpv4NetworkCidr",
                remote_ipv6_network_cidr="remoteIpv6NetworkCidr",
                static_routes_only=False,
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                transit_gateway_id="transitGatewayId",
                transport_transit_gateway_attachment_id="transportTransitGatewayAttachmentId",
                tunnel_bandwidth="tunnelBandwidth",
                tunnel_inside_ip_version="tunnelInsideIpVersion",
                type="type",
                vpn_concentrator_id="vpnConcentratorId",
                vpn_gateway_id="vpnGatewayId",
                vpn_tunnel_options_specifications=[ec2_mixins.CfnVPNConnectionPropsMixin.VpnTunnelOptionsSpecificationProperty(
                    dpd_timeout_action="dpdTimeoutAction",
                    dpd_timeout_seconds=123,
                    enable_tunnel_lifecycle_control=False,
                    ike_versions=[{
                        "value": "value"
                    }],
                    log_options=ec2_mixins.CfnVPNConnectionPropsMixin.VpnTunnelLogOptionsSpecificationProperty(
                        cloudwatch_log_options=ec2_mixins.CfnVPNConnectionPropsMixin.CloudwatchLogOptionsSpecificationProperty(
                            bgp_log_enabled=False,
                            bgp_log_group_arn="bgpLogGroupArn",
                            bgp_log_output_format="bgpLogOutputFormat",
                            log_enabled=False,
                            log_group_arn="logGroupArn",
                            log_output_format="logOutputFormat"
                        )
                    ),
                    phase1_dh_group_numbers=[ec2_mixins.CfnVPNConnectionPropsMixin.Phase1DHGroupNumbersRequestListValueProperty(
                        value=123
                    )],
                    phase1_encryption_algorithms=[ec2_mixins.CfnVPNConnectionPropsMixin.Phase1EncryptionAlgorithmsRequestListValueProperty(
                        value="value"
                    )],
                    phase1_integrity_algorithms=[ec2_mixins.CfnVPNConnectionPropsMixin.Phase1IntegrityAlgorithmsRequestListValueProperty(
                        value="value"
                    )],
                    phase1_lifetime_seconds=123,
                    phase2_dh_group_numbers=[ec2_mixins.CfnVPNConnectionPropsMixin.Phase2DHGroupNumbersRequestListValueProperty(
                        value=123
                    )],
                    phase2_encryption_algorithms=[ec2_mixins.CfnVPNConnectionPropsMixin.Phase2EncryptionAlgorithmsRequestListValueProperty(
                        value="value"
                    )],
                    phase2_integrity_algorithms=[ec2_mixins.CfnVPNConnectionPropsMixin.Phase2IntegrityAlgorithmsRequestListValueProperty(
                        value="value"
                    )],
                    phase2_lifetime_seconds=123,
                    pre_shared_key="preSharedKey",
                    rekey_fuzz_percentage=123,
                    rekey_margin_time_seconds=123,
                    replay_window_size=123,
                    startup_action="startupAction",
                    tunnel_inside_cidr="tunnelInsideCidr",
                    tunnel_inside_ipv6_cidr="tunnelInsideIpv6Cidr"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d36961197217ac5b4c12d11c2bd9b07926f3feeca88c2319cf55f8a02650fa19)
            check_type(argname="argument customer_gateway_id", value=customer_gateway_id, expected_type=type_hints["customer_gateway_id"])
            check_type(argname="argument enable_acceleration", value=enable_acceleration, expected_type=type_hints["enable_acceleration"])
            check_type(argname="argument local_ipv4_network_cidr", value=local_ipv4_network_cidr, expected_type=type_hints["local_ipv4_network_cidr"])
            check_type(argname="argument local_ipv6_network_cidr", value=local_ipv6_network_cidr, expected_type=type_hints["local_ipv6_network_cidr"])
            check_type(argname="argument outside_ip_address_type", value=outside_ip_address_type, expected_type=type_hints["outside_ip_address_type"])
            check_type(argname="argument pre_shared_key_storage", value=pre_shared_key_storage, expected_type=type_hints["pre_shared_key_storage"])
            check_type(argname="argument remote_ipv4_network_cidr", value=remote_ipv4_network_cidr, expected_type=type_hints["remote_ipv4_network_cidr"])
            check_type(argname="argument remote_ipv6_network_cidr", value=remote_ipv6_network_cidr, expected_type=type_hints["remote_ipv6_network_cidr"])
            check_type(argname="argument static_routes_only", value=static_routes_only, expected_type=type_hints["static_routes_only"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument transit_gateway_id", value=transit_gateway_id, expected_type=type_hints["transit_gateway_id"])
            check_type(argname="argument transport_transit_gateway_attachment_id", value=transport_transit_gateway_attachment_id, expected_type=type_hints["transport_transit_gateway_attachment_id"])
            check_type(argname="argument tunnel_bandwidth", value=tunnel_bandwidth, expected_type=type_hints["tunnel_bandwidth"])
            check_type(argname="argument tunnel_inside_ip_version", value=tunnel_inside_ip_version, expected_type=type_hints["tunnel_inside_ip_version"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument vpn_concentrator_id", value=vpn_concentrator_id, expected_type=type_hints["vpn_concentrator_id"])
            check_type(argname="argument vpn_gateway_id", value=vpn_gateway_id, expected_type=type_hints["vpn_gateway_id"])
            check_type(argname="argument vpn_tunnel_options_specifications", value=vpn_tunnel_options_specifications, expected_type=type_hints["vpn_tunnel_options_specifications"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if customer_gateway_id is not None:
            self._values["customer_gateway_id"] = customer_gateway_id
        if enable_acceleration is not None:
            self._values["enable_acceleration"] = enable_acceleration
        if local_ipv4_network_cidr is not None:
            self._values["local_ipv4_network_cidr"] = local_ipv4_network_cidr
        if local_ipv6_network_cidr is not None:
            self._values["local_ipv6_network_cidr"] = local_ipv6_network_cidr
        if outside_ip_address_type is not None:
            self._values["outside_ip_address_type"] = outside_ip_address_type
        if pre_shared_key_storage is not None:
            self._values["pre_shared_key_storage"] = pre_shared_key_storage
        if remote_ipv4_network_cidr is not None:
            self._values["remote_ipv4_network_cidr"] = remote_ipv4_network_cidr
        if remote_ipv6_network_cidr is not None:
            self._values["remote_ipv6_network_cidr"] = remote_ipv6_network_cidr
        if static_routes_only is not None:
            self._values["static_routes_only"] = static_routes_only
        if tags is not None:
            self._values["tags"] = tags
        if transit_gateway_id is not None:
            self._values["transit_gateway_id"] = transit_gateway_id
        if transport_transit_gateway_attachment_id is not None:
            self._values["transport_transit_gateway_attachment_id"] = transport_transit_gateway_attachment_id
        if tunnel_bandwidth is not None:
            self._values["tunnel_bandwidth"] = tunnel_bandwidth
        if tunnel_inside_ip_version is not None:
            self._values["tunnel_inside_ip_version"] = tunnel_inside_ip_version
        if type is not None:
            self._values["type"] = type
        if vpn_concentrator_id is not None:
            self._values["vpn_concentrator_id"] = vpn_concentrator_id
        if vpn_gateway_id is not None:
            self._values["vpn_gateway_id"] = vpn_gateway_id
        if vpn_tunnel_options_specifications is not None:
            self._values["vpn_tunnel_options_specifications"] = vpn_tunnel_options_specifications

    @builtins.property
    def customer_gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the customer gateway at your end of the VPN connection.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-customergatewayid
        '''
        result = self._values.get("customer_gateway_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_acceleration(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Indicate whether to enable acceleration for the VPN connection.

        Default: ``false``

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-enableacceleration
        '''
        result = self._values.get("enable_acceleration")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def local_ipv4_network_cidr(self) -> typing.Optional[builtins.str]:
        '''The IPv4 CIDR on the customer gateway (on-premises) side of the VPN connection.

        Default: ``0.0.0.0/0``

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-localipv4networkcidr
        '''
        result = self._values.get("local_ipv4_network_cidr")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_ipv6_network_cidr(self) -> typing.Optional[builtins.str]:
        '''The IPv6 CIDR on the customer gateway (on-premises) side of the VPN connection.

        Default: ``::/0``

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-localipv6networkcidr
        '''
        result = self._values.get("local_ipv6_network_cidr")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def outside_ip_address_type(self) -> typing.Optional[builtins.str]:
        '''The type of IP address assigned to the outside interface of the customer gateway device.

        Valid values: ``PrivateIpv4`` | ``PublicIpv4`` | ``Ipv6``

        Default: ``PublicIpv4``

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-outsideipaddresstype
        '''
        result = self._values.get("outside_ip_address_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def pre_shared_key_storage(self) -> typing.Optional[builtins.str]:
        '''Describes the storage location for an instance store-backed AMI.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-presharedkeystorage
        '''
        result = self._values.get("pre_shared_key_storage")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def remote_ipv4_network_cidr(self) -> typing.Optional[builtins.str]:
        '''The IPv4 CIDR on the AWS side of the VPN connection.

        Default: ``0.0.0.0/0``

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-remoteipv4networkcidr
        '''
        result = self._values.get("remote_ipv4_network_cidr")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def remote_ipv6_network_cidr(self) -> typing.Optional[builtins.str]:
        '''The IPv6 CIDR on the AWS side of the VPN connection.

        Default: ``::/0``

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-remoteipv6networkcidr
        '''
        result = self._values.get("remote_ipv6_network_cidr")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def static_routes_only(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Indicates whether the VPN connection uses static routes only.

        Static routes must be used for devices that don't support BGP.

        If you are creating a VPN connection for a device that does not support Border Gateway Protocol (BGP), you must specify ``true`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-staticroutesonly
        '''
        result = self._values.get("static_routes_only")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''Any tags assigned to the VPN connection.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def transit_gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the transit gateway associated with the VPN connection.

        You must specify either ``TransitGatewayId`` or ``VpnGatewayId`` , but not both.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-transitgatewayid
        '''
        result = self._values.get("transit_gateway_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def transport_transit_gateway_attachment_id(self) -> typing.Optional[builtins.str]:
        '''The transit gateway attachment ID to use for the VPN tunnel.

        Required if ``OutsideIpAddressType`` is set to ``PrivateIpv4`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-transporttransitgatewayattachmentid
        '''
        result = self._values.get("transport_transit_gateway_attachment_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tunnel_bandwidth(self) -> typing.Optional[builtins.str]:
        '''The desired bandwidth specification for the VPN tunnel, used when creating or modifying VPN connection options to set the tunnel's throughput capacity.

        ``standard`` supports up to 1.25 Gbps per tunnel, while ``large`` supports up to 5 Gbps per tunnel. The default value is ``standard`` . Existing VPN connections without a bandwidth setting will automatically default to ``standard`` .

        :default: - "standard"

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-tunnelbandwidth
        '''
        result = self._values.get("tunnel_bandwidth")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tunnel_inside_ip_version(self) -> typing.Optional[builtins.str]:
        '''Indicate whether the VPN tunnels process IPv4 or IPv6 traffic.

        Default: ``ipv4``

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-tunnelinsideipversion
        '''
        result = self._values.get("tunnel_inside_ip_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''The type of VPN connection.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpn_concentrator_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the VPN concentrator to associate with the VPN connection.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-vpnconcentratorid
        '''
        result = self._values.get("vpn_concentrator_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpn_gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the virtual private gateway at the AWS side of the VPN connection.

        You must specify either ``TransitGatewayId`` or ``VpnGatewayId`` , but not both.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-vpngatewayid
        '''
        result = self._values.get("vpn_gateway_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpn_tunnel_options_specifications(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVPNConnectionPropsMixin.VpnTunnelOptionsSpecificationProperty"]]]]:
        '''The tunnel options for the VPN connection.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-vpntunneloptionsspecifications
        '''
        result = self._values.get("vpn_tunnel_options_specifications")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVPNConnectionPropsMixin.VpnTunnelOptionsSpecificationProperty"]]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnVPNConnectionMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnVPNConnectionPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPNConnectionPropsMixin",
):
    '''Specifies a VPN connection between a virtual private gateway and a VPN customer gateway or a transit gateway and a VPN customer gateway.

    To specify a VPN connection between a transit gateway and customer gateway, use the ``TransitGatewayId`` and ``CustomerGatewayId`` properties.

    To specify a VPN connection between a virtual private gateway and customer gateway, use the ``VpnGatewayId`` and ``CustomerGatewayId`` properties.

    For more information, see `AWS Site-to-Site VPN <https://docs.aws.amazon.com/vpn/latest/s2svpn/VPC_VPN.html>`_ in the *AWS Site-to-Site VPN User Guide* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html
    :cloudformationResource: AWS::EC2::VPNConnection
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_vPNConnection_props_mixin = ec2_mixins.CfnVPNConnectionPropsMixin(ec2_mixins.CfnVPNConnectionMixinProps(
            customer_gateway_id="customerGatewayId",
            enable_acceleration=False,
            local_ipv4_network_cidr="localIpv4NetworkCidr",
            local_ipv6_network_cidr="localIpv6NetworkCidr",
            outside_ip_address_type="outsideIpAddressType",
            pre_shared_key_storage="preSharedKeyStorage",
            remote_ipv4_network_cidr="remoteIpv4NetworkCidr",
            remote_ipv6_network_cidr="remoteIpv6NetworkCidr",
            static_routes_only=False,
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            transit_gateway_id="transitGatewayId",
            transport_transit_gateway_attachment_id="transportTransitGatewayAttachmentId",
            tunnel_bandwidth="tunnelBandwidth",
            tunnel_inside_ip_version="tunnelInsideIpVersion",
            type="type",
            vpn_concentrator_id="vpnConcentratorId",
            vpn_gateway_id="vpnGatewayId",
            vpn_tunnel_options_specifications=[ec2_mixins.CfnVPNConnectionPropsMixin.VpnTunnelOptionsSpecificationProperty(
                dpd_timeout_action="dpdTimeoutAction",
                dpd_timeout_seconds=123,
                enable_tunnel_lifecycle_control=False,
                ike_versions=[{
                    "value": "value"
                }],
                log_options=ec2_mixins.CfnVPNConnectionPropsMixin.VpnTunnelLogOptionsSpecificationProperty(
                    cloudwatch_log_options=ec2_mixins.CfnVPNConnectionPropsMixin.CloudwatchLogOptionsSpecificationProperty(
                        bgp_log_enabled=False,
                        bgp_log_group_arn="bgpLogGroupArn",
                        bgp_log_output_format="bgpLogOutputFormat",
                        log_enabled=False,
                        log_group_arn="logGroupArn",
                        log_output_format="logOutputFormat"
                    )
                ),
                phase1_dh_group_numbers=[ec2_mixins.CfnVPNConnectionPropsMixin.Phase1DHGroupNumbersRequestListValueProperty(
                    value=123
                )],
                phase1_encryption_algorithms=[ec2_mixins.CfnVPNConnectionPropsMixin.Phase1EncryptionAlgorithmsRequestListValueProperty(
                    value="value"
                )],
                phase1_integrity_algorithms=[ec2_mixins.CfnVPNConnectionPropsMixin.Phase1IntegrityAlgorithmsRequestListValueProperty(
                    value="value"
                )],
                phase1_lifetime_seconds=123,
                phase2_dh_group_numbers=[ec2_mixins.CfnVPNConnectionPropsMixin.Phase2DHGroupNumbersRequestListValueProperty(
                    value=123
                )],
                phase2_encryption_algorithms=[ec2_mixins.CfnVPNConnectionPropsMixin.Phase2EncryptionAlgorithmsRequestListValueProperty(
                    value="value"
                )],
                phase2_integrity_algorithms=[ec2_mixins.CfnVPNConnectionPropsMixin.Phase2IntegrityAlgorithmsRequestListValueProperty(
                    value="value"
                )],
                phase2_lifetime_seconds=123,
                pre_shared_key="preSharedKey",
                rekey_fuzz_percentage=123,
                rekey_margin_time_seconds=123,
                replay_window_size=123,
                startup_action="startupAction",
                tunnel_inside_cidr="tunnelInsideCidr",
                tunnel_inside_ipv6_cidr="tunnelInsideIpv6Cidr"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnVPNConnectionMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::VPNConnection``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__93c5a71a78105c566f373c2a3d7857a336e8cb7cbbc056a187bda3d2b1e4cdb0)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__edb0eaae70aa07208302cf60e867f8da5b2d45f36f88f861192d053468561bdb)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__51fe9fd58d29de38bfad6ccc35f18f30712ff4d73425a454f3df49725595fbd1)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnVPNConnectionMixinProps":
        return typing.cast("CfnVPNConnectionMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPNConnectionPropsMixin.CloudwatchLogOptionsSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "bgp_log_enabled": "bgpLogEnabled",
            "bgp_log_group_arn": "bgpLogGroupArn",
            "bgp_log_output_format": "bgpLogOutputFormat",
            "log_enabled": "logEnabled",
            "log_group_arn": "logGroupArn",
            "log_output_format": "logOutputFormat",
        },
    )
    class CloudwatchLogOptionsSpecificationProperty:
        def __init__(
            self,
            *,
            bgp_log_enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            bgp_log_group_arn: typing.Optional[builtins.str] = None,
            bgp_log_output_format: typing.Optional[builtins.str] = None,
            log_enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            log_group_arn: typing.Optional[builtins.str] = None,
            log_output_format: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Options for sending VPN tunnel logs to CloudWatch.

            :param bgp_log_enabled: Specifies whether to enable BGP logging for the VPN connection. Default value is ``False`` . Valid values: ``True`` | ``False``
            :param bgp_log_group_arn: The Amazon Resource Name (ARN) of the CloudWatch log group where BGP logs will be sent.
            :param bgp_log_output_format: The desired output format for BGP logs to be sent to CloudWatch. Default format is ``json`` . Valid values: ``json`` | ``text``
            :param log_enabled: Enable or disable VPN tunnel logging feature. Default value is ``False`` . Valid values: ``True`` | ``False``
            :param log_group_arn: The Amazon Resource Name (ARN) of the CloudWatch log group to send logs to.
            :param log_output_format: Set log format. Default format is ``json`` . Valid values: ``json`` | ``text``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-cloudwatchlogoptionsspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                cloudwatch_log_options_specification_property = ec2_mixins.CfnVPNConnectionPropsMixin.CloudwatchLogOptionsSpecificationProperty(
                    bgp_log_enabled=False,
                    bgp_log_group_arn="bgpLogGroupArn",
                    bgp_log_output_format="bgpLogOutputFormat",
                    log_enabled=False,
                    log_group_arn="logGroupArn",
                    log_output_format="logOutputFormat"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__0687c2579296c74b830581e08da772fff83c07de85c93a36e05c29ff35a0a8b0)
                check_type(argname="argument bgp_log_enabled", value=bgp_log_enabled, expected_type=type_hints["bgp_log_enabled"])
                check_type(argname="argument bgp_log_group_arn", value=bgp_log_group_arn, expected_type=type_hints["bgp_log_group_arn"])
                check_type(argname="argument bgp_log_output_format", value=bgp_log_output_format, expected_type=type_hints["bgp_log_output_format"])
                check_type(argname="argument log_enabled", value=log_enabled, expected_type=type_hints["log_enabled"])
                check_type(argname="argument log_group_arn", value=log_group_arn, expected_type=type_hints["log_group_arn"])
                check_type(argname="argument log_output_format", value=log_output_format, expected_type=type_hints["log_output_format"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if bgp_log_enabled is not None:
                self._values["bgp_log_enabled"] = bgp_log_enabled
            if bgp_log_group_arn is not None:
                self._values["bgp_log_group_arn"] = bgp_log_group_arn
            if bgp_log_output_format is not None:
                self._values["bgp_log_output_format"] = bgp_log_output_format
            if log_enabled is not None:
                self._values["log_enabled"] = log_enabled
            if log_group_arn is not None:
                self._values["log_group_arn"] = log_group_arn
            if log_output_format is not None:
                self._values["log_output_format"] = log_output_format

        @builtins.property
        def bgp_log_enabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Specifies whether to enable BGP logging for the VPN connection. Default value is ``False`` .

            Valid values: ``True`` | ``False``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-cloudwatchlogoptionsspecification.html#cfn-ec2-vpnconnection-cloudwatchlogoptionsspecification-bgplogenabled
            '''
            result = self._values.get("bgp_log_enabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def bgp_log_group_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the CloudWatch log group where BGP logs will be sent.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-cloudwatchlogoptionsspecification.html#cfn-ec2-vpnconnection-cloudwatchlogoptionsspecification-bgploggrouparn
            '''
            result = self._values.get("bgp_log_group_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def bgp_log_output_format(self) -> typing.Optional[builtins.str]:
            '''The desired output format for BGP logs to be sent to CloudWatch. Default format is ``json`` .

            Valid values: ``json`` | ``text``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-cloudwatchlogoptionsspecification.html#cfn-ec2-vpnconnection-cloudwatchlogoptionsspecification-bgplogoutputformat
            '''
            result = self._values.get("bgp_log_output_format")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def log_enabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Enable or disable VPN tunnel logging feature. Default value is ``False`` .

            Valid values: ``True`` | ``False``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-cloudwatchlogoptionsspecification.html#cfn-ec2-vpnconnection-cloudwatchlogoptionsspecification-logenabled
            '''
            result = self._values.get("log_enabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def log_group_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the CloudWatch log group to send logs to.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-cloudwatchlogoptionsspecification.html#cfn-ec2-vpnconnection-cloudwatchlogoptionsspecification-loggrouparn
            '''
            result = self._values.get("log_group_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def log_output_format(self) -> typing.Optional[builtins.str]:
            '''Set log format. Default format is ``json`` .

            Valid values: ``json`` | ``text``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-cloudwatchlogoptionsspecification.html#cfn-ec2-vpnconnection-cloudwatchlogoptionsspecification-logoutputformat
            '''
            result = self._values.get("log_output_format")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "CloudwatchLogOptionsSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPNConnectionPropsMixin.IKEVersionsRequestListValueProperty",
        jsii_struct_bases=[],
        name_mapping={"value": "value"},
    )
    class IKEVersionsRequestListValueProperty:
        def __init__(self, *, value: typing.Optional[builtins.str] = None) -> None:
            '''The IKE version that is permitted for the VPN tunnel.

            :param value: The IKE version.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-ikeversionsrequestlistvalue.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                i_kEVersions_request_list_value_property = {
                    "value": "value"
                }
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__2f48208c713c540b4d0e18f4b0151ab73468e7386f69603da7739358f81cac15)
                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def value(self) -> typing.Optional[builtins.str]:
            '''The IKE version.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-ikeversionsrequestlistvalue.html#cfn-ec2-vpnconnection-ikeversionsrequestlistvalue-value
            '''
            result = self._values.get("value")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "IKEVersionsRequestListValueProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPNConnectionPropsMixin.Phase1DHGroupNumbersRequestListValueProperty",
        jsii_struct_bases=[],
        name_mapping={"value": "value"},
    )
    class Phase1DHGroupNumbersRequestListValueProperty:
        def __init__(self, *, value: typing.Optional[jsii.Number] = None) -> None:
            '''Specifies a Diffie-Hellman group number for the VPN tunnel for phase 1 IKE negotiations.

            :param value: The Diffie-Hellmann group number.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-phase1dhgroupnumbersrequestlistvalue.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                phase1_dHGroup_numbers_request_list_value_property = ec2_mixins.CfnVPNConnectionPropsMixin.Phase1DHGroupNumbersRequestListValueProperty(
                    value=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__d9e0fdc6a2ca4ed6463a72f3e7be676f79966e0b2c376b7e78a6b3a41ceb1e10)
                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def value(self) -> typing.Optional[jsii.Number]:
            '''The Diffie-Hellmann group number.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-phase1dhgroupnumbersrequestlistvalue.html#cfn-ec2-vpnconnection-phase1dhgroupnumbersrequestlistvalue-value
            '''
            result = self._values.get("value")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "Phase1DHGroupNumbersRequestListValueProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPNConnectionPropsMixin.Phase1EncryptionAlgorithmsRequestListValueProperty",
        jsii_struct_bases=[],
        name_mapping={"value": "value"},
    )
    class Phase1EncryptionAlgorithmsRequestListValueProperty:
        def __init__(self, *, value: typing.Optional[builtins.str] = None) -> None:
            '''Specifies the encryption algorithm for the VPN tunnel for phase 1 IKE negotiations.

            :param value: The value for the encryption algorithm.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-phase1encryptionalgorithmsrequestlistvalue.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                phase1_encryption_algorithms_request_list_value_property = ec2_mixins.CfnVPNConnectionPropsMixin.Phase1EncryptionAlgorithmsRequestListValueProperty(
                    value="value"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__e396eb3e0debdd8638f8015bbcfbc8bbd8fc345582019d69b073909784222c07)
                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def value(self) -> typing.Optional[builtins.str]:
            '''The value for the encryption algorithm.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-phase1encryptionalgorithmsrequestlistvalue.html#cfn-ec2-vpnconnection-phase1encryptionalgorithmsrequestlistvalue-value
            '''
            result = self._values.get("value")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "Phase1EncryptionAlgorithmsRequestListValueProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPNConnectionPropsMixin.Phase1IntegrityAlgorithmsRequestListValueProperty",
        jsii_struct_bases=[],
        name_mapping={"value": "value"},
    )
    class Phase1IntegrityAlgorithmsRequestListValueProperty:
        def __init__(self, *, value: typing.Optional[builtins.str] = None) -> None:
            '''Specifies the integrity algorithm for the VPN tunnel for phase 1 IKE negotiations.

            :param value: The value for the integrity algorithm.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-phase1integrityalgorithmsrequestlistvalue.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                phase1_integrity_algorithms_request_list_value_property = ec2_mixins.CfnVPNConnectionPropsMixin.Phase1IntegrityAlgorithmsRequestListValueProperty(
                    value="value"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__e67eb354a95c6770ef14a61fca9fedf03ce399f5cd88e430dd31ec696cc86d35)
                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def value(self) -> typing.Optional[builtins.str]:
            '''The value for the integrity algorithm.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-phase1integrityalgorithmsrequestlistvalue.html#cfn-ec2-vpnconnection-phase1integrityalgorithmsrequestlistvalue-value
            '''
            result = self._values.get("value")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "Phase1IntegrityAlgorithmsRequestListValueProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPNConnectionPropsMixin.Phase2DHGroupNumbersRequestListValueProperty",
        jsii_struct_bases=[],
        name_mapping={"value": "value"},
    )
    class Phase2DHGroupNumbersRequestListValueProperty:
        def __init__(self, *, value: typing.Optional[jsii.Number] = None) -> None:
            '''Specifies a Diffie-Hellman group number for the VPN tunnel for phase 2 IKE negotiations.

            :param value: The Diffie-Hellmann group number.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-phase2dhgroupnumbersrequestlistvalue.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                phase2_dHGroup_numbers_request_list_value_property = ec2_mixins.CfnVPNConnectionPropsMixin.Phase2DHGroupNumbersRequestListValueProperty(
                    value=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__f5b3c8cc4b858f844f0edf19adc67e7b59cf57fba473382454bef9f715c3993a)
                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def value(self) -> typing.Optional[jsii.Number]:
            '''The Diffie-Hellmann group number.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-phase2dhgroupnumbersrequestlistvalue.html#cfn-ec2-vpnconnection-phase2dhgroupnumbersrequestlistvalue-value
            '''
            result = self._values.get("value")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "Phase2DHGroupNumbersRequestListValueProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPNConnectionPropsMixin.Phase2EncryptionAlgorithmsRequestListValueProperty",
        jsii_struct_bases=[],
        name_mapping={"value": "value"},
    )
    class Phase2EncryptionAlgorithmsRequestListValueProperty:
        def __init__(self, *, value: typing.Optional[builtins.str] = None) -> None:
            '''Specifies the encryption algorithm for the VPN tunnel for phase 2 IKE negotiations.

            :param value: The encryption algorithm.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-phase2encryptionalgorithmsrequestlistvalue.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                phase2_encryption_algorithms_request_list_value_property = ec2_mixins.CfnVPNConnectionPropsMixin.Phase2EncryptionAlgorithmsRequestListValueProperty(
                    value="value"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__b3111b3640744debc2d480e551f9d13a885baa62c5c1328b5eff0acd4a6c033a)
                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def value(self) -> typing.Optional[builtins.str]:
            '''The encryption algorithm.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-phase2encryptionalgorithmsrequestlistvalue.html#cfn-ec2-vpnconnection-phase2encryptionalgorithmsrequestlistvalue-value
            '''
            result = self._values.get("value")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "Phase2EncryptionAlgorithmsRequestListValueProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPNConnectionPropsMixin.Phase2IntegrityAlgorithmsRequestListValueProperty",
        jsii_struct_bases=[],
        name_mapping={"value": "value"},
    )
    class Phase2IntegrityAlgorithmsRequestListValueProperty:
        def __init__(self, *, value: typing.Optional[builtins.str] = None) -> None:
            '''Specifies the integrity algorithm for the VPN tunnel for phase 2 IKE negotiations.

            :param value: The integrity algorithm.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-phase2integrityalgorithmsrequestlistvalue.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                phase2_integrity_algorithms_request_list_value_property = ec2_mixins.CfnVPNConnectionPropsMixin.Phase2IntegrityAlgorithmsRequestListValueProperty(
                    value="value"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__d9a2e5829873eccebc7232236f3d43aba915dff99e60dc5a8c011c1791a179c5)
                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def value(self) -> typing.Optional[builtins.str]:
            '''The integrity algorithm.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-phase2integrityalgorithmsrequestlistvalue.html#cfn-ec2-vpnconnection-phase2integrityalgorithmsrequestlistvalue-value
            '''
            result = self._values.get("value")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "Phase2IntegrityAlgorithmsRequestListValueProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPNConnectionPropsMixin.VpnTunnelLogOptionsSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={"cloudwatch_log_options": "cloudwatchLogOptions"},
    )
    class VpnTunnelLogOptionsSpecificationProperty:
        def __init__(
            self,
            *,
            cloudwatch_log_options: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnVPNConnectionPropsMixin.CloudwatchLogOptionsSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Options for logging VPN tunnel activity.

            :param cloudwatch_log_options: Options for sending VPN tunnel logs to CloudWatch.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunnellogoptionsspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                vpn_tunnel_log_options_specification_property = ec2_mixins.CfnVPNConnectionPropsMixin.VpnTunnelLogOptionsSpecificationProperty(
                    cloudwatch_log_options=ec2_mixins.CfnVPNConnectionPropsMixin.CloudwatchLogOptionsSpecificationProperty(
                        bgp_log_enabled=False,
                        bgp_log_group_arn="bgpLogGroupArn",
                        bgp_log_output_format="bgpLogOutputFormat",
                        log_enabled=False,
                        log_group_arn="logGroupArn",
                        log_output_format="logOutputFormat"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__9f2c0a56046b918e4a5fde30c670382135eb18acd54fb670e6739ad2b82a98cd)
                check_type(argname="argument cloudwatch_log_options", value=cloudwatch_log_options, expected_type=type_hints["cloudwatch_log_options"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if cloudwatch_log_options is not None:
                self._values["cloudwatch_log_options"] = cloudwatch_log_options

        @builtins.property
        def cloudwatch_log_options(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVPNConnectionPropsMixin.CloudwatchLogOptionsSpecificationProperty"]]:
            '''Options for sending VPN tunnel logs to CloudWatch.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunnellogoptionsspecification.html#cfn-ec2-vpnconnection-vpntunnellogoptionsspecification-cloudwatchlogoptions
            '''
            result = self._values.get("cloudwatch_log_options")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVPNConnectionPropsMixin.CloudwatchLogOptionsSpecificationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "VpnTunnelLogOptionsSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPNConnectionPropsMixin.VpnTunnelOptionsSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "dpd_timeout_action": "dpdTimeoutAction",
            "dpd_timeout_seconds": "dpdTimeoutSeconds",
            "enable_tunnel_lifecycle_control": "enableTunnelLifecycleControl",
            "ike_versions": "ikeVersions",
            "log_options": "logOptions",
            "phase1_dh_group_numbers": "phase1DhGroupNumbers",
            "phase1_encryption_algorithms": "phase1EncryptionAlgorithms",
            "phase1_integrity_algorithms": "phase1IntegrityAlgorithms",
            "phase1_lifetime_seconds": "phase1LifetimeSeconds",
            "phase2_dh_group_numbers": "phase2DhGroupNumbers",
            "phase2_encryption_algorithms": "phase2EncryptionAlgorithms",
            "phase2_integrity_algorithms": "phase2IntegrityAlgorithms",
            "phase2_lifetime_seconds": "phase2LifetimeSeconds",
            "pre_shared_key": "preSharedKey",
            "rekey_fuzz_percentage": "rekeyFuzzPercentage",
            "rekey_margin_time_seconds": "rekeyMarginTimeSeconds",
            "replay_window_size": "replayWindowSize",
            "startup_action": "startupAction",
            "tunnel_inside_cidr": "tunnelInsideCidr",
            "tunnel_inside_ipv6_cidr": "tunnelInsideIpv6Cidr",
        },
    )
    class VpnTunnelOptionsSpecificationProperty:
        def __init__(
            self,
            *,
            dpd_timeout_action: typing.Optional[builtins.str] = None,
            dpd_timeout_seconds: typing.Optional[jsii.Number] = None,
            enable_tunnel_lifecycle_control: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            ike_versions: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnVPNConnectionPropsMixin.IKEVersionsRequestListValueProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            log_options: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnVPNConnectionPropsMixin.VpnTunnelLogOptionsSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            phase1_dh_group_numbers: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnVPNConnectionPropsMixin.Phase1DHGroupNumbersRequestListValueProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            phase1_encryption_algorithms: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnVPNConnectionPropsMixin.Phase1EncryptionAlgorithmsRequestListValueProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            phase1_integrity_algorithms: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnVPNConnectionPropsMixin.Phase1IntegrityAlgorithmsRequestListValueProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            phase1_lifetime_seconds: typing.Optional[jsii.Number] = None,
            phase2_dh_group_numbers: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnVPNConnectionPropsMixin.Phase2DHGroupNumbersRequestListValueProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            phase2_encryption_algorithms: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnVPNConnectionPropsMixin.Phase2EncryptionAlgorithmsRequestListValueProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            phase2_integrity_algorithms: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnVPNConnectionPropsMixin.Phase2IntegrityAlgorithmsRequestListValueProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            phase2_lifetime_seconds: typing.Optional[jsii.Number] = None,
            pre_shared_key: typing.Optional[builtins.str] = None,
            rekey_fuzz_percentage: typing.Optional[jsii.Number] = None,
            rekey_margin_time_seconds: typing.Optional[jsii.Number] = None,
            replay_window_size: typing.Optional[jsii.Number] = None,
            startup_action: typing.Optional[builtins.str] = None,
            tunnel_inside_cidr: typing.Optional[builtins.str] = None,
            tunnel_inside_ipv6_cidr: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The tunnel options for a single VPN tunnel.

            :param dpd_timeout_action: The action to take after DPD timeout occurs. Specify ``restart`` to restart the IKE initiation. Specify ``clear`` to end the IKE session. Valid Values: ``clear`` | ``none`` | ``restart`` Default: ``clear``
            :param dpd_timeout_seconds: The number of seconds after which a DPD timeout occurs. Constraints: A value greater than or equal to 30. Default: ``30``
            :param enable_tunnel_lifecycle_control: Turn on or off tunnel endpoint lifecycle control feature.
            :param ike_versions: The IKE versions that are permitted for the VPN tunnel. Valid values: ``ikev1`` | ``ikev2``
            :param log_options: Options for logging VPN tunnel activity.
            :param phase1_dh_group_numbers: One or more Diffie-Hellman group numbers that are permitted for the VPN tunnel for phase 1 IKE negotiations. Valid values: ``2`` | ``14`` | ``15`` | ``16`` | ``17`` | ``18`` | ``19`` | ``20`` | ``21`` | ``22`` | ``23`` | ``24``
            :param phase1_encryption_algorithms: One or more encryption algorithms that are permitted for the VPN tunnel for phase 1 IKE negotiations. Valid values: ``AES128`` | ``AES256`` | ``AES128-GCM-16`` | ``AES256-GCM-16``
            :param phase1_integrity_algorithms: One or more integrity algorithms that are permitted for the VPN tunnel for phase 1 IKE negotiations. Valid values: ``SHA1`` | ``SHA2-256`` | ``SHA2-384`` | ``SHA2-512``
            :param phase1_lifetime_seconds: The lifetime for phase 1 of the IKE negotiation, in seconds. Constraints: A value between 900 and 28,800. Default: ``28800``
            :param phase2_dh_group_numbers: One or more Diffie-Hellman group numbers that are permitted for the VPN tunnel for phase 2 IKE negotiations. Valid values: ``2`` | ``5`` | ``14`` | ``15`` | ``16`` | ``17`` | ``18`` | ``19`` | ``20`` | ``21`` | ``22`` | ``23`` | ``24``
            :param phase2_encryption_algorithms: One or more encryption algorithms that are permitted for the VPN tunnel for phase 2 IKE negotiations. Valid values: ``AES128`` | ``AES256`` | ``AES128-GCM-16`` | ``AES256-GCM-16``
            :param phase2_integrity_algorithms: One or more integrity algorithms that are permitted for the VPN tunnel for phase 2 IKE negotiations. Valid values: ``SHA1`` | ``SHA2-256`` | ``SHA2-384`` | ``SHA2-512``
            :param phase2_lifetime_seconds: The lifetime for phase 2 of the IKE negotiation, in seconds. Constraints: A value between 900 and 3,600. The value must be less than the value for ``Phase1LifetimeSeconds`` . Default: ``3600``
            :param pre_shared_key: The pre-shared key (PSK) to establish initial authentication between the virtual private gateway and customer gateway. Constraints: Allowed characters are alphanumeric characters, periods (.), and underscores (_). Must be between 8 and 64 characters in length and cannot start with zero (0).
            :param rekey_fuzz_percentage: The percentage of the rekey window (determined by ``RekeyMarginTimeSeconds`` ) during which the rekey time is randomly selected. Constraints: A value between 0 and 100. Default: ``100``
            :param rekey_margin_time_seconds: The margin time, in seconds, before the phase 2 lifetime expires, during which the AWS side of the VPN connection performs an IKE rekey. The exact time of the rekey is randomly selected based on the value for ``RekeyFuzzPercentage`` . Constraints: A value between 60 and half of ``Phase2LifetimeSeconds`` . Default: ``270``
            :param replay_window_size: The number of packets in an IKE replay window. Constraints: A value between 64 and 2048. Default: ``1024``
            :param startup_action: The action to take when the establishing the tunnel for the VPN connection. By default, your customer gateway device must initiate the IKE negotiation and bring up the tunnel. Specify ``start`` for AWS to initiate the IKE negotiation. Valid Values: ``add`` | ``start`` Default: ``add``
            :param tunnel_inside_cidr: The range of inside IP addresses for the tunnel. Any specified CIDR blocks must be unique across all VPN connections that use the same virtual private gateway. Constraints: A size /30 CIDR block from the ``169.254.0.0/16`` range. The following CIDR blocks are reserved and cannot be used: - ``169.254.0.0/30`` - ``169.254.1.0/30`` - ``169.254.2.0/30`` - ``169.254.3.0/30`` - ``169.254.4.0/30`` - ``169.254.5.0/30`` - ``169.254.169.252/30``
            :param tunnel_inside_ipv6_cidr: The range of inside IPv6 addresses for the tunnel. Any specified CIDR blocks must be unique across all VPN connections that use the same transit gateway. Constraints: A size /126 CIDR block from the local ``fd00::/8`` range.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunneloptionsspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                vpn_tunnel_options_specification_property = ec2_mixins.CfnVPNConnectionPropsMixin.VpnTunnelOptionsSpecificationProperty(
                    dpd_timeout_action="dpdTimeoutAction",
                    dpd_timeout_seconds=123,
                    enable_tunnel_lifecycle_control=False,
                    ike_versions=[{
                        "value": "value"
                    }],
                    log_options=ec2_mixins.CfnVPNConnectionPropsMixin.VpnTunnelLogOptionsSpecificationProperty(
                        cloudwatch_log_options=ec2_mixins.CfnVPNConnectionPropsMixin.CloudwatchLogOptionsSpecificationProperty(
                            bgp_log_enabled=False,
                            bgp_log_group_arn="bgpLogGroupArn",
                            bgp_log_output_format="bgpLogOutputFormat",
                            log_enabled=False,
                            log_group_arn="logGroupArn",
                            log_output_format="logOutputFormat"
                        )
                    ),
                    phase1_dh_group_numbers=[ec2_mixins.CfnVPNConnectionPropsMixin.Phase1DHGroupNumbersRequestListValueProperty(
                        value=123
                    )],
                    phase1_encryption_algorithms=[ec2_mixins.CfnVPNConnectionPropsMixin.Phase1EncryptionAlgorithmsRequestListValueProperty(
                        value="value"
                    )],
                    phase1_integrity_algorithms=[ec2_mixins.CfnVPNConnectionPropsMixin.Phase1IntegrityAlgorithmsRequestListValueProperty(
                        value="value"
                    )],
                    phase1_lifetime_seconds=123,
                    phase2_dh_group_numbers=[ec2_mixins.CfnVPNConnectionPropsMixin.Phase2DHGroupNumbersRequestListValueProperty(
                        value=123
                    )],
                    phase2_encryption_algorithms=[ec2_mixins.CfnVPNConnectionPropsMixin.Phase2EncryptionAlgorithmsRequestListValueProperty(
                        value="value"
                    )],
                    phase2_integrity_algorithms=[ec2_mixins.CfnVPNConnectionPropsMixin.Phase2IntegrityAlgorithmsRequestListValueProperty(
                        value="value"
                    )],
                    phase2_lifetime_seconds=123,
                    pre_shared_key="preSharedKey",
                    rekey_fuzz_percentage=123,
                    rekey_margin_time_seconds=123,
                    replay_window_size=123,
                    startup_action="startupAction",
                    tunnel_inside_cidr="tunnelInsideCidr",
                    tunnel_inside_ipv6_cidr="tunnelInsideIpv6Cidr"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__4d90f6d35a70cc9b17cde62a94c969899fb8453018d81870249d53ffef1ab445)
                check_type(argname="argument dpd_timeout_action", value=dpd_timeout_action, expected_type=type_hints["dpd_timeout_action"])
                check_type(argname="argument dpd_timeout_seconds", value=dpd_timeout_seconds, expected_type=type_hints["dpd_timeout_seconds"])
                check_type(argname="argument enable_tunnel_lifecycle_control", value=enable_tunnel_lifecycle_control, expected_type=type_hints["enable_tunnel_lifecycle_control"])
                check_type(argname="argument ike_versions", value=ike_versions, expected_type=type_hints["ike_versions"])
                check_type(argname="argument log_options", value=log_options, expected_type=type_hints["log_options"])
                check_type(argname="argument phase1_dh_group_numbers", value=phase1_dh_group_numbers, expected_type=type_hints["phase1_dh_group_numbers"])
                check_type(argname="argument phase1_encryption_algorithms", value=phase1_encryption_algorithms, expected_type=type_hints["phase1_encryption_algorithms"])
                check_type(argname="argument phase1_integrity_algorithms", value=phase1_integrity_algorithms, expected_type=type_hints["phase1_integrity_algorithms"])
                check_type(argname="argument phase1_lifetime_seconds", value=phase1_lifetime_seconds, expected_type=type_hints["phase1_lifetime_seconds"])
                check_type(argname="argument phase2_dh_group_numbers", value=phase2_dh_group_numbers, expected_type=type_hints["phase2_dh_group_numbers"])
                check_type(argname="argument phase2_encryption_algorithms", value=phase2_encryption_algorithms, expected_type=type_hints["phase2_encryption_algorithms"])
                check_type(argname="argument phase2_integrity_algorithms", value=phase2_integrity_algorithms, expected_type=type_hints["phase2_integrity_algorithms"])
                check_type(argname="argument phase2_lifetime_seconds", value=phase2_lifetime_seconds, expected_type=type_hints["phase2_lifetime_seconds"])
                check_type(argname="argument pre_shared_key", value=pre_shared_key, expected_type=type_hints["pre_shared_key"])
                check_type(argname="argument rekey_fuzz_percentage", value=rekey_fuzz_percentage, expected_type=type_hints["rekey_fuzz_percentage"])
                check_type(argname="argument rekey_margin_time_seconds", value=rekey_margin_time_seconds, expected_type=type_hints["rekey_margin_time_seconds"])
                check_type(argname="argument replay_window_size", value=replay_window_size, expected_type=type_hints["replay_window_size"])
                check_type(argname="argument startup_action", value=startup_action, expected_type=type_hints["startup_action"])
                check_type(argname="argument tunnel_inside_cidr", value=tunnel_inside_cidr, expected_type=type_hints["tunnel_inside_cidr"])
                check_type(argname="argument tunnel_inside_ipv6_cidr", value=tunnel_inside_ipv6_cidr, expected_type=type_hints["tunnel_inside_ipv6_cidr"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if dpd_timeout_action is not None:
                self._values["dpd_timeout_action"] = dpd_timeout_action
            if dpd_timeout_seconds is not None:
                self._values["dpd_timeout_seconds"] = dpd_timeout_seconds
            if enable_tunnel_lifecycle_control is not None:
                self._values["enable_tunnel_lifecycle_control"] = enable_tunnel_lifecycle_control
            if ike_versions is not None:
                self._values["ike_versions"] = ike_versions
            if log_options is not None:
                self._values["log_options"] = log_options
            if phase1_dh_group_numbers is not None:
                self._values["phase1_dh_group_numbers"] = phase1_dh_group_numbers
            if phase1_encryption_algorithms is not None:
                self._values["phase1_encryption_algorithms"] = phase1_encryption_algorithms
            if phase1_integrity_algorithms is not None:
                self._values["phase1_integrity_algorithms"] = phase1_integrity_algorithms
            if phase1_lifetime_seconds is not None:
                self._values["phase1_lifetime_seconds"] = phase1_lifetime_seconds
            if phase2_dh_group_numbers is not None:
                self._values["phase2_dh_group_numbers"] = phase2_dh_group_numbers
            if phase2_encryption_algorithms is not None:
                self._values["phase2_encryption_algorithms"] = phase2_encryption_algorithms
            if phase2_integrity_algorithms is not None:
                self._values["phase2_integrity_algorithms"] = phase2_integrity_algorithms
            if phase2_lifetime_seconds is not None:
                self._values["phase2_lifetime_seconds"] = phase2_lifetime_seconds
            if pre_shared_key is not None:
                self._values["pre_shared_key"] = pre_shared_key
            if rekey_fuzz_percentage is not None:
                self._values["rekey_fuzz_percentage"] = rekey_fuzz_percentage
            if rekey_margin_time_seconds is not None:
                self._values["rekey_margin_time_seconds"] = rekey_margin_time_seconds
            if replay_window_size is not None:
                self._values["replay_window_size"] = replay_window_size
            if startup_action is not None:
                self._values["startup_action"] = startup_action
            if tunnel_inside_cidr is not None:
                self._values["tunnel_inside_cidr"] = tunnel_inside_cidr
            if tunnel_inside_ipv6_cidr is not None:
                self._values["tunnel_inside_ipv6_cidr"] = tunnel_inside_ipv6_cidr

        @builtins.property
        def dpd_timeout_action(self) -> typing.Optional[builtins.str]:
            '''The action to take after DPD timeout occurs.

            Specify ``restart`` to restart the IKE initiation. Specify ``clear`` to end the IKE session.

            Valid Values: ``clear`` | ``none`` | ``restart``

            Default: ``clear``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunneloptionsspecification.html#cfn-ec2-vpnconnection-vpntunneloptionsspecification-dpdtimeoutaction
            '''
            result = self._values.get("dpd_timeout_action")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def dpd_timeout_seconds(self) -> typing.Optional[jsii.Number]:
            '''The number of seconds after which a DPD timeout occurs.

            Constraints: A value greater than or equal to 30.

            Default: ``30``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunneloptionsspecification.html#cfn-ec2-vpnconnection-vpntunneloptionsspecification-dpdtimeoutseconds
            '''
            result = self._values.get("dpd_timeout_seconds")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def enable_tunnel_lifecycle_control(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Turn on or off tunnel endpoint lifecycle control feature.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunneloptionsspecification.html#cfn-ec2-vpnconnection-vpntunneloptionsspecification-enabletunnellifecyclecontrol
            '''
            result = self._values.get("enable_tunnel_lifecycle_control")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def ike_versions(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVPNConnectionPropsMixin.IKEVersionsRequestListValueProperty"]]]]:
            '''The IKE versions that are permitted for the VPN tunnel.

            Valid values: ``ikev1`` | ``ikev2``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunneloptionsspecification.html#cfn-ec2-vpnconnection-vpntunneloptionsspecification-ikeversions
            '''
            result = self._values.get("ike_versions")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVPNConnectionPropsMixin.IKEVersionsRequestListValueProperty"]]]], result)

        @builtins.property
        def log_options(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVPNConnectionPropsMixin.VpnTunnelLogOptionsSpecificationProperty"]]:
            '''Options for logging VPN tunnel activity.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunneloptionsspecification.html#cfn-ec2-vpnconnection-vpntunneloptionsspecification-logoptions
            '''
            result = self._values.get("log_options")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVPNConnectionPropsMixin.VpnTunnelLogOptionsSpecificationProperty"]], result)

        @builtins.property
        def phase1_dh_group_numbers(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVPNConnectionPropsMixin.Phase1DHGroupNumbersRequestListValueProperty"]]]]:
            '''One or more Diffie-Hellman group numbers that are permitted for the VPN tunnel for phase 1 IKE negotiations.

            Valid values: ``2`` | ``14`` | ``15`` | ``16`` | ``17`` | ``18`` | ``19`` | ``20`` | ``21`` | ``22`` | ``23`` | ``24``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunneloptionsspecification.html#cfn-ec2-vpnconnection-vpntunneloptionsspecification-phase1dhgroupnumbers
            '''
            result = self._values.get("phase1_dh_group_numbers")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVPNConnectionPropsMixin.Phase1DHGroupNumbersRequestListValueProperty"]]]], result)

        @builtins.property
        def phase1_encryption_algorithms(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVPNConnectionPropsMixin.Phase1EncryptionAlgorithmsRequestListValueProperty"]]]]:
            '''One or more encryption algorithms that are permitted for the VPN tunnel for phase 1 IKE negotiations.

            Valid values: ``AES128`` | ``AES256`` | ``AES128-GCM-16`` | ``AES256-GCM-16``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunneloptionsspecification.html#cfn-ec2-vpnconnection-vpntunneloptionsspecification-phase1encryptionalgorithms
            '''
            result = self._values.get("phase1_encryption_algorithms")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVPNConnectionPropsMixin.Phase1EncryptionAlgorithmsRequestListValueProperty"]]]], result)

        @builtins.property
        def phase1_integrity_algorithms(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVPNConnectionPropsMixin.Phase1IntegrityAlgorithmsRequestListValueProperty"]]]]:
            '''One or more integrity algorithms that are permitted for the VPN tunnel for phase 1 IKE negotiations.

            Valid values: ``SHA1`` | ``SHA2-256`` | ``SHA2-384`` | ``SHA2-512``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunneloptionsspecification.html#cfn-ec2-vpnconnection-vpntunneloptionsspecification-phase1integrityalgorithms
            '''
            result = self._values.get("phase1_integrity_algorithms")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVPNConnectionPropsMixin.Phase1IntegrityAlgorithmsRequestListValueProperty"]]]], result)

        @builtins.property
        def phase1_lifetime_seconds(self) -> typing.Optional[jsii.Number]:
            '''The lifetime for phase 1 of the IKE negotiation, in seconds.

            Constraints: A value between 900 and 28,800.

            Default: ``28800``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunneloptionsspecification.html#cfn-ec2-vpnconnection-vpntunneloptionsspecification-phase1lifetimeseconds
            '''
            result = self._values.get("phase1_lifetime_seconds")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def phase2_dh_group_numbers(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVPNConnectionPropsMixin.Phase2DHGroupNumbersRequestListValueProperty"]]]]:
            '''One or more Diffie-Hellman group numbers that are permitted for the VPN tunnel for phase 2 IKE negotiations.

            Valid values: ``2`` | ``5`` | ``14`` | ``15`` | ``16`` | ``17`` | ``18`` | ``19`` | ``20`` | ``21`` | ``22`` | ``23`` | ``24``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunneloptionsspecification.html#cfn-ec2-vpnconnection-vpntunneloptionsspecification-phase2dhgroupnumbers
            '''
            result = self._values.get("phase2_dh_group_numbers")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVPNConnectionPropsMixin.Phase2DHGroupNumbersRequestListValueProperty"]]]], result)

        @builtins.property
        def phase2_encryption_algorithms(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVPNConnectionPropsMixin.Phase2EncryptionAlgorithmsRequestListValueProperty"]]]]:
            '''One or more encryption algorithms that are permitted for the VPN tunnel for phase 2 IKE negotiations.

            Valid values: ``AES128`` | ``AES256`` | ``AES128-GCM-16`` | ``AES256-GCM-16``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunneloptionsspecification.html#cfn-ec2-vpnconnection-vpntunneloptionsspecification-phase2encryptionalgorithms
            '''
            result = self._values.get("phase2_encryption_algorithms")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVPNConnectionPropsMixin.Phase2EncryptionAlgorithmsRequestListValueProperty"]]]], result)

        @builtins.property
        def phase2_integrity_algorithms(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVPNConnectionPropsMixin.Phase2IntegrityAlgorithmsRequestListValueProperty"]]]]:
            '''One or more integrity algorithms that are permitted for the VPN tunnel for phase 2 IKE negotiations.

            Valid values: ``SHA1`` | ``SHA2-256`` | ``SHA2-384`` | ``SHA2-512``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunneloptionsspecification.html#cfn-ec2-vpnconnection-vpntunneloptionsspecification-phase2integrityalgorithms
            '''
            result = self._values.get("phase2_integrity_algorithms")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVPNConnectionPropsMixin.Phase2IntegrityAlgorithmsRequestListValueProperty"]]]], result)

        @builtins.property
        def phase2_lifetime_seconds(self) -> typing.Optional[jsii.Number]:
            '''The lifetime for phase 2 of the IKE negotiation, in seconds.

            Constraints: A value between 900 and 3,600. The value must be less than the value for ``Phase1LifetimeSeconds`` .

            Default: ``3600``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunneloptionsspecification.html#cfn-ec2-vpnconnection-vpntunneloptionsspecification-phase2lifetimeseconds
            '''
            result = self._values.get("phase2_lifetime_seconds")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def pre_shared_key(self) -> typing.Optional[builtins.str]:
            '''The pre-shared key (PSK) to establish initial authentication between the virtual private gateway and customer gateway.

            Constraints: Allowed characters are alphanumeric characters, periods (.), and underscores (_). Must be between 8 and 64 characters in length and cannot start with zero (0).

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunneloptionsspecification.html#cfn-ec2-vpnconnection-vpntunneloptionsspecification-presharedkey
            '''
            result = self._values.get("pre_shared_key")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def rekey_fuzz_percentage(self) -> typing.Optional[jsii.Number]:
            '''The percentage of the rekey window (determined by ``RekeyMarginTimeSeconds`` ) during which the rekey time is randomly selected.

            Constraints: A value between 0 and 100.

            Default: ``100``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunneloptionsspecification.html#cfn-ec2-vpnconnection-vpntunneloptionsspecification-rekeyfuzzpercentage
            '''
            result = self._values.get("rekey_fuzz_percentage")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def rekey_margin_time_seconds(self) -> typing.Optional[jsii.Number]:
            '''The margin time, in seconds, before the phase 2 lifetime expires, during which the AWS side of the VPN connection performs an IKE rekey.

            The exact time of the rekey is randomly selected based on the value for ``RekeyFuzzPercentage`` .

            Constraints: A value between 60 and half of ``Phase2LifetimeSeconds`` .

            Default: ``270``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunneloptionsspecification.html#cfn-ec2-vpnconnection-vpntunneloptionsspecification-rekeymargintimeseconds
            '''
            result = self._values.get("rekey_margin_time_seconds")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def replay_window_size(self) -> typing.Optional[jsii.Number]:
            '''The number of packets in an IKE replay window.

            Constraints: A value between 64 and 2048.

            Default: ``1024``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunneloptionsspecification.html#cfn-ec2-vpnconnection-vpntunneloptionsspecification-replaywindowsize
            '''
            result = self._values.get("replay_window_size")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def startup_action(self) -> typing.Optional[builtins.str]:
            '''The action to take when the establishing the tunnel for the VPN connection.

            By default, your customer gateway device must initiate the IKE negotiation and bring up the tunnel. Specify ``start`` for AWS to initiate the IKE negotiation.

            Valid Values: ``add`` | ``start``

            Default: ``add``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunneloptionsspecification.html#cfn-ec2-vpnconnection-vpntunneloptionsspecification-startupaction
            '''
            result = self._values.get("startup_action")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def tunnel_inside_cidr(self) -> typing.Optional[builtins.str]:
            '''The range of inside IP addresses for the tunnel.

            Any specified CIDR blocks must be unique across all VPN connections that use the same virtual private gateway.

            Constraints: A size /30 CIDR block from the ``169.254.0.0/16`` range. The following CIDR blocks are reserved and cannot be used:

            - ``169.254.0.0/30``
            - ``169.254.1.0/30``
            - ``169.254.2.0/30``
            - ``169.254.3.0/30``
            - ``169.254.4.0/30``
            - ``169.254.5.0/30``
            - ``169.254.169.252/30``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunneloptionsspecification.html#cfn-ec2-vpnconnection-vpntunneloptionsspecification-tunnelinsidecidr
            '''
            result = self._values.get("tunnel_inside_cidr")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def tunnel_inside_ipv6_cidr(self) -> typing.Optional[builtins.str]:
            '''The range of inside IPv6 addresses for the tunnel.

            Any specified CIDR blocks must be unique across all VPN connections that use the same transit gateway.

            Constraints: A size /126 CIDR block from the local ``fd00::/8`` range.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunneloptionsspecification.html#cfn-ec2-vpnconnection-vpntunneloptionsspecification-tunnelinsideipv6cidr
            '''
            result = self._values.get("tunnel_inside_ipv6_cidr")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "VpnTunnelOptionsSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPNConnectionRouteMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "destination_cidr_block": "destinationCidrBlock",
        "vpn_connection_id": "vpnConnectionId",
    },
)
class CfnVPNConnectionRouteMixinProps:
    def __init__(
        self,
        *,
        destination_cidr_block: typing.Optional[builtins.str] = None,
        vpn_connection_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnVPNConnectionRoutePropsMixin.

        :param destination_cidr_block: The CIDR block associated with the local subnet of the customer network.
        :param vpn_connection_id: The ID of the VPN connection.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnectionroute.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_vPNConnection_route_mixin_props = ec2_mixins.CfnVPNConnectionRouteMixinProps(
                destination_cidr_block="destinationCidrBlock",
                vpn_connection_id="vpnConnectionId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c4613b28853a38dd76854ee76624922c0925fbcd55a0123b8dec6a1d7f38654b)
            check_type(argname="argument destination_cidr_block", value=destination_cidr_block, expected_type=type_hints["destination_cidr_block"])
            check_type(argname="argument vpn_connection_id", value=vpn_connection_id, expected_type=type_hints["vpn_connection_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if destination_cidr_block is not None:
            self._values["destination_cidr_block"] = destination_cidr_block
        if vpn_connection_id is not None:
            self._values["vpn_connection_id"] = vpn_connection_id

    @builtins.property
    def destination_cidr_block(self) -> typing.Optional[builtins.str]:
        '''The CIDR block associated with the local subnet of the customer network.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnectionroute.html#cfn-ec2-vpnconnectionroute-destinationcidrblock
        '''
        result = self._values.get("destination_cidr_block")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpn_connection_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the VPN connection.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnectionroute.html#cfn-ec2-vpnconnectionroute-vpnconnectionid
        '''
        result = self._values.get("vpn_connection_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnVPNConnectionRouteMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnVPNConnectionRoutePropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPNConnectionRoutePropsMixin",
):
    '''Specifies a static route for a VPN connection between an existing virtual private gateway and a VPN customer gateway.

    The static route allows traffic to be routed from the virtual private gateway to the VPN customer gateway.

    For more information, see `AWS Site-to-Site VPN <https://docs.aws.amazon.com/vpn/latest/s2svpn/VPC_VPN.html>`_ in the *AWS Site-to-Site VPN User Guide* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnectionroute.html
    :cloudformationResource: AWS::EC2::VPNConnectionRoute
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_vPNConnection_route_props_mixin = ec2_mixins.CfnVPNConnectionRoutePropsMixin(ec2_mixins.CfnVPNConnectionRouteMixinProps(
            destination_cidr_block="destinationCidrBlock",
            vpn_connection_id="vpnConnectionId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnVPNConnectionRouteMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::VPNConnectionRoute``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__308dd661ef681ba389803b8210ece10a3e85efa324e3238f3510a4e92874594b)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e743143e29029c23ecaa9bd0f10d0b45d487f24e8ce4c480ff7d755778d1e1cc)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b256ae8317eeb97e69d75b8502e319c9a1293d0d05adc74dc9196be830aceb7e)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnVPNConnectionRouteMixinProps":
        return typing.cast("CfnVPNConnectionRouteMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPNGatewayMixinProps",
    jsii_struct_bases=[],
    name_mapping={"amazon_side_asn": "amazonSideAsn", "tags": "tags", "type": "type"},
)
class CfnVPNGatewayMixinProps:
    def __init__(
        self,
        *,
        amazon_side_asn: typing.Optional[jsii.Number] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnVPNGatewayPropsMixin.

        :param amazon_side_asn: The private Autonomous System Number (ASN) for the Amazon side of a BGP session.
        :param tags: Any tags assigned to the virtual private gateway.
        :param type: The type of VPN connection the virtual private gateway supports.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngateway.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_vPNGateway_mixin_props = ec2_mixins.CfnVPNGatewayMixinProps(
                amazon_side_asn=123,
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                type="type"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c791d14a19f424e0025b79adb0ddcdc1b48b88df3d251d8553009239f2487ac8)
            check_type(argname="argument amazon_side_asn", value=amazon_side_asn, expected_type=type_hints["amazon_side_asn"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if amazon_side_asn is not None:
            self._values["amazon_side_asn"] = amazon_side_asn
        if tags is not None:
            self._values["tags"] = tags
        if type is not None:
            self._values["type"] = type

    @builtins.property
    def amazon_side_asn(self) -> typing.Optional[jsii.Number]:
        '''The private Autonomous System Number (ASN) for the Amazon side of a BGP session.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngateway.html#cfn-ec2-vpngateway-amazonsideasn
        '''
        result = self._values.get("amazon_side_asn")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''Any tags assigned to the virtual private gateway.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngateway.html#cfn-ec2-vpngateway-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''The type of VPN connection the virtual private gateway supports.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngateway.html#cfn-ec2-vpngateway-type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnVPNGatewayMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnVPNGatewayPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPNGatewayPropsMixin",
):
    '''Specifies a virtual private gateway.

    A virtual private gateway is the endpoint on the VPC side of your VPN connection. You can create a virtual private gateway before creating the VPC itself.

    For more information, see `AWS Site-to-Site VPN <https://docs.aws.amazon.com/vpn/latest/s2svpn/VPC_VPN.html>`_ in the *AWS Site-to-Site VPN User Guide* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngateway.html
    :cloudformationResource: AWS::EC2::VPNGateway
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_vPNGateway_props_mixin = ec2_mixins.CfnVPNGatewayPropsMixin(ec2_mixins.CfnVPNGatewayMixinProps(
            amazon_side_asn=123,
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            type="type"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnVPNGatewayMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::VPNGateway``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2395772c3d93f863c03eaae80a04dc0d8c4eeb63adf1e395844223496691154f)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9068e6163d3d5e198292277515538fe38c265f71abf66ac8555a9fc5b640a355)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__110a364a7015cd3108f031025f6d3a26948aa2b2d82465e8488890c0ea5e68c5)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnVPNGatewayMixinProps":
        return typing.cast("CfnVPNGatewayMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPNGatewayRoutePropagationMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "route_table_ids": "routeTableIds",
        "vpn_gateway_id": "vpnGatewayId",
    },
)
class CfnVPNGatewayRoutePropagationMixinProps:
    def __init__(
        self,
        *,
        route_table_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        vpn_gateway_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnVPNGatewayRoutePropagationPropsMixin.

        :param route_table_ids: The ID of the route table. The routing table must be associated with the same VPC that the virtual private gateway is attached to.
        :param vpn_gateway_id: The ID of the virtual private gateway that is attached to a VPC. The virtual private gateway must be attached to the same VPC that the routing tables are associated with.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngatewayroutepropagation.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_vPNGateway_route_propagation_mixin_props = ec2_mixins.CfnVPNGatewayRoutePropagationMixinProps(
                route_table_ids=["routeTableIds"],
                vpn_gateway_id="vpnGatewayId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1a998d1c385190b8f5a08665ec1baef60a7165e7b41eb8c6bf1da39bb716b08c)
            check_type(argname="argument route_table_ids", value=route_table_ids, expected_type=type_hints["route_table_ids"])
            check_type(argname="argument vpn_gateway_id", value=vpn_gateway_id, expected_type=type_hints["vpn_gateway_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if route_table_ids is not None:
            self._values["route_table_ids"] = route_table_ids
        if vpn_gateway_id is not None:
            self._values["vpn_gateway_id"] = vpn_gateway_id

    @builtins.property
    def route_table_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The ID of the route table.

        The routing table must be associated with the same VPC that the virtual private gateway is attached to.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngatewayroutepropagation.html#cfn-ec2-vpngatewayroutepropagation-routetableids
        '''
        result = self._values.get("route_table_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def vpn_gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the virtual private gateway that is attached to a VPC.

        The virtual private gateway must be attached to the same VPC that the routing tables are associated with.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngatewayroutepropagation.html#cfn-ec2-vpngatewayroutepropagation-vpngatewayid
        '''
        result = self._values.get("vpn_gateway_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnVPNGatewayRoutePropagationMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnVPNGatewayRoutePropagationPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVPNGatewayRoutePropagationPropsMixin",
):
    '''Enables a virtual private gateway (VGW) to propagate routes to the specified route table of a VPC.

    If you reference a VPN gateway that is in the same template as your VPN gateway route propagation, you must explicitly declare a dependency on the VPN gateway attachment. The ``AWS::EC2::VPNGatewayRoutePropagation`` resource cannot use the VPN gateway until it has successfully attached to the VPC. Add a `DependsOn Attribute <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html>`_ in the ``AWS::EC2::VPNGatewayRoutePropagation`` resource to explicitly declare a dependency on the VPN gateway attachment.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngatewayroutepropagation.html
    :cloudformationResource: AWS::EC2::VPNGatewayRoutePropagation
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_vPNGateway_route_propagation_props_mixin = ec2_mixins.CfnVPNGatewayRoutePropagationPropsMixin(ec2_mixins.CfnVPNGatewayRoutePropagationMixinProps(
            route_table_ids=["routeTableIds"],
            vpn_gateway_id="vpnGatewayId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnVPNGatewayRoutePropagationMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::VPNGatewayRoutePropagation``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6c9aae0c85c28669ec453a4f76d68f39baf02b40593b419fd7fff425e9d801c3)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__55ee5429753b46948a86d9f5d0fa86dbdcf00d1c53ca08b29c541f08db625dfb)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0b471d6f7daa48ba8df996161b63700d1203c233f726b640d0e351cbecd5847f)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnVPNGatewayRoutePropagationMixinProps":
        return typing.cast("CfnVPNGatewayRoutePropagationMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVerifiedAccessEndpointMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "application_domain": "applicationDomain",
        "attachment_type": "attachmentType",
        "cidr_options": "cidrOptions",
        "description": "description",
        "domain_certificate_arn": "domainCertificateArn",
        "endpoint_domain_prefix": "endpointDomainPrefix",
        "endpoint_type": "endpointType",
        "load_balancer_options": "loadBalancerOptions",
        "network_interface_options": "networkInterfaceOptions",
        "policy_document": "policyDocument",
        "policy_enabled": "policyEnabled",
        "rds_options": "rdsOptions",
        "security_group_ids": "securityGroupIds",
        "sse_specification": "sseSpecification",
        "tags": "tags",
        "verified_access_group_id": "verifiedAccessGroupId",
    },
)
class CfnVerifiedAccessEndpointMixinProps:
    def __init__(
        self,
        *,
        application_domain: typing.Optional[builtins.str] = None,
        attachment_type: typing.Optional[builtins.str] = None,
        cidr_options: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnVerifiedAccessEndpointPropsMixin.CidrOptionsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        description: typing.Optional[builtins.str] = None,
        domain_certificate_arn: typing.Optional[builtins.str] = None,
        endpoint_domain_prefix: typing.Optional[builtins.str] = None,
        endpoint_type: typing.Optional[builtins.str] = None,
        load_balancer_options: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnVerifiedAccessEndpointPropsMixin.LoadBalancerOptionsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        network_interface_options: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnVerifiedAccessEndpointPropsMixin.NetworkInterfaceOptionsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        policy_document: typing.Optional[builtins.str] = None,
        policy_enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        rds_options: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnVerifiedAccessEndpointPropsMixin.RdsOptionsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        security_group_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        sse_specification: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnVerifiedAccessEndpointPropsMixin.SseSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        verified_access_group_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnVerifiedAccessEndpointPropsMixin.

        :param application_domain: The DNS name for users to reach your application.
        :param attachment_type: The type of attachment used to provide connectivity between the AWS Verified Access endpoint and the application.
        :param cidr_options: The options for a CIDR endpoint.
        :param description: A description for the AWS Verified Access endpoint.
        :param domain_certificate_arn: The ARN of a public TLS/SSL certificate imported into or created with ACM.
        :param endpoint_domain_prefix: A custom identifier that is prepended to the DNS name that is generated for the endpoint.
        :param endpoint_type: The type of AWS Verified Access endpoint. Incoming application requests will be sent to an IP address, load balancer or a network interface depending on the endpoint type specified.
        :param load_balancer_options: The load balancer details if creating the AWS Verified Access endpoint as ``load-balancer`` type.
        :param network_interface_options: The options for network-interface type endpoint.
        :param policy_document: The Verified Access policy document.
        :param policy_enabled: The status of the Verified Access policy.
        :param rds_options: The options for an RDS endpoint.
        :param security_group_ids: The IDs of the security groups for the endpoint.
        :param sse_specification: The options for additional server side encryption.
        :param tags: The tags.
        :param verified_access_group_id: The ID of the AWS Verified Access group.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_verified_access_endpoint_mixin_props = ec2_mixins.CfnVerifiedAccessEndpointMixinProps(
                application_domain="applicationDomain",
                attachment_type="attachmentType",
                cidr_options=ec2_mixins.CfnVerifiedAccessEndpointPropsMixin.CidrOptionsProperty(
                    cidr="cidr",
                    port_ranges=[ec2_mixins.CfnVerifiedAccessEndpointPropsMixin.PortRangeProperty(
                        from_port=123,
                        to_port=123
                    )],
                    protocol="protocol",
                    subnet_ids=["subnetIds"]
                ),
                description="description",
                domain_certificate_arn="domainCertificateArn",
                endpoint_domain_prefix="endpointDomainPrefix",
                endpoint_type="endpointType",
                load_balancer_options=ec2_mixins.CfnVerifiedAccessEndpointPropsMixin.LoadBalancerOptionsProperty(
                    load_balancer_arn="loadBalancerArn",
                    port=123,
                    port_ranges=[ec2_mixins.CfnVerifiedAccessEndpointPropsMixin.PortRangeProperty(
                        from_port=123,
                        to_port=123
                    )],
                    protocol="protocol",
                    subnet_ids=["subnetIds"]
                ),
                network_interface_options=ec2_mixins.CfnVerifiedAccessEndpointPropsMixin.NetworkInterfaceOptionsProperty(
                    network_interface_id="networkInterfaceId",
                    port=123,
                    port_ranges=[ec2_mixins.CfnVerifiedAccessEndpointPropsMixin.PortRangeProperty(
                        from_port=123,
                        to_port=123
                    )],
                    protocol="protocol"
                ),
                policy_document="policyDocument",
                policy_enabled=False,
                rds_options=ec2_mixins.CfnVerifiedAccessEndpointPropsMixin.RdsOptionsProperty(
                    port=123,
                    protocol="protocol",
                    rds_db_cluster_arn="rdsDbClusterArn",
                    rds_db_instance_arn="rdsDbInstanceArn",
                    rds_db_proxy_arn="rdsDbProxyArn",
                    rds_endpoint="rdsEndpoint",
                    subnet_ids=["subnetIds"]
                ),
                security_group_ids=["securityGroupIds"],
                sse_specification=ec2_mixins.CfnVerifiedAccessEndpointPropsMixin.SseSpecificationProperty(
                    customer_managed_key_enabled=False,
                    kms_key_arn="kmsKeyArn"
                ),
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                verified_access_group_id="verifiedAccessGroupId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c31d950250dc8cb7d342faf82ca0704be2cdd33fcada3d30ce003df952360972)
            check_type(argname="argument application_domain", value=application_domain, expected_type=type_hints["application_domain"])
            check_type(argname="argument attachment_type", value=attachment_type, expected_type=type_hints["attachment_type"])
            check_type(argname="argument cidr_options", value=cidr_options, expected_type=type_hints["cidr_options"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument domain_certificate_arn", value=domain_certificate_arn, expected_type=type_hints["domain_certificate_arn"])
            check_type(argname="argument endpoint_domain_prefix", value=endpoint_domain_prefix, expected_type=type_hints["endpoint_domain_prefix"])
            check_type(argname="argument endpoint_type", value=endpoint_type, expected_type=type_hints["endpoint_type"])
            check_type(argname="argument load_balancer_options", value=load_balancer_options, expected_type=type_hints["load_balancer_options"])
            check_type(argname="argument network_interface_options", value=network_interface_options, expected_type=type_hints["network_interface_options"])
            check_type(argname="argument policy_document", value=policy_document, expected_type=type_hints["policy_document"])
            check_type(argname="argument policy_enabled", value=policy_enabled, expected_type=type_hints["policy_enabled"])
            check_type(argname="argument rds_options", value=rds_options, expected_type=type_hints["rds_options"])
            check_type(argname="argument security_group_ids", value=security_group_ids, expected_type=type_hints["security_group_ids"])
            check_type(argname="argument sse_specification", value=sse_specification, expected_type=type_hints["sse_specification"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument verified_access_group_id", value=verified_access_group_id, expected_type=type_hints["verified_access_group_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if application_domain is not None:
            self._values["application_domain"] = application_domain
        if attachment_type is not None:
            self._values["attachment_type"] = attachment_type
        if cidr_options is not None:
            self._values["cidr_options"] = cidr_options
        if description is not None:
            self._values["description"] = description
        if domain_certificate_arn is not None:
            self._values["domain_certificate_arn"] = domain_certificate_arn
        if endpoint_domain_prefix is not None:
            self._values["endpoint_domain_prefix"] = endpoint_domain_prefix
        if endpoint_type is not None:
            self._values["endpoint_type"] = endpoint_type
        if load_balancer_options is not None:
            self._values["load_balancer_options"] = load_balancer_options
        if network_interface_options is not None:
            self._values["network_interface_options"] = network_interface_options
        if policy_document is not None:
            self._values["policy_document"] = policy_document
        if policy_enabled is not None:
            self._values["policy_enabled"] = policy_enabled
        if rds_options is not None:
            self._values["rds_options"] = rds_options
        if security_group_ids is not None:
            self._values["security_group_ids"] = security_group_ids
        if sse_specification is not None:
            self._values["sse_specification"] = sse_specification
        if tags is not None:
            self._values["tags"] = tags
        if verified_access_group_id is not None:
            self._values["verified_access_group_id"] = verified_access_group_id

    @builtins.property
    def application_domain(self) -> typing.Optional[builtins.str]:
        '''The DNS name for users to reach your application.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-applicationdomain
        '''
        result = self._values.get("application_domain")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def attachment_type(self) -> typing.Optional[builtins.str]:
        '''The type of attachment used to provide connectivity between the AWS Verified Access endpoint and the application.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-attachmenttype
        '''
        result = self._values.get("attachment_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def cidr_options(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVerifiedAccessEndpointPropsMixin.CidrOptionsProperty"]]:
        '''The options for a CIDR endpoint.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-cidroptions
        '''
        result = self._values.get("cidr_options")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVerifiedAccessEndpointPropsMixin.CidrOptionsProperty"]], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''A description for the AWS Verified Access endpoint.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def domain_certificate_arn(self) -> typing.Optional[builtins.str]:
        '''The ARN of a public TLS/SSL certificate imported into or created with ACM.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-domaincertificatearn
        '''
        result = self._values.get("domain_certificate_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def endpoint_domain_prefix(self) -> typing.Optional[builtins.str]:
        '''A custom identifier that is prepended to the DNS name that is generated for the endpoint.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-endpointdomainprefix
        '''
        result = self._values.get("endpoint_domain_prefix")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def endpoint_type(self) -> typing.Optional[builtins.str]:
        '''The type of AWS Verified Access endpoint.

        Incoming application requests will be sent to an IP address, load balancer or a network interface depending on the endpoint type specified.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-endpointtype
        '''
        result = self._values.get("endpoint_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def load_balancer_options(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVerifiedAccessEndpointPropsMixin.LoadBalancerOptionsProperty"]]:
        '''The load balancer details if creating the AWS Verified Access endpoint as ``load-balancer`` type.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-loadbalanceroptions
        '''
        result = self._values.get("load_balancer_options")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVerifiedAccessEndpointPropsMixin.LoadBalancerOptionsProperty"]], result)

    @builtins.property
    def network_interface_options(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVerifiedAccessEndpointPropsMixin.NetworkInterfaceOptionsProperty"]]:
        '''The options for network-interface type endpoint.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-networkinterfaceoptions
        '''
        result = self._values.get("network_interface_options")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVerifiedAccessEndpointPropsMixin.NetworkInterfaceOptionsProperty"]], result)

    @builtins.property
    def policy_document(self) -> typing.Optional[builtins.str]:
        '''The Verified Access policy document.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-policydocument
        '''
        result = self._values.get("policy_document")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def policy_enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''The status of the Verified Access policy.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-policyenabled
        '''
        result = self._values.get("policy_enabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def rds_options(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVerifiedAccessEndpointPropsMixin.RdsOptionsProperty"]]:
        '''The options for an RDS endpoint.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-rdsoptions
        '''
        result = self._values.get("rds_options")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVerifiedAccessEndpointPropsMixin.RdsOptionsProperty"]], result)

    @builtins.property
    def security_group_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The IDs of the security groups for the endpoint.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-securitygroupids
        '''
        result = self._values.get("security_group_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def sse_specification(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVerifiedAccessEndpointPropsMixin.SseSpecificationProperty"]]:
        '''The options for additional server side encryption.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-ssespecification
        '''
        result = self._values.get("sse_specification")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVerifiedAccessEndpointPropsMixin.SseSpecificationProperty"]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def verified_access_group_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the AWS Verified Access group.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-verifiedaccessgroupid
        '''
        result = self._values.get("verified_access_group_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnVerifiedAccessEndpointMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnVerifiedAccessEndpointPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVerifiedAccessEndpointPropsMixin",
):
    '''An AWS Verified Access endpoint specifies the application that AWS Verified Access provides access to.

    It must be attached to an AWS Verified Access group. An AWS Verified Access endpoint must also have an attached access policy before you attached it to a group.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html
    :cloudformationResource: AWS::EC2::VerifiedAccessEndpoint
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_verified_access_endpoint_props_mixin = ec2_mixins.CfnVerifiedAccessEndpointPropsMixin(ec2_mixins.CfnVerifiedAccessEndpointMixinProps(
            application_domain="applicationDomain",
            attachment_type="attachmentType",
            cidr_options=ec2_mixins.CfnVerifiedAccessEndpointPropsMixin.CidrOptionsProperty(
                cidr="cidr",
                port_ranges=[ec2_mixins.CfnVerifiedAccessEndpointPropsMixin.PortRangeProperty(
                    from_port=123,
                    to_port=123
                )],
                protocol="protocol",
                subnet_ids=["subnetIds"]
            ),
            description="description",
            domain_certificate_arn="domainCertificateArn",
            endpoint_domain_prefix="endpointDomainPrefix",
            endpoint_type="endpointType",
            load_balancer_options=ec2_mixins.CfnVerifiedAccessEndpointPropsMixin.LoadBalancerOptionsProperty(
                load_balancer_arn="loadBalancerArn",
                port=123,
                port_ranges=[ec2_mixins.CfnVerifiedAccessEndpointPropsMixin.PortRangeProperty(
                    from_port=123,
                    to_port=123
                )],
                protocol="protocol",
                subnet_ids=["subnetIds"]
            ),
            network_interface_options=ec2_mixins.CfnVerifiedAccessEndpointPropsMixin.NetworkInterfaceOptionsProperty(
                network_interface_id="networkInterfaceId",
                port=123,
                port_ranges=[ec2_mixins.CfnVerifiedAccessEndpointPropsMixin.PortRangeProperty(
                    from_port=123,
                    to_port=123
                )],
                protocol="protocol"
            ),
            policy_document="policyDocument",
            policy_enabled=False,
            rds_options=ec2_mixins.CfnVerifiedAccessEndpointPropsMixin.RdsOptionsProperty(
                port=123,
                protocol="protocol",
                rds_db_cluster_arn="rdsDbClusterArn",
                rds_db_instance_arn="rdsDbInstanceArn",
                rds_db_proxy_arn="rdsDbProxyArn",
                rds_endpoint="rdsEndpoint",
                subnet_ids=["subnetIds"]
            ),
            security_group_ids=["securityGroupIds"],
            sse_specification=ec2_mixins.CfnVerifiedAccessEndpointPropsMixin.SseSpecificationProperty(
                customer_managed_key_enabled=False,
                kms_key_arn="kmsKeyArn"
            ),
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            verified_access_group_id="verifiedAccessGroupId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnVerifiedAccessEndpointMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::VerifiedAccessEndpoint``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__57212d5bd1543cc2a74331b1f720dda63776dcc4353a36e5e49550fc486304bd)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7dd6e601cb6da65392e2393c73b15f3a1721c81ed1ccef07bcc2cf90dc96ef93)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4bc7cf198424e2ed2189a84cfc9e853940010c8e2adfd7d81941c0420027dc61)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnVerifiedAccessEndpointMixinProps":
        return typing.cast("CfnVerifiedAccessEndpointMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVerifiedAccessEndpointPropsMixin.CidrOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "cidr": "cidr",
            "port_ranges": "portRanges",
            "protocol": "protocol",
            "subnet_ids": "subnetIds",
        },
    )
    class CidrOptionsProperty:
        def __init__(
            self,
            *,
            cidr: typing.Optional[builtins.str] = None,
            port_ranges: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnVerifiedAccessEndpointPropsMixin.PortRangeProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            protocol: typing.Optional[builtins.str] = None,
            subnet_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        ) -> None:
            '''Describes the CIDR options for a Verified Access endpoint.

            :param cidr: The CIDR.
            :param port_ranges: The port ranges.
            :param protocol: The protocol.
            :param subnet_ids: The IDs of the subnets.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-cidroptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                cidr_options_property = ec2_mixins.CfnVerifiedAccessEndpointPropsMixin.CidrOptionsProperty(
                    cidr="cidr",
                    port_ranges=[ec2_mixins.CfnVerifiedAccessEndpointPropsMixin.PortRangeProperty(
                        from_port=123,
                        to_port=123
                    )],
                    protocol="protocol",
                    subnet_ids=["subnetIds"]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__fd84ae0ae745e2ca1dde44d27af7f6ff8a80b91004d91fc6a71dcca6f376f70f)
                check_type(argname="argument cidr", value=cidr, expected_type=type_hints["cidr"])
                check_type(argname="argument port_ranges", value=port_ranges, expected_type=type_hints["port_ranges"])
                check_type(argname="argument protocol", value=protocol, expected_type=type_hints["protocol"])
                check_type(argname="argument subnet_ids", value=subnet_ids, expected_type=type_hints["subnet_ids"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if cidr is not None:
                self._values["cidr"] = cidr
            if port_ranges is not None:
                self._values["port_ranges"] = port_ranges
            if protocol is not None:
                self._values["protocol"] = protocol
            if subnet_ids is not None:
                self._values["subnet_ids"] = subnet_ids

        @builtins.property
        def cidr(self) -> typing.Optional[builtins.str]:
            '''The CIDR.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-cidroptions.html#cfn-ec2-verifiedaccessendpoint-cidroptions-cidr
            '''
            result = self._values.get("cidr")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def port_ranges(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVerifiedAccessEndpointPropsMixin.PortRangeProperty"]]]]:
            '''The port ranges.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-cidroptions.html#cfn-ec2-verifiedaccessendpoint-cidroptions-portranges
            '''
            result = self._values.get("port_ranges")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVerifiedAccessEndpointPropsMixin.PortRangeProperty"]]]], result)

        @builtins.property
        def protocol(self) -> typing.Optional[builtins.str]:
            '''The protocol.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-cidroptions.html#cfn-ec2-verifiedaccessendpoint-cidroptions-protocol
            '''
            result = self._values.get("protocol")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def subnet_ids(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The IDs of the subnets.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-cidroptions.html#cfn-ec2-verifiedaccessendpoint-cidroptions-subnetids
            '''
            result = self._values.get("subnet_ids")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "CidrOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVerifiedAccessEndpointPropsMixin.LoadBalancerOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "load_balancer_arn": "loadBalancerArn",
            "port": "port",
            "port_ranges": "portRanges",
            "protocol": "protocol",
            "subnet_ids": "subnetIds",
        },
    )
    class LoadBalancerOptionsProperty:
        def __init__(
            self,
            *,
            load_balancer_arn: typing.Optional[builtins.str] = None,
            port: typing.Optional[jsii.Number] = None,
            port_ranges: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnVerifiedAccessEndpointPropsMixin.PortRangeProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            protocol: typing.Optional[builtins.str] = None,
            subnet_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        ) -> None:
            '''Describes the load balancer options when creating an AWS Verified Access endpoint using the ``load-balancer`` type.

            :param load_balancer_arn: The ARN of the load balancer.
            :param port: The IP port number.
            :param port_ranges: The port ranges.
            :param protocol: The IP protocol.
            :param subnet_ids: The IDs of the subnets. You can specify only one subnet per Availability Zone.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-loadbalanceroptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                load_balancer_options_property = ec2_mixins.CfnVerifiedAccessEndpointPropsMixin.LoadBalancerOptionsProperty(
                    load_balancer_arn="loadBalancerArn",
                    port=123,
                    port_ranges=[ec2_mixins.CfnVerifiedAccessEndpointPropsMixin.PortRangeProperty(
                        from_port=123,
                        to_port=123
                    )],
                    protocol="protocol",
                    subnet_ids=["subnetIds"]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__3f5ce9f1b4e74a434e675b0da56811246cc2e49ba2fe03014e0c977f02b0790e)
                check_type(argname="argument load_balancer_arn", value=load_balancer_arn, expected_type=type_hints["load_balancer_arn"])
                check_type(argname="argument port", value=port, expected_type=type_hints["port"])
                check_type(argname="argument port_ranges", value=port_ranges, expected_type=type_hints["port_ranges"])
                check_type(argname="argument protocol", value=protocol, expected_type=type_hints["protocol"])
                check_type(argname="argument subnet_ids", value=subnet_ids, expected_type=type_hints["subnet_ids"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if load_balancer_arn is not None:
                self._values["load_balancer_arn"] = load_balancer_arn
            if port is not None:
                self._values["port"] = port
            if port_ranges is not None:
                self._values["port_ranges"] = port_ranges
            if protocol is not None:
                self._values["protocol"] = protocol
            if subnet_ids is not None:
                self._values["subnet_ids"] = subnet_ids

        @builtins.property
        def load_balancer_arn(self) -> typing.Optional[builtins.str]:
            '''The ARN of the load balancer.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-loadbalanceroptions.html#cfn-ec2-verifiedaccessendpoint-loadbalanceroptions-loadbalancerarn
            '''
            result = self._values.get("load_balancer_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def port(self) -> typing.Optional[jsii.Number]:
            '''The IP port number.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-loadbalanceroptions.html#cfn-ec2-verifiedaccessendpoint-loadbalanceroptions-port
            '''
            result = self._values.get("port")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def port_ranges(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVerifiedAccessEndpointPropsMixin.PortRangeProperty"]]]]:
            '''The port ranges.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-loadbalanceroptions.html#cfn-ec2-verifiedaccessendpoint-loadbalanceroptions-portranges
            '''
            result = self._values.get("port_ranges")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVerifiedAccessEndpointPropsMixin.PortRangeProperty"]]]], result)

        @builtins.property
        def protocol(self) -> typing.Optional[builtins.str]:
            '''The IP protocol.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-loadbalanceroptions.html#cfn-ec2-verifiedaccessendpoint-loadbalanceroptions-protocol
            '''
            result = self._values.get("protocol")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def subnet_ids(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The IDs of the subnets.

            You can specify only one subnet per Availability Zone.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-loadbalanceroptions.html#cfn-ec2-verifiedaccessendpoint-loadbalanceroptions-subnetids
            '''
            result = self._values.get("subnet_ids")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "LoadBalancerOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVerifiedAccessEndpointPropsMixin.NetworkInterfaceOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "network_interface_id": "networkInterfaceId",
            "port": "port",
            "port_ranges": "portRanges",
            "protocol": "protocol",
        },
    )
    class NetworkInterfaceOptionsProperty:
        def __init__(
            self,
            *,
            network_interface_id: typing.Optional[builtins.str] = None,
            port: typing.Optional[jsii.Number] = None,
            port_ranges: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnVerifiedAccessEndpointPropsMixin.PortRangeProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            protocol: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes the network interface options when creating an AWS Verified Access endpoint using the ``network-interface`` type.

            :param network_interface_id: The ID of the network interface.
            :param port: The IP port number.
            :param port_ranges: The port ranges.
            :param protocol: The IP protocol.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-networkinterfaceoptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                network_interface_options_property = ec2_mixins.CfnVerifiedAccessEndpointPropsMixin.NetworkInterfaceOptionsProperty(
                    network_interface_id="networkInterfaceId",
                    port=123,
                    port_ranges=[ec2_mixins.CfnVerifiedAccessEndpointPropsMixin.PortRangeProperty(
                        from_port=123,
                        to_port=123
                    )],
                    protocol="protocol"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__59fc6db2db18cf5e517f96ec6e1701cb4331ebdadb23d734f9888adb1cd1de50)
                check_type(argname="argument network_interface_id", value=network_interface_id, expected_type=type_hints["network_interface_id"])
                check_type(argname="argument port", value=port, expected_type=type_hints["port"])
                check_type(argname="argument port_ranges", value=port_ranges, expected_type=type_hints["port_ranges"])
                check_type(argname="argument protocol", value=protocol, expected_type=type_hints["protocol"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if network_interface_id is not None:
                self._values["network_interface_id"] = network_interface_id
            if port is not None:
                self._values["port"] = port
            if port_ranges is not None:
                self._values["port_ranges"] = port_ranges
            if protocol is not None:
                self._values["protocol"] = protocol

        @builtins.property
        def network_interface_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the network interface.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-networkinterfaceoptions.html#cfn-ec2-verifiedaccessendpoint-networkinterfaceoptions-networkinterfaceid
            '''
            result = self._values.get("network_interface_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def port(self) -> typing.Optional[jsii.Number]:
            '''The IP port number.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-networkinterfaceoptions.html#cfn-ec2-verifiedaccessendpoint-networkinterfaceoptions-port
            '''
            result = self._values.get("port")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def port_ranges(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVerifiedAccessEndpointPropsMixin.PortRangeProperty"]]]]:
            '''The port ranges.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-networkinterfaceoptions.html#cfn-ec2-verifiedaccessendpoint-networkinterfaceoptions-portranges
            '''
            result = self._values.get("port_ranges")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVerifiedAccessEndpointPropsMixin.PortRangeProperty"]]]], result)

        @builtins.property
        def protocol(self) -> typing.Optional[builtins.str]:
            '''The IP protocol.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-networkinterfaceoptions.html#cfn-ec2-verifiedaccessendpoint-networkinterfaceoptions-protocol
            '''
            result = self._values.get("protocol")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "NetworkInterfaceOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVerifiedAccessEndpointPropsMixin.PortRangeProperty",
        jsii_struct_bases=[],
        name_mapping={"from_port": "fromPort", "to_port": "toPort"},
    )
    class PortRangeProperty:
        def __init__(
            self,
            *,
            from_port: typing.Optional[jsii.Number] = None,
            to_port: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Describes the port range for a Verified Access endpoint.

            :param from_port: The start of the port range.
            :param to_port: The end of the port range.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-portrange.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                port_range_property = ec2_mixins.CfnVerifiedAccessEndpointPropsMixin.PortRangeProperty(
                    from_port=123,
                    to_port=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__9be762310dc8d762b930e2b2e95b2b1ed705b309ae679ece382ec9fe126eecfe)
                check_type(argname="argument from_port", value=from_port, expected_type=type_hints["from_port"])
                check_type(argname="argument to_port", value=to_port, expected_type=type_hints["to_port"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if from_port is not None:
                self._values["from_port"] = from_port
            if to_port is not None:
                self._values["to_port"] = to_port

        @builtins.property
        def from_port(self) -> typing.Optional[jsii.Number]:
            '''The start of the port range.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-portrange.html#cfn-ec2-verifiedaccessendpoint-portrange-fromport
            '''
            result = self._values.get("from_port")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def to_port(self) -> typing.Optional[jsii.Number]:
            '''The end of the port range.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-portrange.html#cfn-ec2-verifiedaccessendpoint-portrange-toport
            '''
            result = self._values.get("to_port")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PortRangeProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVerifiedAccessEndpointPropsMixin.RdsOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "port": "port",
            "protocol": "protocol",
            "rds_db_cluster_arn": "rdsDbClusterArn",
            "rds_db_instance_arn": "rdsDbInstanceArn",
            "rds_db_proxy_arn": "rdsDbProxyArn",
            "rds_endpoint": "rdsEndpoint",
            "subnet_ids": "subnetIds",
        },
    )
    class RdsOptionsProperty:
        def __init__(
            self,
            *,
            port: typing.Optional[jsii.Number] = None,
            protocol: typing.Optional[builtins.str] = None,
            rds_db_cluster_arn: typing.Optional[builtins.str] = None,
            rds_db_instance_arn: typing.Optional[builtins.str] = None,
            rds_db_proxy_arn: typing.Optional[builtins.str] = None,
            rds_endpoint: typing.Optional[builtins.str] = None,
            subnet_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        ) -> None:
            '''Describes the RDS options for a Verified Access endpoint.

            :param port: The port.
            :param protocol: The protocol.
            :param rds_db_cluster_arn: The ARN of the DB cluster.
            :param rds_db_instance_arn: The ARN of the RDS instance.
            :param rds_db_proxy_arn: The ARN of the RDS proxy.
            :param rds_endpoint: The RDS endpoint.
            :param subnet_ids: The IDs of the subnets. You can specify only one subnet per Availability Zone.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-rdsoptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                rds_options_property = ec2_mixins.CfnVerifiedAccessEndpointPropsMixin.RdsOptionsProperty(
                    port=123,
                    protocol="protocol",
                    rds_db_cluster_arn="rdsDbClusterArn",
                    rds_db_instance_arn="rdsDbInstanceArn",
                    rds_db_proxy_arn="rdsDbProxyArn",
                    rds_endpoint="rdsEndpoint",
                    subnet_ids=["subnetIds"]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__07ed2784e78d3ce7440899e21878f6001d077a9ba6b7d6a1dbb71273a4bd5f3a)
                check_type(argname="argument port", value=port, expected_type=type_hints["port"])
                check_type(argname="argument protocol", value=protocol, expected_type=type_hints["protocol"])
                check_type(argname="argument rds_db_cluster_arn", value=rds_db_cluster_arn, expected_type=type_hints["rds_db_cluster_arn"])
                check_type(argname="argument rds_db_instance_arn", value=rds_db_instance_arn, expected_type=type_hints["rds_db_instance_arn"])
                check_type(argname="argument rds_db_proxy_arn", value=rds_db_proxy_arn, expected_type=type_hints["rds_db_proxy_arn"])
                check_type(argname="argument rds_endpoint", value=rds_endpoint, expected_type=type_hints["rds_endpoint"])
                check_type(argname="argument subnet_ids", value=subnet_ids, expected_type=type_hints["subnet_ids"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if port is not None:
                self._values["port"] = port
            if protocol is not None:
                self._values["protocol"] = protocol
            if rds_db_cluster_arn is not None:
                self._values["rds_db_cluster_arn"] = rds_db_cluster_arn
            if rds_db_instance_arn is not None:
                self._values["rds_db_instance_arn"] = rds_db_instance_arn
            if rds_db_proxy_arn is not None:
                self._values["rds_db_proxy_arn"] = rds_db_proxy_arn
            if rds_endpoint is not None:
                self._values["rds_endpoint"] = rds_endpoint
            if subnet_ids is not None:
                self._values["subnet_ids"] = subnet_ids

        @builtins.property
        def port(self) -> typing.Optional[jsii.Number]:
            '''The port.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-rdsoptions.html#cfn-ec2-verifiedaccessendpoint-rdsoptions-port
            '''
            result = self._values.get("port")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def protocol(self) -> typing.Optional[builtins.str]:
            '''The protocol.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-rdsoptions.html#cfn-ec2-verifiedaccessendpoint-rdsoptions-protocol
            '''
            result = self._values.get("protocol")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def rds_db_cluster_arn(self) -> typing.Optional[builtins.str]:
            '''The ARN of the DB cluster.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-rdsoptions.html#cfn-ec2-verifiedaccessendpoint-rdsoptions-rdsdbclusterarn
            '''
            result = self._values.get("rds_db_cluster_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def rds_db_instance_arn(self) -> typing.Optional[builtins.str]:
            '''The ARN of the RDS instance.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-rdsoptions.html#cfn-ec2-verifiedaccessendpoint-rdsoptions-rdsdbinstancearn
            '''
            result = self._values.get("rds_db_instance_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def rds_db_proxy_arn(self) -> typing.Optional[builtins.str]:
            '''The ARN of the RDS proxy.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-rdsoptions.html#cfn-ec2-verifiedaccessendpoint-rdsoptions-rdsdbproxyarn
            '''
            result = self._values.get("rds_db_proxy_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def rds_endpoint(self) -> typing.Optional[builtins.str]:
            '''The RDS endpoint.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-rdsoptions.html#cfn-ec2-verifiedaccessendpoint-rdsoptions-rdsendpoint
            '''
            result = self._values.get("rds_endpoint")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def subnet_ids(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The IDs of the subnets.

            You can specify only one subnet per Availability Zone.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-rdsoptions.html#cfn-ec2-verifiedaccessendpoint-rdsoptions-subnetids
            '''
            result = self._values.get("subnet_ids")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "RdsOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVerifiedAccessEndpointPropsMixin.SseSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "customer_managed_key_enabled": "customerManagedKeyEnabled",
            "kms_key_arn": "kmsKeyArn",
        },
    )
    class SseSpecificationProperty:
        def __init__(
            self,
            *,
            customer_managed_key_enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            kms_key_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''AWS Verified Access provides server side encryption by default to data at rest using AWS -owned KMS keys.

            You also have the option of using customer managed KMS keys, which can be specified using the options below.

            :param customer_managed_key_enabled: Enable or disable the use of customer managed KMS keys for server side encryption. Valid values: ``True`` | ``False``
            :param kms_key_arn: The ARN of the KMS key.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-ssespecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                sse_specification_property = ec2_mixins.CfnVerifiedAccessEndpointPropsMixin.SseSpecificationProperty(
                    customer_managed_key_enabled=False,
                    kms_key_arn="kmsKeyArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__ef184c0c4b1ef1eee429b57af3a9353a2d930cd7a6c317717667ef0e0c260681)
                check_type(argname="argument customer_managed_key_enabled", value=customer_managed_key_enabled, expected_type=type_hints["customer_managed_key_enabled"])
                check_type(argname="argument kms_key_arn", value=kms_key_arn, expected_type=type_hints["kms_key_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if customer_managed_key_enabled is not None:
                self._values["customer_managed_key_enabled"] = customer_managed_key_enabled
            if kms_key_arn is not None:
                self._values["kms_key_arn"] = kms_key_arn

        @builtins.property
        def customer_managed_key_enabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Enable or disable the use of customer managed KMS keys for server side encryption.

            Valid values: ``True`` | ``False``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-ssespecification.html#cfn-ec2-verifiedaccessendpoint-ssespecification-customermanagedkeyenabled
            '''
            result = self._values.get("customer_managed_key_enabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def kms_key_arn(self) -> typing.Optional[builtins.str]:
            '''The ARN of the KMS key.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-ssespecification.html#cfn-ec2-verifiedaccessendpoint-ssespecification-kmskeyarn
            '''
            result = self._values.get("kms_key_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SseSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVerifiedAccessGroupMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "description": "description",
        "policy_document": "policyDocument",
        "policy_enabled": "policyEnabled",
        "sse_specification": "sseSpecification",
        "tags": "tags",
        "verified_access_instance_id": "verifiedAccessInstanceId",
    },
)
class CfnVerifiedAccessGroupMixinProps:
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        policy_document: typing.Optional[builtins.str] = None,
        policy_enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        sse_specification: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnVerifiedAccessGroupPropsMixin.SseSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        verified_access_instance_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnVerifiedAccessGroupPropsMixin.

        :param description: A description for the AWS Verified Access group.
        :param policy_document: The Verified Access policy document.
        :param policy_enabled: The status of the Verified Access policy.
        :param sse_specification: The options for additional server side encryption.
        :param tags: The tags.
        :param verified_access_instance_id: The ID of the AWS Verified Access instance.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_verified_access_group_mixin_props = ec2_mixins.CfnVerifiedAccessGroupMixinProps(
                description="description",
                policy_document="policyDocument",
                policy_enabled=False,
                sse_specification=ec2_mixins.CfnVerifiedAccessGroupPropsMixin.SseSpecificationProperty(
                    customer_managed_key_enabled=False,
                    kms_key_arn="kmsKeyArn"
                ),
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                verified_access_instance_id="verifiedAccessInstanceId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__80d1573c04c2fc2fd255d375ebc70aaa0f9f7340d40c4cc16a80fb1f84237384)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument policy_document", value=policy_document, expected_type=type_hints["policy_document"])
            check_type(argname="argument policy_enabled", value=policy_enabled, expected_type=type_hints["policy_enabled"])
            check_type(argname="argument sse_specification", value=sse_specification, expected_type=type_hints["sse_specification"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument verified_access_instance_id", value=verified_access_instance_id, expected_type=type_hints["verified_access_instance_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if description is not None:
            self._values["description"] = description
        if policy_document is not None:
            self._values["policy_document"] = policy_document
        if policy_enabled is not None:
            self._values["policy_enabled"] = policy_enabled
        if sse_specification is not None:
            self._values["sse_specification"] = sse_specification
        if tags is not None:
            self._values["tags"] = tags
        if verified_access_instance_id is not None:
            self._values["verified_access_instance_id"] = verified_access_instance_id

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''A description for the AWS Verified Access group.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html#cfn-ec2-verifiedaccessgroup-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def policy_document(self) -> typing.Optional[builtins.str]:
        '''The Verified Access policy document.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html#cfn-ec2-verifiedaccessgroup-policydocument
        '''
        result = self._values.get("policy_document")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def policy_enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''The status of the Verified Access policy.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html#cfn-ec2-verifiedaccessgroup-policyenabled
        '''
        result = self._values.get("policy_enabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def sse_specification(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVerifiedAccessGroupPropsMixin.SseSpecificationProperty"]]:
        '''The options for additional server side encryption.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html#cfn-ec2-verifiedaccessgroup-ssespecification
        '''
        result = self._values.get("sse_specification")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVerifiedAccessGroupPropsMixin.SseSpecificationProperty"]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html#cfn-ec2-verifiedaccessgroup-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def verified_access_instance_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the AWS Verified Access instance.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html#cfn-ec2-verifiedaccessgroup-verifiedaccessinstanceid
        '''
        result = self._values.get("verified_access_instance_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnVerifiedAccessGroupMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnVerifiedAccessGroupPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVerifiedAccessGroupPropsMixin",
):
    '''An AWS Verified Access group is a collection of AWS Verified Access endpoints who's associated applications have similar security requirements.

    Each instance within a Verified Access group shares an Verified Access policy. For example, you can group all Verified Access instances associated with "sales" applications together and use one common Verified Access policy.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html
    :cloudformationResource: AWS::EC2::VerifiedAccessGroup
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_verified_access_group_props_mixin = ec2_mixins.CfnVerifiedAccessGroupPropsMixin(ec2_mixins.CfnVerifiedAccessGroupMixinProps(
            description="description",
            policy_document="policyDocument",
            policy_enabled=False,
            sse_specification=ec2_mixins.CfnVerifiedAccessGroupPropsMixin.SseSpecificationProperty(
                customer_managed_key_enabled=False,
                kms_key_arn="kmsKeyArn"
            ),
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            verified_access_instance_id="verifiedAccessInstanceId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnVerifiedAccessGroupMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::VerifiedAccessGroup``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e65be89c082d276eded3f95b92d737be756ce5e8621dcf5a3858f277733afe65)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7db4756757bd6f69c2f485acf9b576242b1635a586e5c2711f05f443bdd22649)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7a008ad523ad57ca02783cc13849ad7668c4387410541c1899c271fd04e144fd)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnVerifiedAccessGroupMixinProps":
        return typing.cast("CfnVerifiedAccessGroupMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVerifiedAccessGroupPropsMixin.SseSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "customer_managed_key_enabled": "customerManagedKeyEnabled",
            "kms_key_arn": "kmsKeyArn",
        },
    )
    class SseSpecificationProperty:
        def __init__(
            self,
            *,
            customer_managed_key_enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            kms_key_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''AWS Verified Access provides server side encryption by default to data at rest using AWS -owned KMS keys.

            You also have the option of using customer managed KMS keys, which can be specified using the options below.

            :param customer_managed_key_enabled: Enable or disable the use of customer managed KMS keys for server side encryption. Valid values: ``True`` | ``False``
            :param kms_key_arn: The ARN of the KMS key.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessgroup-ssespecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                sse_specification_property = ec2_mixins.CfnVerifiedAccessGroupPropsMixin.SseSpecificationProperty(
                    customer_managed_key_enabled=False,
                    kms_key_arn="kmsKeyArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__4be2a705be44078f99c0fb54ec6f7971b520d6c71a4b1b519dc180d93b035c84)
                check_type(argname="argument customer_managed_key_enabled", value=customer_managed_key_enabled, expected_type=type_hints["customer_managed_key_enabled"])
                check_type(argname="argument kms_key_arn", value=kms_key_arn, expected_type=type_hints["kms_key_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if customer_managed_key_enabled is not None:
                self._values["customer_managed_key_enabled"] = customer_managed_key_enabled
            if kms_key_arn is not None:
                self._values["kms_key_arn"] = kms_key_arn

        @builtins.property
        def customer_managed_key_enabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Enable or disable the use of customer managed KMS keys for server side encryption.

            Valid values: ``True`` | ``False``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessgroup-ssespecification.html#cfn-ec2-verifiedaccessgroup-ssespecification-customermanagedkeyenabled
            '''
            result = self._values.get("customer_managed_key_enabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def kms_key_arn(self) -> typing.Optional[builtins.str]:
            '''The ARN of the KMS key.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessgroup-ssespecification.html#cfn-ec2-verifiedaccessgroup-ssespecification-kmskeyarn
            '''
            result = self._values.get("kms_key_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SseSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.implements(_IMixin_11e4b965)
class CfnVerifiedAccessInstanceLogsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVerifiedAccessInstanceLogsMixin",
):
    '''An AWS Verified Access instance is a regional entity that evaluates application requests and grants access only when your security requirements are met.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html
    :cloudformationResource: AWS::EC2::VerifiedAccessInstance
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import aws_logs as logs
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        # logs_delivery: logs.ILogsDelivery
        
        cfn_verified_access_instance_logs_mixin = ec2_mixins.CfnVerifiedAccessInstanceLogsMixin("logType", logs_delivery)
    '''

    def __init__(
        self,
        log_type: builtins.str,
        log_delivery: "_ILogsDelivery_0d3c9e29",
    ) -> None:
        '''Create a mixin to enable vended logs for ``AWS::EC2::VerifiedAccessInstance``.

        :param log_type: Type of logs that are getting vended.
        :param log_delivery: Object in charge of setting up the delivery source, delivery destination, and delivery connection.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ae07f22a595c607ca5dc2de34321c791f4032d11d08567466153bdcce2850c4e)
            check_type(argname="argument log_type", value=log_type, expected_type=type_hints["log_type"])
            check_type(argname="argument log_delivery", value=log_delivery, expected_type=type_hints["log_delivery"])
        jsii.create(self.__class__, self, [log_type, log_delivery])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        resource: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply vended logs configuration to the construct.

        :param resource: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__54835a32a6afbd853ea00f897032ccf9dc2c7e46f0c0a90cbe1de91553b332e9)
            check_type(argname="argument resource", value=resource, expected_type=type_hints["resource"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [resource]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct (has vendedLogs property).

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__594625c13a60e6edd827a5ac0320463c073cc340bdea3c1d85832b548bfdff4b)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VERIFIED_ACCESS_LOGS")
    def VERIFIED_ACCESS_LOGS(cls) -> "CfnVerifiedAccessInstanceVerifiedAccessLogs":
        return typing.cast("CfnVerifiedAccessInstanceVerifiedAccessLogs", jsii.sget(cls, "VERIFIED_ACCESS_LOGS"))

    @builtins.property
    @jsii.member(jsii_name="logDelivery")
    def _log_delivery(self) -> "_ILogsDelivery_0d3c9e29":
        return typing.cast("_ILogsDelivery_0d3c9e29", jsii.get(self, "logDelivery"))

    @builtins.property
    @jsii.member(jsii_name="logType")
    def _log_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "logType"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVerifiedAccessInstanceMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "cidr_endpoints_custom_sub_domain": "cidrEndpointsCustomSubDomain",
        "description": "description",
        "fips_enabled": "fipsEnabled",
        "logging_configurations": "loggingConfigurations",
        "tags": "tags",
        "verified_access_trust_provider_ids": "verifiedAccessTrustProviderIds",
        "verified_access_trust_providers": "verifiedAccessTrustProviders",
    },
)
class CfnVerifiedAccessInstanceMixinProps:
    def __init__(
        self,
        *,
        cidr_endpoints_custom_sub_domain: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        fips_enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        logging_configurations: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnVerifiedAccessInstancePropsMixin.VerifiedAccessLogsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        verified_access_trust_provider_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        verified_access_trust_providers: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnVerifiedAccessInstancePropsMixin.VerifiedAccessTrustProviderProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
    ) -> None:
        '''Properties for CfnVerifiedAccessInstancePropsMixin.

        :param cidr_endpoints_custom_sub_domain: The custom subdomain.
        :param description: A description for the AWS Verified Access instance.
        :param fips_enabled: Indicates whether support for Federal Information Processing Standards (FIPS) is enabled on the instance.
        :param logging_configurations: The logging configuration for the Verified Access instances.
        :param tags: The tags.
        :param verified_access_trust_provider_ids: The IDs of the AWS Verified Access trust providers.
        :param verified_access_trust_providers: The IDs of the AWS Verified Access trust providers.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_verified_access_instance_mixin_props = ec2_mixins.CfnVerifiedAccessInstanceMixinProps(
                cidr_endpoints_custom_sub_domain="cidrEndpointsCustomSubDomain",
                description="description",
                fips_enabled=False,
                logging_configurations=ec2_mixins.CfnVerifiedAccessInstancePropsMixin.VerifiedAccessLogsProperty(
                    cloud_watch_logs=ec2_mixins.CfnVerifiedAccessInstancePropsMixin.CloudWatchLogsProperty(
                        enabled=False,
                        log_group="logGroup"
                    ),
                    include_trust_context=False,
                    kinesis_data_firehose=ec2_mixins.CfnVerifiedAccessInstancePropsMixin.KinesisDataFirehoseProperty(
                        delivery_stream="deliveryStream",
                        enabled=False
                    ),
                    log_version="logVersion",
                    s3=ec2_mixins.CfnVerifiedAccessInstancePropsMixin.S3Property(
                        bucket_name="bucketName",
                        bucket_owner="bucketOwner",
                        enabled=False,
                        prefix="prefix"
                    )
                ),
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                verified_access_trust_provider_ids=["verifiedAccessTrustProviderIds"],
                verified_access_trust_providers=[ec2_mixins.CfnVerifiedAccessInstancePropsMixin.VerifiedAccessTrustProviderProperty(
                    description="description",
                    device_trust_provider_type="deviceTrustProviderType",
                    trust_provider_type="trustProviderType",
                    user_trust_provider_type="userTrustProviderType",
                    verified_access_trust_provider_id="verifiedAccessTrustProviderId"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__110e8a27e2e550749c0f3a007b0b114b74c5fce0cba9914bee4b356ffdd7515b)
            check_type(argname="argument cidr_endpoints_custom_sub_domain", value=cidr_endpoints_custom_sub_domain, expected_type=type_hints["cidr_endpoints_custom_sub_domain"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument fips_enabled", value=fips_enabled, expected_type=type_hints["fips_enabled"])
            check_type(argname="argument logging_configurations", value=logging_configurations, expected_type=type_hints["logging_configurations"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument verified_access_trust_provider_ids", value=verified_access_trust_provider_ids, expected_type=type_hints["verified_access_trust_provider_ids"])
            check_type(argname="argument verified_access_trust_providers", value=verified_access_trust_providers, expected_type=type_hints["verified_access_trust_providers"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if cidr_endpoints_custom_sub_domain is not None:
            self._values["cidr_endpoints_custom_sub_domain"] = cidr_endpoints_custom_sub_domain
        if description is not None:
            self._values["description"] = description
        if fips_enabled is not None:
            self._values["fips_enabled"] = fips_enabled
        if logging_configurations is not None:
            self._values["logging_configurations"] = logging_configurations
        if tags is not None:
            self._values["tags"] = tags
        if verified_access_trust_provider_ids is not None:
            self._values["verified_access_trust_provider_ids"] = verified_access_trust_provider_ids
        if verified_access_trust_providers is not None:
            self._values["verified_access_trust_providers"] = verified_access_trust_providers

    @builtins.property
    def cidr_endpoints_custom_sub_domain(self) -> typing.Optional[builtins.str]:
        '''The custom subdomain.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html#cfn-ec2-verifiedaccessinstance-cidrendpointscustomsubdomain
        '''
        result = self._values.get("cidr_endpoints_custom_sub_domain")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''A description for the AWS Verified Access instance.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html#cfn-ec2-verifiedaccessinstance-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def fips_enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Indicates whether support for Federal Information Processing Standards (FIPS) is enabled on the instance.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html#cfn-ec2-verifiedaccessinstance-fipsenabled
        '''
        result = self._values.get("fips_enabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def logging_configurations(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVerifiedAccessInstancePropsMixin.VerifiedAccessLogsProperty"]]:
        '''The logging configuration for the Verified Access instances.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html#cfn-ec2-verifiedaccessinstance-loggingconfigurations
        '''
        result = self._values.get("logging_configurations")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVerifiedAccessInstancePropsMixin.VerifiedAccessLogsProperty"]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html#cfn-ec2-verifiedaccessinstance-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def verified_access_trust_provider_ids(
        self,
    ) -> typing.Optional[typing.List[builtins.str]]:
        '''The IDs of the AWS Verified Access trust providers.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html#cfn-ec2-verifiedaccessinstance-verifiedaccesstrustproviderids
        '''
        result = self._values.get("verified_access_trust_provider_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def verified_access_trust_providers(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVerifiedAccessInstancePropsMixin.VerifiedAccessTrustProviderProperty"]]]]:
        '''The IDs of the AWS Verified Access trust providers.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html#cfn-ec2-verifiedaccessinstance-verifiedaccesstrustproviders
        '''
        result = self._values.get("verified_access_trust_providers")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVerifiedAccessInstancePropsMixin.VerifiedAccessTrustProviderProperty"]]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnVerifiedAccessInstanceMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnVerifiedAccessInstancePropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVerifiedAccessInstancePropsMixin",
):
    '''An AWS Verified Access instance is a regional entity that evaluates application requests and grants access only when your security requirements are met.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html
    :cloudformationResource: AWS::EC2::VerifiedAccessInstance
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_verified_access_instance_props_mixin = ec2_mixins.CfnVerifiedAccessInstancePropsMixin(ec2_mixins.CfnVerifiedAccessInstanceMixinProps(
            cidr_endpoints_custom_sub_domain="cidrEndpointsCustomSubDomain",
            description="description",
            fips_enabled=False,
            logging_configurations=ec2_mixins.CfnVerifiedAccessInstancePropsMixin.VerifiedAccessLogsProperty(
                cloud_watch_logs=ec2_mixins.CfnVerifiedAccessInstancePropsMixin.CloudWatchLogsProperty(
                    enabled=False,
                    log_group="logGroup"
                ),
                include_trust_context=False,
                kinesis_data_firehose=ec2_mixins.CfnVerifiedAccessInstancePropsMixin.KinesisDataFirehoseProperty(
                    delivery_stream="deliveryStream",
                    enabled=False
                ),
                log_version="logVersion",
                s3=ec2_mixins.CfnVerifiedAccessInstancePropsMixin.S3Property(
                    bucket_name="bucketName",
                    bucket_owner="bucketOwner",
                    enabled=False,
                    prefix="prefix"
                )
            ),
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            verified_access_trust_provider_ids=["verifiedAccessTrustProviderIds"],
            verified_access_trust_providers=[ec2_mixins.CfnVerifiedAccessInstancePropsMixin.VerifiedAccessTrustProviderProperty(
                description="description",
                device_trust_provider_type="deviceTrustProviderType",
                trust_provider_type="trustProviderType",
                user_trust_provider_type="userTrustProviderType",
                verified_access_trust_provider_id="verifiedAccessTrustProviderId"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnVerifiedAccessInstanceMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::VerifiedAccessInstance``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6fd1b2499ee4b9a9c510033d9a3ebc57da9e3062c3cf6001d3512718562284aa)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2e408f7c1540a8753b1e9b926ea68c12a0b8d2db76365bf2a83cc4b5c3950651)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4a8a5addb8ffaf2fd604fc56e4f9f89880f625f762874b63f57d71613d77840d)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnVerifiedAccessInstanceMixinProps":
        return typing.cast("CfnVerifiedAccessInstanceMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVerifiedAccessInstancePropsMixin.CloudWatchLogsProperty",
        jsii_struct_bases=[],
        name_mapping={"enabled": "enabled", "log_group": "logGroup"},
    )
    class CloudWatchLogsProperty:
        def __init__(
            self,
            *,
            enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            log_group: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Options for CloudWatch Logs as a logging destination.

            :param enabled: Indicates whether logging is enabled.
            :param log_group: The ID of the CloudWatch Logs log group.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-cloudwatchlogs.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                cloud_watch_logs_property = ec2_mixins.CfnVerifiedAccessInstancePropsMixin.CloudWatchLogsProperty(
                    enabled=False,
                    log_group="logGroup"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__4bc41b6c871cba558f2e52759c5e451ab0e549e65418ccb7023f1685c7b5acaf)
                check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
                check_type(argname="argument log_group", value=log_group, expected_type=type_hints["log_group"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if enabled is not None:
                self._values["enabled"] = enabled
            if log_group is not None:
                self._values["log_group"] = log_group

        @builtins.property
        def enabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether logging is enabled.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-cloudwatchlogs.html#cfn-ec2-verifiedaccessinstance-cloudwatchlogs-enabled
            '''
            result = self._values.get("enabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def log_group(self) -> typing.Optional[builtins.str]:
            '''The ID of the CloudWatch Logs log group.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-cloudwatchlogs.html#cfn-ec2-verifiedaccessinstance-cloudwatchlogs-loggroup
            '''
            result = self._values.get("log_group")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "CloudWatchLogsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVerifiedAccessInstancePropsMixin.KinesisDataFirehoseProperty",
        jsii_struct_bases=[],
        name_mapping={"delivery_stream": "deliveryStream", "enabled": "enabled"},
    )
    class KinesisDataFirehoseProperty:
        def __init__(
            self,
            *,
            delivery_stream: typing.Optional[builtins.str] = None,
            enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        ) -> None:
            '''Options for Kinesis as a logging destination.

            :param delivery_stream: The ID of the delivery stream.
            :param enabled: Indicates whether logging is enabled.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-kinesisdatafirehose.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                kinesis_data_firehose_property = ec2_mixins.CfnVerifiedAccessInstancePropsMixin.KinesisDataFirehoseProperty(
                    delivery_stream="deliveryStream",
                    enabled=False
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__0999e73772ceedea400414ddab1793fad66547469ac9e49df6823138f97f09ac)
                check_type(argname="argument delivery_stream", value=delivery_stream, expected_type=type_hints["delivery_stream"])
                check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if delivery_stream is not None:
                self._values["delivery_stream"] = delivery_stream
            if enabled is not None:
                self._values["enabled"] = enabled

        @builtins.property
        def delivery_stream(self) -> typing.Optional[builtins.str]:
            '''The ID of the delivery stream.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-kinesisdatafirehose.html#cfn-ec2-verifiedaccessinstance-kinesisdatafirehose-deliverystream
            '''
            result = self._values.get("delivery_stream")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def enabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether logging is enabled.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-kinesisdatafirehose.html#cfn-ec2-verifiedaccessinstance-kinesisdatafirehose-enabled
            '''
            result = self._values.get("enabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "KinesisDataFirehoseProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVerifiedAccessInstancePropsMixin.S3Property",
        jsii_struct_bases=[],
        name_mapping={
            "bucket_name": "bucketName",
            "bucket_owner": "bucketOwner",
            "enabled": "enabled",
            "prefix": "prefix",
        },
    )
    class S3Property:
        def __init__(
            self,
            *,
            bucket_name: typing.Optional[builtins.str] = None,
            bucket_owner: typing.Optional[builtins.str] = None,
            enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            prefix: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Options for Amazon S3 as a logging destination.

            :param bucket_name: The bucket name.
            :param bucket_owner: The AWS account number that owns the bucket.
            :param enabled: Indicates whether logging is enabled.
            :param prefix: The bucket prefix.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-s3.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                s3_property = ec2_mixins.CfnVerifiedAccessInstancePropsMixin.S3Property(
                    bucket_name="bucketName",
                    bucket_owner="bucketOwner",
                    enabled=False,
                    prefix="prefix"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__0d5a053f7119224f0f396110ad206ceccbb7352d3dffb12da04b80f6037bc392)
                check_type(argname="argument bucket_name", value=bucket_name, expected_type=type_hints["bucket_name"])
                check_type(argname="argument bucket_owner", value=bucket_owner, expected_type=type_hints["bucket_owner"])
                check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
                check_type(argname="argument prefix", value=prefix, expected_type=type_hints["prefix"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if bucket_name is not None:
                self._values["bucket_name"] = bucket_name
            if bucket_owner is not None:
                self._values["bucket_owner"] = bucket_owner
            if enabled is not None:
                self._values["enabled"] = enabled
            if prefix is not None:
                self._values["prefix"] = prefix

        @builtins.property
        def bucket_name(self) -> typing.Optional[builtins.str]:
            '''The bucket name.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-s3.html#cfn-ec2-verifiedaccessinstance-s3-bucketname
            '''
            result = self._values.get("bucket_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def bucket_owner(self) -> typing.Optional[builtins.str]:
            '''The AWS account number that owns the bucket.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-s3.html#cfn-ec2-verifiedaccessinstance-s3-bucketowner
            '''
            result = self._values.get("bucket_owner")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def enabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether logging is enabled.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-s3.html#cfn-ec2-verifiedaccessinstance-s3-enabled
            '''
            result = self._values.get("enabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def prefix(self) -> typing.Optional[builtins.str]:
            '''The bucket prefix.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-s3.html#cfn-ec2-verifiedaccessinstance-s3-prefix
            '''
            result = self._values.get("prefix")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "S3Property(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVerifiedAccessInstancePropsMixin.VerifiedAccessLogsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "cloud_watch_logs": "cloudWatchLogs",
            "include_trust_context": "includeTrustContext",
            "kinesis_data_firehose": "kinesisDataFirehose",
            "log_version": "logVersion",
            "s3": "s3",
        },
    )
    class VerifiedAccessLogsProperty:
        def __init__(
            self,
            *,
            cloud_watch_logs: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnVerifiedAccessInstancePropsMixin.CloudWatchLogsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            include_trust_context: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            kinesis_data_firehose: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnVerifiedAccessInstancePropsMixin.KinesisDataFirehoseProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            log_version: typing.Optional[builtins.str] = None,
            s3: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnVerifiedAccessInstancePropsMixin.S3Property", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Describes the options for Verified Access logs.

            :param cloud_watch_logs: CloudWatch Logs logging destination.
            :param include_trust_context: Indicates whether to include trust data sent by trust providers in the logs.
            :param kinesis_data_firehose: Kinesis logging destination.
            :param log_version: The logging version. Valid values: ``ocsf-0.1`` | ``ocsf-1.0.0-rc.2``
            :param s3: Amazon S3 logging options.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesslogs.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                verified_access_logs_property = ec2_mixins.CfnVerifiedAccessInstancePropsMixin.VerifiedAccessLogsProperty(
                    cloud_watch_logs=ec2_mixins.CfnVerifiedAccessInstancePropsMixin.CloudWatchLogsProperty(
                        enabled=False,
                        log_group="logGroup"
                    ),
                    include_trust_context=False,
                    kinesis_data_firehose=ec2_mixins.CfnVerifiedAccessInstancePropsMixin.KinesisDataFirehoseProperty(
                        delivery_stream="deliveryStream",
                        enabled=False
                    ),
                    log_version="logVersion",
                    s3=ec2_mixins.CfnVerifiedAccessInstancePropsMixin.S3Property(
                        bucket_name="bucketName",
                        bucket_owner="bucketOwner",
                        enabled=False,
                        prefix="prefix"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__ff24c9a9db7163375678262308b7778df83a5947b324602c83d6790181d549c2)
                check_type(argname="argument cloud_watch_logs", value=cloud_watch_logs, expected_type=type_hints["cloud_watch_logs"])
                check_type(argname="argument include_trust_context", value=include_trust_context, expected_type=type_hints["include_trust_context"])
                check_type(argname="argument kinesis_data_firehose", value=kinesis_data_firehose, expected_type=type_hints["kinesis_data_firehose"])
                check_type(argname="argument log_version", value=log_version, expected_type=type_hints["log_version"])
                check_type(argname="argument s3", value=s3, expected_type=type_hints["s3"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if cloud_watch_logs is not None:
                self._values["cloud_watch_logs"] = cloud_watch_logs
            if include_trust_context is not None:
                self._values["include_trust_context"] = include_trust_context
            if kinesis_data_firehose is not None:
                self._values["kinesis_data_firehose"] = kinesis_data_firehose
            if log_version is not None:
                self._values["log_version"] = log_version
            if s3 is not None:
                self._values["s3"] = s3

        @builtins.property
        def cloud_watch_logs(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVerifiedAccessInstancePropsMixin.CloudWatchLogsProperty"]]:
            '''CloudWatch Logs logging destination.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesslogs.html#cfn-ec2-verifiedaccessinstance-verifiedaccesslogs-cloudwatchlogs
            '''
            result = self._values.get("cloud_watch_logs")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVerifiedAccessInstancePropsMixin.CloudWatchLogsProperty"]], result)

        @builtins.property
        def include_trust_context(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether to include trust data sent by trust providers in the logs.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesslogs.html#cfn-ec2-verifiedaccessinstance-verifiedaccesslogs-includetrustcontext
            '''
            result = self._values.get("include_trust_context")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def kinesis_data_firehose(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVerifiedAccessInstancePropsMixin.KinesisDataFirehoseProperty"]]:
            '''Kinesis logging destination.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesslogs.html#cfn-ec2-verifiedaccessinstance-verifiedaccesslogs-kinesisdatafirehose
            '''
            result = self._values.get("kinesis_data_firehose")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVerifiedAccessInstancePropsMixin.KinesisDataFirehoseProperty"]], result)

        @builtins.property
        def log_version(self) -> typing.Optional[builtins.str]:
            '''The logging version.

            Valid values: ``ocsf-0.1`` | ``ocsf-1.0.0-rc.2``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesslogs.html#cfn-ec2-verifiedaccessinstance-verifiedaccesslogs-logversion
            '''
            result = self._values.get("log_version")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def s3(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVerifiedAccessInstancePropsMixin.S3Property"]]:
            '''Amazon S3 logging options.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesslogs.html#cfn-ec2-verifiedaccessinstance-verifiedaccesslogs-s3
            '''
            result = self._values.get("s3")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVerifiedAccessInstancePropsMixin.S3Property"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "VerifiedAccessLogsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVerifiedAccessInstancePropsMixin.VerifiedAccessTrustProviderProperty",
        jsii_struct_bases=[],
        name_mapping={
            "description": "description",
            "device_trust_provider_type": "deviceTrustProviderType",
            "trust_provider_type": "trustProviderType",
            "user_trust_provider_type": "userTrustProviderType",
            "verified_access_trust_provider_id": "verifiedAccessTrustProviderId",
        },
    )
    class VerifiedAccessTrustProviderProperty:
        def __init__(
            self,
            *,
            description: typing.Optional[builtins.str] = None,
            device_trust_provider_type: typing.Optional[builtins.str] = None,
            trust_provider_type: typing.Optional[builtins.str] = None,
            user_trust_provider_type: typing.Optional[builtins.str] = None,
            verified_access_trust_provider_id: typing.Optional[builtins.str] = None,
        ) -> None:
            '''A trust provider is a third-party entity that creates, maintains, and manages identity information for users and devices.

            When an application request is made, the identity information sent by the trust provider is evaluated by Verified Access before allowing or denying the application request.

            :param description: A description for the AWS Verified Access trust provider.
            :param device_trust_provider_type: The type of device-based trust provider.
            :param trust_provider_type: The type of Verified Access trust provider.
            :param user_trust_provider_type: The type of user-based trust provider.
            :param verified_access_trust_provider_id: The ID of the AWS Verified Access trust provider.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesstrustprovider.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                verified_access_trust_provider_property = ec2_mixins.CfnVerifiedAccessInstancePropsMixin.VerifiedAccessTrustProviderProperty(
                    description="description",
                    device_trust_provider_type="deviceTrustProviderType",
                    trust_provider_type="trustProviderType",
                    user_trust_provider_type="userTrustProviderType",
                    verified_access_trust_provider_id="verifiedAccessTrustProviderId"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__e6b49c9c673246b203a1f1abd420c68dced1d70f59850a13a7542f26738828c3)
                check_type(argname="argument description", value=description, expected_type=type_hints["description"])
                check_type(argname="argument device_trust_provider_type", value=device_trust_provider_type, expected_type=type_hints["device_trust_provider_type"])
                check_type(argname="argument trust_provider_type", value=trust_provider_type, expected_type=type_hints["trust_provider_type"])
                check_type(argname="argument user_trust_provider_type", value=user_trust_provider_type, expected_type=type_hints["user_trust_provider_type"])
                check_type(argname="argument verified_access_trust_provider_id", value=verified_access_trust_provider_id, expected_type=type_hints["verified_access_trust_provider_id"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if description is not None:
                self._values["description"] = description
            if device_trust_provider_type is not None:
                self._values["device_trust_provider_type"] = device_trust_provider_type
            if trust_provider_type is not None:
                self._values["trust_provider_type"] = trust_provider_type
            if user_trust_provider_type is not None:
                self._values["user_trust_provider_type"] = user_trust_provider_type
            if verified_access_trust_provider_id is not None:
                self._values["verified_access_trust_provider_id"] = verified_access_trust_provider_id

        @builtins.property
        def description(self) -> typing.Optional[builtins.str]:
            '''A description for the AWS Verified Access trust provider.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccessinstance-verifiedaccesstrustprovider-description
            '''
            result = self._values.get("description")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def device_trust_provider_type(self) -> typing.Optional[builtins.str]:
            '''The type of device-based trust provider.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccessinstance-verifiedaccesstrustprovider-devicetrustprovidertype
            '''
            result = self._values.get("device_trust_provider_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def trust_provider_type(self) -> typing.Optional[builtins.str]:
            '''The type of Verified Access trust provider.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccessinstance-verifiedaccesstrustprovider-trustprovidertype
            '''
            result = self._values.get("trust_provider_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def user_trust_provider_type(self) -> typing.Optional[builtins.str]:
            '''The type of user-based trust provider.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccessinstance-verifiedaccesstrustprovider-usertrustprovidertype
            '''
            result = self._values.get("user_trust_provider_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def verified_access_trust_provider_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the AWS Verified Access trust provider.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccessinstance-verifiedaccesstrustprovider-verifiedaccesstrustproviderid
            '''
            result = self._values.get("verified_access_trust_provider_id")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "VerifiedAccessTrustProviderProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


class CfnVerifiedAccessInstanceVerifiedAccessLogs(
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVerifiedAccessInstanceVerifiedAccessLogs",
):
    '''Builder for CfnVerifiedAccessInstanceLogsMixin to generate VERIFIED_ACCESS_LOGS for CfnVerifiedAccessInstance.

    :cloudformationResource: AWS::EC2::VerifiedAccessInstance
    :logType: VERIFIED_ACCESS_LOGS
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_verified_access_instance_verified_access_logs = ec2_mixins.CfnVerifiedAccessInstanceVerifiedAccessLogs()
    '''

    def __init__(self) -> None:
        '''
        :stability: experimental
        '''
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="toFirehose")
    def to_firehose(
        self,
        delivery_stream: "_aws_cdk_interfaces_aws_kinesisfirehose_ceddda9d.IDeliveryStreamRef",
    ) -> "CfnVerifiedAccessInstanceLogsMixin":
        '''Send logs to a Firehose Delivery Stream.

        :param delivery_stream: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5cd5cd84b9949f4da82e94244c44605acc59dd84c8be6388034af4dff989bb3d)
            check_type(argname="argument delivery_stream", value=delivery_stream, expected_type=type_hints["delivery_stream"])
        return typing.cast("CfnVerifiedAccessInstanceLogsMixin", jsii.invoke(self, "toFirehose", [delivery_stream]))

    @jsii.member(jsii_name="toLogGroup")
    def to_log_group(
        self,
        log_group: "_aws_cdk_interfaces_aws_logs_ceddda9d.ILogGroupRef",
    ) -> "CfnVerifiedAccessInstanceLogsMixin":
        '''Send logs to a CloudWatch Log Group.

        :param log_group: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8631ddd54bc752fc1b1e80f6fbb0577c3bf6aa98d0f75b55b1cbfad5c494b201)
            check_type(argname="argument log_group", value=log_group, expected_type=type_hints["log_group"])
        return typing.cast("CfnVerifiedAccessInstanceLogsMixin", jsii.invoke(self, "toLogGroup", [log_group]))

    @jsii.member(jsii_name="toS3")
    def to_s3(
        self,
        bucket: "_aws_cdk_interfaces_aws_s3_ceddda9d.IBucketRef",
    ) -> "CfnVerifiedAccessInstanceLogsMixin":
        '''Send logs to an S3 Bucket.

        :param bucket: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cb7a15fd7bacf91708ef6f0fa7c093ae4f43ae36c160360da34a13fb2f4ec45b)
            check_type(argname="argument bucket", value=bucket, expected_type=type_hints["bucket"])
        return typing.cast("CfnVerifiedAccessInstanceLogsMixin", jsii.invoke(self, "toS3", [bucket]))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVerifiedAccessTrustProviderMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "description": "description",
        "device_options": "deviceOptions",
        "device_trust_provider_type": "deviceTrustProviderType",
        "native_application_oidc_options": "nativeApplicationOidcOptions",
        "oidc_options": "oidcOptions",
        "policy_reference_name": "policyReferenceName",
        "sse_specification": "sseSpecification",
        "tags": "tags",
        "trust_provider_type": "trustProviderType",
        "user_trust_provider_type": "userTrustProviderType",
    },
)
class CfnVerifiedAccessTrustProviderMixinProps:
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        device_options: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnVerifiedAccessTrustProviderPropsMixin.DeviceOptionsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        device_trust_provider_type: typing.Optional[builtins.str] = None,
        native_application_oidc_options: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnVerifiedAccessTrustProviderPropsMixin.NativeApplicationOidcOptionsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        oidc_options: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnVerifiedAccessTrustProviderPropsMixin.OidcOptionsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        policy_reference_name: typing.Optional[builtins.str] = None,
        sse_specification: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnVerifiedAccessTrustProviderPropsMixin.SseSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        trust_provider_type: typing.Optional[builtins.str] = None,
        user_trust_provider_type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnVerifiedAccessTrustProviderPropsMixin.

        :param description: A description for the AWS Verified Access trust provider.
        :param device_options: The options for device-identity trust provider.
        :param device_trust_provider_type: The type of device-based trust provider.
        :param native_application_oidc_options: The OpenID Connect (OIDC) options.
        :param oidc_options: The options for an OpenID Connect-compatible user-identity trust provider.
        :param policy_reference_name: The identifier to be used when working with policy rules.
        :param sse_specification: The options for additional server side encryption.
        :param tags: The tags.
        :param trust_provider_type: The type of Verified Access trust provider.
        :param user_trust_provider_type: The type of user-based trust provider.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_verified_access_trust_provider_mixin_props = ec2_mixins.CfnVerifiedAccessTrustProviderMixinProps(
                description="description",
                device_options=ec2_mixins.CfnVerifiedAccessTrustProviderPropsMixin.DeviceOptionsProperty(
                    public_signing_key_url="publicSigningKeyUrl",
                    tenant_id="tenantId"
                ),
                device_trust_provider_type="deviceTrustProviderType",
                native_application_oidc_options=ec2_mixins.CfnVerifiedAccessTrustProviderPropsMixin.NativeApplicationOidcOptionsProperty(
                    authorization_endpoint="authorizationEndpoint",
                    client_id="clientId",
                    client_secret="clientSecret",
                    issuer="issuer",
                    public_signing_key_endpoint="publicSigningKeyEndpoint",
                    scope="scope",
                    token_endpoint="tokenEndpoint",
                    user_info_endpoint="userInfoEndpoint"
                ),
                oidc_options=ec2_mixins.CfnVerifiedAccessTrustProviderPropsMixin.OidcOptionsProperty(
                    authorization_endpoint="authorizationEndpoint",
                    client_id="clientId",
                    client_secret="clientSecret",
                    issuer="issuer",
                    scope="scope",
                    token_endpoint="tokenEndpoint",
                    user_info_endpoint="userInfoEndpoint"
                ),
                policy_reference_name="policyReferenceName",
                sse_specification=ec2_mixins.CfnVerifiedAccessTrustProviderPropsMixin.SseSpecificationProperty(
                    customer_managed_key_enabled=False,
                    kms_key_arn="kmsKeyArn"
                ),
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                trust_provider_type="trustProviderType",
                user_trust_provider_type="userTrustProviderType"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__243e4d6025ee1517428096b67728e728fed5a17e0795ab17f5bf07383d2000d5)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument device_options", value=device_options, expected_type=type_hints["device_options"])
            check_type(argname="argument device_trust_provider_type", value=device_trust_provider_type, expected_type=type_hints["device_trust_provider_type"])
            check_type(argname="argument native_application_oidc_options", value=native_application_oidc_options, expected_type=type_hints["native_application_oidc_options"])
            check_type(argname="argument oidc_options", value=oidc_options, expected_type=type_hints["oidc_options"])
            check_type(argname="argument policy_reference_name", value=policy_reference_name, expected_type=type_hints["policy_reference_name"])
            check_type(argname="argument sse_specification", value=sse_specification, expected_type=type_hints["sse_specification"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument trust_provider_type", value=trust_provider_type, expected_type=type_hints["trust_provider_type"])
            check_type(argname="argument user_trust_provider_type", value=user_trust_provider_type, expected_type=type_hints["user_trust_provider_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if description is not None:
            self._values["description"] = description
        if device_options is not None:
            self._values["device_options"] = device_options
        if device_trust_provider_type is not None:
            self._values["device_trust_provider_type"] = device_trust_provider_type
        if native_application_oidc_options is not None:
            self._values["native_application_oidc_options"] = native_application_oidc_options
        if oidc_options is not None:
            self._values["oidc_options"] = oidc_options
        if policy_reference_name is not None:
            self._values["policy_reference_name"] = policy_reference_name
        if sse_specification is not None:
            self._values["sse_specification"] = sse_specification
        if tags is not None:
            self._values["tags"] = tags
        if trust_provider_type is not None:
            self._values["trust_provider_type"] = trust_provider_type
        if user_trust_provider_type is not None:
            self._values["user_trust_provider_type"] = user_trust_provider_type

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''A description for the AWS Verified Access trust provider.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def device_options(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVerifiedAccessTrustProviderPropsMixin.DeviceOptionsProperty"]]:
        '''The options for device-identity trust provider.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-deviceoptions
        '''
        result = self._values.get("device_options")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVerifiedAccessTrustProviderPropsMixin.DeviceOptionsProperty"]], result)

    @builtins.property
    def device_trust_provider_type(self) -> typing.Optional[builtins.str]:
        '''The type of device-based trust provider.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-devicetrustprovidertype
        '''
        result = self._values.get("device_trust_provider_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def native_application_oidc_options(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVerifiedAccessTrustProviderPropsMixin.NativeApplicationOidcOptionsProperty"]]:
        '''The OpenID Connect (OIDC) options.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-nativeapplicationoidcoptions
        '''
        result = self._values.get("native_application_oidc_options")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVerifiedAccessTrustProviderPropsMixin.NativeApplicationOidcOptionsProperty"]], result)

    @builtins.property
    def oidc_options(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVerifiedAccessTrustProviderPropsMixin.OidcOptionsProperty"]]:
        '''The options for an OpenID Connect-compatible user-identity trust provider.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-oidcoptions
        '''
        result = self._values.get("oidc_options")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVerifiedAccessTrustProviderPropsMixin.OidcOptionsProperty"]], result)

    @builtins.property
    def policy_reference_name(self) -> typing.Optional[builtins.str]:
        '''The identifier to be used when working with policy rules.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-policyreferencename
        '''
        result = self._values.get("policy_reference_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def sse_specification(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVerifiedAccessTrustProviderPropsMixin.SseSpecificationProperty"]]:
        '''The options for additional server side encryption.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-ssespecification
        '''
        result = self._values.get("sse_specification")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnVerifiedAccessTrustProviderPropsMixin.SseSpecificationProperty"]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def trust_provider_type(self) -> typing.Optional[builtins.str]:
        '''The type of Verified Access trust provider.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-trustprovidertype
        '''
        result = self._values.get("trust_provider_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def user_trust_provider_type(self) -> typing.Optional[builtins.str]:
        '''The type of user-based trust provider.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-usertrustprovidertype
        '''
        result = self._values.get("user_trust_provider_type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnVerifiedAccessTrustProviderMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnVerifiedAccessTrustProviderPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVerifiedAccessTrustProviderPropsMixin",
):
    '''A trust provider is a third-party entity that creates, maintains, and manages identity information for users and devices.

    When an application request is made, the identity information sent by the trust provider is evaluated by Verified Access before allowing or denying the application request.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html
    :cloudformationResource: AWS::EC2::VerifiedAccessTrustProvider
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_verified_access_trust_provider_props_mixin = ec2_mixins.CfnVerifiedAccessTrustProviderPropsMixin(ec2_mixins.CfnVerifiedAccessTrustProviderMixinProps(
            description="description",
            device_options=ec2_mixins.CfnVerifiedAccessTrustProviderPropsMixin.DeviceOptionsProperty(
                public_signing_key_url="publicSigningKeyUrl",
                tenant_id="tenantId"
            ),
            device_trust_provider_type="deviceTrustProviderType",
            native_application_oidc_options=ec2_mixins.CfnVerifiedAccessTrustProviderPropsMixin.NativeApplicationOidcOptionsProperty(
                authorization_endpoint="authorizationEndpoint",
                client_id="clientId",
                client_secret="clientSecret",
                issuer="issuer",
                public_signing_key_endpoint="publicSigningKeyEndpoint",
                scope="scope",
                token_endpoint="tokenEndpoint",
                user_info_endpoint="userInfoEndpoint"
            ),
            oidc_options=ec2_mixins.CfnVerifiedAccessTrustProviderPropsMixin.OidcOptionsProperty(
                authorization_endpoint="authorizationEndpoint",
                client_id="clientId",
                client_secret="clientSecret",
                issuer="issuer",
                scope="scope",
                token_endpoint="tokenEndpoint",
                user_info_endpoint="userInfoEndpoint"
            ),
            policy_reference_name="policyReferenceName",
            sse_specification=ec2_mixins.CfnVerifiedAccessTrustProviderPropsMixin.SseSpecificationProperty(
                customer_managed_key_enabled=False,
                kms_key_arn="kmsKeyArn"
            ),
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            trust_provider_type="trustProviderType",
            user_trust_provider_type="userTrustProviderType"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnVerifiedAccessTrustProviderMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::VerifiedAccessTrustProvider``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b80ed4335d8a431a875a3c625a143d1485772f240e08b07c60e446a9490ecbb9)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__be5294f10ab1d25c47d883faa069af2253ed22a9c437e4bfb7588e1c1cdd29bf)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0bf23d135e4e697b69ba7cfd571e2906a3e55446abbbf65e304b67aa1e124bff)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnVerifiedAccessTrustProviderMixinProps":
        return typing.cast("CfnVerifiedAccessTrustProviderMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVerifiedAccessTrustProviderPropsMixin.DeviceOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "public_signing_key_url": "publicSigningKeyUrl",
            "tenant_id": "tenantId",
        },
    )
    class DeviceOptionsProperty:
        def __init__(
            self,
            *,
            public_signing_key_url: typing.Optional[builtins.str] = None,
            tenant_id: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes the options for an AWS Verified Access device-identity based trust provider.

            :param public_signing_key_url: The URL AWS Verified Access will use to verify the authenticity of the device tokens.
            :param tenant_id: The ID of the tenant application with the device-identity provider.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-deviceoptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                device_options_property = ec2_mixins.CfnVerifiedAccessTrustProviderPropsMixin.DeviceOptionsProperty(
                    public_signing_key_url="publicSigningKeyUrl",
                    tenant_id="tenantId"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__1124417ce1fe28d9e4d895df70af80af4b22b66bca0dfdf7e44a4fb44aca8f90)
                check_type(argname="argument public_signing_key_url", value=public_signing_key_url, expected_type=type_hints["public_signing_key_url"])
                check_type(argname="argument tenant_id", value=tenant_id, expected_type=type_hints["tenant_id"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if public_signing_key_url is not None:
                self._values["public_signing_key_url"] = public_signing_key_url
            if tenant_id is not None:
                self._values["tenant_id"] = tenant_id

        @builtins.property
        def public_signing_key_url(self) -> typing.Optional[builtins.str]:
            '''The URL AWS Verified Access will use to verify the authenticity of the device tokens.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-deviceoptions.html#cfn-ec2-verifiedaccesstrustprovider-deviceoptions-publicsigningkeyurl
            '''
            result = self._values.get("public_signing_key_url")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def tenant_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the tenant application with the device-identity provider.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-deviceoptions.html#cfn-ec2-verifiedaccesstrustprovider-deviceoptions-tenantid
            '''
            result = self._values.get("tenant_id")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "DeviceOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVerifiedAccessTrustProviderPropsMixin.NativeApplicationOidcOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "authorization_endpoint": "authorizationEndpoint",
            "client_id": "clientId",
            "client_secret": "clientSecret",
            "issuer": "issuer",
            "public_signing_key_endpoint": "publicSigningKeyEndpoint",
            "scope": "scope",
            "token_endpoint": "tokenEndpoint",
            "user_info_endpoint": "userInfoEndpoint",
        },
    )
    class NativeApplicationOidcOptionsProperty:
        def __init__(
            self,
            *,
            authorization_endpoint: typing.Optional[builtins.str] = None,
            client_id: typing.Optional[builtins.str] = None,
            client_secret: typing.Optional[builtins.str] = None,
            issuer: typing.Optional[builtins.str] = None,
            public_signing_key_endpoint: typing.Optional[builtins.str] = None,
            scope: typing.Optional[builtins.str] = None,
            token_endpoint: typing.Optional[builtins.str] = None,
            user_info_endpoint: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes the OpenID Connect (OIDC) options.

            :param authorization_endpoint: The authorization endpoint of the IdP.
            :param client_id: The OAuth 2.0 client identifier.
            :param client_secret: The OAuth 2.0 client secret.
            :param issuer: The OIDC issuer identifier of the IdP.
            :param public_signing_key_endpoint: The public signing key endpoint.
            :param scope: The set of user claims to be requested from the IdP.
            :param token_endpoint: The token endpoint of the IdP.
            :param user_info_endpoint: The user info endpoint of the IdP.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-nativeapplicationoidcoptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                native_application_oidc_options_property = ec2_mixins.CfnVerifiedAccessTrustProviderPropsMixin.NativeApplicationOidcOptionsProperty(
                    authorization_endpoint="authorizationEndpoint",
                    client_id="clientId",
                    client_secret="clientSecret",
                    issuer="issuer",
                    public_signing_key_endpoint="publicSigningKeyEndpoint",
                    scope="scope",
                    token_endpoint="tokenEndpoint",
                    user_info_endpoint="userInfoEndpoint"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__3c168e90e3ed3bb6f9ced325c36bc3dc08d8b4a5f29c963446ae3e47d9647f8f)
                check_type(argname="argument authorization_endpoint", value=authorization_endpoint, expected_type=type_hints["authorization_endpoint"])
                check_type(argname="argument client_id", value=client_id, expected_type=type_hints["client_id"])
                check_type(argname="argument client_secret", value=client_secret, expected_type=type_hints["client_secret"])
                check_type(argname="argument issuer", value=issuer, expected_type=type_hints["issuer"])
                check_type(argname="argument public_signing_key_endpoint", value=public_signing_key_endpoint, expected_type=type_hints["public_signing_key_endpoint"])
                check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
                check_type(argname="argument token_endpoint", value=token_endpoint, expected_type=type_hints["token_endpoint"])
                check_type(argname="argument user_info_endpoint", value=user_info_endpoint, expected_type=type_hints["user_info_endpoint"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if authorization_endpoint is not None:
                self._values["authorization_endpoint"] = authorization_endpoint
            if client_id is not None:
                self._values["client_id"] = client_id
            if client_secret is not None:
                self._values["client_secret"] = client_secret
            if issuer is not None:
                self._values["issuer"] = issuer
            if public_signing_key_endpoint is not None:
                self._values["public_signing_key_endpoint"] = public_signing_key_endpoint
            if scope is not None:
                self._values["scope"] = scope
            if token_endpoint is not None:
                self._values["token_endpoint"] = token_endpoint
            if user_info_endpoint is not None:
                self._values["user_info_endpoint"] = user_info_endpoint

        @builtins.property
        def authorization_endpoint(self) -> typing.Optional[builtins.str]:
            '''The authorization endpoint of the IdP.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-nativeapplicationoidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-nativeapplicationoidcoptions-authorizationendpoint
            '''
            result = self._values.get("authorization_endpoint")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def client_id(self) -> typing.Optional[builtins.str]:
            '''The OAuth 2.0 client identifier.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-nativeapplicationoidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-nativeapplicationoidcoptions-clientid
            '''
            result = self._values.get("client_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def client_secret(self) -> typing.Optional[builtins.str]:
            '''The OAuth 2.0 client secret.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-nativeapplicationoidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-nativeapplicationoidcoptions-clientsecret
            '''
            result = self._values.get("client_secret")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def issuer(self) -> typing.Optional[builtins.str]:
            '''The OIDC issuer identifier of the IdP.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-nativeapplicationoidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-nativeapplicationoidcoptions-issuer
            '''
            result = self._values.get("issuer")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def public_signing_key_endpoint(self) -> typing.Optional[builtins.str]:
            '''The public signing key endpoint.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-nativeapplicationoidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-nativeapplicationoidcoptions-publicsigningkeyendpoint
            '''
            result = self._values.get("public_signing_key_endpoint")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def scope(self) -> typing.Optional[builtins.str]:
            '''The set of user claims to be requested from the IdP.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-nativeapplicationoidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-nativeapplicationoidcoptions-scope
            '''
            result = self._values.get("scope")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def token_endpoint(self) -> typing.Optional[builtins.str]:
            '''The token endpoint of the IdP.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-nativeapplicationoidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-nativeapplicationoidcoptions-tokenendpoint
            '''
            result = self._values.get("token_endpoint")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def user_info_endpoint(self) -> typing.Optional[builtins.str]:
            '''The user info endpoint of the IdP.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-nativeapplicationoidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-nativeapplicationoidcoptions-userinfoendpoint
            '''
            result = self._values.get("user_info_endpoint")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "NativeApplicationOidcOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVerifiedAccessTrustProviderPropsMixin.OidcOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "authorization_endpoint": "authorizationEndpoint",
            "client_id": "clientId",
            "client_secret": "clientSecret",
            "issuer": "issuer",
            "scope": "scope",
            "token_endpoint": "tokenEndpoint",
            "user_info_endpoint": "userInfoEndpoint",
        },
    )
    class OidcOptionsProperty:
        def __init__(
            self,
            *,
            authorization_endpoint: typing.Optional[builtins.str] = None,
            client_id: typing.Optional[builtins.str] = None,
            client_secret: typing.Optional[builtins.str] = None,
            issuer: typing.Optional[builtins.str] = None,
            scope: typing.Optional[builtins.str] = None,
            token_endpoint: typing.Optional[builtins.str] = None,
            user_info_endpoint: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes the options for an OpenID Connect-compatible user-identity trust provider.

            :param authorization_endpoint: The OIDC authorization endpoint.
            :param client_id: The client identifier.
            :param client_secret: The client secret.
            :param issuer: The OIDC issuer.
            :param scope: The OpenID Connect (OIDC) scope specified.
            :param token_endpoint: The OIDC token endpoint.
            :param user_info_endpoint: The OIDC user info endpoint.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-oidcoptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                oidc_options_property = ec2_mixins.CfnVerifiedAccessTrustProviderPropsMixin.OidcOptionsProperty(
                    authorization_endpoint="authorizationEndpoint",
                    client_id="clientId",
                    client_secret="clientSecret",
                    issuer="issuer",
                    scope="scope",
                    token_endpoint="tokenEndpoint",
                    user_info_endpoint="userInfoEndpoint"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__ee9bdcb0c6cad8db84e38243fc0a52f9d683e67623cad9b84ff1112fa524ea41)
                check_type(argname="argument authorization_endpoint", value=authorization_endpoint, expected_type=type_hints["authorization_endpoint"])
                check_type(argname="argument client_id", value=client_id, expected_type=type_hints["client_id"])
                check_type(argname="argument client_secret", value=client_secret, expected_type=type_hints["client_secret"])
                check_type(argname="argument issuer", value=issuer, expected_type=type_hints["issuer"])
                check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
                check_type(argname="argument token_endpoint", value=token_endpoint, expected_type=type_hints["token_endpoint"])
                check_type(argname="argument user_info_endpoint", value=user_info_endpoint, expected_type=type_hints["user_info_endpoint"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if authorization_endpoint is not None:
                self._values["authorization_endpoint"] = authorization_endpoint
            if client_id is not None:
                self._values["client_id"] = client_id
            if client_secret is not None:
                self._values["client_secret"] = client_secret
            if issuer is not None:
                self._values["issuer"] = issuer
            if scope is not None:
                self._values["scope"] = scope
            if token_endpoint is not None:
                self._values["token_endpoint"] = token_endpoint
            if user_info_endpoint is not None:
                self._values["user_info_endpoint"] = user_info_endpoint

        @builtins.property
        def authorization_endpoint(self) -> typing.Optional[builtins.str]:
            '''The OIDC authorization endpoint.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-oidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-oidcoptions-authorizationendpoint
            '''
            result = self._values.get("authorization_endpoint")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def client_id(self) -> typing.Optional[builtins.str]:
            '''The client identifier.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-oidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-oidcoptions-clientid
            '''
            result = self._values.get("client_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def client_secret(self) -> typing.Optional[builtins.str]:
            '''The client secret.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-oidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-oidcoptions-clientsecret
            '''
            result = self._values.get("client_secret")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def issuer(self) -> typing.Optional[builtins.str]:
            '''The OIDC issuer.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-oidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-oidcoptions-issuer
            '''
            result = self._values.get("issuer")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def scope(self) -> typing.Optional[builtins.str]:
            '''The OpenID Connect (OIDC) scope specified.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-oidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-oidcoptions-scope
            '''
            result = self._values.get("scope")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def token_endpoint(self) -> typing.Optional[builtins.str]:
            '''The OIDC token endpoint.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-oidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-oidcoptions-tokenendpoint
            '''
            result = self._values.get("token_endpoint")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def user_info_endpoint(self) -> typing.Optional[builtins.str]:
            '''The OIDC user info endpoint.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-oidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-oidcoptions-userinfoendpoint
            '''
            result = self._values.get("user_info_endpoint")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "OidcOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVerifiedAccessTrustProviderPropsMixin.SseSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "customer_managed_key_enabled": "customerManagedKeyEnabled",
            "kms_key_arn": "kmsKeyArn",
        },
    )
    class SseSpecificationProperty:
        def __init__(
            self,
            *,
            customer_managed_key_enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            kms_key_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''AWS Verified Access provides server side encryption by default to data at rest using AWS -owned KMS keys.

            You also have the option of using customer managed KMS keys, which can be specified using the options below.

            :param customer_managed_key_enabled: Enable or disable the use of customer managed KMS keys for server side encryption. Valid values: ``True`` | ``False``
            :param kms_key_arn: The ARN of the KMS key.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-ssespecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
                
                sse_specification_property = ec2_mixins.CfnVerifiedAccessTrustProviderPropsMixin.SseSpecificationProperty(
                    customer_managed_key_enabled=False,
                    kms_key_arn="kmsKeyArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__bb5b7761eb671357148a4ff38002eb6ad9bcd0f423902c8baa520ad6c581581f)
                check_type(argname="argument customer_managed_key_enabled", value=customer_managed_key_enabled, expected_type=type_hints["customer_managed_key_enabled"])
                check_type(argname="argument kms_key_arn", value=kms_key_arn, expected_type=type_hints["kms_key_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if customer_managed_key_enabled is not None:
                self._values["customer_managed_key_enabled"] = customer_managed_key_enabled
            if kms_key_arn is not None:
                self._values["kms_key_arn"] = kms_key_arn

        @builtins.property
        def customer_managed_key_enabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Enable or disable the use of customer managed KMS keys for server side encryption.

            Valid values: ``True`` | ``False``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-ssespecification.html#cfn-ec2-verifiedaccesstrustprovider-ssespecification-customermanagedkeyenabled
            '''
            result = self._values.get("customer_managed_key_enabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def kms_key_arn(self) -> typing.Optional[builtins.str]:
            '''The ARN of the KMS key.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-ssespecification.html#cfn-ec2-verifiedaccesstrustprovider-ssespecification-kmskeyarn
            '''
            result = self._values.get("kms_key_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SseSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVolumeAttachmentMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "device": "device",
        "instance_id": "instanceId",
        "volume_id": "volumeId",
    },
)
class CfnVolumeAttachmentMixinProps:
    def __init__(
        self,
        *,
        device: typing.Optional[builtins.str] = None,
        instance_id: typing.Optional[builtins.str] = None,
        volume_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnVolumeAttachmentPropsMixin.

        :param device: The device name (for example, ``/dev/sdh`` or ``xvdh`` ).
        :param instance_id: The ID of the instance to which the volume attaches. This value can be a reference to an ```AWS::EC2::Instance`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html>`_ resource, or it can be the physical ID of an existing EC2 instance.
        :param volume_id: The ID of the Amazon EBS volume. The volume and instance must be within the same Availability Zone. This value can be a reference to an ```AWS::EC2::Volume`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html>`_ resource, or it can be the volume ID of an existing Amazon EBS volume.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volumeattachment.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_volume_attachment_mixin_props = ec2_mixins.CfnVolumeAttachmentMixinProps(
                device="device",
                instance_id="instanceId",
                volume_id="volumeId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__24363ff5eefdd3a9c9ba361bf0cd1a02697bb40b9ae9fd7be59bce8b19047a47)
            check_type(argname="argument device", value=device, expected_type=type_hints["device"])
            check_type(argname="argument instance_id", value=instance_id, expected_type=type_hints["instance_id"])
            check_type(argname="argument volume_id", value=volume_id, expected_type=type_hints["volume_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if device is not None:
            self._values["device"] = device
        if instance_id is not None:
            self._values["instance_id"] = instance_id
        if volume_id is not None:
            self._values["volume_id"] = volume_id

    @builtins.property
    def device(self) -> typing.Optional[builtins.str]:
        '''The device name (for example, ``/dev/sdh`` or ``xvdh`` ).

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volumeattachment.html#cfn-ec2-volumeattachment-device
        '''
        result = self._values.get("device")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def instance_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the instance to which the volume attaches.

        This value can be a reference to an ```AWS::EC2::Instance`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html>`_ resource, or it can be the physical ID of an existing EC2 instance.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volumeattachment.html#cfn-ec2-volumeattachment-instanceid
        '''
        result = self._values.get("instance_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def volume_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the Amazon EBS volume.

        The volume and instance must be within the same Availability Zone. This value can be a reference to an ```AWS::EC2::Volume`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html>`_ resource, or it can be the volume ID of an existing Amazon EBS volume.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volumeattachment.html#cfn-ec2-volumeattachment-volumeid
        '''
        result = self._values.get("volume_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnVolumeAttachmentMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnVolumeAttachmentPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVolumeAttachmentPropsMixin",
):
    '''Attaches an Amazon EBS volume to a running instance and exposes it to the instance with the specified device name.

    Before this resource can be deleted (and therefore the volume detached), you must first unmount the volume in the instance. Failure to do so results in the volume being stuck in the busy state while it is trying to detach, which could possibly damage the file system or the data it contains.

    If an Amazon EBS volume is the root device of an instance, it cannot be detached while the instance is in the "running" state. To detach the root volume, stop the instance first.

    If the root volume is detached from an instance with an AWS Marketplace product code, then the product codes from that volume are no longer associated with the instance.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volumeattachment.html
    :cloudformationResource: AWS::EC2::VolumeAttachment
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_volume_attachment_props_mixin = ec2_mixins.CfnVolumeAttachmentPropsMixin(ec2_mixins.CfnVolumeAttachmentMixinProps(
            device="device",
            instance_id="instanceId",
            volume_id="volumeId"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnVolumeAttachmentMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::VolumeAttachment``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__527cf76feb26f77bd1741dd91926107ceac1a06268af275b94de9a5c5c73a856)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__42d2c0eede422d58b8b86ddfaedc696a0415439e3d172f0fae404d1c0ec28342)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dbd57f54471250bc19e760492eb730b4bac4e908d3fb69a2311d7e44f7618fac)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnVolumeAttachmentMixinProps":
        return typing.cast("CfnVolumeAttachmentMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVolumeMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "auto_enable_io": "autoEnableIo",
        "availability_zone": "availabilityZone",
        "availability_zone_id": "availabilityZoneId",
        "encrypted": "encrypted",
        "iops": "iops",
        "kms_key_id": "kmsKeyId",
        "multi_attach_enabled": "multiAttachEnabled",
        "outpost_arn": "outpostArn",
        "size": "size",
        "snapshot_id": "snapshotId",
        "source_volume_id": "sourceVolumeId",
        "tags": "tags",
        "throughput": "throughput",
        "volume_initialization_rate": "volumeInitializationRate",
        "volume_type": "volumeType",
    },
)
class CfnVolumeMixinProps:
    def __init__(
        self,
        *,
        auto_enable_io: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        availability_zone: typing.Optional[builtins.str] = None,
        availability_zone_id: typing.Optional[builtins.str] = None,
        encrypted: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        iops: typing.Optional[jsii.Number] = None,
        kms_key_id: typing.Optional[builtins.str] = None,
        multi_attach_enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        outpost_arn: typing.Optional[builtins.str] = None,
        size: typing.Optional[jsii.Number] = None,
        snapshot_id: typing.Optional[builtins.str] = None,
        source_volume_id: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        throughput: typing.Optional[jsii.Number] = None,
        volume_initialization_rate: typing.Optional[jsii.Number] = None,
        volume_type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnVolumePropsMixin.

        :param auto_enable_io: Indicates whether the volume is auto-enabled for I/O operations. By default, Amazon EBS disables I/O to the volume from attached EC2 instances when it determines that a volume's data is potentially inconsistent. If the consistency of the volume is not a concern, and you prefer that the volume be made available immediately if it's impaired, you can configure the volume to automatically enable I/O.
        :param availability_zone: The ID of the Availability Zone in which to create the volume. For example, ``us-east-1a`` . Either ``AvailabilityZone`` or ``AvailabilityZoneId`` must be specified, but not both. If you are creating a volume copy, omit this parameter. The volume copy is created in the same Availability Zone as the source volume.
        :param availability_zone_id: The ID of the Availability Zone in which to create the volume. For example, ``use1-az1`` . Either ``AvailabilityZone`` or ``AvailabilityZoneId`` must be specified, but not both. If you are creating a volume copy, omit this parameter. The volume copy is created in the same Availability Zone as the source volume.
        :param encrypted: Indicates whether the volume should be encrypted. The effect of setting the encryption state to ``true`` depends on the volume origin (new, from a snapshot, or from an existing volume), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see `Encryption by default <https://docs.aws.amazon.com/ebs/latest/userguide/work-with-ebs-encr.html#encryption-by-default>`_ in the *Amazon EBS User Guide* . If you are creating a volume copy, omit this parameter. The volume is automatically encrypted with the same KMS key as the source volume. You can't copy unencrypted volumes.
        :param iops: The number of I/O operations per second (IOPS) to provision for the volume. Required for ``io1`` and ``io2`` volumes. Optional for ``gp3`` volumes. Omit for all other volume types. Valid ranges: - gp3: ``3,000`` ( *default* ) ``- 80,000`` IOPS - io1: ``100 - 64,000`` IOPS - io2: ``100 - 256,000`` IOPS .. epigraph:: `Instances built on the Nitro System <https://docs.aws.amazon.com/ec2/latest/instancetypes/ec2-nitro-instances.html>`_ can support up to 256,000 IOPS. Other instances can support up to 32,000 IOPS.
        :param kms_key_id: The identifier of the AWS KMS key to use for Amazon EBS encryption. If ``KmsKeyId`` is specified, the encrypted state must be ``true`` . If you omit this property and your account is enabled for encryption by default, or *Encrypted* is set to ``true`` , then the volume is encrypted using the default key specified for your account. If your account does not have a default key, then the volume is encrypted using the AWS managed key . Alternatively, if you want to specify a different key, you can specify one of the following: - Key ID. For example, 1234abcd-12ab-34cd-56ef-1234567890ab. - Key alias. Specify the alias for the key, prefixed with ``alias/`` . For example, for a key with the alias ``my_cmk`` , use ``alias/my_cmk`` . Or to specify the AWS managed key , use ``alias/aws/ebs`` . - Key ARN. For example, arn:aws:kms:us-east-1:012345678910:key/1234abcd-12ab-34cd-56ef-1234567890ab. - Alias ARN. For example, arn:aws:kms:us-east-1:012345678910:alias/ExampleAlias. If you are creating a volume copy, omit this parameter. The volume is automatically encrypted with the same KMS key as the source volume. You can't copy unencrypted volumes.
        :param multi_attach_enabled: Indicates whether Amazon EBS Multi-Attach is enabled. AWS CloudFormation does not currently support updating a single-attach volume to be multi-attach enabled, updating a multi-attach enabled volume to be single-attach, or updating the size or number of I/O operations per second (IOPS) of a multi-attach enabled volume.
        :param outpost_arn: The Amazon Resource Name (ARN) of the Outpost on which to create the volume. If you intend to use a volume with an instance running on an outpost, then you must create the volume on the same outpost as the instance. You can't use a volume created in an AWS Region with an instance on an AWS outpost, or the other way around.
        :param size: The size of the volume, in GiBs. - Required for new empty volumes. - Optional for volumes created from snapshots and volume copies. In this case, the size defaults to the size of the snapshot or source volume. You can optionally specify a size that is equal to or larger than the size of the source snapshot or volume. Supported volume sizes: - gp2: ``1 - 16,384`` GiB - gp3: ``1 - 65,536`` GiB - io1: ``4 - 16,384`` GiB - io2: ``4 - 65,536`` GiB - st1 and sc1: ``125 - 16,384`` GiB - standard: ``1 - 1024`` GiB
        :param snapshot_id: The snapshot from which to create the volume. Only specify to create a volume from a snapshot. To create a new empty volume, omit this parameter and specify a value for ``Size`` instead. To create a volume copy, omit this parameter and specify ``SourceVolumeId`` instead.
        :param source_volume_id: The ID of the source EBS volume to copy. When specified, the volume is created as an exact copy of the specified volume. Only specify to create a volume copy. To create a new empty volume or to create a volume from a snapshot, omit this parameter,
        :param tags: The tags to apply to the volume during creation.
        :param throughput: The throughput to provision for a volume, with a maximum of 1,000 MiB/s. This parameter is valid only for ``gp3`` volumes. The default value is 125. Valid Range: Minimum value of 125. Maximum value of 1000.
        :param volume_initialization_rate: Specifies the Amazon EBS Provisioned Rate for Volume Initialization (volume initialization rate), in MiB/s, at which to download the snapshot blocks from Amazon S3 to the volume. This is also known as *volume initialization* . Specifying a volume initialization rate ensures that the volume is initialized at a predictable and consistent rate after creation. This parameter is supported only for volumes created from snapshots. Omit this parameter if: - You want to create the volume using fast snapshot restore. You must specify a snapshot that is enabled for fast snapshot restore. In this case, the volume is fully initialized at creation. .. epigraph:: If you specify a snapshot that is enabled for fast snapshot restore and a volume initialization rate, the volume will be initialized at the specified rate instead of fast snapshot restore. - You want to create a volume that is initialized at the default rate. For more information, see `Initialize Amazon EBS volumes <https://docs.aws.amazon.com/ebs/latest/userguide/initalize-volume.html>`_ in the *Amazon EC2 User Guide* . Valid range: 100 - 300 MiB/s
        :param volume_type: The volume type. This parameter can be one of the following values:. - General Purpose SSD: ``gp2`` | ``gp3`` - Provisioned IOPS SSD: ``io1`` | ``io2`` - Throughput Optimized HDD: ``st1`` - Cold HDD: ``sc1`` - Magnetic: ``standard`` .. epigraph:: Throughput Optimized HDD ( ``st1`` ) and Cold HDD ( ``sc1`` ) volumes can't be used as boot volumes. For more information, see `Amazon EBS volume types <https://docs.aws.amazon.com/ebs/latest/userguide/ebs-volume-types.html>`_ in the *Amazon EBS User Guide* . Default: ``gp2``

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
            
            cfn_volume_mixin_props = ec2_mixins.CfnVolumeMixinProps(
                auto_enable_io=False,
                availability_zone="availabilityZone",
                availability_zone_id="availabilityZoneId",
                encrypted=False,
                iops=123,
                kms_key_id="kmsKeyId",
                multi_attach_enabled=False,
                outpost_arn="outpostArn",
                size=123,
                snapshot_id="snapshotId",
                source_volume_id="sourceVolumeId",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                throughput=123,
                volume_initialization_rate=123,
                volume_type="volumeType"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4c8f1dd17bdc5d6cb18761cf4a6032606365f44f7bdfbc39d4b3937d82c52817)
            check_type(argname="argument auto_enable_io", value=auto_enable_io, expected_type=type_hints["auto_enable_io"])
            check_type(argname="argument availability_zone", value=availability_zone, expected_type=type_hints["availability_zone"])
            check_type(argname="argument availability_zone_id", value=availability_zone_id, expected_type=type_hints["availability_zone_id"])
            check_type(argname="argument encrypted", value=encrypted, expected_type=type_hints["encrypted"])
            check_type(argname="argument iops", value=iops, expected_type=type_hints["iops"])
            check_type(argname="argument kms_key_id", value=kms_key_id, expected_type=type_hints["kms_key_id"])
            check_type(argname="argument multi_attach_enabled", value=multi_attach_enabled, expected_type=type_hints["multi_attach_enabled"])
            check_type(argname="argument outpost_arn", value=outpost_arn, expected_type=type_hints["outpost_arn"])
            check_type(argname="argument size", value=size, expected_type=type_hints["size"])
            check_type(argname="argument snapshot_id", value=snapshot_id, expected_type=type_hints["snapshot_id"])
            check_type(argname="argument source_volume_id", value=source_volume_id, expected_type=type_hints["source_volume_id"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument throughput", value=throughput, expected_type=type_hints["throughput"])
            check_type(argname="argument volume_initialization_rate", value=volume_initialization_rate, expected_type=type_hints["volume_initialization_rate"])
            check_type(argname="argument volume_type", value=volume_type, expected_type=type_hints["volume_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if auto_enable_io is not None:
            self._values["auto_enable_io"] = auto_enable_io
        if availability_zone is not None:
            self._values["availability_zone"] = availability_zone
        if availability_zone_id is not None:
            self._values["availability_zone_id"] = availability_zone_id
        if encrypted is not None:
            self._values["encrypted"] = encrypted
        if iops is not None:
            self._values["iops"] = iops
        if kms_key_id is not None:
            self._values["kms_key_id"] = kms_key_id
        if multi_attach_enabled is not None:
            self._values["multi_attach_enabled"] = multi_attach_enabled
        if outpost_arn is not None:
            self._values["outpost_arn"] = outpost_arn
        if size is not None:
            self._values["size"] = size
        if snapshot_id is not None:
            self._values["snapshot_id"] = snapshot_id
        if source_volume_id is not None:
            self._values["source_volume_id"] = source_volume_id
        if tags is not None:
            self._values["tags"] = tags
        if throughput is not None:
            self._values["throughput"] = throughput
        if volume_initialization_rate is not None:
            self._values["volume_initialization_rate"] = volume_initialization_rate
        if volume_type is not None:
            self._values["volume_type"] = volume_type

    @builtins.property
    def auto_enable_io(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Indicates whether the volume is auto-enabled for I/O operations.

        By default, Amazon EBS disables I/O to the volume from attached EC2 instances when it determines that a volume's data is potentially inconsistent. If the consistency of the volume is not a concern, and you prefer that the volume be made available immediately if it's impaired, you can configure the volume to automatically enable I/O.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-autoenableio
        '''
        result = self._values.get("auto_enable_io")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def availability_zone(self) -> typing.Optional[builtins.str]:
        '''The ID of the Availability Zone in which to create the volume. For example, ``us-east-1a`` .

        Either ``AvailabilityZone`` or ``AvailabilityZoneId`` must be specified, but not both.

        If you are creating a volume copy, omit this parameter. The volume copy is created in the same Availability Zone as the source volume.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-availabilityzone
        '''
        result = self._values.get("availability_zone")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def availability_zone_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the Availability Zone in which to create the volume. For example, ``use1-az1`` .

        Either ``AvailabilityZone`` or ``AvailabilityZoneId`` must be specified, but not both.

        If you are creating a volume copy, omit this parameter. The volume copy is created in the same Availability Zone as the source volume.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-availabilityzoneid
        '''
        result = self._values.get("availability_zone_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def encrypted(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Indicates whether the volume should be encrypted.

        The effect of setting the encryption state to ``true`` depends on the volume origin (new, from a snapshot, or from an existing volume), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see `Encryption by default <https://docs.aws.amazon.com/ebs/latest/userguide/work-with-ebs-encr.html#encryption-by-default>`_ in the *Amazon EBS User Guide* .

        If you are creating a volume copy, omit this parameter. The volume is automatically encrypted with the same KMS key as the source volume. You can't copy unencrypted volumes.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-encrypted
        '''
        result = self._values.get("encrypted")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def iops(self) -> typing.Optional[jsii.Number]:
        '''The number of I/O operations per second (IOPS) to provision for the volume.

        Required for ``io1`` and ``io2`` volumes. Optional for ``gp3`` volumes. Omit for all other volume types.

        Valid ranges:

        - gp3: ``3,000`` ( *default* ) ``- 80,000`` IOPS
        - io1: ``100 - 64,000`` IOPS
        - io2: ``100 - 256,000`` IOPS

        .. epigraph::

           `Instances built on the Nitro System <https://docs.aws.amazon.com/ec2/latest/instancetypes/ec2-nitro-instances.html>`_ can support up to 256,000 IOPS. Other instances can support up to 32,000 IOPS.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-iops
        '''
        result = self._values.get("iops")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def kms_key_id(self) -> typing.Optional[builtins.str]:
        '''The identifier of the AWS KMS key to use for Amazon EBS encryption.

        If ``KmsKeyId`` is specified, the encrypted state must be ``true`` .

        If you omit this property and your account is enabled for encryption by default, or *Encrypted* is set to ``true`` , then the volume is encrypted using the default key specified for your account. If your account does not have a default key, then the volume is encrypted using the AWS managed key .

        Alternatively, if you want to specify a different key, you can specify one of the following:

        - Key ID. For example, 1234abcd-12ab-34cd-56ef-1234567890ab.
        - Key alias. Specify the alias for the key, prefixed with ``alias/`` . For example, for a key with the alias ``my_cmk`` , use ``alias/my_cmk`` . Or to specify the AWS managed key , use ``alias/aws/ebs`` .
        - Key ARN. For example, arn:aws:kms:us-east-1:012345678910:key/1234abcd-12ab-34cd-56ef-1234567890ab.
        - Alias ARN. For example, arn:aws:kms:us-east-1:012345678910:alias/ExampleAlias.

        If you are creating a volume copy, omit this parameter. The volume is automatically encrypted with the same KMS key as the source volume. You can't copy unencrypted volumes.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-kmskeyid
        '''
        result = self._values.get("kms_key_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def multi_attach_enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Indicates whether Amazon EBS Multi-Attach is enabled.

        AWS CloudFormation does not currently support updating a single-attach volume to be multi-attach enabled, updating a multi-attach enabled volume to be single-attach, or updating the size or number of I/O operations per second (IOPS) of a multi-attach enabled volume.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-multiattachenabled
        '''
        result = self._values.get("multi_attach_enabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def outpost_arn(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the Outpost on which to create the volume.

        If you intend to use a volume with an instance running on an outpost, then you must create the volume on the same outpost as the instance. You can't use a volume created in an AWS Region with an instance on an AWS outpost, or the other way around.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-outpostarn
        '''
        result = self._values.get("outpost_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def size(self) -> typing.Optional[jsii.Number]:
        '''The size of the volume, in GiBs.

        - Required for new empty volumes.
        - Optional for volumes created from snapshots and volume copies. In this case, the size defaults to the size of the snapshot or source volume. You can optionally specify a size that is equal to or larger than the size of the source snapshot or volume.

        Supported volume sizes:

        - gp2: ``1 - 16,384`` GiB
        - gp3: ``1 - 65,536`` GiB
        - io1: ``4 - 16,384`` GiB
        - io2: ``4 - 65,536`` GiB
        - st1 and sc1: ``125 - 16,384`` GiB
        - standard: ``1 - 1024`` GiB

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-size
        '''
        result = self._values.get("size")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def snapshot_id(self) -> typing.Optional[builtins.str]:
        '''The snapshot from which to create the volume.

        Only specify to create a volume from a snapshot. To create a new empty volume, omit this parameter and specify a value for ``Size`` instead. To create a volume copy, omit this parameter and specify ``SourceVolumeId`` instead.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-snapshotid
        '''
        result = self._values.get("snapshot_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def source_volume_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the source EBS volume to copy.

        When specified, the volume is created as an exact copy of the specified volume. Only specify to create a volume copy. To create a new empty volume or to create a volume from a snapshot, omit this parameter,

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-sourcevolumeid
        '''
        result = self._values.get("source_volume_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags to apply to the volume during creation.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def throughput(self) -> typing.Optional[jsii.Number]:
        '''The throughput to provision for a volume, with a maximum of 1,000 MiB/s.

        This parameter is valid only for ``gp3`` volumes. The default value is 125.

        Valid Range: Minimum value of 125. Maximum value of 1000.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-throughput
        '''
        result = self._values.get("throughput")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def volume_initialization_rate(self) -> typing.Optional[jsii.Number]:
        '''Specifies the Amazon EBS Provisioned Rate for Volume Initialization (volume initialization rate), in MiB/s, at which to download the snapshot blocks from Amazon S3 to the volume.

        This is also known as *volume initialization* . Specifying a volume initialization rate ensures that the volume is initialized at a predictable and consistent rate after creation.

        This parameter is supported only for volumes created from snapshots. Omit this parameter if:

        - You want to create the volume using fast snapshot restore. You must specify a snapshot that is enabled for fast snapshot restore. In this case, the volume is fully initialized at creation.

        .. epigraph::

           If you specify a snapshot that is enabled for fast snapshot restore and a volume initialization rate, the volume will be initialized at the specified rate instead of fast snapshot restore.

        - You want to create a volume that is initialized at the default rate.

        For more information, see `Initialize Amazon EBS volumes <https://docs.aws.amazon.com/ebs/latest/userguide/initalize-volume.html>`_ in the *Amazon EC2 User Guide* .

        Valid range: 100 - 300 MiB/s

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-volumeinitializationrate
        '''
        result = self._values.get("volume_initialization_rate")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def volume_type(self) -> typing.Optional[builtins.str]:
        '''The volume type. This parameter can be one of the following values:.

        - General Purpose SSD: ``gp2`` | ``gp3``
        - Provisioned IOPS SSD: ``io1`` | ``io2``
        - Throughput Optimized HDD: ``st1``
        - Cold HDD: ``sc1``
        - Magnetic: ``standard``

        .. epigraph::

           Throughput Optimized HDD ( ``st1`` ) and Cold HDD ( ``sc1`` ) volumes can't be used as boot volumes.

        For more information, see `Amazon EBS volume types <https://docs.aws.amazon.com/ebs/latest/userguide/ebs-volume-types.html>`_ in the *Amazon EBS User Guide* .

        Default: ``gp2``

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-volumetype
        '''
        result = self._values.get("volume_type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnVolumeMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnVolumePropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_ec2.mixins.CfnVolumePropsMixin",
):
    '''Specifies an Amazon Elastic Block Store (Amazon EBS) volume.

    You can create an empty volume, a volume from a snapshot, or a volume copy from an existing source volume.
    .. epigraph::

       - When you use AWS CloudFormation to update an Amazon EBS volume that modifies ``Iops`` , ``Size`` , or ``VolumeType`` , there is a cooldown period before another operation can occur. This can cause your stack to report being in ``UPDATE_IN_PROGRESS`` or ``UPDATE_ROLLBACK_IN_PROGRESS`` for long periods of time. Some common scenarios when you might encounter a cooldown period for Amazon EBS include:
       - You successfully update an Amazon EBS volume and the update succeeds. When you attempt another update within the cooldown window, that update will be subject to a cooldown period.
       - You successfully update an Amazon EBS volume and the update succeeds but another change in your ``update-stack`` call fails. The rollback will be subject to a cooldown period.

       For more information, see `Requirements for EBS volume modifications <https://docs.aws.amazon.com/ebs/latest/userguide/modify-volume-requirements.html>`_ .

       - Amazon EBS does not support sizing down an Amazon EBS volume. AWS CloudFormation does not attempt to modify an Amazon EBS volume to a smaller size on rollback.

    *DeletionPolicy attribute*

    To control how AWS CloudFormation handles the volume when the stack is deleted, set a deletion policy for your volume. You can choose to retain the volume, to delete the volume, or to create a snapshot of the volume. For more information, see `DeletionPolicy attribute <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html>`_ .
    .. epigraph::

       If you set a deletion policy that creates a snapshot, all tags on the volume are included in the snapshot.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html
    :cloudformationResource: AWS::EC2::Volume
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_ec2 import mixins as ec2_mixins
        
        cfn_volume_props_mixin = ec2_mixins.CfnVolumePropsMixin(ec2_mixins.CfnVolumeMixinProps(
            auto_enable_io=False,
            availability_zone="availabilityZone",
            availability_zone_id="availabilityZoneId",
            encrypted=False,
            iops=123,
            kms_key_id="kmsKeyId",
            multi_attach_enabled=False,
            outpost_arn="outpostArn",
            size=123,
            snapshot_id="snapshotId",
            source_volume_id="sourceVolumeId",
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            throughput=123,
            volume_initialization_rate=123,
            volume_type="volumeType"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnVolumeMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::EC2::Volume``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c118566bdb7e06790caca9feff179e60c93c2bd697aa6695d7695efd1163edb1)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dd9bd4259f6add33f206da0b2fe29bb194bfaa49493b135994e2023bc1e9e0c6)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__06f33ebda76c73c1224960ca1718d6c287573dff4d1774b626ee031d21402038)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnVolumeMixinProps":
        return typing.cast("CfnVolumeMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


__all__ = [
    "CfnCapacityManagerDataExportMixinProps",
    "CfnCapacityManagerDataExportPropsMixin",
    "CfnCapacityReservationFleetMixinProps",
    "CfnCapacityReservationFleetPropsMixin",
    "CfnCapacityReservationMixinProps",
    "CfnCapacityReservationPropsMixin",
    "CfnCarrierGatewayMixinProps",
    "CfnCarrierGatewayPropsMixin",
    "CfnClientVpnAuthorizationRuleMixinProps",
    "CfnClientVpnAuthorizationRulePropsMixin",
    "CfnClientVpnEndpointMixinProps",
    "CfnClientVpnEndpointPropsMixin",
    "CfnClientVpnRouteMixinProps",
    "CfnClientVpnRoutePropsMixin",
    "CfnClientVpnTargetNetworkAssociationMixinProps",
    "CfnClientVpnTargetNetworkAssociationPropsMixin",
    "CfnCustomerGatewayMixinProps",
    "CfnCustomerGatewayPropsMixin",
    "CfnDHCPOptionsMixinProps",
    "CfnDHCPOptionsPropsMixin",
    "CfnEC2FleetMixinProps",
    "CfnEC2FleetPropsMixin",
    "CfnEIPAssociationMixinProps",
    "CfnEIPAssociationPropsMixin",
    "CfnEIPMixinProps",
    "CfnEIPPropsMixin",
    "CfnEgressOnlyInternetGatewayMixinProps",
    "CfnEgressOnlyInternetGatewayPropsMixin",
    "CfnEnclaveCertificateIamRoleAssociationMixinProps",
    "CfnEnclaveCertificateIamRoleAssociationPropsMixin",
    "CfnFlowLogMixinProps",
    "CfnFlowLogPropsMixin",
    "CfnGatewayRouteTableAssociationMixinProps",
    "CfnGatewayRouteTableAssociationPropsMixin",
    "CfnHostMixinProps",
    "CfnHostPropsMixin",
    "CfnIPAMAllocationMixinProps",
    "CfnIPAMAllocationPropsMixin",
    "CfnIPAMMixinProps",
    "CfnIPAMPoolCidrMixinProps",
    "CfnIPAMPoolCidrPropsMixin",
    "CfnIPAMPoolMixinProps",
    "CfnIPAMPoolPropsMixin",
    "CfnIPAMPropsMixin",
    "CfnIPAMResourceDiscoveryAssociationMixinProps",
    "CfnIPAMResourceDiscoveryAssociationPropsMixin",
    "CfnIPAMResourceDiscoveryMixinProps",
    "CfnIPAMResourceDiscoveryPropsMixin",
    "CfnIPAMScopeMixinProps",
    "CfnIPAMScopePropsMixin",
    "CfnInstanceConnectEndpointMixinProps",
    "CfnInstanceConnectEndpointPropsMixin",
    "CfnInstanceMixinProps",
    "CfnInstancePropsMixin",
    "CfnInternetGatewayMixinProps",
    "CfnInternetGatewayPropsMixin",
    "CfnIpPoolRouteTableAssociationMixinProps",
    "CfnIpPoolRouteTableAssociationPropsMixin",
    "CfnKeyPairMixinProps",
    "CfnKeyPairPropsMixin",
    "CfnLaunchTemplateMixinProps",
    "CfnLaunchTemplatePropsMixin",
    "CfnLocalGatewayRouteMixinProps",
    "CfnLocalGatewayRoutePropsMixin",
    "CfnLocalGatewayRouteTableMixinProps",
    "CfnLocalGatewayRouteTablePropsMixin",
    "CfnLocalGatewayRouteTableVPCAssociationMixinProps",
    "CfnLocalGatewayRouteTableVPCAssociationPropsMixin",
    "CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationMixinProps",
    "CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationPropsMixin",
    "CfnLocalGatewayVirtualInterfaceGroupMixinProps",
    "CfnLocalGatewayVirtualInterfaceGroupPropsMixin",
    "CfnLocalGatewayVirtualInterfaceMixinProps",
    "CfnLocalGatewayVirtualInterfacePropsMixin",
    "CfnNatGatewayMixinProps",
    "CfnNatGatewayPropsMixin",
    "CfnNetworkAclEntryMixinProps",
    "CfnNetworkAclEntryPropsMixin",
    "CfnNetworkAclMixinProps",
    "CfnNetworkAclPropsMixin",
    "CfnNetworkInsightsAccessScopeAnalysisMixinProps",
    "CfnNetworkInsightsAccessScopeAnalysisPropsMixin",
    "CfnNetworkInsightsAccessScopeMixinProps",
    "CfnNetworkInsightsAccessScopePropsMixin",
    "CfnNetworkInsightsAnalysisMixinProps",
    "CfnNetworkInsightsAnalysisPropsMixin",
    "CfnNetworkInsightsPathMixinProps",
    "CfnNetworkInsightsPathPropsMixin",
    "CfnNetworkInterfaceAttachmentMixinProps",
    "CfnNetworkInterfaceAttachmentPropsMixin",
    "CfnNetworkInterfaceMixinProps",
    "CfnNetworkInterfacePermissionMixinProps",
    "CfnNetworkInterfacePermissionPropsMixin",
    "CfnNetworkInterfacePropsMixin",
    "CfnNetworkPerformanceMetricSubscriptionMixinProps",
    "CfnNetworkPerformanceMetricSubscriptionPropsMixin",
    "CfnPlacementGroupMixinProps",
    "CfnPlacementGroupPropsMixin",
    "CfnPrefixListMixinProps",
    "CfnPrefixListPropsMixin",
    "CfnRouteMixinProps",
    "CfnRoutePropsMixin",
    "CfnRouteServerAssociationMixinProps",
    "CfnRouteServerAssociationPropsMixin",
    "CfnRouteServerEndpointMixinProps",
    "CfnRouteServerEndpointPropsMixin",
    "CfnRouteServerMixinProps",
    "CfnRouteServerPeerEventLogs",
    "CfnRouteServerPeerLogsMixin",
    "CfnRouteServerPeerMixinProps",
    "CfnRouteServerPeerPropsMixin",
    "CfnRouteServerPropagationMixinProps",
    "CfnRouteServerPropagationPropsMixin",
    "CfnRouteServerPropsMixin",
    "CfnRouteTableMixinProps",
    "CfnRouteTablePropsMixin",
    "CfnSecurityGroupEgressMixinProps",
    "CfnSecurityGroupEgressPropsMixin",
    "CfnSecurityGroupIngressMixinProps",
    "CfnSecurityGroupIngressPropsMixin",
    "CfnSecurityGroupMixinProps",
    "CfnSecurityGroupPropsMixin",
    "CfnSecurityGroupVpcAssociationMixinProps",
    "CfnSecurityGroupVpcAssociationPropsMixin",
    "CfnSnapshotBlockPublicAccessMixinProps",
    "CfnSnapshotBlockPublicAccessPropsMixin",
    "CfnSpotFleetMixinProps",
    "CfnSpotFleetPropsMixin",
    "CfnSubnetCidrBlockMixinProps",
    "CfnSubnetCidrBlockPropsMixin",
    "CfnSubnetMixinProps",
    "CfnSubnetNetworkAclAssociationMixinProps",
    "CfnSubnetNetworkAclAssociationPropsMixin",
    "CfnSubnetPropsMixin",
    "CfnSubnetRouteTableAssociationMixinProps",
    "CfnSubnetRouteTableAssociationPropsMixin",
    "CfnTrafficMirrorFilterMixinProps",
    "CfnTrafficMirrorFilterPropsMixin",
    "CfnTrafficMirrorFilterRuleMixinProps",
    "CfnTrafficMirrorFilterRulePropsMixin",
    "CfnTrafficMirrorSessionMixinProps",
    "CfnTrafficMirrorSessionPropsMixin",
    "CfnTrafficMirrorTargetMixinProps",
    "CfnTrafficMirrorTargetPropsMixin",
    "CfnTransitGatewayAttachmentMixinProps",
    "CfnTransitGatewayAttachmentPropsMixin",
    "CfnTransitGatewayConnectMixinProps",
    "CfnTransitGatewayConnectPeerMixinProps",
    "CfnTransitGatewayConnectPeerPropsMixin",
    "CfnTransitGatewayConnectPropsMixin",
    "CfnTransitGatewayMeteringPolicyEntryMixinProps",
    "CfnTransitGatewayMeteringPolicyEntryPropsMixin",
    "CfnTransitGatewayMeteringPolicyMixinProps",
    "CfnTransitGatewayMeteringPolicyPropsMixin",
    "CfnTransitGatewayMixinProps",
    "CfnTransitGatewayMulticastDomainAssociationMixinProps",
    "CfnTransitGatewayMulticastDomainAssociationPropsMixin",
    "CfnTransitGatewayMulticastDomainMixinProps",
    "CfnTransitGatewayMulticastDomainPropsMixin",
    "CfnTransitGatewayMulticastGroupMemberMixinProps",
    "CfnTransitGatewayMulticastGroupMemberPropsMixin",
    "CfnTransitGatewayMulticastGroupSourceMixinProps",
    "CfnTransitGatewayMulticastGroupSourcePropsMixin",
    "CfnTransitGatewayPeeringAttachmentMixinProps",
    "CfnTransitGatewayPeeringAttachmentPropsMixin",
    "CfnTransitGatewayPropsMixin",
    "CfnTransitGatewayRouteMixinProps",
    "CfnTransitGatewayRoutePropsMixin",
    "CfnTransitGatewayRouteTableAssociationMixinProps",
    "CfnTransitGatewayRouteTableAssociationPropsMixin",
    "CfnTransitGatewayRouteTableMixinProps",
    "CfnTransitGatewayRouteTablePropagationMixinProps",
    "CfnTransitGatewayRouteTablePropagationPropsMixin",
    "CfnTransitGatewayRouteTablePropsMixin",
    "CfnTransitGatewayVpcAttachmentMixinProps",
    "CfnTransitGatewayVpcAttachmentPropsMixin",
    "CfnVPCBlockPublicAccessExclusionMixinProps",
    "CfnVPCBlockPublicAccessExclusionPropsMixin",
    "CfnVPCBlockPublicAccessOptionsMixinProps",
    "CfnVPCBlockPublicAccessOptionsPropsMixin",
    "CfnVPCCidrBlockMixinProps",
    "CfnVPCCidrBlockPropsMixin",
    "CfnVPCDHCPOptionsAssociationMixinProps",
    "CfnVPCDHCPOptionsAssociationPropsMixin",
    "CfnVPCEncryptionControlMixinProps",
    "CfnVPCEncryptionControlPropsMixin",
    "CfnVPCEndpointConnectionNotificationMixinProps",
    "CfnVPCEndpointConnectionNotificationPropsMixin",
    "CfnVPCEndpointMixinProps",
    "CfnVPCEndpointPropsMixin",
    "CfnVPCEndpointServiceMixinProps",
    "CfnVPCEndpointServicePermissionsMixinProps",
    "CfnVPCEndpointServicePermissionsPropsMixin",
    "CfnVPCEndpointServicePropsMixin",
    "CfnVPCGatewayAttachmentMixinProps",
    "CfnVPCGatewayAttachmentPropsMixin",
    "CfnVPCLogsMixin",
    "CfnVPCMixinProps",
    "CfnVPCPeeringConnectionMixinProps",
    "CfnVPCPeeringConnectionPropsMixin",
    "CfnVPCPropsMixin",
    "CfnVPCRoute53ResolverQueryLogs",
    "CfnVPNConcentratorMixinProps",
    "CfnVPNConcentratorPropsMixin",
    "CfnVPNConnectionConnectionLogs",
    "CfnVPNConnectionEventLogs",
    "CfnVPNConnectionLogsMixin",
    "CfnVPNConnectionMixinProps",
    "CfnVPNConnectionPropsMixin",
    "CfnVPNConnectionRouteMixinProps",
    "CfnVPNConnectionRoutePropsMixin",
    "CfnVPNGatewayMixinProps",
    "CfnVPNGatewayPropsMixin",
    "CfnVPNGatewayRoutePropagationMixinProps",
    "CfnVPNGatewayRoutePropagationPropsMixin",
    "CfnVerifiedAccessEndpointMixinProps",
    "CfnVerifiedAccessEndpointPropsMixin",
    "CfnVerifiedAccessGroupMixinProps",
    "CfnVerifiedAccessGroupPropsMixin",
    "CfnVerifiedAccessInstanceLogsMixin",
    "CfnVerifiedAccessInstanceMixinProps",
    "CfnVerifiedAccessInstancePropsMixin",
    "CfnVerifiedAccessInstanceVerifiedAccessLogs",
    "CfnVerifiedAccessTrustProviderMixinProps",
    "CfnVerifiedAccessTrustProviderPropsMixin",
    "CfnVolumeAttachmentMixinProps",
    "CfnVolumeAttachmentPropsMixin",
    "CfnVolumeMixinProps",
    "CfnVolumePropsMixin",
]

publication.publish()

def _typecheckingstub__cb9428cd38efead942b6c73c8728a06f2a7512171c4eba67cb608c413fa1d734(
    *,
    output_format: typing.Optional[builtins.str] = None,
    s3_bucket_name: typing.Optional[builtins.str] = None,
    s3_bucket_prefix: typing.Optional[builtins.str] = None,
    schedule: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c47485cda4d9350b4895b86984f81dbf78a8afba86714b2fe381f5d20d69e44f(
    props: typing.Union[CfnCapacityManagerDataExportMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ace914deb2d176085468b292e65af5010728491ed79f134caba1f80a7e80c169(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__413d46007c5e1f6585631c2dcbc3b7c62e9e16249e43e47f4bd75cbe1dd9424d(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4267f13608148016d60f4cc03a1edac5d15ea9c20824066ff0ea16f7eb9be649(
    *,
    allocation_strategy: typing.Optional[builtins.str] = None,
    end_date: typing.Optional[builtins.str] = None,
    instance_match_criteria: typing.Optional[builtins.str] = None,
    instance_type_specifications: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnCapacityReservationFleetPropsMixin.InstanceTypeSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    no_remove_end_date: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    remove_end_date: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    tag_specifications: typing.Optional[typing.Sequence[typing.Union[CfnCapacityReservationFleetPropsMixin.TagSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    tenancy: typing.Optional[builtins.str] = None,
    total_target_capacity: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eb1ea5538acaee5bd733345aae21fc24d00a6bf27e5959f36d3246c9fd777d69(
    props: typing.Union[CfnCapacityReservationFleetMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__85d0faf66c66a6b5040c775038cd2ea758ecec4a80b1ca84619337a0edd91415(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__948f0599a9f723dddadb636bbad085a1f0d4efefc261fdc0c3b8a7edc261d2d2(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8c365b5e08a5052ee666da92cd3212fae896d8c6ca1b939f46286967afad626c(
    *,
    availability_zone: typing.Optional[builtins.str] = None,
    availability_zone_id: typing.Optional[builtins.str] = None,
    ebs_optimized: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    instance_platform: typing.Optional[builtins.str] = None,
    instance_type: typing.Optional[builtins.str] = None,
    priority: typing.Optional[jsii.Number] = None,
    weight: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bb36bac7a98fe9455333ccc52e0259303f483b04dd668b064e130ce9d61a2ec6(
    *,
    resource_type: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c14409d6f07ae8fd53e2088206631a7147684cffae15cd3c12f30e577a21a738(
    *,
    availability_zone: typing.Optional[builtins.str] = None,
    availability_zone_id: typing.Optional[builtins.str] = None,
    ebs_optimized: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    end_date: typing.Optional[builtins.str] = None,
    end_date_type: typing.Optional[builtins.str] = None,
    ephemeral_storage: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    instance_count: typing.Optional[jsii.Number] = None,
    instance_match_criteria: typing.Optional[builtins.str] = None,
    instance_platform: typing.Optional[builtins.str] = None,
    instance_type: typing.Optional[builtins.str] = None,
    out_post_arn: typing.Optional[builtins.str] = None,
    placement_group_arn: typing.Optional[builtins.str] = None,
    tag_specifications: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnCapacityReservationPropsMixin.TagSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    tenancy: typing.Optional[builtins.str] = None,
    unused_reservation_billing_owner_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__12085d72c1c23e0db75116f97d1bb46f9cb70b3a042db7587345cfe66eed5596(
    props: typing.Union[CfnCapacityReservationMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__92005209ebc2470e8042c90da0e83b59acce46a5716df008c0202583720869de(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1fe0dc6876ca4af33b52097b63b29606611daf58358b74f2c82268a18811409b(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__99ffa74931853cb6aa8ba127c435f44a3bdc7ee0fb48a6f9d0688b4c6156b123(
    *,
    allocation_type: typing.Optional[builtins.str] = None,
    count: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ffcdb15aefbc9de358a5ed691aea25b91d21a45704532e04dd7d028886f644a1(
    *,
    commitment_end_date: typing.Optional[builtins.str] = None,
    committed_instance_count: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__68615a49147a5f741deef9593164692843e2831fad36f56e4b91ccc872d2dd26(
    *,
    resource_type: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b75d8d831b2a1bafe4ce5a6792759efb0c8c9b002526f5c20dbc1b5d70ceb083(
    *,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    vpc_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b4db07a5e08b8fd1e21101be5f20d49b5614cc938ce1e2507e569b678c72fdde(
    props: typing.Union[CfnCarrierGatewayMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d001f36d0cefe6a908568eb819ef0ba06db68582ea879d541c7fb0c0aecc38cb(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cea6fffe5117f573c19cefacc7bbcda644d377cf49d4a363b869241501cea45f(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3ec649f17e001bab7d0bb3610c3849f7811459d1e3e6ac476c3460724de2bd6f(
    *,
    access_group_id: typing.Optional[builtins.str] = None,
    authorize_all_groups: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    client_vpn_endpoint_id: typing.Optional[builtins.str] = None,
    description: typing.Optional[builtins.str] = None,
    target_network_cidr: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__27a5846cfcacaa5f7648545f5b88c5bef186ca01edacdee14bae10ab5674322c(
    props: typing.Union[CfnClientVpnAuthorizationRuleMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f93bb1d1dcc37260a4ce8fcdadeafeaf83750714799ed6f08534cf0358a6be6e(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__edb0eb5db04efe81c1838e21bccee2734766b6930aaefed2188d4981116abf62(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ca3d88a9a0a35db755b106702b6a5fdad6d638967bac5e9dbfdaf1def3b1959c(
    *,
    authentication_options: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnClientVpnEndpointPropsMixin.ClientAuthenticationRequestProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    client_cidr_block: typing.Optional[builtins.str] = None,
    client_connect_options: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnClientVpnEndpointPropsMixin.ClientConnectOptionsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    client_login_banner_options: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnClientVpnEndpointPropsMixin.ClientLoginBannerOptionsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    client_route_enforcement_options: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnClientVpnEndpointPropsMixin.ClientRouteEnforcementOptionsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    connection_log_options: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnClientVpnEndpointPropsMixin.ConnectionLogOptionsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    description: typing.Optional[builtins.str] = None,
    disconnect_on_session_timeout: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    dns_servers: typing.Optional[typing.Sequence[builtins.str]] = None,
    endpoint_ip_address_type: typing.Optional[builtins.str] = None,
    security_group_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    self_service_portal: typing.Optional[builtins.str] = None,
    server_certificate_arn: typing.Optional[builtins.str] = None,
    session_timeout_hours: typing.Optional[jsii.Number] = None,
    split_tunnel: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    tag_specifications: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnClientVpnEndpointPropsMixin.TagSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    traffic_ip_address_type: typing.Optional[builtins.str] = None,
    transport_protocol: typing.Optional[builtins.str] = None,
    vpc_id: typing.Optional[builtins.str] = None,
    vpn_port: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__37ce4ab8625879fce12cbc125fc6e3fa18fdcb88a43281c3fa179173cbd7a7da(
    props: typing.Union[CfnClientVpnEndpointMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1a70605cb8bdf5ac0460e106a19d1d66ea7f06cae58a73c59f8907eabd16c5b1(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__92cd0b05373c52b71927efcf04fc64f975338a2850bfe56c56a8470f283e6d6a(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d520cfd5ed167ff4c5107bb396a564decebcf2a781a352f2d7a1ed27944854d7(
    *,
    client_root_certificate_chain_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e0370f0d85d6a1fd1c7f88a7f9c44241ce1e3518d04cd8e26db389ce0a1dae0b(
    *,
    active_directory: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnClientVpnEndpointPropsMixin.DirectoryServiceAuthenticationRequestProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    federated_authentication: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnClientVpnEndpointPropsMixin.FederatedAuthenticationRequestProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    mutual_authentication: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnClientVpnEndpointPropsMixin.CertificateAuthenticationRequestProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__99f1868876ae828e5c7582fa50577396204153ec4ce41c19f8ab9d11de254ab1(
    *,
    enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    lambda_function_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4d14612524e7d9922e4288c8e9192513b0ea4b78e23743f1bd9496b2452de2d2(
    *,
    banner_text: typing.Optional[builtins.str] = None,
    enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f09a2a48682d3a7e5b9e9ac1b5d67964e1a25da769ee6e8c05cecd4ff8d08a14(
    *,
    enforced: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e5b61b7536eaf574f22502fb413043a4380aab58e67cf426cdfaa474b3e8e604(
    *,
    cloudwatch_log_group: typing.Optional[builtins.str] = None,
    cloudwatch_log_stream: typing.Optional[builtins.str] = None,
    enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__440ed12d26871abeeb7a8eeb3eac1f7ca6bc1f28c50f22b36e227e1f7b4ba7bd(
    *,
    directory_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a3a260415294a9eb202d056946081d95f5f3e7bda69d013b4655fa213b75c6c2(
    *,
    saml_provider_arn: typing.Optional[builtins.str] = None,
    self_service_saml_provider_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5b9a0676460c8f9b10d514869c961d91cce9cd0cb7967e299c018706ca9c2c44(
    *,
    resource_type: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__27b7fdac4d9ad4979d05165c65c29f7e365bf171ba919e4ffcb8c962807f82cb(
    *,
    client_vpn_endpoint_id: typing.Optional[builtins.str] = None,
    description: typing.Optional[builtins.str] = None,
    destination_cidr_block: typing.Optional[builtins.str] = None,
    target_vpc_subnet_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b7f4e2ff941bc083820e4f1be4dc5f22dfc13389bb6475e570ebbcb05ff6ae43(
    props: typing.Union[CfnClientVpnRouteMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c01cb807916550c476361405be6ec7e8a4219c0736145b91c050af95f3884584(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bdb5d8472d1422cab13f8b2fe7ecdc3aa9d84a5731c08b866562750d5fecfa7d(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fc48cdb59418350b2e1c0b19ff5d850f70004279adfa44d745fd9f19a8d0b05b(
    *,
    client_vpn_endpoint_id: typing.Optional[builtins.str] = None,
    subnet_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f5ee9caf9d0d66d98d6604b6f1c61ea4f49bfdb34856a603ed4e638b0179167f(
    props: typing.Union[CfnClientVpnTargetNetworkAssociationMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cf67c6ebb706aefb40fceba9afd038a462f163d63a3676a02d780a99dd9a33ea(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7f109488fe397938197f1f86d0e602b5874753d15bd9e9174da315eed84993cb(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8a2e95085bf0186789d5a669e4aafbfccb76b81df7555fa4a6105a90c4a177bb(
    *,
    bgp_asn: typing.Optional[jsii.Number] = None,
    bgp_asn_extended: typing.Optional[jsii.Number] = None,
    certificate_arn: typing.Optional[builtins.str] = None,
    device_name: typing.Optional[builtins.str] = None,
    ip_address: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5d34645a188b514496b583b1124d1bd38209128df1697f55ff5bb6b5ab791c6c(
    props: typing.Union[CfnCustomerGatewayMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dd3a73060d433be76a89d7b8832c7bbc055a26eed8b1dda9e6abd7b6686cb548(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3eaccf33ebad31c4b13616f48f12a22de01b3adc6afc01764060a919e9e9fb51(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__799fad1100366695f0ac1c8833a574ffe01aa6bcb7304b73926899a84bf9fa2b(
    *,
    domain_name: typing.Optional[builtins.str] = None,
    domain_name_servers: typing.Optional[typing.Sequence[builtins.str]] = None,
    ipv6_address_preferred_lease_time: typing.Optional[jsii.Number] = None,
    netbios_name_servers: typing.Optional[typing.Sequence[builtins.str]] = None,
    netbios_node_type: typing.Optional[jsii.Number] = None,
    ntp_servers: typing.Optional[typing.Sequence[builtins.str]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0d479c7abddf1a54a1dce44652673f5ce118cdbb7e931410766923dea112b457(
    props: typing.Union[CfnDHCPOptionsMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ef32be983feb9e5248c51a0a61e65dcaa877b0106e2c53a83f98b28a1e7beaa2(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__882967bec9f0d4da3ffb3cd532a9dc9fb1e2c8f1dcb68c77bb659d7943853529(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4fa11ea760cb56b087bfc05ec40127de0799fc3f623aa1ad453fad507443bf8f(
    *,
    context: typing.Optional[builtins.str] = None,
    excess_capacity_termination_policy: typing.Optional[builtins.str] = None,
    launch_template_configs: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnEC2FleetPropsMixin.FleetLaunchTemplateConfigRequestProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    on_demand_options: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnEC2FleetPropsMixin.OnDemandOptionsRequestProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    replace_unhealthy_instances: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    spot_options: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnEC2FleetPropsMixin.SpotOptionsRequestProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    tag_specifications: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnEC2FleetPropsMixin.TagSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    target_capacity_specification: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnEC2FleetPropsMixin.TargetCapacitySpecificationRequestProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    terminate_instances_with_expiration: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    type: typing.Optional[builtins.str] = None,
    valid_from: typing.Optional[builtins.str] = None,
    valid_until: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0a0ade40dd8375fa37b4226524a397ab1e9114fb72e7737155dd78a5b76e75bc(
    props: typing.Union[CfnEC2FleetMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5bfe67ab3699fc3f4c738ad48abe6388d54243f98492d69f4c93c7c3618189b6(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6ba37d3a19b49ccecd0f4db3ea26c1da03393cce53dd9e04ccf26eb102e2bfdf(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cfec8755e0a8853197672fda7e7aeee5b7cb713427780e884e7907ef384db5c4(
    *,
    max: typing.Optional[jsii.Number] = None,
    min: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dcba1647314dce68af996609fa426ff261a7978f1d4e868f14ee6c53f4a2bf15(
    *,
    max: typing.Optional[jsii.Number] = None,
    min: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b874a0c58e0ab53171020a26fffc614eb0c506a9876948d1decf218cb338aff9(
    *,
    max: typing.Optional[jsii.Number] = None,
    min: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a4df1876735bf0fe3c6cc2993137ee84f2df8761e5e36a6a72caf618ca23e147(
    *,
    cpu: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnEC2FleetPropsMixin.CpuPerformanceFactorRequestProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__53f20dcd475275e245a8e352d10b4134acc05d1ae953a0d94ba3ba13f86429fe(
    *,
    device_name: typing.Optional[builtins.str] = None,
    ebs: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnEC2FleetPropsMixin.EbsBlockDeviceProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    no_device: typing.Optional[builtins.str] = None,
    virtual_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__01e71c82d4b4a997b932b845ac413428604802ef5500fc521e3d7ed23e3759aa(
    *,
    replacement_strategy: typing.Optional[builtins.str] = None,
    termination_delay: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b4983a1d19e4a2078d9191504bc7e94ada1a5a53bd8e873380d4716683c2df12(
    *,
    usage_strategy: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ac34f70b114a4821e78e30f4c5d37930ed5122d709c6d576ee23c09380a9ea6c(
    *,
    references: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnEC2FleetPropsMixin.PerformanceFactorReferenceRequestProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__388deb8d8cce1233cbf8ec2981e1d6458148d81f0142257a2480a5867413ae8d(
    *,
    delete_on_termination: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    encrypted: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    iops: typing.Optional[jsii.Number] = None,
    kms_key_id: typing.Optional[builtins.str] = None,
    snapshot_id: typing.Optional[builtins.str] = None,
    volume_size: typing.Optional[jsii.Number] = None,
    volume_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dd6edd78c182d5ba8d931f4764b3876c56b2fca323b8e198b814db85587c1304(
    *,
    launch_template_specification: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnEC2FleetPropsMixin.FleetLaunchTemplateSpecificationRequestProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    overrides: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnEC2FleetPropsMixin.FleetLaunchTemplateOverridesRequestProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7e74815cc8aea50de1461d2341e9c78df1cc47803ee7eb255fb1ea541fbc0fd7(
    *,
    availability_zone: typing.Optional[builtins.str] = None,
    availability_zone_id: typing.Optional[builtins.str] = None,
    block_device_mappings: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnEC2FleetPropsMixin.BlockDeviceMappingProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    instance_requirements: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnEC2FleetPropsMixin.InstanceRequirementsRequestProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    instance_type: typing.Optional[builtins.str] = None,
    max_price: typing.Optional[builtins.str] = None,
    placement: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnEC2FleetPropsMixin.PlacementProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    priority: typing.Optional[jsii.Number] = None,
    subnet_id: typing.Optional[builtins.str] = None,
    weighted_capacity: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a82fbbd23ee3ac25d49eaf556d29da470ec6f00ccf3a92e64afe0accc8e0a9cb(
    *,
    launch_template_id: typing.Optional[builtins.str] = None,
    launch_template_name: typing.Optional[builtins.str] = None,
    version: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b9effd05486d429b9da8f8da7ffaa9bf0b229d9201b671cfcc6d6319a746879d(
    *,
    accelerator_count: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnEC2FleetPropsMixin.AcceleratorCountRequestProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    accelerator_manufacturers: typing.Optional[typing.Sequence[builtins.str]] = None,
    accelerator_names: typing.Optional[typing.Sequence[builtins.str]] = None,
    accelerator_total_memory_mib: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnEC2FleetPropsMixin.AcceleratorTotalMemoryMiBRequestProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    accelerator_types: typing.Optional[typing.Sequence[builtins.str]] = None,
    allowed_instance_types: typing.Optional[typing.Sequence[builtins.str]] = None,
    bare_metal: typing.Optional[builtins.str] = None,
    baseline_ebs_bandwidth_mbps: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnEC2FleetPropsMixin.BaselineEbsBandwidthMbpsRequestProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    baseline_performance_factors: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnEC2FleetPropsMixin.BaselinePerformanceFactorsRequestProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    burstable_performance: typing.Optional[builtins.str] = None,
    cpu_manufacturers: typing.Optional[typing.Sequence[builtins.str]] = None,
    excluded_instance_types: typing.Optional[typing.Sequence[builtins.str]] = None,
    instance_generations: typing.Optional[typing.Sequence[builtins.str]] = None,
    local_storage: typing.Optional[builtins.str] = None,
    local_storage_types: typing.Optional[typing.Sequence[builtins.str]] = None,
    max_spot_price_as_percentage_of_optimal_on_demand_price: typing.Optional[jsii.Number] = None,
    memory_gib_per_v_cpu: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnEC2FleetPropsMixin.MemoryGiBPerVCpuRequestProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    memory_mib: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnEC2FleetPropsMixin.MemoryMiBRequestProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    network_bandwidth_gbps: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnEC2FleetPropsMixin.NetworkBandwidthGbpsRequestProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    network_interface_count: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnEC2FleetPropsMixin.NetworkInterfaceCountRequestProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    on_demand_max_price_percentage_over_lowest_price: typing.Optional[jsii.Number] = None,
    require_encryption_in_transit: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    require_hibernate_support: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    spot_max_price_percentage_over_lowest_price: typing.Optional[jsii.Number] = None,
    total_local_storage_gb: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnEC2FleetPropsMixin.TotalLocalStorageGBRequestProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    v_cpu_count: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnEC2FleetPropsMixin.VCpuCountRangeRequestProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__805379d61902900b02b5c2d0666783c20b83674bf5f317d67c0e008bb6df1ea1(
    *,
    capacity_rebalance: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnEC2FleetPropsMixin.CapacityRebalanceProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8ed74afd75bee0f596d8af3510d69d28456a90ef309b7bb4a4a241b1af6c0b63(
    *,
    max: typing.Optional[jsii.Number] = None,
    min: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3b874376ac9fa043f15d858e6ee829b9dfb2afab9f404b26659517d41d2f2907(
    *,
    max: typing.Optional[jsii.Number] = None,
    min: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5bdf53d88616dbede6d1ca141faf743b623b658b71543c2542b823c1dbaae16a(
    *,
    max: typing.Optional[jsii.Number] = None,
    min: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fe339aa933ed5af10bcef3ac04afe48d018b77f9f5e10e6506483babd36030de(
    *,
    max: typing.Optional[jsii.Number] = None,
    min: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__571dfa5900fdfad08d914819390c179e4ee1593849ab4425721658aa1b538b71(
    *,
    allocation_strategy: typing.Optional[builtins.str] = None,
    capacity_reservation_options: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnEC2FleetPropsMixin.CapacityReservationOptionsRequestProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    max_total_price: typing.Optional[builtins.str] = None,
    min_target_capacity: typing.Optional[jsii.Number] = None,
    single_availability_zone: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    single_instance_type: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bcedb1280014d05a3aa4be64f1e9fca8a6ac46ecf146aed642e6818f6ecc69d7(
    *,
    instance_family: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f6977c793ee2a964db400526ee24bd97e47272bee1a25b1df60ae7e447978db5(
    *,
    affinity: typing.Optional[builtins.str] = None,
    availability_zone: typing.Optional[builtins.str] = None,
    group_name: typing.Optional[builtins.str] = None,
    host_id: typing.Optional[builtins.str] = None,
    host_resource_group_arn: typing.Optional[builtins.str] = None,
    partition_number: typing.Optional[jsii.Number] = None,
    spread_domain: typing.Optional[builtins.str] = None,
    tenancy: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3c6b2df71255bf48ab1c14a395b17e27504d9951e17b7f1a4e11b258b5820a2a(
    *,
    allocation_strategy: typing.Optional[builtins.str] = None,
    instance_interruption_behavior: typing.Optional[builtins.str] = None,
    instance_pools_to_use_count: typing.Optional[jsii.Number] = None,
    maintenance_strategies: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnEC2FleetPropsMixin.MaintenanceStrategiesProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    max_total_price: typing.Optional[builtins.str] = None,
    min_target_capacity: typing.Optional[jsii.Number] = None,
    single_availability_zone: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    single_instance_type: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0d1313bc805ea3d571eecff01f484d33857f91316f4ca3393781c20fa63e20eb(
    *,
    resource_type: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a89ddaeb76525805a280e3a769f5b4aaaad797551f31f57265001a2ad94a07d4(
    *,
    default_target_capacity_type: typing.Optional[builtins.str] = None,
    on_demand_target_capacity: typing.Optional[jsii.Number] = None,
    spot_target_capacity: typing.Optional[jsii.Number] = None,
    target_capacity_unit_type: typing.Optional[builtins.str] = None,
    total_target_capacity: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c2d5aa9bc115dfae49e05201b78d29a9edad7a8e5c3359ffdf29c098f343f2a0(
    *,
    max: typing.Optional[jsii.Number] = None,
    min: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3ab7ac48ded16bf8f6123977a0a0ab9b350c145e5e2c4dc1aa8e00cf511f258f(
    *,
    max: typing.Optional[jsii.Number] = None,
    min: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6aaafba9cc377c70b61c7624e9ce04d1d4a9be19d0c47893d796db52f20bfb38(
    *,
    allocation_id: typing.Optional[builtins.str] = None,
    eip: typing.Optional[builtins.str] = None,
    instance_id: typing.Optional[builtins.str] = None,
    network_interface_id: typing.Optional[builtins.str] = None,
    private_ip_address: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5f75a125fed46cf19f0aecae05c651563140f330ed414d206462b1909a1fd616(
    props: typing.Union[CfnEIPAssociationMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__82d5d7b37fe86c1420a8e083ddceed0fd81e4299f7b9695cbcfffc4b987a9afb(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1c41b29e46fd82d97e3559b86479520e7161b068873e4f814987dec3bab5a8c9(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7b4321961ee9578d9fcd8cc8e89efb811afa69d80f452514f7f10d5fd4236ae7(
    *,
    address: typing.Optional[builtins.str] = None,
    domain: typing.Optional[builtins.str] = None,
    instance_id: typing.Optional[builtins.str] = None,
    ipam_pool_id: typing.Optional[builtins.str] = None,
    network_border_group: typing.Optional[builtins.str] = None,
    public_ipv4_pool: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    transfer_address: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__af6d10912a62e85163c2029b7478781f0881b73183c96170ca49f3da535e1d65(
    props: typing.Union[CfnEIPMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bf097a02687c5e5b23fc0ec3c06229b35eabc5cad3a79a146a3ceb93b251d5db(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e46afd6f46be79c7f8623a1c4dfbd6160cf8d24cefa1db52cf2e834669539468(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__292636e4119269553ac36bb94a807f4f88b73017215231098112f6090bf4c473(
    *,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    vpc_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9d3725848eba9124e67c376045cf5cd5583f74845d93546c56182fda7c3357ea(
    props: typing.Union[CfnEgressOnlyInternetGatewayMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__40ccbf3a44dd3ffc513cfa80b78c38c2e66352e3436f894229f81f8e96b6720f(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3ac90168fa2fa28ec3908c87306fcb90a5c81c2fdb21985215c517e455ffa02f(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b92b07067d721a2538c6383c1e5eb88aa2635fe3cd054afd2fa554fd8e00f800(
    *,
    certificate_arn: typing.Optional[builtins.str] = None,
    role_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__24ab8e9600cf8f37c54cc94518c30839628a371d5f2d2d4550fad5c8e95b2a90(
    props: typing.Union[CfnEnclaveCertificateIamRoleAssociationMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0bf396ae33f121a716ef2a611788ec55ae58b32b3ce8455a4b0f6116275894cb(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8d5eb2a80ea377b5b345e7516fe074e211f75cc5fdc84be8143e25160db3e8d0(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__19a0e8f9fc3bbe335f1c91f25b15df9b9486c2187eee8982b8d5034f63b1e849(
    *,
    deliver_cross_account_role: typing.Optional[builtins.str] = None,
    deliver_logs_permission_arn: typing.Optional[builtins.str] = None,
    destination_options: typing.Any = None,
    log_destination: typing.Optional[builtins.str] = None,
    log_destination_type: typing.Optional[builtins.str] = None,
    log_format: typing.Optional[builtins.str] = None,
    log_group_name: typing.Optional[builtins.str] = None,
    max_aggregation_interval: typing.Optional[jsii.Number] = None,
    resource_id: typing.Optional[builtins.str] = None,
    resource_type: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    traffic_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__954aa64ec8678d4fdee8a4744ad57b053d643c30c46d1fafa60ae0abf833c25f(
    props: typing.Union[CfnFlowLogMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f7a046758cd8eb35b7ed603cf01eb4fb3d7da5e58e6e868af70cd2f34b4d6bc9(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4e4ae0278237c20623c958dce2d6766adeec2d0cdcbc256f5239b78d108ce63f(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2bf0e0af524063edee90f30df57ebece61733883704939869fcc767ef735e66d(
    *,
    file_format: typing.Optional[builtins.str] = None,
    hive_compatible_partitions: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    per_hour_partition: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c9c4f0724fc9828f3c4ab579ad4a8dfe82600528a5824faeaa60f4962b8bed05(
    *,
    gateway_id: typing.Optional[builtins.str] = None,
    route_table_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bc34f333cac962e0adcdbb652d3a5119c2c47b4b4ce7ea19f0e8edf03b57081b(
    props: typing.Union[CfnGatewayRouteTableAssociationMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5dd6819168a34e66476bfac4bfeeee3cff9cf87c3a78f0b7cbe65741729a13e6(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e1180a86e05a0a14178bcdfbce14d941c1631a58af9006661c0127fbead6a076(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6dd0932246e90c83404013360eca298e680ac68b38e504feb536117c7934dd1a(
    *,
    asset_id: typing.Optional[builtins.str] = None,
    auto_placement: typing.Optional[builtins.str] = None,
    availability_zone: typing.Optional[builtins.str] = None,
    host_maintenance: typing.Optional[builtins.str] = None,
    host_recovery: typing.Optional[builtins.str] = None,
    instance_family: typing.Optional[builtins.str] = None,
    instance_type: typing.Optional[builtins.str] = None,
    outpost_arn: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eef94dd5ba073e13621755e3b764cbf685a90f5121c106ed9aec22f7a8044c7a(
    props: typing.Union[CfnHostMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3cf7b725c441a77fecad51fb9db240cde475a8be246373b73007dd441b82eb54(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9fe27a480fd4dc86940f607a4bfcde05f39e72bae982da1408771b9482710f24(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__06b90d2128171e00fbc5aa2aa100382cf0322f625b67817d50d0089a60b0123b(
    *,
    cidr: typing.Optional[builtins.str] = None,
    description: typing.Optional[builtins.str] = None,
    ipam_pool_id: typing.Optional[builtins.str] = None,
    netmask_length: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c627c0c057c8d4e1f2df9f8c82dfdcf82d5f59b77fae7cd132215a5048a34230(
    props: typing.Union[CfnIPAMAllocationMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1fe40de42037cb7fc208ee103de323bf1290c67b2989a68c8e08593980e0d8ee(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__10c9d8d418bc7e50153941602620f0cc1d5a931f01b10050def4b580dfbc92a2(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__01f41952a31d241e80e2da300b963f27cc44b1c148b0357535722dc8425ab309(
    *,
    default_resource_discovery_organizational_unit_exclusions: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnIPAMPropsMixin.IpamOrganizationalUnitExclusionProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    description: typing.Optional[builtins.str] = None,
    enable_private_gua: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    metered_account: typing.Optional[builtins.str] = None,
    operating_regions: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnIPAMPropsMixin.IpamOperatingRegionProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    tier: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a3d75353eb74e3467a06ce861c6edab9443bf9e380df5cacd86274ab75af3c79(
    *,
    cidr: typing.Optional[builtins.str] = None,
    ipam_pool_id: typing.Optional[builtins.str] = None,
    netmask_length: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ea7e46fe1bf56a809cdf03767aec34e73ed2c3c413935d343e17bb75d91b3abd(
    props: typing.Union[CfnIPAMPoolCidrMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0c558b53a94c9f2dbccc3d49f68c46a89cc0cc1765245a69eec588019d752f8d(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__00f2de57870b786d4c90cccf153c79b2d7bd156d78ff675217314d6669b13fed(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9e263e5544d1c034065230b57a7f4cf03dfc7b1a98bc5b553a3316752e3f0766(
    *,
    address_family: typing.Optional[builtins.str] = None,
    allocation_default_netmask_length: typing.Optional[jsii.Number] = None,
    allocation_max_netmask_length: typing.Optional[jsii.Number] = None,
    allocation_min_netmask_length: typing.Optional[jsii.Number] = None,
    allocation_resource_tags: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    auto_import: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    aws_service: typing.Optional[builtins.str] = None,
    description: typing.Optional[builtins.str] = None,
    ipam_scope_id: typing.Optional[builtins.str] = None,
    locale: typing.Optional[builtins.str] = None,
    provisioned_cidrs: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnIPAMPoolPropsMixin.ProvisionedCidrProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    public_ip_source: typing.Optional[builtins.str] = None,
    publicly_advertisable: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    source_ipam_pool_id: typing.Optional[builtins.str] = None,
    source_resource: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnIPAMPoolPropsMixin.SourceResourceProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9a60d83b2a0abbc445b28f509ff9391299a25e2454349c3a7c1ba17e09556e15(
    props: typing.Union[CfnIPAMPoolMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__81c0c7187436481d0c65def2ab021a9fd90991050bf8b88874491b0ec2134cf5(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8c98ac5405393fc2bb6fc1463949ecc0ceb28a5df592f074fa09ddeb15be0e4e(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e240d6cdece1d4e05e7eb46970366adbc3b7433442ffe40c1b1ef176b4918f4e(
    *,
    cidr: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__864d9b72493c06c44b25b1a685ccafdf38e8b5eaf7887b11213493297b3828a0(
    *,
    resource_id: typing.Optional[builtins.str] = None,
    resource_owner: typing.Optional[builtins.str] = None,
    resource_region: typing.Optional[builtins.str] = None,
    resource_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2b7afb3d05d69ded687470d5229e9207613fd938157bb6da1af6c2f74295d544(
    props: typing.Union[CfnIPAMMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f13b261afddb081431a60f0cb3f373cc584e65b6b5801c29b1b3d9e7a0c5125d(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__60d56153df6fbcf9fb4131bfb8513f5eaee9128aca0359ef2ded8e1da388b23a(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__42b2e8711e052d5c0a2d64efbc9ee16c373c5be79085b52e220da0709df0609f(
    *,
    region_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__556159646e2d57ee0c8eb5f8118b3b90df7ad7722b3a79433887a31ceb5f868b(
    *,
    organizations_entity_path: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__492ae81ed0fe1741e1b9dc0928403c5ec6d8a34f7674b6c8ba69cfbd2f189080(
    *,
    ipam_id: typing.Optional[builtins.str] = None,
    ipam_resource_discovery_id: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__867b01f83f2dce2d85dcc75d4b551f76ec42f54dd229443466f1f562e4912a21(
    props: typing.Union[CfnIPAMResourceDiscoveryAssociationMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a362c4c2c31935fee732309e58db71da9a1127a41e39a1f50d0b3a34de25d6d2(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8998f8c4a4c8086ab821e67278b80cd688d9815ca5e9b5c71bd78e699af1d905(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8913d840aefc1f2eeb5527b498859b38f8f6bee0eb75635f21fe7ee7a71cf71d(
    *,
    description: typing.Optional[builtins.str] = None,
    operating_regions: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnIPAMResourceDiscoveryPropsMixin.IpamOperatingRegionProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    organizational_unit_exclusions: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnIPAMResourceDiscoveryPropsMixin.IpamResourceDiscoveryOrganizationalUnitExclusionProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3cb8ef35301df0baae72d784a27f8800a678ccc8fef4fe053ef3d5467b620680(
    props: typing.Union[CfnIPAMResourceDiscoveryMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__541b2dcae956ea75d8893bf8c4c195b233e4e5dd3c1dd411892b168b03f88ffa(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3ed3bbe0e8ab697a88406144c1113306ac9a8c8beadd46e02e7eaeb89c91b995(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8da3d335f1e813588c4de562b86720e1516b0248a2cd7bed9e33df292f0ce89b(
    *,
    region_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e938f9049fae6c7767364568d31d7b8be924004e957e7f7de022556e7cae4ac2(
    *,
    organizations_entity_path: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8178db85ece707e4c126ecb9e1e675b4db7ae2108584b6ea23e06352c70d60d6(
    *,
    description: typing.Optional[builtins.str] = None,
    external_authority_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnIPAMScopePropsMixin.IpamScopeExternalAuthorityConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    ipam_id: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__63f54f98c00c7d0c0fc1776f7279099ba492dc5c67d9e79b988a51f9c0048436(
    props: typing.Union[CfnIPAMScopeMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6e62100f59ede4761b7773928085e75e7a80dd68acc421ce3ceac40a275bb9ec(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__480b82ed6ad2fd3f282034f4a6f122c69c52dfd2d4471d9e13462a9822aef363(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__314001993689940117cb4b021baaf1a82056262d8508916adf1b42274a88ca78(
    *,
    external_resource_identifier: typing.Optional[builtins.str] = None,
    ipam_scope_external_authority_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fc1001c39b6a4e34435bae1a0635d7fc2a6bc0142a5bc838d4c331e57df915ee(
    *,
    client_token: typing.Optional[builtins.str] = None,
    preserve_client_ip: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    security_group_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    subnet_id: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e43a6054f9133ba69da03a6e0044d745d56f467f6886f64858680c8038ca5357(
    props: typing.Union[CfnInstanceConnectEndpointMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b6c366bcf5a94a0f4a290184f6674e6d4ffa8400f139f10c424d46dc4a3f7f64(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f9780da515b5f07ae21fb56a4f0ef391b0142e76e66b44a4ee9baa5f9147cdcc(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1d226f35f2b7c4539dfaebf6f2f3099e717a2a51176d11fe7509fedd6c168acf(
    *,
    additional_info: typing.Optional[builtins.str] = None,
    affinity: typing.Optional[builtins.str] = None,
    availability_zone: typing.Optional[builtins.str] = None,
    block_device_mappings: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnInstancePropsMixin.BlockDeviceMappingProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    cpu_options: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnInstancePropsMixin.CpuOptionsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    credit_specification: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnInstancePropsMixin.CreditSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    disable_api_termination: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    ebs_optimized: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    elastic_gpu_specifications: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnInstancePropsMixin.ElasticGpuSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    elastic_inference_accelerators: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnInstancePropsMixin.ElasticInferenceAcceleratorProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    enclave_options: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnInstancePropsMixin.EnclaveOptionsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    hibernation_options: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnInstancePropsMixin.HibernationOptionsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    host_id: typing.Optional[builtins.str] = None,
    host_resource_group_arn: typing.Optional[builtins.str] = None,
    iam_instance_profile: typing.Optional[builtins.str] = None,
    image_id: typing.Optional[builtins.str] = None,
    instance_initiated_shutdown_behavior: typing.Optional[builtins.str] = None,
    instance_type: typing.Optional[builtins.str] = None,
    ipv6_address_count: typing.Optional[jsii.Number] = None,
    ipv6_addresses: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnInstancePropsMixin.InstanceIpv6AddressProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    kernel_id: typing.Optional[builtins.str] = None,
    key_name: typing.Optional[builtins.str] = None,
    launch_template: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnInstancePropsMixin.LaunchTemplateSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    license_specifications: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnInstancePropsMixin.LicenseSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    metadata_options: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnInstancePropsMixin.MetadataOptionsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    monitoring: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    network_interfaces: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnInstancePropsMixin.NetworkInterfaceProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    placement_group_name: typing.Optional[builtins.str] = None,
    private_dns_name_options: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnInstancePropsMixin.PrivateDnsNameOptionsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    private_ip_address: typing.Optional[builtins.str] = None,
    propagate_tags_to_volume_on_creation: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    ramdisk_id: typing.Optional[builtins.str] = None,
    security_group_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    security_groups: typing.Optional[typing.Sequence[builtins.str]] = None,
    source_dest_check: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    ssm_associations: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnInstancePropsMixin.SsmAssociationProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    subnet_id: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    tenancy: typing.Optional[builtins.str] = None,
    user_data: typing.Optional[builtins.str] = None,
    volumes: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnInstancePropsMixin.VolumeProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ccd6a03d6e58b786df704b81ccbc5069d73a5967a53979c83ab3da3762423a99(
    props: typing.Union[CfnInstanceMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1543feb92dc3b58fff0ac4c9c261a346ac0c6f966ba2839bfcdcea8b6e1991f3(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__71e330001e7618b0cd10b69bb31944ea2ce130c8ece062bf2a8030dc1ef73ea0(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__337d93eeb93f34076aa933341fd3f4280b377e2a2d711469d211554b4dc62505(
    *,
    key: typing.Optional[builtins.str] = None,
    value: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8a1b1bcc682cbf98735a58395825d806f544d8921f586377b3ec680d1215af7e(
    *,
    device_name: typing.Optional[builtins.str] = None,
    ebs: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnInstancePropsMixin.EbsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    no_device: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnInstancePropsMixin.NoDeviceProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    virtual_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aa7e40fd6c5b55a4c86b287de9df0b0ae3f1e5fdce8679cf5fe1d5d8463b7bb3(
    *,
    core_count: typing.Optional[jsii.Number] = None,
    threads_per_core: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4ca1bcb5f39d7df26147dcdcee273756762fd890b789b9108af04dcf99ff8c60(
    *,
    cpu_credits: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fec51512cd7ea3aa3c4921cba32ae6ec0dcf42b1161ea73654714a37e9008268(
    *,
    delete_on_termination: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    encrypted: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    iops: typing.Optional[jsii.Number] = None,
    kms_key_id: typing.Optional[builtins.str] = None,
    snapshot_id: typing.Optional[builtins.str] = None,
    volume_size: typing.Optional[jsii.Number] = None,
    volume_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5030efb09121c8de356f9008376b22a2e1597bbf68f021e21791e21ded0750fe(
    *,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e815aa4a51d795bb85c88c54c6758f54a0293db404519aea3fd9295dd612bdca(
    *,
    count: typing.Optional[jsii.Number] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__838bd0a78651b05bb0f3fd35b80d6f5b5a48ffa1e17e83ab4b4fc4cc8d511bef(
    *,
    ena_srd_enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    ena_srd_udp_specification: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnInstancePropsMixin.EnaSrdUdpSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ec99fe7d3680efc105725767ffa4331a59e47a4b9f2f8c1467724074bfa01319(
    *,
    ena_srd_udp_enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ad132a665ba2b7ec4ebbf890f56add2bd083d35e412230e3a01d6aca2f277708(
    *,
    enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__40ed17182fc149cd22251d65e605c35a0e690a71ba99d34d7b4b79924ab1c2a3(
    *,
    configured: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4a1a54cbe0962b9362670d8e410176938339a63f3fbb56d7ca12707eac86b26b(
    *,
    ipv6_address: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__14575557fc86b61b07c92e3995e721dee5767885314771e9c214471d1307af3a(
    *,
    launch_template_id: typing.Optional[builtins.str] = None,
    launch_template_name: typing.Optional[builtins.str] = None,
    version: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__753dc090b54fa4e40f47c6d64e1866f790be3b00f09adc0d49f5788db952a052(
    *,
    license_configuration_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__636b55fb2c25df671b20d48b136b9d31c75074dc6b55cbc3f597060d32e28ae2(
    *,
    http_endpoint: typing.Optional[builtins.str] = None,
    http_protocol_ipv6: typing.Optional[builtins.str] = None,
    http_put_response_hop_limit: typing.Optional[jsii.Number] = None,
    http_tokens: typing.Optional[builtins.str] = None,
    instance_metadata_tags: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__752f7d14a986923339cf950611b025feabc674f8dd75f0e62fc75acf0631aea5(
    *,
    associate_carrier_ip_address: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    associate_public_ip_address: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    delete_on_termination: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    description: typing.Optional[builtins.str] = None,
    device_index: typing.Optional[builtins.str] = None,
    ena_srd_specification: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnInstancePropsMixin.EnaSrdSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    group_set: typing.Optional[typing.Sequence[builtins.str]] = None,
    ipv6_address_count: typing.Optional[jsii.Number] = None,
    ipv6_addresses: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnInstancePropsMixin.InstanceIpv6AddressProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    network_interface_id: typing.Optional[builtins.str] = None,
    private_ip_address: typing.Optional[builtins.str] = None,
    private_ip_addresses: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnInstancePropsMixin.PrivateIpAddressSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    secondary_private_ip_address_count: typing.Optional[jsii.Number] = None,
    subnet_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c963de002d1038e2a839e73de9ecaf1329e7793b399ce49a5c082daa09d18295(
    *,
    enable_resource_name_dns_aaaa_record: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    enable_resource_name_dns_a_record: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    hostname_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3950ffc687313fadddd795671e7dc59044e01cbbb4093f63761934294caf8fcc(
    *,
    primary: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    private_ip_address: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__230c4541f1a13df62bcf6a21332f91a2059b2e0d1e6f601ba61ed1900ac45378(
    *,
    association_parameters: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnInstancePropsMixin.AssociationParameterProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    document_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7eee5d3fb54208b57ca466d4f022582b9a31b4d66b3a38fa3317f308e1495945(
    *,
    code: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8a772932780cd0d2d231f5ea2e03d87078083905b254ff39c37eceeb79ce1d39(
    *,
    device: typing.Optional[builtins.str] = None,
    volume_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__47f9ff446e0773ea7c53167d151a4d36bb1cfdb19e08f49123cc45589bf243cc(
    *,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3611eefc37dee1499ae28e8ef336e08855039f77a6d154eec76fb9863a871030(
    props: typing.Union[CfnInternetGatewayMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__933a1291f4a4fb33d0effbc64a1adb042d1370970b4497c74419922d494a9ccd(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1e713ff4bd3369c3853144c15ca67ec92e2f4aa6c5b0b23fc85b7fe75e04af53(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7e1d262cf73d57822efef9c2bb8ccb6a5c02ddc50bfb1fbe0c5579cfdd9658e9(
    *,
    public_ipv4_pool: typing.Optional[builtins.str] = None,
    route_table_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5a3a6368152db411210d096a94f9866442b7f67b62e65e49ed57bfe4ce065920(
    props: typing.Union[CfnIpPoolRouteTableAssociationMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__08cc2716570dc103400f6b6a4be98eb8c5b77f42adae015ceff35006be0f3679(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d2c0c14826668618044ad571183705b73d633c7d3826741a2afac8927a19982f(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__44084727a7afd984ac91c9a5f2ad1398930af5930bf0601afc04fa100e0c4db9(
    *,
    key_format: typing.Optional[builtins.str] = None,
    key_name: typing.Optional[builtins.str] = None,
    key_type: typing.Optional[builtins.str] = None,
    public_key_material: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b1075277d980fa20a4e5e5e15e4ba5615d28932842c45691b4348dcb4f5af566(
    props: typing.Union[CfnKeyPairMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__358d345640a2ee47e0bcdb2510b1790c5b1293c97daa86ae1670a6cdcc5513c9(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__325448334e7b50ddf9ddf2a57c13e74d11ce7e528cca34de6ba84f7955d78320(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9d4e2ace3d1dda2cdb3eed9e998ebd7a384bf2841519b72ebd095f58ba69958c(
    *,
    launch_template_data: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.LaunchTemplateDataProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    launch_template_name: typing.Optional[builtins.str] = None,
    tag_specifications: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.LaunchTemplateTagSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    version_description: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5474e3e38d5f66f863bb62d766fb9883d5e434fa14f4a2b036ca02673d09e36a(
    props: typing.Union[CfnLaunchTemplateMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1086efa572fb90b1e8a5371fec8bd3173ce5362dcd14d33e7ffcd2d86697a101(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dffebb7c111a6e62f8933a3e3dcb2e99128dbf060170594752a76f24441af7fa(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a2fa1ae5527e42a0a47cd8ec4f4510dd1d1ad17901ebab4244df9b602b9716c0(
    *,
    max: typing.Optional[jsii.Number] = None,
    min: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b11c354bb962a95f0c98bed1b78237d9e7e1bf5109490a72e2278633468dc040(
    *,
    max: typing.Optional[jsii.Number] = None,
    min: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f4bfc277d85c54d67239ebe4480a8a6c4f389281ecbb1a8af17d291d8dbfcf78(
    *,
    max: typing.Optional[jsii.Number] = None,
    min: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__248e62961218a521f45cb7f596aa7c953f6df656044176ed63094b5f9f3515e0(
    *,
    cpu: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.CpuProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4db281a81e83e651fa6728ba6a9e2257e4e6fcb6334141386ea9d8661b98c3bb(
    *,
    device_name: typing.Optional[builtins.str] = None,
    ebs: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.EbsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    no_device: typing.Optional[builtins.str] = None,
    virtual_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__086f0dbd1a0663e9308eda116ef6793987b16b1663e1d8588514f2899e587961(
    *,
    capacity_reservation_preference: typing.Optional[builtins.str] = None,
    capacity_reservation_target: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.CapacityReservationTargetProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__99c4927757284b4736bcabf44b4921dd3757e798eec3910cca1a4386c5fd73e6(
    *,
    capacity_reservation_id: typing.Optional[builtins.str] = None,
    capacity_reservation_resource_group_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0b5a4cc80934fd891da9e61ebea8411b661ed3c45568387809edd2642ccdd31c(
    *,
    tcp_established_timeout: typing.Optional[jsii.Number] = None,
    udp_stream_timeout: typing.Optional[jsii.Number] = None,
    udp_timeout: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1422df4de4f0370d929b27048d9f11f8e58455b01ed74d47d3d6240a34e5325d(
    *,
    amd_sev_snp: typing.Optional[builtins.str] = None,
    core_count: typing.Optional[jsii.Number] = None,
    threads_per_core: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__32ec87664b7ed4f991a21ebd53c2dfebb89928e31bd4db317578ec239a3effeb(
    *,
    references: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.ReferenceProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f0b0de1ddacac42e341cbb52058aaf87b56beaa2df785c8504fde58be5f499dc(
    *,
    cpu_credits: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__978f1216898dc69ad436e7182f0b0d1b897197040b185e4de3531d0d2665dd31(
    *,
    delete_on_termination: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    encrypted: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    iops: typing.Optional[jsii.Number] = None,
    kms_key_id: typing.Optional[builtins.str] = None,
    snapshot_id: typing.Optional[builtins.str] = None,
    throughput: typing.Optional[jsii.Number] = None,
    volume_initialization_rate: typing.Optional[jsii.Number] = None,
    volume_size: typing.Optional[jsii.Number] = None,
    volume_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ca1939f1ff97145a3b958ea0c5a3f873834656f204b4ffab751afd0a1b5a7516(
    *,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__62998cc2f3e5769140ecc1f6d96bd837ff139d94b77afbd716290ac8ef57b772(
    *,
    ena_srd_enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    ena_srd_udp_specification: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.EnaSrdUdpSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8743066a9329d8d3a26808290853cf58c6f9367c0527830c9b01570b1c39d8dd(
    *,
    ena_srd_udp_enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__72ab36f592d546363b9798e76ab00c27a0f01fbfaf7b6a858003f1d8dc273d93(
    *,
    enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__01260a92e5722d9da3da46f90b610dbfa635e24540d4915cefbafa4862f67488(
    *,
    configured: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6a15f1670c4df4370505b15c7147c32614f5bcda2db67d077e00d1e01eb65ad4(
    *,
    arn: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8c1940850963348126c5dd1ae35626844c3a04026aa94a2a1b14df405cdbea86(
    *,
    market_type: typing.Optional[builtins.str] = None,
    spot_options: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.SpotOptionsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9a31aff9b7bdab15555051756b0cfdba6b03631e576909c57f154e9c8f03ba54(
    *,
    accelerator_count: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.AcceleratorCountProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    accelerator_manufacturers: typing.Optional[typing.Sequence[builtins.str]] = None,
    accelerator_names: typing.Optional[typing.Sequence[builtins.str]] = None,
    accelerator_total_memory_mib: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.AcceleratorTotalMemoryMiBProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    accelerator_types: typing.Optional[typing.Sequence[builtins.str]] = None,
    allowed_instance_types: typing.Optional[typing.Sequence[builtins.str]] = None,
    bare_metal: typing.Optional[builtins.str] = None,
    baseline_ebs_bandwidth_mbps: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.BaselineEbsBandwidthMbpsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    baseline_performance_factors: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.BaselinePerformanceFactorsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    burstable_performance: typing.Optional[builtins.str] = None,
    cpu_manufacturers: typing.Optional[typing.Sequence[builtins.str]] = None,
    excluded_instance_types: typing.Optional[typing.Sequence[builtins.str]] = None,
    instance_generations: typing.Optional[typing.Sequence[builtins.str]] = None,
    local_storage: typing.Optional[builtins.str] = None,
    local_storage_types: typing.Optional[typing.Sequence[builtins.str]] = None,
    max_spot_price_as_percentage_of_optimal_on_demand_price: typing.Optional[jsii.Number] = None,
    memory_gib_per_v_cpu: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.MemoryGiBPerVCpuProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    memory_mib: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.MemoryMiBProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    network_bandwidth_gbps: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.NetworkBandwidthGbpsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    network_interface_count: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.NetworkInterfaceCountProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    on_demand_max_price_percentage_over_lowest_price: typing.Optional[jsii.Number] = None,
    require_hibernate_support: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    spot_max_price_percentage_over_lowest_price: typing.Optional[jsii.Number] = None,
    total_local_storage_gb: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.TotalLocalStorageGBProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    v_cpu_count: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.VCpuCountProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2a69c0e8eb18fd44b77bb8e79c12bf0df266e0e8762c48058dfeb06ddf645ce8(
    *,
    ipv4_prefix: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__99e3fe4fcf40ea358b63611a484a7ec8412d694d24f87eaa14d5642a1a1af141(
    *,
    ipv6_address: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b555e85994591eec38fee9a6e524f83cf30102040ceedf5d8c854d7f2db10764(
    *,
    ipv6_prefix: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0bfc269af1eefdc1cdc9fb233a656e9e25b85b36db90447b3088bad27841bfcb(
    *,
    block_device_mappings: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.BlockDeviceMappingProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    capacity_reservation_specification: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.CapacityReservationSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    cpu_options: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.CpuOptionsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    credit_specification: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.CreditSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    disable_api_stop: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    disable_api_termination: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    ebs_optimized: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    elastic_gpu_specifications: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.ElasticGpuSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    elastic_inference_accelerators: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.LaunchTemplateElasticInferenceAcceleratorProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    enclave_options: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.EnclaveOptionsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    hibernation_options: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.HibernationOptionsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    iam_instance_profile: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.IamInstanceProfileProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    image_id: typing.Optional[builtins.str] = None,
    instance_initiated_shutdown_behavior: typing.Optional[builtins.str] = None,
    instance_market_options: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.InstanceMarketOptionsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    instance_requirements: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.InstanceRequirementsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    instance_type: typing.Optional[builtins.str] = None,
    kernel_id: typing.Optional[builtins.str] = None,
    key_name: typing.Optional[builtins.str] = None,
    license_specifications: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.LicenseSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    maintenance_options: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.MaintenanceOptionsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    metadata_options: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.MetadataOptionsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    monitoring: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.MonitoringProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    network_interfaces: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.NetworkInterfaceProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    network_performance_options: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.NetworkPerformanceOptionsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    placement: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.PlacementProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    private_dns_name_options: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.PrivateDnsNameOptionsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    ram_disk_id: typing.Optional[builtins.str] = None,
    security_group_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    security_groups: typing.Optional[typing.Sequence[builtins.str]] = None,
    tag_specifications: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.TagSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    user_data: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ef42cf24e5e695d25947fdcf54f22f0735b874b1e66b0f5c7b2164beedd69987(
    *,
    count: typing.Optional[jsii.Number] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ba722af32047e934c636844fb1cb7a233bbb4ca5dfd737e73e54af58edbaaeb3(
    *,
    resource_type: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f33cf57d80fddde60e907a3ddfe637125f32e24d17180e902a7febbdcdf72b13(
    *,
    license_configuration_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5654590e83d3e61560ceed84eb56e77f7817347b859a99aadb3cd04a2c82a501(
    *,
    auto_recovery: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d7559d641b2c1163d8c661812952517982b292b2ad3e227d413c2dd3bdb4a603(
    *,
    max: typing.Optional[jsii.Number] = None,
    min: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ebc01c0d1c391f6b7979a47eec84dac262d9320c2dd94ea9ba4682d9f015cfb9(
    *,
    max: typing.Optional[jsii.Number] = None,
    min: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bf7bbc8c0ead237e2c30dbcf5f9a42c8cc58d7c353811c7685eb697b1b013489(
    *,
    http_endpoint: typing.Optional[builtins.str] = None,
    http_protocol_ipv6: typing.Optional[builtins.str] = None,
    http_put_response_hop_limit: typing.Optional[jsii.Number] = None,
    http_tokens: typing.Optional[builtins.str] = None,
    instance_metadata_tags: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9c016b67f5324eb7ba6ce35420b05ff613cab4ef1445914ebaad958bc3ec1f36(
    *,
    enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__88a41404d2f1aa6ee39e2728178f70773d0784aee67d8a8efbf78e76e6a8be57(
    *,
    max: typing.Optional[jsii.Number] = None,
    min: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d8bf076c2089938dac7eff484d33b571823eb10520abf2772d40505a0431e193(
    *,
    max: typing.Optional[jsii.Number] = None,
    min: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__25892afe09b618557ddf2d2cb6962addbf937fc9ff3121d66b07da343c61a0fd(
    *,
    associate_carrier_ip_address: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    associate_public_ip_address: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    connection_tracking_specification: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.ConnectionTrackingSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    delete_on_termination: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    description: typing.Optional[builtins.str] = None,
    device_index: typing.Optional[jsii.Number] = None,
    ena_queue_count: typing.Optional[jsii.Number] = None,
    ena_srd_specification: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.EnaSrdSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    groups: typing.Optional[typing.Sequence[builtins.str]] = None,
    interface_type: typing.Optional[builtins.str] = None,
    ipv4_prefix_count: typing.Optional[jsii.Number] = None,
    ipv4_prefixes: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.Ipv4PrefixSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    ipv6_address_count: typing.Optional[jsii.Number] = None,
    ipv6_addresses: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.Ipv6AddProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    ipv6_prefix_count: typing.Optional[jsii.Number] = None,
    ipv6_prefixes: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.Ipv6PrefixSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    network_card_index: typing.Optional[jsii.Number] = None,
    network_interface_id: typing.Optional[builtins.str] = None,
    primary_ipv6: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    private_ip_address: typing.Optional[builtins.str] = None,
    private_ip_addresses: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnLaunchTemplatePropsMixin.PrivateIpAddProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    secondary_private_ip_address_count: typing.Optional[jsii.Number] = None,
    subnet_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7bf71324f6f1a2e0a7c4697808d704e3fe52ecf6d1030ea5345d590b4beea72c(
    *,
    bandwidth_weighting: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__035c5e3631d6b7a94af1c5ffe79699b99970560cb8c80a50e86972e033b85214(
    *,
    affinity: typing.Optional[builtins.str] = None,
    availability_zone: typing.Optional[builtins.str] = None,
    group_id: typing.Optional[builtins.str] = None,
    group_name: typing.Optional[builtins.str] = None,
    host_id: typing.Optional[builtins.str] = None,
    host_resource_group_arn: typing.Optional[builtins.str] = None,
    partition_number: typing.Optional[jsii.Number] = None,
    spread_domain: typing.Optional[builtins.str] = None,
    tenancy: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2ae9f701f4ffbdc23e0c8dddbd7f11734212cdbf86746dd770056493767a5168(
    *,
    enable_resource_name_dns_aaaa_record: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    enable_resource_name_dns_a_record: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    hostname_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1eb6665f049efa8dceab238cfdedb625b3c83f4000b3b1a3afe278c1b0b0965c(
    *,
    primary: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    private_ip_address: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bfcff78ab73b0d214d15dbaa843aecb1669b0d02dd501ec35a0ee2b39fadc4d8(
    *,
    instance_family: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__84ff837f46b86cb2cfe052302218c451d5a9c1c8c484f2a9d175dc4ded6cb87d(
    *,
    block_duration_minutes: typing.Optional[jsii.Number] = None,
    instance_interruption_behavior: typing.Optional[builtins.str] = None,
    max_price: typing.Optional[builtins.str] = None,
    spot_instance_type: typing.Optional[builtins.str] = None,
    valid_until: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__17ec4eafee121a7c99bc49c0663d085d1b3510a8be2b941435ba0dbb2e310d02(
    *,
    resource_type: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a5a10183f239509135b72a456a98a498c9f7f62932f403e14641e40efb407378(
    *,
    max: typing.Optional[jsii.Number] = None,
    min: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ef48843da0c45113e35a37208a973c41aaec357bfe06eb0d19af9e41c84aca0b(
    *,
    max: typing.Optional[jsii.Number] = None,
    min: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c0c3a1e5c5e3473847a829c2e20a14b44e0d0a9d867658478a83c5559259ea8e(
    *,
    destination_cidr_block: typing.Optional[builtins.str] = None,
    local_gateway_route_table_id: typing.Optional[builtins.str] = None,
    local_gateway_virtual_interface_group_id: typing.Optional[builtins.str] = None,
    network_interface_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b2598c027dab78ba8fab8bf6e619a47c9e25ca5acccb38b2839b6dc32e546b41(
    props: typing.Union[CfnLocalGatewayRouteMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b17e6dba46b50749e355663cb74c4117c56e5009bb84d7e21840b38e8cbc27b3(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b6c0b9abde7358886a452d1687579592bd3b4e3e8c419d00af948be06ca64d8d(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8734861774b3253f97d6bf71cdc1f97cee754bc7a771f0a3d2771b5db95e643a(
    *,
    local_gateway_id: typing.Optional[builtins.str] = None,
    mode: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7f09510fd3300c6727059961cd6d37aa008ee264b6ff275c50aa8f71c878c3e8(
    props: typing.Union[CfnLocalGatewayRouteTableMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ff2b1758952e3b9c89fc1b16aba1d4a0de798330ed82e075a4f579050aa26ac0(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__374e9a34a3f4e4a74eede5a899f369bd2a945f0cf1b74de4cc7d028913af5b37(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0239962953c4482123e542643090af5b1f116caa0e0cd0b7e9be493ff52fe0f9(
    *,
    local_gateway_route_table_id: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    vpc_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__08799c82eeec4e1d747ec35b16945005f9caa79faeed21aa2d4998f4d40d75e7(
    props: typing.Union[CfnLocalGatewayRouteTableVPCAssociationMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9dbdd41f10646e89e13b364632cc2a0f369c3f1769fc741e467d8ef9ee4d3ba7(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__44c95db2b81600f20ff77aa15c88b58b7d610746c86da3b6df4c07f89b2131ff(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6ea439fe7f52962dbe4094ae948f32d27c0ac6c9a0688819eb6df3255c46df55(
    *,
    local_gateway_route_table_id: typing.Optional[builtins.str] = None,
    local_gateway_virtual_interface_group_id: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4a1125b2c181e00bea2cbd8066baa6b3369697761c3726b25a9b9da2f6560f02(
    props: typing.Union[CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f8b008fc550ef2d344ec98b66dc4c82198bf0fcdf7c0ee02cf71a818086a6835(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bd65b945dbe2d9121b15055ed1ca0c071bace51e82a276a8c26f01b37e6d91ec(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__452d0ccfbbd8a3aa9152637a38c1d60b1d5e673ec6049ba347afc733ca59188f(
    *,
    local_bgp_asn: typing.Optional[jsii.Number] = None,
    local_bgp_asn_extended: typing.Optional[jsii.Number] = None,
    local_gateway_id: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fa536b650b17ac381c9cec830a0489cb4a47dd32d6d054f609ed8200f858ab5c(
    props: typing.Union[CfnLocalGatewayVirtualInterfaceGroupMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d4826e36048e0d5adfe1a40f8577bed98e84deeb3aa1f23ea01871026a36457c(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b4a902e543aad4d1a3db8eea9b75bda7425ebac42968920cfcf1ee6d61829c60(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__124bd5fee7fdbd43875b3a24fdbd91459eaddedddaeafbcd930e86e08d9be180(
    *,
    local_address: typing.Optional[builtins.str] = None,
    local_gateway_virtual_interface_group_id: typing.Optional[builtins.str] = None,
    outpost_lag_id: typing.Optional[builtins.str] = None,
    peer_address: typing.Optional[builtins.str] = None,
    peer_bgp_asn: typing.Optional[jsii.Number] = None,
    peer_bgp_asn_extended: typing.Optional[jsii.Number] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    vlan: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__37546942174763d6fc7fbabf4101c34eb7da4dc156e7e6a9bcf9fdc1ff0d269d(
    props: typing.Union[CfnLocalGatewayVirtualInterfaceMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6ee3d8a11d5c9a98e6d30f9a096b7e4b2af8b03168bd679e39004e6c7f10f3fc(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__41e8af99ec302a9922777ea3881a74da346c2b61dbc456d10b2e843d6d46330f(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__68167a0b3f33310ab398389f86c8681b33d82127d2ee165ef334c9b1166b424a(
    *,
    allocation_id: typing.Optional[builtins.str] = None,
    availability_mode: typing.Optional[builtins.str] = None,
    availability_zone_addresses: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNatGatewayPropsMixin.AvailabilityZoneAddressProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    connectivity_type: typing.Optional[builtins.str] = None,
    max_drain_duration_seconds: typing.Optional[jsii.Number] = None,
    private_ip_address: typing.Optional[builtins.str] = None,
    secondary_allocation_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    secondary_private_ip_address_count: typing.Optional[jsii.Number] = None,
    secondary_private_ip_addresses: typing.Optional[typing.Sequence[builtins.str]] = None,
    subnet_id: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    vpc_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__264394afd1351433c06a428cd4302f3957e584af18bf49cd7aac4dc1d8511ff9(
    props: typing.Union[CfnNatGatewayMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__087cf570400487e8e8450a88f7f03ecb776537cf37bf0af4709284a248e8ac60(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a3cf8137a4c1ced1d6d1f2ee9c6b29069a44a0aa0903331b10a9a8c94e99e013(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__29b46d6944b9b565e55738423e36fa390617f435cefc03476f8daec0e83536cf(
    *,
    allocation_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    availability_zone: typing.Optional[builtins.str] = None,
    availability_zone_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__00a3ef97b127d59a3d5af6792b484b15c48e12c8b5aae800ac0aff1ecd1b5be7(
    *,
    cidr_block: typing.Optional[builtins.str] = None,
    egress: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    icmp: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkAclEntryPropsMixin.IcmpProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    ipv6_cidr_block: typing.Optional[builtins.str] = None,
    network_acl_id: typing.Optional[builtins.str] = None,
    port_range: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkAclEntryPropsMixin.PortRangeProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    protocol: typing.Optional[jsii.Number] = None,
    rule_action: typing.Optional[builtins.str] = None,
    rule_number: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9372ef7465912e96618bb6277ba56d42b3d6bf1efbb8782bb850a37f54e3ebb5(
    props: typing.Union[CfnNetworkAclEntryMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c3867578fc9e5e637c67e27732a87683f5db24de48049eb43d60281b8612bece(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a7e9ae28d4c75b46a3cd862879b73c44ddd47847be1204985b8bdccc6d314d55(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b2044fbfd5d7552224d8dffb083b14eec0061cef63c1293cab0df32975a31144(
    *,
    code: typing.Optional[jsii.Number] = None,
    type: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5142c24e90fb1580de1ac88b04e14ce4cb0abf88be740f0a740a8b9f3b67d01a(
    *,
    from_: typing.Optional[jsii.Number] = None,
    to: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aa70990cdb9b7ff762664f95ec8f4a84df2f2e339c1100c3efc8746a886e4e3d(
    *,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    vpc_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6f02ce9eb899190dbcac35d8640840091820dc5c88eb8c757afbe0916615eb43(
    props: typing.Union[CfnNetworkAclMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3e87f76490d846fd2b13bd090dd0980da986fd3807302d93f784d3d3569106f4(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7303daf30e8763b88cdd1b7ffdc5da41e5f4d98600c24c55781935a85da0d9d9(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__493418819f6a818081c498e41bfd501ae10acc98f1a1b52c7cc82cbdf2196393(
    *,
    network_insights_access_scope_id: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a8031baccbbf243f27d14be162fabe68e5d676a4de3a001aad6c9d00a0d25b91(
    props: typing.Union[CfnNetworkInsightsAccessScopeAnalysisMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f211a4baf4dbf6fb34bb1c1607d914b4e83a27080255dbd3569e625020f7beda(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7e9f11dbf86eddb759cadd19414494f0ea6f05330b16dc5fa3481542f34a2020(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a4739b2175c51f0265d9931e723847828c42851de7f26e07023dae6c06b35c6b(
    *,
    exclude_paths: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAccessScopePropsMixin.AccessScopePathRequestProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    match_paths: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAccessScopePropsMixin.AccessScopePathRequestProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cb261b2f71341c8c78bfbeb4e3cf15fdd79e584563a06fa6b6bd10790d7d82da(
    props: typing.Union[CfnNetworkInsightsAccessScopeMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__34ccb83a7ae268b901d84ca393ef1d6dac73c7539d50bfe0b253d8642da83c6c(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3148816a61df0bbdfc7653b075995799cdfc3223a6b54423b16e9992b40ebb50(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aeaa89a252e4e740ee48ea49d0e05e72f6211c219b83af9053a2874e2b695310(
    *,
    destination: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAccessScopePropsMixin.PathStatementRequestProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    source: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAccessScopePropsMixin.PathStatementRequestProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    through_resources: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAccessScopePropsMixin.ThroughResourcesStatementRequestProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__092e98a73392b6a41a2f6d1e1e15bcb73d3c52b203640b7767c8af503a37a5a8(
    *,
    destination_addresses: typing.Optional[typing.Sequence[builtins.str]] = None,
    destination_ports: typing.Optional[typing.Sequence[builtins.str]] = None,
    destination_prefix_lists: typing.Optional[typing.Sequence[builtins.str]] = None,
    protocols: typing.Optional[typing.Sequence[builtins.str]] = None,
    source_addresses: typing.Optional[typing.Sequence[builtins.str]] = None,
    source_ports: typing.Optional[typing.Sequence[builtins.str]] = None,
    source_prefix_lists: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3aa5e7dee02452bc28c4db5b9e2ea005ba166978e0a96ed6c10bd0b85e2be32d(
    *,
    packet_header_statement: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAccessScopePropsMixin.PacketHeaderStatementRequestProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    resource_statement: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAccessScopePropsMixin.ResourceStatementRequestProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__760f070c3bfcd69ae08fd5c145f4d6b8e2a0cbe402f37d165e6bb8584e63d3ae(
    *,
    resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    resource_types: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7555ca7b173d036fc4fdd99c2b6bc4c9d1b222b2f99593480046f0f7e8544b18(
    *,
    resource_statement: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAccessScopePropsMixin.ResourceStatementRequestProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ea8301d508fcbeb5bd5c3edd25c9f7382c092cf943c7768e5bcd57e577485c05(
    *,
    additional_accounts: typing.Optional[typing.Sequence[builtins.str]] = None,
    filter_in_arns: typing.Optional[typing.Sequence[builtins.str]] = None,
    filter_out_arns: typing.Optional[typing.Sequence[builtins.str]] = None,
    network_insights_path_id: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3ce0a306dbe9120ac8fd73180d2724fa4cf25ceaec00d2fd960a91d50c3d44ac(
    props: typing.Union[CfnNetworkInsightsAnalysisMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3c031d0869cdb70dbe2b8a44759401da1b4701c085e30e0db72615efdf3207ae(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__00d1b813ea1b0cd9683068d0ecd9a0518e2ad3f32b407a5feef624d18165d7ab(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7326ea3a400ab406f6b58238c0f8a75ec4d88e8c037e517ab3bd3968841e9080(
    *,
    additional_detail_type: typing.Optional[builtins.str] = None,
    component: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    load_balancers: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    service_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bac411709452f264c3f6da44e7dc337d74da4ef8763884cb8b063fa42a8ff590(
    *,
    component_arn: typing.Optional[builtins.str] = None,
    component_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1923826e28de467f3d279853470a0a796cb0161ebf954e0fc8fa5cdc75c45159(
    *,
    cidr: typing.Optional[builtins.str] = None,
    egress: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    port_range: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.PortRangeProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    protocol: typing.Optional[builtins.str] = None,
    rule_action: typing.Optional[builtins.str] = None,
    rule_number: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__61a24c33b307b619bc4d691b8356d3a0463e27a46aececeaa20c3fc0283c22a7(
    *,
    arn: typing.Optional[builtins.str] = None,
    id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fa049116c68e1feb8015f56fcdac4d7f224c854f338049a946e3b4f607aed7fb(
    *,
    instance_port: typing.Optional[jsii.Number] = None,
    load_balancer_port: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2f9b4a1c11c7a16bf24761e48cdf429d4bb39786e35e2e8e1511fda1bc96a26e(
    *,
    address: typing.Optional[builtins.str] = None,
    availability_zone: typing.Optional[builtins.str] = None,
    instance: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    port: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0367461e816c11043c71ec8531c2d0cdeffcbc7d424106c3ab0468738faed5f2(
    *,
    destination_addresses: typing.Optional[typing.Sequence[builtins.str]] = None,
    destination_port_ranges: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.PortRangeProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    protocol: typing.Optional[builtins.str] = None,
    source_addresses: typing.Optional[typing.Sequence[builtins.str]] = None,
    source_port_ranges: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.PortRangeProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__84304a16293fc0d84cc074809cbe1d903d501e1858542b8399ed802c259b81db(
    *,
    destination_cidr: typing.Optional[builtins.str] = None,
    destination_prefix_list_id: typing.Optional[builtins.str] = None,
    egress_only_internet_gateway_id: typing.Optional[builtins.str] = None,
    gateway_id: typing.Optional[builtins.str] = None,
    instance_id: typing.Optional[builtins.str] = None,
    nat_gateway_id: typing.Optional[builtins.str] = None,
    network_interface_id: typing.Optional[builtins.str] = None,
    origin: typing.Optional[builtins.str] = None,
    state: typing.Optional[builtins.str] = None,
    transit_gateway_id: typing.Optional[builtins.str] = None,
    vpc_peering_connection_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ff8f34175a086820fbae63928e74c475d84a4da438fe72adad3496d5e658eae5(
    *,
    cidr: typing.Optional[builtins.str] = None,
    direction: typing.Optional[builtins.str] = None,
    port_range: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.PortRangeProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    prefix_list_id: typing.Optional[builtins.str] = None,
    protocol: typing.Optional[builtins.str] = None,
    security_group_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c7c2c3061b433a46abb88340becbd31d93c80d005ebc7853683160b6c194edba(
    *,
    acl: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    acl_rule: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisAclRuleProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    address: typing.Optional[builtins.str] = None,
    addresses: typing.Optional[typing.Sequence[builtins.str]] = None,
    attached_to: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    availability_zones: typing.Optional[typing.Sequence[builtins.str]] = None,
    cidrs: typing.Optional[typing.Sequence[builtins.str]] = None,
    classic_load_balancer_listener: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisLoadBalancerListenerProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    component: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    component_account: typing.Optional[builtins.str] = None,
    component_region: typing.Optional[builtins.str] = None,
    customer_gateway: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    destination: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    destination_vpc: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    direction: typing.Optional[builtins.str] = None,
    elastic_load_balancer_listener: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    explanation_code: typing.Optional[builtins.str] = None,
    ingress_route_table: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    internet_gateway: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    load_balancer_arn: typing.Optional[builtins.str] = None,
    load_balancer_listener_port: typing.Optional[jsii.Number] = None,
    load_balancer_target: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisLoadBalancerTargetProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    load_balancer_target_group: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    load_balancer_target_groups: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    load_balancer_target_port: typing.Optional[jsii.Number] = None,
    missing_component: typing.Optional[builtins.str] = None,
    nat_gateway: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    network_interface: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    packet_field: typing.Optional[builtins.str] = None,
    port: typing.Optional[jsii.Number] = None,
    port_ranges: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.PortRangeProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    prefix_list: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    protocols: typing.Optional[typing.Sequence[builtins.str]] = None,
    route_table: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    route_table_route: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisRouteTableRouteProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    security_group: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    security_group_rule: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisSecurityGroupRuleProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    security_groups: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    source_vpc: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    state: typing.Optional[builtins.str] = None,
    subnet: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    subnet_route_table: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    transit_gateway: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    transit_gateway_attachment: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    transit_gateway_route_table: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    transit_gateway_route_table_route: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.TransitGatewayRouteTableRouteProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    vpc: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    vpc_endpoint: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    vpc_peering_connection: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    vpn_connection: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    vpn_gateway: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d55f31184075d7059874669c059a4bbcbd46d664cb62acdad0d73329a7c39f8c(
    *,
    acl_rule: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisAclRuleProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    additional_details: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AdditionalDetailProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    component: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    destination_vpc: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    elastic_load_balancer_listener: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    explanations: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.ExplanationProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    inbound_header: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisPacketHeaderProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    outbound_header: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisPacketHeaderProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    route_table_route: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisRouteTableRouteProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    security_group_rule: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisSecurityGroupRuleProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    sequence_number: typing.Optional[jsii.Number] = None,
    service_name: typing.Optional[builtins.str] = None,
    source_vpc: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    subnet: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    transit_gateway: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    transit_gateway_route_table_route: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.TransitGatewayRouteTableRouteProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    vpc: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsAnalysisPropsMixin.AnalysisComponentProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7b1c5bae9bb53ef42b0bc7349975d9f67868b9631191efb4f7be3048a5a5063e(
    *,
    from_: typing.Optional[jsii.Number] = None,
    to: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c0901058b815a896a9bc0cb903e99c970ddfff7f606bb311cf5cde3cd1ae96de(
    *,
    attachment_id: typing.Optional[builtins.str] = None,
    destination_cidr: typing.Optional[builtins.str] = None,
    prefix_list_id: typing.Optional[builtins.str] = None,
    resource_id: typing.Optional[builtins.str] = None,
    resource_type: typing.Optional[builtins.str] = None,
    route_origin: typing.Optional[builtins.str] = None,
    state: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6aa749e33f80367942994e7bfe06e8d409f0504fc16a8b266c1ff013218052da(
    *,
    destination: typing.Optional[builtins.str] = None,
    destination_ip: typing.Optional[builtins.str] = None,
    destination_port: typing.Optional[jsii.Number] = None,
    filter_at_destination: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsPathPropsMixin.PathFilterProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    filter_at_source: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsPathPropsMixin.PathFilterProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    protocol: typing.Optional[builtins.str] = None,
    source: typing.Optional[builtins.str] = None,
    source_ip: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3e5e83658d7a85ba99e4e360403b5009923a4ac1ac9a31453d7509db6c003540(
    props: typing.Union[CfnNetworkInsightsPathMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e16935d940c40abece8320fd10a47ddd000741bac114464b62a97190dfd1a23c(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__72258fbc73943ea7e34b62a0ae8314ba34155d6f9bb8686408d6ebbb2478ba74(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__70362d998e73c43f0bcbbc776ce1a9e6f95a1c7c7ec293a5f556177949f569c2(
    *,
    from_port: typing.Optional[jsii.Number] = None,
    to_port: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e8e811c26844ac8fc86580826953bfd4b9da82f4526a1b341ebc9ab627192b08(
    *,
    destination_address: typing.Optional[builtins.str] = None,
    destination_port_range: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsPathPropsMixin.FilterPortRangeProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    source_address: typing.Optional[builtins.str] = None,
    source_port_range: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInsightsPathPropsMixin.FilterPortRangeProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b1f4eb45034f4f5b319608034b11da2e7126d52d5555e6fa55bb1ddea65649a4(
    *,
    delete_on_termination: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    device_index: typing.Optional[builtins.str] = None,
    ena_queue_count: typing.Optional[jsii.Number] = None,
    ena_srd_specification: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInterfaceAttachmentPropsMixin.EnaSrdSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    instance_id: typing.Optional[builtins.str] = None,
    network_interface_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d2e921f512f81d273ddbbc5c5689880b49290e2469a3afafbe12f34a9cc8f8db(
    props: typing.Union[CfnNetworkInterfaceAttachmentMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e3135fd80817efe2b124a0b7c0300ace8e105e4febb495cb3218b76e1fe38ff5(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c748786a87b501dd3026e817b8024e1ef7f17c3e451f0c5fbe15991f27f59bb9(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4f1e092756b6dfdd82c9b8bf400ae792b41654ef51495207c7ad43b94970a75a(
    *,
    ena_srd_enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    ena_srd_udp_specification: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInterfaceAttachmentPropsMixin.EnaSrdUdpSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9200910cdaf785d98b05d7091064df5392918720835e2721b92fc62078f0555c(
    *,
    ena_srd_udp_enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ba8899d7a1cb6df8789ae4e62b9bb3947e99baa1f6ae5062eaab0929aca85282(
    *,
    connection_tracking_specification: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInterfacePropsMixin.ConnectionTrackingSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    description: typing.Optional[builtins.str] = None,
    enable_primary_ipv6: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    group_set: typing.Optional[typing.Sequence[builtins.str]] = None,
    interface_type: typing.Optional[builtins.str] = None,
    ipv4_prefix_count: typing.Optional[jsii.Number] = None,
    ipv4_prefixes: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInterfacePropsMixin.Ipv4PrefixSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    ipv6_address_count: typing.Optional[jsii.Number] = None,
    ipv6_addresses: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInterfacePropsMixin.InstanceIpv6AddressProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    ipv6_prefix_count: typing.Optional[jsii.Number] = None,
    ipv6_prefixes: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInterfacePropsMixin.Ipv6PrefixSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    private_ip_address: typing.Optional[builtins.str] = None,
    private_ip_addresses: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnNetworkInterfacePropsMixin.PrivateIpAddressSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    public_ip_dns_hostname_type_specification: typing.Optional[builtins.str] = None,
    secondary_private_ip_address_count: typing.Optional[jsii.Number] = None,
    source_dest_check: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    subnet_id: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__842fc21e18c154ac0eeffc10633f90b057942701d14c87663facbc8b707d7da5(
    *,
    aws_account_id: typing.Optional[builtins.str] = None,
    network_interface_id: typing.Optional[builtins.str] = None,
    permission: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a87622d97556ddbb198f15704f4137110e28444b8356b6a5a8f9b4bb6d31d2a5(
    props: typing.Union[CfnNetworkInterfacePermissionMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__47dfff50e7b8fcef996bcee52aa4d473c673fb3515f829c30db1832cb896b238(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__02ace1bcd759e11bc58e84b7756b6813b726c081ad052591b8acafc167e8d7a3(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8814c582e1d68570a42007dee51b71c3ca8e0ba3a9abc4a4f615a85ac51d56ba(
    props: typing.Union[CfnNetworkInterfaceMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8d133d99846465488f8bd331c575498715e222fa16964958959111a30fade813(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6de35757b2a50c8c59a41800caf1de3b6b368c74ce26338a88e1f7518214b71c(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__15d9c2c50c83febc14cb68ca45f247f76bd34a12534804739d26c71f786e9ed0(
    *,
    tcp_established_timeout: typing.Optional[jsii.Number] = None,
    udp_stream_timeout: typing.Optional[jsii.Number] = None,
    udp_timeout: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e610428ece8f1704c4b46162b4e590a35d6dab2c5f780734bf286aa4cf294304(
    *,
    ipv6_address: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__15df342d08f40166ed1b3f2f9c7720b3aecd873125e83c6df018b5047751ddc4(
    *,
    ipv4_prefix: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__934b0598113db2173b749fd699f1f4469cd8b77d04d11d98e72fa50f9a10bec4(
    *,
    ipv6_prefix: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6b70e32c0cdea5f6acc46b72fea40cbfba3924f1dd1dde85ad048ebbe6059c1c(
    *,
    primary: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    private_ip_address: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3204ccca498321f58eb0856ef128b909111f93c2282676f70cdbbabd7a2b9c66(
    *,
    dns_hostname_type: typing.Optional[builtins.str] = None,
    public_dual_stack_dns_name: typing.Optional[builtins.str] = None,
    public_ipv4_dns_name: typing.Optional[builtins.str] = None,
    public_ipv6_dns_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2e59d999cef5da0d3fb5cc1df26fe8dc1c030355cfce09e19759bdbb51243ed0(
    *,
    destination: typing.Optional[builtins.str] = None,
    metric: typing.Optional[builtins.str] = None,
    source: typing.Optional[builtins.str] = None,
    statistic: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__77a11ea3ab7e9fd741cd11e958e4198c8a02f830aefdf4a97b844a3bfdabbac6(
    props: typing.Union[CfnNetworkPerformanceMetricSubscriptionMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0178bba9641d33d604911a8d3762475d13463fa8f77df6663b7a6b80e2db2ead(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0cecb24eae197b0b841a161a7049bd67519e72f349d506b9e6a0e81bc144984d(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__85d4d1325334f9d22842fdeb9a409def6a76c2c4c808bad1c12f4bbef6498d48(
    *,
    partition_count: typing.Optional[jsii.Number] = None,
    spread_level: typing.Optional[builtins.str] = None,
    strategy: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bb1e4a0ab53a2ed21005bbd161912217129aba3a61b9a9c8e899a858d1b3ea61(
    props: typing.Union[CfnPlacementGroupMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8c7eb5402698f950846c385c35d4900aad013fc87c0ec5d64135b7f8415ce90f(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d92d38de8a4ad8ad1f0289659aff7a9bc602a71be53b0fa3820ce4178caed90f(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__54f9f1d6bffd75f28cfaa68196f9f7b90cf993729e1a19dd145a01d797cd3226(
    *,
    address_family: typing.Optional[builtins.str] = None,
    entries: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPrefixListPropsMixin.EntryProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    max_entries: typing.Optional[jsii.Number] = None,
    prefix_list_name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8e4ee30c82286464153faf767c7887855c4383d2d01a0b2c66719db185a9be53(
    props: typing.Union[CfnPrefixListMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b56751f9f6b2e370d5045807bf2ffeb5e836ce70e3c87af17854c3b4eabe05d2(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c28de386216ffef61c8313d20cc060e536da30b1ef475b60251ef7eb894bb5fc(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b73742aaf31ae9e675bf1f0e841a8f327f017b2281898aa19cbd117efc807fc0(
    *,
    cidr: typing.Optional[builtins.str] = None,
    description: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__82322c7ef24fc4cf9ccc12569083519b922a7678cf5917c51f414abcac894401(
    *,
    carrier_gateway_id: typing.Optional[builtins.str] = None,
    core_network_arn: typing.Optional[builtins.str] = None,
    destination_cidr_block: typing.Optional[builtins.str] = None,
    destination_ipv6_cidr_block: typing.Optional[builtins.str] = None,
    destination_prefix_list_id: typing.Optional[builtins.str] = None,
    egress_only_internet_gateway_id: typing.Optional[builtins.str] = None,
    gateway_id: typing.Optional[builtins.str] = None,
    instance_id: typing.Optional[builtins.str] = None,
    local_gateway_id: typing.Optional[builtins.str] = None,
    nat_gateway_id: typing.Optional[builtins.str] = None,
    network_interface_id: typing.Optional[builtins.str] = None,
    route_table_id: typing.Optional[builtins.str] = None,
    transit_gateway_id: typing.Optional[builtins.str] = None,
    vpc_endpoint_id: typing.Optional[builtins.str] = None,
    vpc_peering_connection_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eb72a9d8d13d80a800ceb12aaa4a5c8ff944cc161a933bce804ef2e142075a65(
    props: typing.Union[CfnRouteMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cc57c141eaba292d3f04933b7abe48b8e03fbee1f5495149459043892b3ba8ee(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__41b8169bf8fda01dcd0ca174c3f654d6e61a4f406169d42a9054a407ff9ae585(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7174855bc013932c701809b02578d449ee5584f3f0545561da096ba39ff8b7e1(
    *,
    route_server_id: typing.Optional[builtins.str] = None,
    vpc_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9a711b840d0c23decebfed2922534922a771c14c81270f37f1dda2e2b0f833c6(
    props: typing.Union[CfnRouteServerAssociationMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b899f66692fa1d07e7aa13d7b7c23992d10158d1efbef81e5cb8f7d43750f12c(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fa6cb530e2c33493295049046ee06039a03dc2b373339be66958c8ba0d3d2699(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5cfd42a155747febaa676b5905fae1016e14faa6de69402b1cd19cc9dff6d28d(
    *,
    route_server_id: typing.Optional[builtins.str] = None,
    subnet_id: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c60bb416cd1a8794c3e4df1f7f69f04097b4a7c11081b25a51ba34fbf0f7179c(
    props: typing.Union[CfnRouteServerEndpointMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a32ad93e428e377c4a64c8f108328c2c0b20e9dca84941443ebbb41690713b98(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__33ccae950a0a43d1bcebca96d44572b17195cbe1b61d41189daf1403184f44ac(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2480af15cb2d3d35a13be6cb2714d1f50bb42da3bc913941f884b65fb9c5a0df(
    *,
    amazon_side_asn: typing.Optional[jsii.Number] = None,
    persist_routes: typing.Optional[builtins.str] = None,
    persist_routes_duration: typing.Optional[jsii.Number] = None,
    sns_notifications_enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e62af65b07d05908bdf46d749244d1cc99dffcd32323e46cecdfbebcbeb947b9(
    delivery_stream: _aws_cdk_interfaces_aws_kinesisfirehose_ceddda9d.IDeliveryStreamRef,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b982f19ff649590805549ffc3f5e8f8bf05456543fc9b2e398f71eb61adc82a4(
    log_group: _aws_cdk_interfaces_aws_logs_ceddda9d.ILogGroupRef,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e5aa15c5a090e9206ad9c49e22bbcd6540feaba02aa8a94bb2f96441f7de6fe9(
    bucket: _aws_cdk_interfaces_aws_s3_ceddda9d.IBucketRef,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e887379c7ce461cf348e2d0a8886b52ad7923d6fee0347023e8e70995b5c98ad(
    log_type: builtins.str,
    log_delivery: _ILogsDelivery_0d3c9e29,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b53a309af28da1eec8b32e48fe86c145f2eda70f8ac9c3a10faefedb25aa2368(
    resource: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8e3988d66ef777b3f2816b11e3632f39fd0e01a4920356b90f4e74fc630aba7b(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__23d7b4e4677f86ed600f3de488dd3f7d7c39e60069c06404abb424bc59bf8d40(
    *,
    bgp_options: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnRouteServerPeerPropsMixin.BgpOptionsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    peer_address: typing.Optional[builtins.str] = None,
    route_server_endpoint_id: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c916425b7277689a5ae6fa9518e048f868c9d1d8c3393ba03c5da02880780e76(
    props: typing.Union[CfnRouteServerPeerMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6eed4970751922be1e775116d5884975b78fc7128aa90337633b315961e3a5dd(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0340163d25fc60edd6a8977bc60f424d104bf72b0a3d3c34004932d89ea2a126(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a4ff7f4b8e93cf4c4b3d217e320f4ee147cb8d2b269aeac4ec8bbbdc7d4843e0(
    *,
    peer_asn: typing.Optional[jsii.Number] = None,
    peer_liveness_detection: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f60d31a866abdd61948547c41cc7342a7ef13569d0bef024dabbec56e3adaaf1(
    *,
    route_server_id: typing.Optional[builtins.str] = None,
    route_table_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e525643ecdde452c5ec34e33b78dc4df260e6fbd7f393e2cfe8faa9872d458fd(
    props: typing.Union[CfnRouteServerPropagationMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9b70bb1ec8b7007a0da1e231e1014ec2f61bc5bf64117fde375b90ad562de322(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f681d6ccb4601c45d7c542e6845fbfe3a38ae1aacb1bc1af89523812022fa1a9(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__39a64501aff440c7baeb3cf595a9488753c2a8763ba176e2150c096df6e8b50b(
    props: typing.Union[CfnRouteServerMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__667fc4040bc5a0ddbbbe46c61a7d4fd1b0985aff398baf70c6823d4e67389292(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__971b6f87df1615275c1559054d9f25f32115cb40e1ad701f1d5f2bf7c2235e0d(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__57d211aefa5d44f81b9bd1aa488a05b8f3322ef57ad58ead910d9766bdb892d8(
    *,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    vpc_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1f01ca4cef3ef219214ace82860edb224714e9d3764625ecb187b278817e46f9(
    props: typing.Union[CfnRouteTableMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cf9d91b3e55497efebe78b86dc6b08f757be3a31e494b3ce030274cdcdffde63(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c72de2109c79077a69626bb9fa6ad1f1af9e834eeea6b6f725c03c0716649bb3(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3c3899d635c39e73e3cabe279f23c268324e8d4bd394f194900b08595bd28d95(
    *,
    cidr_ip: typing.Optional[builtins.str] = None,
    cidr_ipv6: typing.Optional[builtins.str] = None,
    description: typing.Optional[builtins.str] = None,
    destination_prefix_list_id: typing.Optional[builtins.str] = None,
    destination_security_group_id: typing.Optional[builtins.str] = None,
    from_port: typing.Optional[jsii.Number] = None,
    group_id: typing.Optional[builtins.str] = None,
    ip_protocol: typing.Optional[builtins.str] = None,
    to_port: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__607aea1004b764eb4f8771cd8db8ebcda47e35d3c3c9426e71febe8f818b8ef1(
    props: typing.Union[CfnSecurityGroupEgressMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__37777a183f1a008728df9f0ba720fd16295f1572d144357b6f333dee1f1fbee6(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__495acd89dd53cca5a5143a0d7b41479e6cb1015fcda0d5028ed7702959078695(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6c56bf6a2395c3ca5a91c2d8ceccf287dce6a1f41b3a3edbb1cbdb92ecd3a5f5(
    *,
    cidr_ip: typing.Optional[builtins.str] = None,
    cidr_ipv6: typing.Optional[builtins.str] = None,
    description: typing.Optional[builtins.str] = None,
    from_port: typing.Optional[jsii.Number] = None,
    group_id: typing.Optional[builtins.str] = None,
    group_name: typing.Optional[builtins.str] = None,
    ip_protocol: typing.Optional[builtins.str] = None,
    source_prefix_list_id: typing.Optional[builtins.str] = None,
    source_security_group_id: typing.Optional[builtins.str] = None,
    source_security_group_name: typing.Optional[builtins.str] = None,
    source_security_group_owner_id: typing.Optional[builtins.str] = None,
    to_port: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6af1b4c6e7913a8b26366e182e9e0eabf9b91f97c7e48cf80fe00e7e7dae3b96(
    props: typing.Union[CfnSecurityGroupIngressMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0bafbd199e4d8bbf31b8e47b0703a8e6e739897735c522f31913ab54a14d9214(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__23e498a34184f6c2bab0fec1f0bae81d209871c1937d4ca426a1dc3036a95f29(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4b126f1cb0b14af7af088c06bb51e0ff49381eb4ffa36b40d3c7d4cbcffc313f(
    *,
    group_description: typing.Optional[builtins.str] = None,
    group_name: typing.Optional[builtins.str] = None,
    security_group_egress: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSecurityGroupPropsMixin.EgressProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    security_group_ingress: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSecurityGroupPropsMixin.IngressProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    vpc_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6349e96c8d096269d3ffc645a7b05b0418eb8c6e0d2b5b14f791fd7516aa8089(
    props: typing.Union[CfnSecurityGroupMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__82824210d31ecff4eec980f3a5aa3d1297ebd4638efaf31ef08cf56bd905a162(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d7818c069e202815233223a48079531220223ed08cb60e6f79f9868ee510c86c(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0a1c9f7d955045ef5a44320aa717072111d3b54c6457b9fe427589098c55dcb1(
    *,
    cidr_ip: typing.Optional[builtins.str] = None,
    cidr_ipv6: typing.Optional[builtins.str] = None,
    description: typing.Optional[builtins.str] = None,
    destination_prefix_list_id: typing.Optional[builtins.str] = None,
    destination_security_group_id: typing.Optional[builtins.str] = None,
    from_port: typing.Optional[jsii.Number] = None,
    ip_protocol: typing.Optional[builtins.str] = None,
    to_port: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__94f5b9d6dbf577079e99f0af127419de2a48784b598ab1073c18da1b7ae4a80f(
    *,
    cidr_ip: typing.Optional[builtins.str] = None,
    cidr_ipv6: typing.Optional[builtins.str] = None,
    description: typing.Optional[builtins.str] = None,
    from_port: typing.Optional[jsii.Number] = None,
    ip_protocol: typing.Optional[builtins.str] = None,
    source_prefix_list_id: typing.Optional[builtins.str] = None,
    source_security_group_id: typing.Optional[builtins.str] = None,
    source_security_group_name: typing.Optional[builtins.str] = None,
    source_security_group_owner_id: typing.Optional[builtins.str] = None,
    to_port: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1d8bba0fbbed0786ead22dfdafb814dc1cd500e6c9323f918f2b0f4893ed7b16(
    *,
    group_id: typing.Optional[builtins.str] = None,
    vpc_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d0af3930582f38446158719a1c7e48eb827a5d269256562d206eaf18d6811653(
    props: typing.Union[CfnSecurityGroupVpcAssociationMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e0ff2953034cbe4dbec2c658e02a71a65f4fd9bcf76d7744ba135db3c45a380d(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ff80db7e1685327b1804bf5fa8ac6762f21fb208ef03346c30f358c9771641d1(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__297530769d14d0feec93aab77b2b8eb92f896078084493eafbf16b1a928c95e7(
    *,
    state: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__90391b006c7994b4ea449044f3bf8bf1c076d670f94e33d97b8a851a0cfdcdab(
    props: typing.Union[CfnSnapshotBlockPublicAccessMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b2e3fe550a517a13e9fc8a77a9596ea304e84b4e3f09ce8ef5b4488e03dde6f4(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__69c33d5a9642820d9ea4738f6bf1ab4ff9b3b8d17d8c1367b1f224f1594f2e52(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__38d7707296a4d0ae2830d001d573e6a3139c137a14c9d396bd7433852c8f4fd1(
    *,
    spot_fleet_request_config_data: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSpotFleetPropsMixin.SpotFleetRequestConfigDataProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5f44c0934133518a52fc157174723e56544f6820fc79641f31d3be7a4d492a66(
    props: typing.Union[CfnSpotFleetMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f10a0dcef9107d5ba6fecade699b0c211d275c56e02cf4d1ec2548ae1c351a2c(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__623b7e36a0e976cc9bb1f2c5e472b848555794f93e4bbf091a2108214f9d07ec(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4ffc9d5136877f4c9aea0f77bc6403e81622bf34c5664c05b06233018d341fc5(
    *,
    max: typing.Optional[jsii.Number] = None,
    min: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__552626f0a128d6f15c56e0732b796a8f5f31baae39a418960ff2bdeb893f06c1(
    *,
    max: typing.Optional[jsii.Number] = None,
    min: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aef771ed2ea0b562879179cf30bef6e79e955d65ac266d93cc73890a2139615c(
    *,
    max: typing.Optional[jsii.Number] = None,
    min: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__10113ee78d18a5c882e5eb889302f44989f7ae6c1a078e0e5ce492b4bd65ff7e(
    *,
    cpu: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSpotFleetPropsMixin.CpuPerformanceFactorRequestProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f4f688a9a941d59502e3e9551236452ea77ed79fe379911abd88cb55b2be01e6(
    *,
    device_name: typing.Optional[builtins.str] = None,
    ebs: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSpotFleetPropsMixin.EbsBlockDeviceProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    no_device: typing.Optional[builtins.str] = None,
    virtual_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2e2f4080d77bba067bf927f835deca977fc69d1962e42cc7c7b7185f4cc62591(
    *,
    name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bfa38537187155be5f63e0c7dc84d50da469f3f830ba12d3dd4db6b3f355b661(
    *,
    classic_load_balancers: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSpotFleetPropsMixin.ClassicLoadBalancerProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0936e06d5752c03e42520625b1f219256125a9dc8f69fcc78a64744f8e3476da(
    *,
    references: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSpotFleetPropsMixin.PerformanceFactorReferenceRequestProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e1370eab1cffb0d063d8b79851262e5557e42495219934bc6f5ff0885d1e4cbe(
    *,
    delete_on_termination: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    encrypted: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    iops: typing.Optional[jsii.Number] = None,
    snapshot_id: typing.Optional[builtins.str] = None,
    volume_size: typing.Optional[jsii.Number] = None,
    volume_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3ef52e5ae991ab8f9ee350cdd87c2195c64d4dc36fd00fcc4e917e037269f57d(
    *,
    launch_template_id: typing.Optional[builtins.str] = None,
    launch_template_name: typing.Optional[builtins.str] = None,
    version: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a83ac6ddf2c9a3465efa512c22d6a343ec66edd44076af4179ed66634a3c8fa4(
    *,
    group_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__303424c0bed8b597227a51ecbfd57b9eb0f84a0aec546a66ce99e104010530aa(
    *,
    arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d25a66a1a5b3fcded0e2b91e1b5afee9b1a7e932773dcc27d3c335198afec655(
    *,
    ipv6_address: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__742db8a91202b8e1b9a6e91545589c40fa9bee7dae23fdf9363014de40e8e45f(
    *,
    associate_public_ip_address: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    delete_on_termination: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    description: typing.Optional[builtins.str] = None,
    device_index: typing.Optional[jsii.Number] = None,
    groups: typing.Optional[typing.Sequence[builtins.str]] = None,
    ipv6_address_count: typing.Optional[jsii.Number] = None,
    ipv6_addresses: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSpotFleetPropsMixin.InstanceIpv6AddressProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    network_interface_id: typing.Optional[builtins.str] = None,
    private_ip_addresses: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSpotFleetPropsMixin.PrivateIpAddressSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    secondary_private_ip_address_count: typing.Optional[jsii.Number] = None,
    subnet_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4d55884cd3a399caafb6c4fa0d7489ff6691b5499a97de05104b1dcbd5088e13(
    *,
    accelerator_count: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSpotFleetPropsMixin.AcceleratorCountRequestProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    accelerator_manufacturers: typing.Optional[typing.Sequence[builtins.str]] = None,
    accelerator_names: typing.Optional[typing.Sequence[builtins.str]] = None,
    accelerator_total_memory_mib: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSpotFleetPropsMixin.AcceleratorTotalMemoryMiBRequestProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    accelerator_types: typing.Optional[typing.Sequence[builtins.str]] = None,
    allowed_instance_types: typing.Optional[typing.Sequence[builtins.str]] = None,
    bare_metal: typing.Optional[builtins.str] = None,
    baseline_ebs_bandwidth_mbps: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSpotFleetPropsMixin.BaselineEbsBandwidthMbpsRequestProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    baseline_performance_factors: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSpotFleetPropsMixin.BaselinePerformanceFactorsRequestProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    burstable_performance: typing.Optional[builtins.str] = None,
    cpu_manufacturers: typing.Optional[typing.Sequence[builtins.str]] = None,
    excluded_instance_types: typing.Optional[typing.Sequence[builtins.str]] = None,
    instance_generations: typing.Optional[typing.Sequence[builtins.str]] = None,
    local_storage: typing.Optional[builtins.str] = None,
    local_storage_types: typing.Optional[typing.Sequence[builtins.str]] = None,
    max_spot_price_as_percentage_of_optimal_on_demand_price: typing.Optional[jsii.Number] = None,
    memory_gib_per_v_cpu: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSpotFleetPropsMixin.MemoryGiBPerVCpuRequestProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    memory_mib: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSpotFleetPropsMixin.MemoryMiBRequestProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    network_bandwidth_gbps: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSpotFleetPropsMixin.NetworkBandwidthGbpsRequestProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    network_interface_count: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSpotFleetPropsMixin.NetworkInterfaceCountRequestProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    on_demand_max_price_percentage_over_lowest_price: typing.Optional[jsii.Number] = None,
    require_encryption_in_transit: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    require_hibernate_support: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    spot_max_price_percentage_over_lowest_price: typing.Optional[jsii.Number] = None,
    total_local_storage_gb: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSpotFleetPropsMixin.TotalLocalStorageGBRequestProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    v_cpu_count: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSpotFleetPropsMixin.VCpuCountRangeRequestProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c75488536f3f88db6ffa05da35984419ca2926ad0967f45c7f5ad89884367519(
    *,
    launch_template_specification: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSpotFleetPropsMixin.FleetLaunchTemplateSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    overrides: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSpotFleetPropsMixin.LaunchTemplateOverridesProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b3a64607d59b50bd2cb6c4d5fd37e260ff2b938153fd2140afc087bb871422d2(
    *,
    availability_zone: typing.Optional[builtins.str] = None,
    availability_zone_id: typing.Optional[builtins.str] = None,
    instance_requirements: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSpotFleetPropsMixin.InstanceRequirementsRequestProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    instance_type: typing.Optional[builtins.str] = None,
    priority: typing.Optional[jsii.Number] = None,
    spot_price: typing.Optional[builtins.str] = None,
    subnet_id: typing.Optional[builtins.str] = None,
    weighted_capacity: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__49ea85e92adc29df7245f72ff55eccb4d1db4df9ef1b0af7b9bdefa3165b05a9(
    *,
    classic_load_balancers_config: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSpotFleetPropsMixin.ClassicLoadBalancersConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    target_groups_config: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSpotFleetPropsMixin.TargetGroupsConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__11686429a98363db4d46a8d1f10756c5a7acbcf2a9cc910b31593b90b5c6ebe8(
    *,
    max: typing.Optional[jsii.Number] = None,
    min: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d1e2fa5fff6920cc58bed08039649976beccf8b75f95d79b2ba38d7365633a2c(
    *,
    max: typing.Optional[jsii.Number] = None,
    min: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__af81bfcfde979558236e806980aa5380f4f9da4ce2bf8a9f2592e1ee46490a92(
    *,
    max: typing.Optional[jsii.Number] = None,
    min: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__24b7c82b06cf6240eb761dd6009e321aefecb3347e9d4cc5bca247e691eb129e(
    *,
    max: typing.Optional[jsii.Number] = None,
    min: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b66bd22ec6b05a97963d256c1fc122f7f832427389b677050771b18094c4606f(
    *,
    instance_family: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__058c4a3b9295b29299d6c7cfefebb8e884ae4e91e57dd3875b19482034a369d6(
    *,
    primary: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    private_ip_address: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3877a7ee660dca966e7a74d2803c625b6364ee9ecb866a49975dbd0423c5817d(
    *,
    replacement_strategy: typing.Optional[builtins.str] = None,
    termination_delay: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__590a4850e9f8a2e6d3fe03fc10276fcc66c9bc20bdbff4ae9c551fd48a40841a(
    *,
    block_device_mappings: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSpotFleetPropsMixin.BlockDeviceMappingProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    ebs_optimized: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    iam_instance_profile: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSpotFleetPropsMixin.IamInstanceProfileSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    image_id: typing.Optional[builtins.str] = None,
    instance_requirements: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSpotFleetPropsMixin.InstanceRequirementsRequestProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    instance_type: typing.Optional[builtins.str] = None,
    kernel_id: typing.Optional[builtins.str] = None,
    key_name: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSpotFleetPropsMixin.SpotFleetMonitoringProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    network_interfaces: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSpotFleetPropsMixin.InstanceNetworkInterfaceSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    placement: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSpotFleetPropsMixin.SpotPlacementProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    ramdisk_id: typing.Optional[builtins.str] = None,
    security_groups: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSpotFleetPropsMixin.GroupIdentifierProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    spot_price: typing.Optional[builtins.str] = None,
    subnet_id: typing.Optional[builtins.str] = None,
    tag_specifications: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSpotFleetPropsMixin.SpotFleetTagSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    user_data: typing.Optional[builtins.str] = None,
    weighted_capacity: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4ba67d212dfaefded8c831e6697d6dc0f148b37b5a0f54626ee8c10cb982fc8e(
    *,
    enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b1ec370e55f4f7fd85594edb603fb608fe8b4c2437da2b45e99f14dedd332939(
    *,
    allocation_strategy: typing.Optional[builtins.str] = None,
    context: typing.Optional[builtins.str] = None,
    excess_capacity_termination_policy: typing.Optional[builtins.str] = None,
    iam_fleet_role: typing.Optional[builtins.str] = None,
    instance_interruption_behavior: typing.Optional[builtins.str] = None,
    instance_pools_to_use_count: typing.Optional[jsii.Number] = None,
    launch_specifications: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSpotFleetPropsMixin.SpotFleetLaunchSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    launch_template_configs: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSpotFleetPropsMixin.LaunchTemplateConfigProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    load_balancers_config: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSpotFleetPropsMixin.LoadBalancersConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    on_demand_allocation_strategy: typing.Optional[builtins.str] = None,
    on_demand_max_total_price: typing.Optional[builtins.str] = None,
    on_demand_target_capacity: typing.Optional[jsii.Number] = None,
    replace_unhealthy_instances: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    spot_maintenance_strategies: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSpotFleetPropsMixin.SpotMaintenanceStrategiesProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    spot_max_total_price: typing.Optional[builtins.str] = None,
    spot_price: typing.Optional[builtins.str] = None,
    tag_specifications: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSpotFleetPropsMixin.SpotFleetTagSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    target_capacity: typing.Optional[jsii.Number] = None,
    target_capacity_unit_type: typing.Optional[builtins.str] = None,
    terminate_instances_with_expiration: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    type: typing.Optional[builtins.str] = None,
    valid_from: typing.Optional[builtins.str] = None,
    valid_until: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e08f3b3eb4e35ea5e82da817f57426310427be9f0ffc368f6036293cd4b3df2b(
    *,
    resource_type: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b3ca4282d9de7eacbbe14fb630b74aa87aad91f70de3e68a8a82038b1a640694(
    *,
    capacity_rebalance: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSpotFleetPropsMixin.SpotCapacityRebalanceProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5a3a2a1f3abc58fdcdf56deba2f376b7701208da8a15036ec33fb568a17bdbbe(
    *,
    availability_zone: typing.Optional[builtins.str] = None,
    availability_zone_id: typing.Optional[builtins.str] = None,
    group_name: typing.Optional[builtins.str] = None,
    tenancy: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__92bd05f4e7452f72b949ba3ed0c3aef92434e3c4a85510af4d0a7e462bab2446(
    *,
    arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__128a7e8614c6bf1b26e7074fb3f64b5257df6948d97d0f217f1241a155a229af(
    *,
    target_groups: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSpotFleetPropsMixin.TargetGroupProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6cd5026f702085387dfd1a05ed4853dd4dbfdcfd6fe76ddcf663fc1e2f33006c(
    *,
    max: typing.Optional[jsii.Number] = None,
    min: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b0a82c744bd8760d1b438d02963d61fde3f52c42068d1e221b027444481e6dcf(
    *,
    max: typing.Optional[jsii.Number] = None,
    min: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c05c7b9ee0dc80bf0a91d1b37bd02bff47f969d1ef733fc9dbd2e3a2b4f861ad(
    *,
    ipv6_cidr_block: typing.Optional[builtins.str] = None,
    ipv6_ipam_pool_id: typing.Optional[builtins.str] = None,
    ipv6_netmask_length: typing.Optional[jsii.Number] = None,
    subnet_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__89ed88def6856b14ed205ebd7fa4e48efe4ff61f6ecf299987d19776462ce3c2(
    props: typing.Union[CfnSubnetCidrBlockMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0df00c1cdb2ca1aab7675ca08ffb2ac6d635a0aedb62507f021d5c15d7e6af5c(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d1c35cf9405dcacebb4d348b23087b9187d7ae5e491b9e08b5b553806a67a597(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__771798dee7e8266a793c3f1fac5bf867741a2f20c8b91b6cca8759f8bd31c0f0(
    *,
    assign_ipv6_address_on_creation: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    availability_zone: typing.Optional[builtins.str] = None,
    availability_zone_id: typing.Optional[builtins.str] = None,
    cidr_block: typing.Optional[builtins.str] = None,
    enable_dns64: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    enable_lni_at_device_index: typing.Optional[jsii.Number] = None,
    ipv4_ipam_pool_id: typing.Optional[builtins.str] = None,
    ipv4_netmask_length: typing.Optional[jsii.Number] = None,
    ipv6_cidr_block: typing.Optional[builtins.str] = None,
    ipv6_ipam_pool_id: typing.Optional[builtins.str] = None,
    ipv6_native: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    ipv6_netmask_length: typing.Optional[jsii.Number] = None,
    map_public_ip_on_launch: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    outpost_arn: typing.Optional[builtins.str] = None,
    private_dns_name_options_on_launch: typing.Any = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    vpc_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a9329e7e6beb773cd9c72e9bc20f0d3c268f21197aa72d1ba622e147d8ba73db(
    *,
    network_acl_id: typing.Optional[builtins.str] = None,
    subnet_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0bbc188eec434567d74789ca31308b5acf269e8aa334322d20c8206ed818ab0e(
    props: typing.Union[CfnSubnetNetworkAclAssociationMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0f1028b0deacb0d57bdfeb3dc75573879fdadfbde1da32db66f631b0cadb33a4(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3f39e6b95cf61bd3c683c7679b24f0f138cf935a3d9d7053450e33d7629a846a(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__59f8a2469aad8a8da9e708c435e6c9e09a4ea8fb547a875cd5904f6f11038012(
    props: typing.Union[CfnSubnetMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d976942109b59c9440e60ebd509d45ea96029cda6bbb4fe21b8fdbdc57608304(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__049073d365e1102a1b0df677d9b8f3936814159d4158bdc4dd2e718bc464be51(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b534f85b7681a8198f45e9f1c7aff3fed785c4dece139cf5271c0781ffa58aa4(
    *,
    internet_gateway_block_mode: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__07e13c208916d0a3bf09054385b09dd01702f6abab7341f485d1c9716654dd4c(
    *,
    enable_resource_name_dns_aaaa_record: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    enable_resource_name_dns_a_record: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    hostname_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2ceb2a5b65d7fa8dedbe8791bd3e994b77986328fd61aa30dd1f878bcdae0e41(
    *,
    route_table_id: typing.Optional[builtins.str] = None,
    subnet_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7f4b887eb791e565652bd3bae7db9022115f3e131149383527fa8d928a9ab161(
    props: typing.Union[CfnSubnetRouteTableAssociationMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ca1b6ef0ab384a858aafe026e5d39714d33c0cf646fd53423fbb6f337d2b980e(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__30376dc42fa5525fcb65864fe936efb8f867ea2cdcc664aad92af8b8aa229ee6(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9ff677402d4737eedcda1bbd25d225e2b429b785e9913de2586b9e15b564e69a(
    *,
    description: typing.Optional[builtins.str] = None,
    network_services: typing.Optional[typing.Sequence[builtins.str]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f95d90b81d5b8e15ed6c91f2af8cda71b9fe03f76ad3a25821ac0031618863a4(
    props: typing.Union[CfnTrafficMirrorFilterMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__52c0218d2c5f26ebd4653730975815450cfd6f603793bffa3533c4ee616e4c3c(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d3732dd7678f733ddae3cb7134912c741425cbe54bba83225c98d5f0bcc66eae(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__53844a1e97754bc769828633ccee88b7e03ee5632bfc0f9428826192f7381135(
    *,
    description: typing.Optional[builtins.str] = None,
    destination_cidr_block: typing.Optional[builtins.str] = None,
    destination_port_range: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTrafficMirrorFilterRulePropsMixin.TrafficMirrorPortRangeProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    protocol: typing.Optional[jsii.Number] = None,
    rule_action: typing.Optional[builtins.str] = None,
    rule_number: typing.Optional[jsii.Number] = None,
    source_cidr_block: typing.Optional[builtins.str] = None,
    source_port_range: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTrafficMirrorFilterRulePropsMixin.TrafficMirrorPortRangeProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    traffic_direction: typing.Optional[builtins.str] = None,
    traffic_mirror_filter_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a1e71646a6aae164f10e21421243dd1eba9397f02c12321907678b9b9b84ebcc(
    props: typing.Union[CfnTrafficMirrorFilterRuleMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d0788a004a1029aa94d3770a0bf7f9727b9170bc0ae2950082dcbb0a220e3bbf(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1ed0c8a342ace0d0199af7492d39144ef758fc5aa9419a39a8db5ce71e9dc5eb(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8a0c8752d8e57bea74a0499dbbdd6cff6a361dbaf57ecbfbf40d79b8cc361ca9(
    *,
    from_port: typing.Optional[jsii.Number] = None,
    to_port: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3a4aeebe11b7fbc88937ec497a7c269e6214c98bf400709cdd06b42bca7e08fd(
    *,
    description: typing.Optional[builtins.str] = None,
    network_interface_id: typing.Optional[builtins.str] = None,
    owner_id: typing.Optional[builtins.str] = None,
    packet_length: typing.Optional[jsii.Number] = None,
    session_number: typing.Optional[jsii.Number] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    traffic_mirror_filter_id: typing.Optional[builtins.str] = None,
    traffic_mirror_target_id: typing.Optional[builtins.str] = None,
    virtual_network_id: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1ef3915bae29f93280652433ee0d270502109724f2164f810556d056966b1588(
    props: typing.Union[CfnTrafficMirrorSessionMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__52708850da0c8e9021563f0d623e2a8587407f68f82aad2fbe805c863b93b0d6(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bc85e1a832cf1b014a0f43c075a572bdf0fa900570e959f076270c38b01b2fc0(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bd8b70d6f10941440da8e9816f2fb1e1aaa2d1fcf2b2c97eb14a680c2a120189(
    *,
    description: typing.Optional[builtins.str] = None,
    gateway_load_balancer_endpoint_id: typing.Optional[builtins.str] = None,
    network_interface_id: typing.Optional[builtins.str] = None,
    network_load_balancer_arn: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__84f4d3c6913140ac4781fd420af9ea1879c04995def0a3f0155b2bf35347df35(
    props: typing.Union[CfnTrafficMirrorTargetMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5c2c9cb7dd214acd9777b62a42e0816acbbcd85c1d06486ff681e0925dd7a344(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5e978cb9223bf8caebd43f1c526856bebf51262ecd86b3418c920552df02b462(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__66b1674979a5d87427e5ab508a97598886cd5ed3521192281fc173069d361e41(
    *,
    options: typing.Any = None,
    subnet_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    transit_gateway_id: typing.Optional[builtins.str] = None,
    vpc_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__feb3392659ab813f1c84b53ef60d90b1d2fad0238792e934344cffcbb6c3f943(
    props: typing.Union[CfnTransitGatewayAttachmentMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7f9f4bf9b8235b64c7358b24ad286d90632cb7f23a2d625f9c5d36d1ed81f068(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__531d75a42bed048789a602eaf4dc2a1ef43e59a599915933597da6d31b7e8ddd(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c7676a9419e73b003af1c40e50eb49773519c9b614906d0b3d4c5c4aa2ff0182(
    *,
    appliance_mode_support: typing.Optional[builtins.str] = None,
    dns_support: typing.Optional[builtins.str] = None,
    ipv6_support: typing.Optional[builtins.str] = None,
    security_group_referencing_support: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a421f1f5a7d087a17f854e565d94071332727d4d626f076ad964e99bb88d3f1f(
    *,
    options: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTransitGatewayConnectPropsMixin.TransitGatewayConnectOptionsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    transport_transit_gateway_attachment_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5572c10bd69825252985ec68d17f1639d84347d3747593b596d258c37379054c(
    *,
    connect_peer_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTransitGatewayConnectPeerPropsMixin.TransitGatewayConnectPeerConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    transit_gateway_attachment_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c796b3f9c936b625b1f3463d365920c8f89319c4e84b4237703aa71d3f543183(
    props: typing.Union[CfnTransitGatewayConnectPeerMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fc0d7196c0f811ec671ff9c052b55b322bd54fd2bd43c3c40252f41ca509dcf9(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c9cee46f7f4119c441f48169a2a4f5b9125976fab2f9c39f5ed2b0a6c68dca4a(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__35d4a18eb834ecda51f1114fb8390e50bfdb3bd509007469d70a611676250907(
    *,
    bgp_status: typing.Optional[builtins.str] = None,
    peer_address: typing.Optional[builtins.str] = None,
    peer_asn: typing.Optional[jsii.Number] = None,
    transit_gateway_address: typing.Optional[builtins.str] = None,
    transit_gateway_asn: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__259b5818f377e940acedf1832400b8afa7b53a4ecd9571c2ff53374b05f9f442(
    *,
    bgp_configurations: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTransitGatewayConnectPeerPropsMixin.TransitGatewayAttachmentBgpConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    inside_cidr_blocks: typing.Optional[typing.Sequence[builtins.str]] = None,
    peer_address: typing.Optional[builtins.str] = None,
    protocol: typing.Optional[builtins.str] = None,
    transit_gateway_address: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__436486e704255d0ddaf235b28986a31522aefaaffcbd8f737d91e178a9e7e188(
    props: typing.Union[CfnTransitGatewayConnectMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__254b168971e4e9d8108333fd2081a2cbcf741d31a99fbd5fbe0babf7a7dfc529(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aefa54b0f198dfd336f7e10374732f1846fe63783757a683cb2a593a45fc83a2(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__062a1ebfe6d2917213f502964e2c725c0a6a7a5b885a4f4444c3d669aab27948(
    *,
    protocol: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dfec8e5a3a3fd9308edfbcdce4d6b6b3f6b096c55a368fe924ac09ceb49dee02(
    *,
    destination_cidr_block: typing.Optional[builtins.str] = None,
    destination_port_range: typing.Optional[builtins.str] = None,
    destination_transit_gateway_attachment_id: typing.Optional[builtins.str] = None,
    destination_transit_gateway_attachment_type: typing.Optional[builtins.str] = None,
    metered_account: typing.Optional[builtins.str] = None,
    policy_rule_number: typing.Optional[jsii.Number] = None,
    protocol: typing.Optional[builtins.str] = None,
    source_cidr_block: typing.Optional[builtins.str] = None,
    source_port_range: typing.Optional[builtins.str] = None,
    source_transit_gateway_attachment_id: typing.Optional[builtins.str] = None,
    source_transit_gateway_attachment_type: typing.Optional[builtins.str] = None,
    transit_gateway_metering_policy_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1c5486d68a10b7bdf3feb329c2977068a535c3efe0a59e2f6eaca28d32edce01(
    props: typing.Union[CfnTransitGatewayMeteringPolicyEntryMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__faf39b958d056eeb58b1e73eea0857162b49ee5f3d93a040c17a6e1deba4c932(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__883c459e2c40b59ee2aceb34c9ec52c9532768d8ef5a4c3fcb229052834f01bc(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5837c538c737659c1bc37f08df3cc2d5f46d4ab8f7cfe3aa0e33f2173bbdfcb8(
    *,
    middlebox_attachment_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    transit_gateway_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bad7870e3fa7e0fea9b98497268f34f4497615553145c0bf871a27daa31a8cb5(
    props: typing.Union[CfnTransitGatewayMeteringPolicyMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d8cece32e4f1e152330ef6ad200ec54ee4da4a4ae76876a7fe11efbcfdb4d3a0(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2acbf5cf3cc4069ecfdf89c6a2ddd171b42e45e470fb92a1f248e9ecb1c9cb25(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d8faa244d705b8f04cbc8c43fd4190155541b670d1ef7cca2675c798d5465ddf(
    *,
    amazon_side_asn: typing.Optional[jsii.Number] = None,
    association_default_route_table_id: typing.Optional[builtins.str] = None,
    auto_accept_shared_attachments: typing.Optional[builtins.str] = None,
    default_route_table_association: typing.Optional[builtins.str] = None,
    default_route_table_propagation: typing.Optional[builtins.str] = None,
    description: typing.Optional[builtins.str] = None,
    dns_support: typing.Optional[builtins.str] = None,
    encryption_support: typing.Optional[builtins.str] = None,
    multicast_support: typing.Optional[builtins.str] = None,
    propagation_default_route_table_id: typing.Optional[builtins.str] = None,
    security_group_referencing_support: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    transit_gateway_cidr_blocks: typing.Optional[typing.Sequence[builtins.str]] = None,
    vpn_ecmp_support: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cfd7ec3a33d6a52b74a914bde55eac2f9f35145134d4b20245c74fef4f38240e(
    *,
    subnet_id: typing.Optional[builtins.str] = None,
    transit_gateway_attachment_id: typing.Optional[builtins.str] = None,
    transit_gateway_multicast_domain_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__29eb5b80c6dd8d914dfbc13eb1967882781a698ba03603ab6fb7df60b8233e77(
    props: typing.Union[CfnTransitGatewayMulticastDomainAssociationMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0113753f527f08d6dc9dcb672fc597fe40af7a5d65bc3ab457a9b3a2d307b8d8(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__19492ab313f9d17cc5ed725236325cb7e2a4e960100acdd74a8161ed7f7201ba(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6fe210755118d419d255748b8aa8d4666cbe43f57ed9866a1f3403e380b4176d(
    *,
    options: typing.Any = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    transit_gateway_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__39c25bb1802bf005ca5c8a974cb270f8fb5ffccef53ab6aed3beebd284056959(
    props: typing.Union[CfnTransitGatewayMulticastDomainMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7ebe9297fca248b90daa695cd71bec28bf8bb49321f9f707fbc77e564a1426c3(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__03f79e2689372361c9bb54e391eee52cd4d6708cbdd21a70603129d92c64d659(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6bb60b7351f1225e250f3805ebeff0d2ceae255073fa9b9d6bdc94a4c0265ec1(
    *,
    auto_accept_shared_associations: typing.Optional[builtins.str] = None,
    igmpv2_support: typing.Optional[builtins.str] = None,
    static_sources_support: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__afdeadd200b6c7cb8d041d27c9db457e938a4c08f30b5de462537169cd7a0621(
    *,
    group_ip_address: typing.Optional[builtins.str] = None,
    network_interface_id: typing.Optional[builtins.str] = None,
    transit_gateway_multicast_domain_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__24cee9eab2caa8fc039b5b54d0f3870b0205fdf9da18972b997efdf30cb8d189(
    props: typing.Union[CfnTransitGatewayMulticastGroupMemberMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__54d0eafd4606dffd74414872b6dce3cfb968c6e10059a6d46984562017680590(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__abc60d97d6b206afb8ab1937a32cf1267832733152622db340bef31173c5085c(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c00c2686dbddd535910594c09a058e130181a174b62a239c625cb9eb3661ff80(
    *,
    group_ip_address: typing.Optional[builtins.str] = None,
    network_interface_id: typing.Optional[builtins.str] = None,
    transit_gateway_multicast_domain_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4a8e33049cdafd33da47bfcde28e559057f05fd0c62fe02a52a495321599d32a(
    props: typing.Union[CfnTransitGatewayMulticastGroupSourceMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a23049a9cee3ed6b5eb1a8fe2cf623365b949a9b94c23ee089101ae121c9731d(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7ddb2bff178a0929e372216d3d58706b068c59ed1a50c42eaec5de9b74d9e1e2(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d31ffa147e1e7b5b766037944e74f3bfc55b5f7e70e2dbeef51eca493dcdbf2c(
    *,
    peer_account_id: typing.Optional[builtins.str] = None,
    peer_region: typing.Optional[builtins.str] = None,
    peer_transit_gateway_id: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    transit_gateway_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__daa37515a3ed6ce3bfa75522d5ec472ed1213f3de0a0acbc70128a73372dec6f(
    props: typing.Union[CfnTransitGatewayPeeringAttachmentMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__534af58b9a1dc1a96ddef6f404832f93722eecc32faeabbbdb259ae819dc6c5c(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bd0e439cd040c764c200dc86bbf76068e959be5694e218be02f3c9df1d85e793(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b6b7a424b10036ae8e91a67ef29fb58b71e74fcd40c9b8f7b153683c89a5f12e(
    *,
    code: typing.Optional[builtins.str] = None,
    message: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__99b01d146274e3ea2e886453c93fb4839388bc60006eb0879459475cac975a2c(
    props: typing.Union[CfnTransitGatewayMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b448f1c7bc72679a7e83ae0032a9fd27ede6fb463c22e79502419b91cc798f08(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3197d6db2ae61ea2ff782114a7728d491747c4e6667f7f7e67a6a9f02a3b3bf5(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__37b59112ae227a05bd5fb38b79ebe8797ef771ea1c0dd7a16c0c4ec297ec2130(
    *,
    blackhole: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    destination_cidr_block: typing.Optional[builtins.str] = None,
    transit_gateway_attachment_id: typing.Optional[builtins.str] = None,
    transit_gateway_route_table_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fb03427bfd8102835f463d8ec7c5f98843dec12f464eb08d0d2e88753a308bb0(
    props: typing.Union[CfnTransitGatewayRouteMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9a8c840d296a60a0fdfeaf0ef68f1b654cdef7723b5ec664d7013722169848a6(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__559f237aabbd05028edf0dc901ab5cc6e1e4d77b910977d95e4702d6afae5410(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c62a8711ce5ac4927f2aaf1c8a1781c7a2975399fbfa5d3183807dbe15607ae0(
    *,
    transit_gateway_attachment_id: typing.Optional[builtins.str] = None,
    transit_gateway_route_table_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__77388eca20ce8172ef79145a6dc85d0731f653f5ad59821becdb9b30bcc82d20(
    props: typing.Union[CfnTransitGatewayRouteTableAssociationMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0c7592b111d5c68e5e5f874e5c9972b4cb74c7845300e2bcfc8904525806b6e5(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8d4b15a32d672c840996d4a8eaf164f3bb3ae3310a3e0510c39951768e427f98(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2e3bfeed4cab4d1ed31b52a1027e8d1b2d61a2a1f055c5bffd6689a3d628a32d(
    *,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    transit_gateway_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6862d94d883d80c4799ea6da18cd54a3fd34d7efad2e5a6ac9fbb6cc099c7443(
    *,
    transit_gateway_attachment_id: typing.Optional[builtins.str] = None,
    transit_gateway_route_table_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a43fd9adf557da26c7e22b8048e8c03b3dcbd41282180821f7f301fce9fe6a80(
    props: typing.Union[CfnTransitGatewayRouteTablePropagationMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b2e8a1062725b76c30304e082b6f52cf7b96bb441083368797e84882f100b280(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5f91dce607325b1640590c030e9294eb67e669693cf43b928f0786dce9b385ca(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b0f5c75e699056727935d96d57159b4a7ddb400085f70cba4e5877b8f5bcf277(
    props: typing.Union[CfnTransitGatewayRouteTableMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b3a5eb9101667d4b7d35c0368d7ee50558cd6dd5dc31f0a785a5014f01545ecd(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d2914e74b9510af1136c660897a0d1821e67cbbf1baf572f6f99877b3e64c893(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0ff8c07cdfa2dcce447879c858756044631c5a5c6d685b2c7383d797630fe8ff(
    *,
    add_subnet_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    options: typing.Any = None,
    remove_subnet_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    subnet_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    transit_gateway_id: typing.Optional[builtins.str] = None,
    vpc_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8388609bf434ff15ea27c7892eecc060de483d97ccab63f68b823cc0a48fecf7(
    props: typing.Union[CfnTransitGatewayVpcAttachmentMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1bb789e27a0a5dee2eae55c3b878134f4d1c7505914f076b93aab1e35829b387(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9c974e3e4cab73dd75d253c2a8bfd147d95d9659e8aa1897b692c6501f04f63b(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fce0195e9aefe8f4e8eff0561ea402cab82ba8bb74e16fabcdcebe70642c1282(
    *,
    appliance_mode_support: typing.Optional[builtins.str] = None,
    dns_support: typing.Optional[builtins.str] = None,
    ipv6_support: typing.Optional[builtins.str] = None,
    security_group_referencing_support: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2462f2371f9976d39e27d934a8c71e50e0e41bf36e0ed7a8b0a58838ec393aa5(
    *,
    internet_gateway_exclusion_mode: typing.Optional[builtins.str] = None,
    subnet_id: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    vpc_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0b33c36cb443589e1b1d91fbca135d7190a23c3a01f9f32035736983732edad2(
    props: typing.Union[CfnVPCBlockPublicAccessExclusionMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4f44dadd5ef35c404c22e16f970ca4af8a756f50136704849691d7d8f8f63b53(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f72f461191175accb04457b0065b1b85d48b80bd91a7dab6d48f256c8b533353(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b2202abd4805207696b1d333fb54a66e2a44b6eab0a70410f00c2973a42d6b7a(
    *,
    internet_gateway_block_mode: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b269b067c01263243b7246eb108a608f1723c6a81da06fbf607b02e5de0f585e(
    props: typing.Union[CfnVPCBlockPublicAccessOptionsMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4e31ffe2ebd46af975ed424c636462c891b393e9fd94c97b485b80b1303c1aed(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0df69515c2758726c9de3723736f82004424304ff5889cf5e3b309b93be638cb(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cedc65c831e938332ea4497119893e59a8cbeb73ac6549d57b68114fa80a6ba7(
    *,
    amazon_provided_ipv6_cidr_block: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    cidr_block: typing.Optional[builtins.str] = None,
    ipv4_ipam_pool_id: typing.Optional[builtins.str] = None,
    ipv4_netmask_length: typing.Optional[jsii.Number] = None,
    ipv6_cidr_block: typing.Optional[builtins.str] = None,
    ipv6_cidr_block_network_border_group: typing.Optional[builtins.str] = None,
    ipv6_ipam_pool_id: typing.Optional[builtins.str] = None,
    ipv6_netmask_length: typing.Optional[jsii.Number] = None,
    ipv6_pool: typing.Optional[builtins.str] = None,
    vpc_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b6d9b5615428faedd42b7c8d0ea790427ca9773250958803c98c7aba4542b517(
    props: typing.Union[CfnVPCCidrBlockMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b239738bf54ef21fe8a7e11ffb1a17d79f93913552a1207bffe8787f0649356b(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ab7b2fef379165a8df78f5c4d0135192261e3f90b9aa16b4399527d64f1cd7e5(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__980c7775cd7004fe2f3481bc54743c4fa1978913ca3bdeae60560583c6ef597d(
    *,
    dhcp_options_id: typing.Optional[builtins.str] = None,
    vpc_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eee4a0e40fbfd617f61a84677475de97f3a67a459f2bcfaf12e997480fb62aaf(
    props: typing.Union[CfnVPCDHCPOptionsAssociationMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c050e40460c90d92e714d5339aa1bde0a5451e203efed6a370f5b991e4e8876e(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__170c8e8c19d0872dc3ec9ebccbf427dfb8f61a30cf8fd3e6740fe4c42fc97b47(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dd66031af79bba638475a35c56d5370532c56e5a4c5fb9eb0da7bcd75070a5b4(
    *,
    egress_only_internet_gateway_exclusion_input: typing.Optional[builtins.str] = None,
    elastic_file_system_exclusion_input: typing.Optional[builtins.str] = None,
    internet_gateway_exclusion_input: typing.Optional[builtins.str] = None,
    lambda_exclusion_input: typing.Optional[builtins.str] = None,
    mode: typing.Optional[builtins.str] = None,
    nat_gateway_exclusion_input: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    virtual_private_gateway_exclusion_input: typing.Optional[builtins.str] = None,
    vpc_id: typing.Optional[builtins.str] = None,
    vpc_lattice_exclusion_input: typing.Optional[builtins.str] = None,
    vpc_peering_exclusion_input: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__934db54e0e0debd1212bc8914636c6058ddd17302af1742db94e0cfa7b56663b(
    props: typing.Union[CfnVPCEncryptionControlMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4c9937ad1ecd79b9fe1d4af47bcef2252a9fa2471e6f48a5ec8820b969359b83(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3d343fc1ad331171425769a475e5aa31defdae5ea8b97d6a0173ba09e3976228(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__efa550c9c9bc1b33892f97305c641aa0eaad112c61487138db4847777bb189f9(
    *,
    egress_only_internet_gateway: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnVPCEncryptionControlPropsMixin.VpcEncryptionControlExclusionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    elastic_file_system: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnVPCEncryptionControlPropsMixin.VpcEncryptionControlExclusionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    internet_gateway: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnVPCEncryptionControlPropsMixin.VpcEncryptionControlExclusionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    lambda_: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnVPCEncryptionControlPropsMixin.VpcEncryptionControlExclusionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    nat_gateway: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnVPCEncryptionControlPropsMixin.VpcEncryptionControlExclusionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    virtual_private_gateway: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnVPCEncryptionControlPropsMixin.VpcEncryptionControlExclusionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    vpc_lattice: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnVPCEncryptionControlPropsMixin.VpcEncryptionControlExclusionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    vpc_peering: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnVPCEncryptionControlPropsMixin.VpcEncryptionControlExclusionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fa688b8af7f397e7d507108114f733b491e61b8a8a8fb26859b200a1644c765f(
    *,
    state: typing.Optional[builtins.str] = None,
    state_message: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d9588faac6a411b49b45b24ec3e436a51d57660390621568fe3355504514cda1(
    *,
    connection_events: typing.Optional[typing.Sequence[builtins.str]] = None,
    connection_notification_arn: typing.Optional[builtins.str] = None,
    service_id: typing.Optional[builtins.str] = None,
    vpc_endpoint_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__66546bad18e895482ab5e0c2ac2da77a8414fcf1bbd83a604be08742fe656531(
    props: typing.Union[CfnVPCEndpointConnectionNotificationMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f3a313135eb427e9a9acb68da999f3b125fb0965f99a17dd6ee69d0317e343cd(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5fb8722945c3726e2f569edd714d373388f891f55d3673ac93e49ffcfba569e3(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6cccf8c658131dd6b41cdea1ded8eb1eb3e32f26b92b9fe97e9069cbc8fcba8b(
    *,
    dns_options: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnVPCEndpointPropsMixin.DnsOptionsSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    ip_address_type: typing.Optional[builtins.str] = None,
    policy_document: typing.Any = None,
    private_dns_enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    resource_configuration_arn: typing.Optional[builtins.str] = None,
    route_table_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    security_group_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    service_name: typing.Optional[builtins.str] = None,
    service_network_arn: typing.Optional[builtins.str] = None,
    service_region: typing.Optional[builtins.str] = None,
    subnet_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    vpc_endpoint_type: typing.Optional[builtins.str] = None,
    vpc_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__88126a5d8e2eb8ff0a196420b78d273237a21bfafcaa023aec77e01f855c31b7(
    props: typing.Union[CfnVPCEndpointMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__83fd60be923b061afad18cf3a6f024e85650d2a3a62a518745705bd1ec032765(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__28aad4c42483c04e533b0d58ad2ef7b2414c8cdf83820ba27d321e499fc5f290(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__575afcdf1fa1620b498d8ef4d67f4720ed4abc05d8cfb37239525e6c5176765c(
    *,
    dns_record_ip_type: typing.Optional[builtins.str] = None,
    private_dns_only_for_inbound_resolver_endpoint: typing.Optional[builtins.str] = None,
    private_dns_preference: typing.Optional[builtins.str] = None,
    private_dns_specified_domains: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__44ad1e43431863b774297acd3c0cc85b653f53a9b6aed46627ce5f88b3c8b83d(
    *,
    acceptance_required: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    contributor_insights_enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    gateway_load_balancer_arns: typing.Optional[typing.Sequence[builtins.str]] = None,
    network_load_balancer_arns: typing.Optional[typing.Sequence[builtins.str]] = None,
    payer_responsibility: typing.Optional[builtins.str] = None,
    supported_ip_address_types: typing.Optional[typing.Sequence[builtins.str]] = None,
    supported_regions: typing.Optional[typing.Sequence[builtins.str]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dd4359405a6d0f4c1e02a52e7ffe260e68f1e2db81827a191d429338ed6e54ba(
    *,
    allowed_principals: typing.Optional[typing.Sequence[builtins.str]] = None,
    service_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ad0f457242983a8b5eafeaf399e4b0f351040d8e424bcc06c880dc8a8d54dc7a(
    props: typing.Union[CfnVPCEndpointServicePermissionsMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__02c380eaea9c7d3fb917e65ced0ff422ce9b3122319fe5c332ed6106409ef53f(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9788c6b35a7be1b4d710749ba90b5536ff818ec46c45328fdc1fda31465af45f(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__689b0481d86c58487fe3ef4f1a7f074848b9b33e06fb782661b5785dbadc997c(
    props: typing.Union[CfnVPCEndpointServiceMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8cefdfa5611fde6514c1d03b826934abc8300c30d0e89e5b33e67c332af70a4c(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2c2af0d5ecd883ee9e273b123356a26a5e411374748c9b0b0c177acf96483e43(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9a4ba044e87002a7c0c608a9b889ae40b46e726bab31c5769898591ed9bfc99a(
    *,
    internet_gateway_id: typing.Optional[builtins.str] = None,
    vpc_id: typing.Optional[builtins.str] = None,
    vpn_gateway_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6ed02ed6645da599d56f634156bdcdca36ee81e6fd3ffa96adad2d0e83fb17e8(
    props: typing.Union[CfnVPCGatewayAttachmentMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6a681442ff5652f81d5b37cd410701f9fd5198a74e0f0e652bc68ba7fd32b25c(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__358e2a6a9835424bef3b4c17e717ec15f639a6a6711bd1a6c90f0cc6c4554705(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c887737e6727e3b16b8ac6538e1fc7d512b67d7a6e88a3a8d55f6bdb1bc2cf69(
    log_type: builtins.str,
    log_delivery: _ILogsDelivery_0d3c9e29,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2d340aa09c1d4740786b10583283e670e3385659d850c72e307cfce7f4b57111(
    resource: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f2d89c70adb4839231da02fd8662b5c1a1aaff9a33627b917996c39b671375e5(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5e7af0352cc50c2d189bac2a54e6e8b54f9451d43dca90873527483c374d63c2(
    *,
    cidr_block: typing.Optional[builtins.str] = None,
    enable_dns_hostnames: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    enable_dns_support: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    instance_tenancy: typing.Optional[builtins.str] = None,
    ipv4_ipam_pool_id: typing.Optional[builtins.str] = None,
    ipv4_netmask_length: typing.Optional[jsii.Number] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e71139fb6d9dde758b7eaed23f54799a2814446825ab7339143cd3eb53a2d2c2(
    *,
    peer_owner_id: typing.Optional[builtins.str] = None,
    peer_region: typing.Optional[builtins.str] = None,
    peer_role_arn: typing.Optional[builtins.str] = None,
    peer_vpc_id: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    vpc_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__91ed3695f9baf55b0e377156e0dbfee88e003a17d1810ef17bf440eed25eb001(
    props: typing.Union[CfnVPCPeeringConnectionMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__edc96c257152d84f56584a22779ff28c5161a8810b210f200b731d30db3a9360(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__79cd33221ee69aa836462862aaeb17477304bff88eb3bcb83034bd79e6b65ac8(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c3261f3455a7b2b764b6d6f9a0a38471743d6edee7d915b6a868e3d139586fab(
    props: typing.Union[CfnVPCMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f006ddf20f05acca08417b3e6434ae3b2b8d42e706338c8490d56646bbb9ec06(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__01f583f83612274f80e96c0f0a43924803392879106e242a2e339650e9095e32(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1ca4b568a71338f3c7febfbfdaa32660bcde709925defef7af2bf63e9dcff93e(
    delivery_stream: _aws_cdk_interfaces_aws_kinesisfirehose_ceddda9d.IDeliveryStreamRef,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1db7e0342b08f126a3d7da6d9626995ea548898b70250c986a5d3b069704ed9b(
    log_group: _aws_cdk_interfaces_aws_logs_ceddda9d.ILogGroupRef,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__996b4cc3fed52d55989f54f04abafdf6602b02765140574ab2fa594ce76048a8(
    bucket: _aws_cdk_interfaces_aws_s3_ceddda9d.IBucketRef,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e9797ad390530f78befc7925a282e5f08c292a54376983270220e1f9af3e93fa(
    *,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    transit_gateway_id: typing.Optional[builtins.str] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__746ae50d15fdd1db12665eecd9cf88e9f4cbe9d684c175735e3574fb97bc0bc8(
    props: typing.Union[CfnVPNConcentratorMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ef34dcd3dc41aa5e08478b2e3b84d3769d76627181f4444ea69cc7802f184862(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__487c8c35fe9689d4c536dfca80f1adb6fb6915a19bdc420a7ac092c1f06bd291(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0714b7ed6595a643ea3885a2bedf04f9357303454c4affc9a3fdc10377c732f1(
    delivery_stream: _aws_cdk_interfaces_aws_kinesisfirehose_ceddda9d.IDeliveryStreamRef,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__39bc7d8b12a17004e39a23a0d8bbd8a88236ef91b8537b8f147bddd516fda175(
    log_group: _aws_cdk_interfaces_aws_logs_ceddda9d.ILogGroupRef,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d0b3873bd6c3a456c0da217041ae01157cc50e3d845dec1841c6ef1a016d16e6(
    bucket: _aws_cdk_interfaces_aws_s3_ceddda9d.IBucketRef,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dc8632c324459312ee0a9390bbc08e46022375cc1cf328bd0d787ea33834020a(
    delivery_stream: _aws_cdk_interfaces_aws_kinesisfirehose_ceddda9d.IDeliveryStreamRef,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__451c99afcbc205eab7eea65b7e4d1a7dea586391acf5bb4e346cb6bb9fd4d292(
    log_group: _aws_cdk_interfaces_aws_logs_ceddda9d.ILogGroupRef,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__317fbbc6872359002d35ad4f0480f2e397891ae2a57c1ef50d9db91437d7877a(
    bucket: _aws_cdk_interfaces_aws_s3_ceddda9d.IBucketRef,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ce9eac90a24fb3cdf1c98803227fb3bbe2a17fe078982123de1a2d76a7c2ce11(
    log_type: builtins.str,
    log_delivery: _ILogsDelivery_0d3c9e29,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__08bf6c65d68079aa41bf6ac20bf557fe4e3e4f206271bce9ec0c13d770c23dfa(
    resource: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f6109783d1dae3a50b20367a7f158e2dc9aeefa1cc9cc390e5b25713ecc06928(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d36961197217ac5b4c12d11c2bd9b07926f3feeca88c2319cf55f8a02650fa19(
    *,
    customer_gateway_id: typing.Optional[builtins.str] = None,
    enable_acceleration: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    local_ipv4_network_cidr: typing.Optional[builtins.str] = None,
    local_ipv6_network_cidr: typing.Optional[builtins.str] = None,
    outside_ip_address_type: typing.Optional[builtins.str] = None,
    pre_shared_key_storage: typing.Optional[builtins.str] = None,
    remote_ipv4_network_cidr: typing.Optional[builtins.str] = None,
    remote_ipv6_network_cidr: typing.Optional[builtins.str] = None,
    static_routes_only: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    transit_gateway_id: typing.Optional[builtins.str] = None,
    transport_transit_gateway_attachment_id: typing.Optional[builtins.str] = None,
    tunnel_bandwidth: typing.Optional[builtins.str] = None,
    tunnel_inside_ip_version: typing.Optional[builtins.str] = None,
    type: typing.Optional[builtins.str] = None,
    vpn_concentrator_id: typing.Optional[builtins.str] = None,
    vpn_gateway_id: typing.Optional[builtins.str] = None,
    vpn_tunnel_options_specifications: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnVPNConnectionPropsMixin.VpnTunnelOptionsSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__93c5a71a78105c566f373c2a3d7857a336e8cb7cbbc056a187bda3d2b1e4cdb0(
    props: typing.Union[CfnVPNConnectionMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__edb0eaae70aa07208302cf60e867f8da5b2d45f36f88f861192d053468561bdb(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__51fe9fd58d29de38bfad6ccc35f18f30712ff4d73425a454f3df49725595fbd1(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0687c2579296c74b830581e08da772fff83c07de85c93a36e05c29ff35a0a8b0(
    *,
    bgp_log_enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    bgp_log_group_arn: typing.Optional[builtins.str] = None,
    bgp_log_output_format: typing.Optional[builtins.str] = None,
    log_enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    log_group_arn: typing.Optional[builtins.str] = None,
    log_output_format: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2f48208c713c540b4d0e18f4b0151ab73468e7386f69603da7739358f81cac15(
    *,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d9e0fdc6a2ca4ed6463a72f3e7be676f79966e0b2c376b7e78a6b3a41ceb1e10(
    *,
    value: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e396eb3e0debdd8638f8015bbcfbc8bbd8fc345582019d69b073909784222c07(
    *,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e67eb354a95c6770ef14a61fca9fedf03ce399f5cd88e430dd31ec696cc86d35(
    *,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f5b3c8cc4b858f844f0edf19adc67e7b59cf57fba473382454bef9f715c3993a(
    *,
    value: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b3111b3640744debc2d480e551f9d13a885baa62c5c1328b5eff0acd4a6c033a(
    *,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d9a2e5829873eccebc7232236f3d43aba915dff99e60dc5a8c011c1791a179c5(
    *,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9f2c0a56046b918e4a5fde30c670382135eb18acd54fb670e6739ad2b82a98cd(
    *,
    cloudwatch_log_options: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnVPNConnectionPropsMixin.CloudwatchLogOptionsSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4d90f6d35a70cc9b17cde62a94c969899fb8453018d81870249d53ffef1ab445(
    *,
    dpd_timeout_action: typing.Optional[builtins.str] = None,
    dpd_timeout_seconds: typing.Optional[jsii.Number] = None,
    enable_tunnel_lifecycle_control: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    ike_versions: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnVPNConnectionPropsMixin.IKEVersionsRequestListValueProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    log_options: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnVPNConnectionPropsMixin.VpnTunnelLogOptionsSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    phase1_dh_group_numbers: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnVPNConnectionPropsMixin.Phase1DHGroupNumbersRequestListValueProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    phase1_encryption_algorithms: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnVPNConnectionPropsMixin.Phase1EncryptionAlgorithmsRequestListValueProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    phase1_integrity_algorithms: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnVPNConnectionPropsMixin.Phase1IntegrityAlgorithmsRequestListValueProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    phase1_lifetime_seconds: typing.Optional[jsii.Number] = None,
    phase2_dh_group_numbers: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnVPNConnectionPropsMixin.Phase2DHGroupNumbersRequestListValueProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    phase2_encryption_algorithms: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnVPNConnectionPropsMixin.Phase2EncryptionAlgorithmsRequestListValueProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    phase2_integrity_algorithms: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnVPNConnectionPropsMixin.Phase2IntegrityAlgorithmsRequestListValueProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    phase2_lifetime_seconds: typing.Optional[jsii.Number] = None,
    pre_shared_key: typing.Optional[builtins.str] = None,
    rekey_fuzz_percentage: typing.Optional[jsii.Number] = None,
    rekey_margin_time_seconds: typing.Optional[jsii.Number] = None,
    replay_window_size: typing.Optional[jsii.Number] = None,
    startup_action: typing.Optional[builtins.str] = None,
    tunnel_inside_cidr: typing.Optional[builtins.str] = None,
    tunnel_inside_ipv6_cidr: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c4613b28853a38dd76854ee76624922c0925fbcd55a0123b8dec6a1d7f38654b(
    *,
    destination_cidr_block: typing.Optional[builtins.str] = None,
    vpn_connection_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__308dd661ef681ba389803b8210ece10a3e85efa324e3238f3510a4e92874594b(
    props: typing.Union[CfnVPNConnectionRouteMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e743143e29029c23ecaa9bd0f10d0b45d487f24e8ce4c480ff7d755778d1e1cc(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b256ae8317eeb97e69d75b8502e319c9a1293d0d05adc74dc9196be830aceb7e(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c791d14a19f424e0025b79adb0ddcdc1b48b88df3d251d8553009239f2487ac8(
    *,
    amazon_side_asn: typing.Optional[jsii.Number] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2395772c3d93f863c03eaae80a04dc0d8c4eeb63adf1e395844223496691154f(
    props: typing.Union[CfnVPNGatewayMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9068e6163d3d5e198292277515538fe38c265f71abf66ac8555a9fc5b640a355(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__110a364a7015cd3108f031025f6d3a26948aa2b2d82465e8488890c0ea5e68c5(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1a998d1c385190b8f5a08665ec1baef60a7165e7b41eb8c6bf1da39bb716b08c(
    *,
    route_table_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    vpn_gateway_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6c9aae0c85c28669ec453a4f76d68f39baf02b40593b419fd7fff425e9d801c3(
    props: typing.Union[CfnVPNGatewayRoutePropagationMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__55ee5429753b46948a86d9f5d0fa86dbdcf00d1c53ca08b29c541f08db625dfb(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0b471d6f7daa48ba8df996161b63700d1203c233f726b640d0e351cbecd5847f(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c31d950250dc8cb7d342faf82ca0704be2cdd33fcada3d30ce003df952360972(
    *,
    application_domain: typing.Optional[builtins.str] = None,
    attachment_type: typing.Optional[builtins.str] = None,
    cidr_options: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnVerifiedAccessEndpointPropsMixin.CidrOptionsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    description: typing.Optional[builtins.str] = None,
    domain_certificate_arn: typing.Optional[builtins.str] = None,
    endpoint_domain_prefix: typing.Optional[builtins.str] = None,
    endpoint_type: typing.Optional[builtins.str] = None,
    load_balancer_options: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnVerifiedAccessEndpointPropsMixin.LoadBalancerOptionsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    network_interface_options: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnVerifiedAccessEndpointPropsMixin.NetworkInterfaceOptionsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    policy_document: typing.Optional[builtins.str] = None,
    policy_enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    rds_options: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnVerifiedAccessEndpointPropsMixin.RdsOptionsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    security_group_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    sse_specification: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnVerifiedAccessEndpointPropsMixin.SseSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    verified_access_group_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__57212d5bd1543cc2a74331b1f720dda63776dcc4353a36e5e49550fc486304bd(
    props: typing.Union[CfnVerifiedAccessEndpointMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7dd6e601cb6da65392e2393c73b15f3a1721c81ed1ccef07bcc2cf90dc96ef93(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4bc7cf198424e2ed2189a84cfc9e853940010c8e2adfd7d81941c0420027dc61(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fd84ae0ae745e2ca1dde44d27af7f6ff8a80b91004d91fc6a71dcca6f376f70f(
    *,
    cidr: typing.Optional[builtins.str] = None,
    port_ranges: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnVerifiedAccessEndpointPropsMixin.PortRangeProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    protocol: typing.Optional[builtins.str] = None,
    subnet_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3f5ce9f1b4e74a434e675b0da56811246cc2e49ba2fe03014e0c977f02b0790e(
    *,
    load_balancer_arn: typing.Optional[builtins.str] = None,
    port: typing.Optional[jsii.Number] = None,
    port_ranges: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnVerifiedAccessEndpointPropsMixin.PortRangeProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    protocol: typing.Optional[builtins.str] = None,
    subnet_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__59fc6db2db18cf5e517f96ec6e1701cb4331ebdadb23d734f9888adb1cd1de50(
    *,
    network_interface_id: typing.Optional[builtins.str] = None,
    port: typing.Optional[jsii.Number] = None,
    port_ranges: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnVerifiedAccessEndpointPropsMixin.PortRangeProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    protocol: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9be762310dc8d762b930e2b2e95b2b1ed705b309ae679ece382ec9fe126eecfe(
    *,
    from_port: typing.Optional[jsii.Number] = None,
    to_port: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__07ed2784e78d3ce7440899e21878f6001d077a9ba6b7d6a1dbb71273a4bd5f3a(
    *,
    port: typing.Optional[jsii.Number] = None,
    protocol: typing.Optional[builtins.str] = None,
    rds_db_cluster_arn: typing.Optional[builtins.str] = None,
    rds_db_instance_arn: typing.Optional[builtins.str] = None,
    rds_db_proxy_arn: typing.Optional[builtins.str] = None,
    rds_endpoint: typing.Optional[builtins.str] = None,
    subnet_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ef184c0c4b1ef1eee429b57af3a9353a2d930cd7a6c317717667ef0e0c260681(
    *,
    customer_managed_key_enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    kms_key_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__80d1573c04c2fc2fd255d375ebc70aaa0f9f7340d40c4cc16a80fb1f84237384(
    *,
    description: typing.Optional[builtins.str] = None,
    policy_document: typing.Optional[builtins.str] = None,
    policy_enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    sse_specification: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnVerifiedAccessGroupPropsMixin.SseSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    verified_access_instance_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e65be89c082d276eded3f95b92d737be756ce5e8621dcf5a3858f277733afe65(
    props: typing.Union[CfnVerifiedAccessGroupMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7db4756757bd6f69c2f485acf9b576242b1635a586e5c2711f05f443bdd22649(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7a008ad523ad57ca02783cc13849ad7668c4387410541c1899c271fd04e144fd(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4be2a705be44078f99c0fb54ec6f7971b520d6c71a4b1b519dc180d93b035c84(
    *,
    customer_managed_key_enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    kms_key_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ae07f22a595c607ca5dc2de34321c791f4032d11d08567466153bdcce2850c4e(
    log_type: builtins.str,
    log_delivery: _ILogsDelivery_0d3c9e29,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__54835a32a6afbd853ea00f897032ccf9dc2c7e46f0c0a90cbe1de91553b332e9(
    resource: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__594625c13a60e6edd827a5ac0320463c073cc340bdea3c1d85832b548bfdff4b(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__110e8a27e2e550749c0f3a007b0b114b74c5fce0cba9914bee4b356ffdd7515b(
    *,
    cidr_endpoints_custom_sub_domain: typing.Optional[builtins.str] = None,
    description: typing.Optional[builtins.str] = None,
    fips_enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    logging_configurations: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnVerifiedAccessInstancePropsMixin.VerifiedAccessLogsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    verified_access_trust_provider_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    verified_access_trust_providers: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnVerifiedAccessInstancePropsMixin.VerifiedAccessTrustProviderProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6fd1b2499ee4b9a9c510033d9a3ebc57da9e3062c3cf6001d3512718562284aa(
    props: typing.Union[CfnVerifiedAccessInstanceMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2e408f7c1540a8753b1e9b926ea68c12a0b8d2db76365bf2a83cc4b5c3950651(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4a8a5addb8ffaf2fd604fc56e4f9f89880f625f762874b63f57d71613d77840d(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4bc41b6c871cba558f2e52759c5e451ab0e549e65418ccb7023f1685c7b5acaf(
    *,
    enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    log_group: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0999e73772ceedea400414ddab1793fad66547469ac9e49df6823138f97f09ac(
    *,
    delivery_stream: typing.Optional[builtins.str] = None,
    enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0d5a053f7119224f0f396110ad206ceccbb7352d3dffb12da04b80f6037bc392(
    *,
    bucket_name: typing.Optional[builtins.str] = None,
    bucket_owner: typing.Optional[builtins.str] = None,
    enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    prefix: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ff24c9a9db7163375678262308b7778df83a5947b324602c83d6790181d549c2(
    *,
    cloud_watch_logs: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnVerifiedAccessInstancePropsMixin.CloudWatchLogsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    include_trust_context: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    kinesis_data_firehose: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnVerifiedAccessInstancePropsMixin.KinesisDataFirehoseProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    log_version: typing.Optional[builtins.str] = None,
    s3: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnVerifiedAccessInstancePropsMixin.S3Property, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e6b49c9c673246b203a1f1abd420c68dced1d70f59850a13a7542f26738828c3(
    *,
    description: typing.Optional[builtins.str] = None,
    device_trust_provider_type: typing.Optional[builtins.str] = None,
    trust_provider_type: typing.Optional[builtins.str] = None,
    user_trust_provider_type: typing.Optional[builtins.str] = None,
    verified_access_trust_provider_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5cd5cd84b9949f4da82e94244c44605acc59dd84c8be6388034af4dff989bb3d(
    delivery_stream: _aws_cdk_interfaces_aws_kinesisfirehose_ceddda9d.IDeliveryStreamRef,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8631ddd54bc752fc1b1e80f6fbb0577c3bf6aa98d0f75b55b1cbfad5c494b201(
    log_group: _aws_cdk_interfaces_aws_logs_ceddda9d.ILogGroupRef,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cb7a15fd7bacf91708ef6f0fa7c093ae4f43ae36c160360da34a13fb2f4ec45b(
    bucket: _aws_cdk_interfaces_aws_s3_ceddda9d.IBucketRef,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__243e4d6025ee1517428096b67728e728fed5a17e0795ab17f5bf07383d2000d5(
    *,
    description: typing.Optional[builtins.str] = None,
    device_options: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnVerifiedAccessTrustProviderPropsMixin.DeviceOptionsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    device_trust_provider_type: typing.Optional[builtins.str] = None,
    native_application_oidc_options: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnVerifiedAccessTrustProviderPropsMixin.NativeApplicationOidcOptionsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    oidc_options: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnVerifiedAccessTrustProviderPropsMixin.OidcOptionsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    policy_reference_name: typing.Optional[builtins.str] = None,
    sse_specification: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnVerifiedAccessTrustProviderPropsMixin.SseSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    trust_provider_type: typing.Optional[builtins.str] = None,
    user_trust_provider_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b80ed4335d8a431a875a3c625a143d1485772f240e08b07c60e446a9490ecbb9(
    props: typing.Union[CfnVerifiedAccessTrustProviderMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__be5294f10ab1d25c47d883faa069af2253ed22a9c437e4bfb7588e1c1cdd29bf(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0bf23d135e4e697b69ba7cfd571e2906a3e55446abbbf65e304b67aa1e124bff(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1124417ce1fe28d9e4d895df70af80af4b22b66bca0dfdf7e44a4fb44aca8f90(
    *,
    public_signing_key_url: typing.Optional[builtins.str] = None,
    tenant_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3c168e90e3ed3bb6f9ced325c36bc3dc08d8b4a5f29c963446ae3e47d9647f8f(
    *,
    authorization_endpoint: typing.Optional[builtins.str] = None,
    client_id: typing.Optional[builtins.str] = None,
    client_secret: typing.Optional[builtins.str] = None,
    issuer: typing.Optional[builtins.str] = None,
    public_signing_key_endpoint: typing.Optional[builtins.str] = None,
    scope: typing.Optional[builtins.str] = None,
    token_endpoint: typing.Optional[builtins.str] = None,
    user_info_endpoint: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ee9bdcb0c6cad8db84e38243fc0a52f9d683e67623cad9b84ff1112fa524ea41(
    *,
    authorization_endpoint: typing.Optional[builtins.str] = None,
    client_id: typing.Optional[builtins.str] = None,
    client_secret: typing.Optional[builtins.str] = None,
    issuer: typing.Optional[builtins.str] = None,
    scope: typing.Optional[builtins.str] = None,
    token_endpoint: typing.Optional[builtins.str] = None,
    user_info_endpoint: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bb5b7761eb671357148a4ff38002eb6ad9bcd0f423902c8baa520ad6c581581f(
    *,
    customer_managed_key_enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    kms_key_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__24363ff5eefdd3a9c9ba361bf0cd1a02697bb40b9ae9fd7be59bce8b19047a47(
    *,
    device: typing.Optional[builtins.str] = None,
    instance_id: typing.Optional[builtins.str] = None,
    volume_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__527cf76feb26f77bd1741dd91926107ceac1a06268af275b94de9a5c5c73a856(
    props: typing.Union[CfnVolumeAttachmentMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__42d2c0eede422d58b8b86ddfaedc696a0415439e3d172f0fae404d1c0ec28342(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dbd57f54471250bc19e760492eb730b4bac4e908d3fb69a2311d7e44f7618fac(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4c8f1dd17bdc5d6cb18761cf4a6032606365f44f7bdfbc39d4b3937d82c52817(
    *,
    auto_enable_io: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    availability_zone: typing.Optional[builtins.str] = None,
    availability_zone_id: typing.Optional[builtins.str] = None,
    encrypted: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    iops: typing.Optional[jsii.Number] = None,
    kms_key_id: typing.Optional[builtins.str] = None,
    multi_attach_enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    outpost_arn: typing.Optional[builtins.str] = None,
    size: typing.Optional[jsii.Number] = None,
    snapshot_id: typing.Optional[builtins.str] = None,
    source_volume_id: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    throughput: typing.Optional[jsii.Number] = None,
    volume_initialization_rate: typing.Optional[jsii.Number] = None,
    volume_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c118566bdb7e06790caca9feff179e60c93c2bd697aa6695d7695efd1163edb1(
    props: typing.Union[CfnVolumeMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dd9bd4259f6add33f206da0b2fe29bb194bfaa49493b135994e2023bc1e9e0c6(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__06f33ebda76c73c1224960ca1718d6c287573dff4d1774b626ee031d21402038(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass
