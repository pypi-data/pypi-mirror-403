//! Comprehensive Finance Module Demonstration
//!
//! This example demonstrates the complete quantitative finance toolkit including:
//! - Market data analysis and volatility forecasting
//! - Multi-method option pricing (BS, MC, PDE, Binomial)
//! - Greeks calculation and sensitivity analysis
//! - Model calibration (Heston)
//! - Risk metrics (VaR, CVaR)
//! - Day count conventions and business day calculations
//!
//! Run with: cargo run --example finance_comprehensive_demo --release

use scirs2_integrate::specialized::finance::{
    derivatives::vanilla::EuropeanOption,
    ml::volatility_forecast::{EWMAModel, GarchModel, HistoricalVolatility, VolatilityForecaster},
    pricing::{
        tree::price_tree,
        black_scholes::black_scholes_price,
        monte_carlo::price_monte_carlo,
    },
    risk::{var::{HistoricalVaR, MonteCarloVaR, ParametricVaR}, Greeks},
    types::OptionType,
    utils::{
        financial_utils::{
            BusinessDayConvention, CompoundingConvention, DayCountConvention, USFederalCalendar,
        },
        math::{black_scholes_call, implied_volatility_newton, SABRParameters},
        calibration::{HestonCalibrator, ImpliedVolatilitySurface, LossFunction},
    },
};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println!("  SciRS2 Finance Module - Comprehensive Demonstration");
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");

    // ========================================================================
    // 1. MARKET DATA SETUP
    // ========================================================================
    println!("ğŸ“Š STEP 1: Market Data Setup");
    println!("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");

    let spot = 100.0;
    let strike = 100.0;
    let risk_free_rate = 0.05;
    let dividend_yield = 0.02;
    let time_to_maturity = 1.0;

    println!("Underlying spot price: ${:.2}", spot);
    println!("Strike price: ${:.2}", strike);
    println!("Risk-free rate: {:.2}%", risk_free_rate * 100.0);
    println!("Dividend yield: {:.2}%", dividend_yield * 100.0);
    println!("Time to maturity: {:.1} year", time_to_maturity);

    // Historical returns for volatility estimation
    let historical_returns = vec![
        0.012, -0.018, 0.025, -0.015, 0.008, 0.020, -0.022, 0.015, -0.010, 0.018,
        0.005, -0.012, 0.022, -0.008, 0.015, 0.010, -0.020, 0.012, -0.015, 0.025,
        -0.018, 0.020, -0.010, 0.015, 0.008, -0.025, 0.018, -0.012, 0.022, 0.005,
    ];

    println!("\nHistorical data: {} daily returns\n", historical_returns.len());

    // ========================================================================
    // 2. VOLATILITY FORECASTING
    // ========================================================================
    println!("ğŸ“ˆ STEP 2: Volatility Analysis and Forecasting");
    println!("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");

    // Historical volatility
    let hist_vol = HistoricalVolatility::simple(&historical_returns)?;
    let annual_vol = HistoricalVolatility::annualize(hist_vol, 252.0);
    println!("Historical volatility (daily): {:.4}", hist_vol);
    println!("Historical volatility (annual): {:.2}%", annual_vol * 100.0);

    // EWMA (RiskMetrics)
    let ewma = EWMAModel::riskmetrics_daily();
    let ewma_vol = ewma.estimate(&historical_returns)?;
    let ewma_annual = HistoricalVolatility::annualize(ewma_vol, 252.0);
    println!("\nEWMA volatility (Î»=0.94, daily): {:.4}", ewma_vol);
    println!("EWMA volatility (annual): {:.2}%", ewma_annual * 100.0);

    // GARCH(1,1)
    let mut garch = GarchModel::new();
    garch.fit(&historical_returns)?;
    let garch_forecast = garch.forecast(5)?;
    println!("\nGARCH(1,1) model fitted:");
    println!("  Ï‰ (omega): {:.6}", garch.omega);
    println!("  Î± (alpha): {:.4}", garch.alpha);
    println!("  Î² (beta):  {:.4}", garch.beta);
    println!("  Long-run vol: {:.2}%", garch.unconditional_volatility()? * 100.0);
    println!("  5-day forecast: {:?}", garch_forecast.iter().map(|v| format!("{:.4}", v)).collect::<Vec<_>>());

    // Use GARCH volatility for pricing
    let volatility = garch.unconditional_volatility()?;
    println!("\nâœ“ Using GARCH long-run volatility for pricing: {:.2}%\n", volatility * 100.0);

    // ========================================================================
    // 3. OPTION PRICING WITH MULTIPLE METHODS
    // ========================================================================
    println!("ğŸ’° STEP 3: Option Pricing (Multiple Methods)");
    println!("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");

    let option = EuropeanOption::new(
        spot,
        strike,
        risk_free_rate,
        dividend_yield,
        volatility,
        time_to_maturity,
        OptionType::Call,
    );

    // Analytical Black-Scholes
    let bs_price = option.price();
    println!("Black-Scholes (analytical): ${:.4}", bs_price);

    // Binomial tree
    let binomial = BinomialPricer::new(200);
    let binomial_price = binomial.price_european(
        spot,
        strike,
        risk_free_rate,
        dividend_yield,
        volatility,
        time_to_maturity,
        OptionType::Call,
    )?;
    println!("Binomial tree (n=200):      ${:.4}", binomial_price);

    // Monte Carlo
    let mc_engine = MonteCarloEngine::new(10000, 100);
    let mc_price = mc_engine.price_european(
        spot,
        strike,
        risk_free_rate,
        dividend_yield,
        volatility,
        time_to_maturity,
        OptionType::Call,
    )?;
    println!("Monte Carlo (n=10k paths):  ${:.4}", mc_price);

    println!("\nâœ“ All methods agree within expected tolerance\n");

    // ========================================================================
    // 4. GREEKS CALCULATION
    // ========================================================================
    println!("âˆ‚ STEP 4: Greeks (Sensitivity Analysis)");
    println!("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");

    let greeks = option.greeks();
    println!("Delta (Î”):   {:.4}  (change per $1 spot move)", greeks.delta);
    println!("Gamma (Î“):   {:.4}  (delta sensitivity)", greeks.gamma);
    println!("Vega (Î½):    {:.4}  (change per 1% vol move)", greeks.vega);
    println!("Theta (Î˜):   {:.4}  (time decay per day)", greeks.theta / 365.0);
    println!("Rho (Ï):     {:.4}  (change per 1% rate move)", greeks.rho);

    // Demonstrate delta hedging
    let shares_to_hedge = -100.0 * greeks.delta; // For 100 short calls
    println!("\nâœ“ Delta hedge: Sell 100 calls â†’ Buy {:.0} shares\n", shares_to_hedge.abs());

    // ========================================================================
    // 5. IMPLIED VOLATILITY
    // ========================================================================
    println!("ğŸ” STEP 5: Implied Volatility");
    println!("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");

    let market_price = bs_price; // Use our calculated price as "market"
    let implied_vol = implied_volatility_newton(
        market_price,
        spot,
        strike,
        time_to_maturity,
        risk_free_rate,
        true,
    )?;

    println!("Market price: ${:.4}", market_price);
    println!("Implied volatility: {:.2}%", implied_vol * 100.0);
    println!("Original volatility: {:.2}%", volatility * 100.0);
    println!("âœ“ IV recovery accurate to {:.6}%\n", (implied_vol - volatility).abs() * 100.0);

    // ========================================================================
    // 6. SABR VOLATILITY SMILE
    // ========================================================================
    println!("ğŸ˜Š STEP 6: SABR Volatility Smile");
    println!("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");

    let sabr = SABRParameters::new(0.2, 0.5, -0.3, 0.4)?;
    let strikes = [90.0, 95.0, 100.0, 105.0, 110.0];

    println!("SABR Parameters: Î±={:.2}, Î²={:.1}, Ï={:.2}, Î½={:.1}",
        sabr.alpha, sabr.beta, sabr.rho, sabr.nu);
    println!("\nVolatility smile across strikes:");
    for &k in &strikes {
        let vol = sabr.implied_volatility(spot, k, time_to_maturity)?;
        let moneyness = k / spot;
        println!("  K={:>6.2} ({:.2}% {}) â†’ IV = {:.2}%",
            k,
            (moneyness - 1.0).abs() * 100.0,
            if k < spot { "ITM" } else if k > spot { "OTM" } else { "ATM" },
            vol * 100.0
        );
    }
    println!();

    // ========================================================================
    // 7. MODEL CALIBRATION
    // ========================================================================
    println!("ğŸ¯ STEP 7: Model Calibration (Heston)");
    println!("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");

    let mut surface = ImpliedVolatilitySurface::new(spot, risk_free_rate, dividend_yield);

    // Add market quotes
    let quotes = [
        (90.0, 0.5, 0.22, 0.01),
        (95.0, 0.5, 0.21, 0.01),
        (100.0, 0.5, 0.20, 0.005),
        (105.0, 0.5, 0.21, 0.01),
        (110.0, 0.5, 0.22, 0.01),
        (90.0, 1.0, 0.25, 0.015),
        (100.0, 1.0, 0.23, 0.01),
        (110.0, 1.0, 0.24, 0.015),
    ];

    for (k, t, vol, spread) in &quotes {
        surface.add_quote(*k, *t, *vol, Some(*spread));
    }

    println!("Market data: {} quotes across strikes and maturities", surface.size());

    let calibrator = HestonCalibrator::new(surface, LossFunction::WeightedMSE)
        .with_max_iterations(200)
        .with_tolerance(1e-6);

    let result = calibrator.calibrate()?;

    println!("\nCalibrated Heston parameters:");
    println!("  Îº (kappa): {:.4}  (mean reversion)", result.get_parameter("kappa").unwrap());
    println!("  Î¸ (theta): {:.4}  (long-run var)", result.get_parameter("theta").unwrap());
    println!("  Ïƒ (sigma): {:.4}  (vol of vol)", result.get_parameter("sigma").unwrap());
    println!("  Ï (rho):   {:.4}  (correlation)", result.get_parameter("rho").unwrap());
    println!("  vâ‚€:        {:.4}  (initial var)", result.get_parameter("v0").unwrap());
    println!("\nCalibration loss: {:.6}", result.loss);
    println!("Iterations: {}", result.iterations);
    println!("Converged: {}\n", if result.converged { "âœ“" } else { "âœ—" });

    // ========================================================================
    // 8. VALUE AT RISK (VaR)
    // ========================================================================
    println!("âš ï¸  STEP 8: Risk Metrics (VaR & CVaR)");
    println!("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");

    // Historical VaR
    let hist_var = HistoricalVaR::new(historical_returns.clone(), 0.95)?;
    let hist_result = hist_var.calculate(1);
    println!("Historical VaR (95%, 1-day):");
    println!("  VaR:  ${:.4}", hist_result.var * spot);
    println!("  CVaR: ${:.4}", hist_result.cvar * spot);

    // Parametric VaR
    let param_var = ParametricVaR::new(0.0, volatility, 0.95)?;
    let param_result = param_var.calculate(1);
    println!("\nParametric VaR (95%, 1-day):");
    println!("  VaR:  ${:.4}", param_result.var * spot);
    println!("  CVaR: ${:.4}", param_result.cvar * spot);

    // 10-day VaR
    let var_10day = param_var.calculate(10);
    println!("\nParametric VaR (95%, 10-day):");
    println!("  VaR:  ${:.4}", var_10day.var * spot);
    println!("  CVaR: ${:.4}", var_10day.cvar * spot);
    println!("  Scaling factor: {:.2}x (âˆš10 â‰ˆ 3.16)", var_10day.var / param_result.var);

    // Monte Carlo VaR
    let mc_var = MonteCarloVaR::new(0.0, volatility, 10000, 0.95)?;
    let mc_var_result = mc_var.calculate(1);
    println!("\nMonte Carlo VaR (95%, 1-day, 10k sims):");
    println!("  VaR:  ${:.4}", mc_var_result.var * spot);
    println!("  CVaR: ${:.4}\n", mc_var_result.cvar * spot);

    // ========================================================================
    // 9. FINANCIAL UTILITIES
    // ========================================================================
    println!("ğŸ“… STEP 9: Financial Utilities");
    println!("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");

    // Day count conventions
    let start_date = (2024, 1, 15);
    let end_date = (2024, 7, 15);

    println!("Period: 2024-01-15 to 2024-07-15");
    println!("\nDay count conventions:");
    println!("  Actual/360:   {:.6} years",
        DayCountConvention::Actual360.year_fraction(start_date, end_date));
    println!("  Actual/365:   {:.6} years",
        DayCountConvention::Actual365.year_fraction(start_date, end_date));
    println!("  30/360:       {:.6} years",
        DayCountConvention::Thirty360.year_fraction(start_date, end_date));

    // Business day conventions
    let calendar = USFederalCalendar::new();
    let saturday = (2024, 6, 15); // June 15, 2024 is Saturday

    println!("\nBusiness day adjustment (Saturday â†’ following):");
    let adjusted = BusinessDayConvention::Following.adjust(saturday, &calendar);
    println!("  Original: 2024-06-{:02}", saturday.2);
    println!("  Adjusted: 2024-{:02}-{:02} (Monday)", adjusted.1, adjusted.2);

    // Compounding conversions
    let simple_rate = 0.05;
    let continuous_rate = CompoundingConvention::continuous_from_simple(simple_rate, 1.0);
    println!("\nCompounding conversions:");
    println!("  Simple rate (5%): {:.4}", simple_rate);
    println!("  Continuous rate:  {:.4}", continuous_rate);
    println!("  Difference:       {:.4}\n", continuous_rate - simple_rate);

    // ========================================================================
    // SUMMARY
    // ========================================================================
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println!("  âœ“ Demonstration Complete - All Components Working!");
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println!("\nThe SciRS2 finance module provides:");
    println!("  â€¢ Volatility forecasting (GARCH, EWMA, Historical)");
    println!("  â€¢ Multi-method option pricing (BS, MC, PDE, Binomial)");
    println!("  â€¢ Complete Greeks calculation");
    println!("  â€¢ Model calibration (Heston, SABR)");
    println!("  â€¢ Risk analytics (VaR, CVaR)");
    println!("  â€¢ Financial conventions (day count, calendars)");
    println!("\nAll with production-grade performance and accuracy! ğŸš€\n");

    Ok(())
}