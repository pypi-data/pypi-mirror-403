#  Software Name: PyGraft-gen
#  SPDX-FileCopyrightText: Copyright (c) Orange SA
#  SPDX-License-Identifier: MIT
#
#  This software is distributed under the MIT license, the text of which is available at https://opensource.org/license/MIT/ or see the "LICENSE" file for more details.
#
#  Authors: See CONTRIBUTORS.txt
#  Software description: A RDF Knowledge Graph stochastic generation solution.
#
# --------------------------------------------------------------------------------------------------
# FILE      : rel2dom_rel2range.rq
# AUTHOR    : Ovidiu PASCAL - Orange INNOV
# DATE      : 2025-12-12
# PURPOSE   : Retrieve ontology-local object-style properties and their effective
#             rdfs:domain / rdfs:range, including inheritance via rdfs:subPropertyOf*,
#             while keeping only the most specific domain and range classes per property.
#
# INTENT    :
#   This query supports relation_info extraction and KG generation. It uses the same
#   ontology-local relations universe as relations.rq, defined in relations_seed.rq and
#   injected via the marker line:
#
#       # @RELATIONS_SEED
#
#   For each property in this universe, the query computes effective domain/range by:
#     - inheriting rdfs:domain / rdfs:range along (rdfs:subPropertyOf)*
#     - discarding owl:Thing and non-IRI values
#     - minimizing redundant superclasses by keeping only the most specific classes
#       (drops a class if a stricter subclass is also present for the same property)
#
# OUTPUT    :
#   - ?prop_uri   : IRI of the property (ontology-local, object-style)
#   - ?domain_uri : IRI of a most-specific domain class (may be unbound)
#   - ?range_uri  : IRI of a most-specific range class (may be unbound)
#
# LOGIC     :
#   1) Bind candidate properties using the shared relations universe seed.
#   2) DOMAIN:
#      - collect inherited domain candidates via superproperties
#      - keep only domain_uri for which no domain_uri2 exists with:
#            domain_uri2 rdfs:subClassOf+ domain_uri
#   3) RANGE:
#      - collect inherited range candidates via superproperties
#      - apply a defensive datatype/literal guard (messy ontologies can still inherit
#        literal-ish ranges even if the property universe tries to exclude them)
#      - keep only range_uri for which no range_uri2 exists with:
#            range_uri2 rdfs:subClassOf+ range_uri
#
# NOTES     :
#   - Pure SPARQL 1.1; no vendor extensions.
#   - Explicit-only + structural inheritance: no OWL reasoning is applied.
#   - Namespace/prefix/CURIE normalization is delegated to Python.
#   - Callers should map unbound domain/range to empty lists in relation_info.
# --------------------------------------------------------------------------------------------------

PREFIX rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX owl:  <http://www.w3.org/2002/07/owl#>
PREFIX xsd:  <http://www.w3.org/2001/XMLSchema#>

SELECT DISTINCT
  ?prop_uri
  ?domain_uri
  ?range_uri
WHERE {
  ### 1) Candidate object properties (same universe as relations.rq)
  # @RELATIONS_SEED

  ### 2) Inherited DOMAIN candidates via superproperties
  OPTIONAL {
    ?prop_uri (rdfs:subPropertyOf)* ?p_sup_d .
    ?p_sup_d rdfs:domain ?domain_uri .
    FILTER(isIRI(?domain_uri) && ?domain_uri != owl:Thing)

    # Keep only the MOST SPECIFIC domain classes for this property
    FILTER NOT EXISTS {
      ?prop_uri (rdfs:subPropertyOf)* ?p_sup_d2 .
      ?p_sup_d2 rdfs:domain ?domain_uri2 .
      FILTER(isIRI(?domain_uri2) && ?domain_uri2 != owl:Thing)
      FILTER(?domain_uri2 != ?domain_uri)
      ?domain_uri2 rdfs:subClassOf+ ?domain_uri .
    }
  }

  ### 3) Inherited RANGE candidates via superproperties
  OPTIONAL {
    ?prop_uri (rdfs:subPropertyOf)* ?p_sup_r .
    ?p_sup_r rdfs:range ?range_uri .
    FILTER(isIRI(?range_uri) && ?range_uri != owl:Thing)

    # Extra guard:
    # Even though the property universe (relations_seed.rq) is supposed to
    # exclude datatype-ish properties, inherited ranges can still point to
    # xsd:* / literal-ish nodes in messy ontologies. This filter ensures we
    # never emit datatype/literal ranges as "range classes" for KG generation.
    FILTER(
      !STRSTARTS(STR(?range_uri), "http://www.w3.org/2001/XMLSchema#") &&
      ?range_uri != rdfs:Literal &&
      ?range_uri != rdfs:Datatype &&
      ?range_uri != rdf:langString
    )

    # Keep only the MOST SPECIFIC range classes for this property
    FILTER NOT EXISTS {
      ?prop_uri (rdfs:subPropertyOf)* ?p_sup_r2 .
      ?p_sup_r2 rdfs:range ?range_uri2 .
      FILTER(isIRI(?range_uri2) && ?range_uri2 != owl:Thing)

      # Apply the same datatype/literal guard to the competing candidate too,
      # so datatype IRIs cannot influence the "most specific" elimination.
      FILTER(
        !STRSTARTS(STR(?range_uri2), "http://www.w3.org/2001/XMLSchema#") &&
        ?range_uri2 != rdfs:Literal &&
        ?range_uri2 != rdfs:Datatype &&
        ?range_uri2 != rdf:langString
      )

      FILTER(?range_uri2 != ?range_uri)
      ?range_uri2 rdfs:subClassOf+ ?range_uri .
    }
  }
}
ORDER BY
  STR(?prop_uri)
  # NOTE:
  # ?domain_uri and ?range_uri are OPTIONAL and may be unbound. COALESCE ensures
  # stable ordering and prevents RDFLib from failing on unbound sort keys.
  COALESCE(STR(?domain_uri), "")
  COALESCE(STR(?range_uri), "")
