from typing import Any, Dict, Optional, TYPE_CHECKING
from ..crypto import compute_merkle_root, verify_signature, compute_log_hash

if TYPE_CHECKING:
    from ..client import Aeterdum

class Logs:
    def __init__(self, client: "Aeterdum"):
        self._client = client

    def create(self, 
               event: str, 
               actor: str, 
               payload: Optional[Dict[str, Any]] = None, 
               metadata: Optional[Dict[str, Any]] = None,
               id: Optional[str] = None) -> Dict[str, Any]:
        """
        Ingest a new audit log.
        If `id` is not provided, one will be generated by the API.
        """
        data = {
            "event": event,
            "actor": actor,
            "payload": payload,
            "metadata": metadata,
        }
        if id:
            data["id"] = id

        return self._client.request("POST", "/v1/logs", json=data)

    def list(self, limit: int = 50, offset: int = 0) -> Dict[str, Any]:
        """
        List logs with pagination.
        """
        params = {"limit": limit, "offset": offset}
        return self._client.request("GET", "/v1/logs", params=params)

    def get(self, id: str) -> Dict[str, Any]:
        """
        Get a single log by ID.
        """
        return self._client.request("GET", f"/v1/logs/{id}")

    def verify(self, id: str) -> Dict[str, Any]:
        """
        Verify the integrity of a log entry.
        Performs client-side cryptographic verification.
        """
        response = self._client.request("GET", f"/v1/verify/{id}")
        
        # 1. Payload Integrity Verification
        payload_verified = True
        log_data = response.get("log")
        if log_data and response.get("log_hash"):
            try:
                computed = compute_log_hash(
                    log_data.get("prev_hash"),
                    log_data.get("event"),
                    log_data.get("actor"),
                    log_data.get("timestamp"),
                    log_data.get("payload")
                )
                if computed != response["log_hash"]:
                    payload_verified = False
            except Exception as e:
                payload_verified = False

        # 2. Merkle Membership Verification
        merkle_verified = False
        if response.get("valid") and "merkle_proof" in response:
            try:
                calculated_root = compute_merkle_root(
                    response["merkle_proof"],
                    response["log_hash"],
                    response["index"],
                    response["total_leaves"]
                )
                merkle_verified = (calculated_root == response["merkle_root"])
            except Exception as e:
                merkle_verified = False
        
        # Combined Result
        response["client_verified"] = payload_verified and merkle_verified
        
        # 3. Signature Verification
        pub_key = self._client.server_public_key or response.get("public_key")
        sig = response.get("signature")
        root = response.get("merkle_root")
        
        if pub_key and sig and root:
            response["signature_verified"] = verify_signature(pub_key, sig, root)
                
        return response
