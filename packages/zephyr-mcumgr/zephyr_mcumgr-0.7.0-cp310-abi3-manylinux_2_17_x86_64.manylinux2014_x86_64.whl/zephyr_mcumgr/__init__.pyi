# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import collections.abc
import datetime
import enum
import typing

@typing.final
class FileChecksum:
    r"""
    Return value of `MCUmgrClient.fs_file_checksum`.
    """
    @property
    def type(self) -> builtins.str:
        r"""
        type of hash/checksum that was performed
        """
    @property
    def offset(self) -> builtins.int:
        r"""
        offset that hash/checksum calculation started at
        """
    @property
    def length(self) -> builtins.int:
        r"""
        length of input data used for hash/checksum generation (in bytes)
        """
    @property
    def output(self) -> bytes:
        r"""
        output hash/checksum
        """

@typing.final
class FileChecksumProperties:
    r"""
    Properties of a hash/checksum algorithm
    """
    @property
    def format(self) -> 'FileChecksumDataFormat':
        r"""
        format that the hash/checksum returns
        """
    @property
    def size(self) -> builtins.int:
        r"""
        size (in bytes) of output hash/checksum response
        """

@typing.final
class FileStatus:
    r"""
    Return value of `MCUmgrClient.fs_file_status`.
    """
    @property
    def length(self) -> builtins.int:
        r"""
        length of file (in bytes)
        """

@typing.final
class ImageState:
    r"""
    The state of an image slot
    """
    @property
    def image(self) -> builtins.int:
        r"""
        image number
        """
    @property
    def slot(self) -> builtins.int:
        r"""
        slot number within “image”
        """
    @property
    def version(self) -> builtins.str:
        r"""
        string representing image version, as set with `imgtool`
        """
    @property
    def hash(self) -> typing.Optional[bytes]:
        r"""
        SHA256 hash of the image header and body
        
        Note that this will not be the same as the SHA256 of the whole file, it is the field in the
        MCUboot TLV section that contains a hash of the data which is used for signature
        verification purposes.
        """
    @property
    def bootable(self) -> builtins.bool:
        r"""
        true if image has bootable flag set
        """
    @property
    def pending(self) -> builtins.bool:
        r"""
        true if image is set for next swap
        """
    @property
    def confirmed(self) -> builtins.bool:
        r"""
        true if image has been confirmed
        """
    @property
    def active(self) -> builtins.bool:
        r"""
        true if image is currently active application
        """
    @property
    def permanent(self) -> builtins.bool:
        r"""
        true if image is to stay in primary slot after the next boot
        """

@typing.final
class MCUmgrClient:
    r"""
    A high level client for Zephyr's MCUmgr SMP functionality
    """
    @staticmethod
    def serial(serial: builtins.str, baud_rate: builtins.int = 115200, timeout_ms: builtins.int = 2000) -> 'MCUmgrClient':
        r"""
        Creates a new serial port based Zephyr MCUmgr SMP client.
        
        ### Arguments
        
        * `serial` - The identifier of the serial device. (Windows: `COMxx`, Linux: `/dev/ttyXX`)
        * `baud_rate` - The baud rate of the serial port.
        * `timeout_ms` - The communication timeout, in ms.
        """
    @staticmethod
    def usb_serial(identifier: builtins.str, baud_rate: builtins.int = 115200, timeout_ms: builtins.int = 2000) -> 'MCUmgrClient':
        r"""
        Creates a Zephyr MCUmgr SMP client based on a USB serial port identified by VID:PID.
        
        Useful for programming many devices in rapid succession, as Windows usually
        gives each one a different COMxx identifier.
        
        ### Arguments
        
        * `identifier` - A regex that identifies the device.
        * `baud_rate` - The baud rate the port should operate at.
        * `timeout_ms` - The communication timeout, in ms.
        
        ### Identifier examples
        
        - `1234:89AB` - Vendor ID 1234, Product ID 89AB. Will fail if product has multiple serial ports.
        - `1234:89AB:12` - Vendor ID 1234, Product ID 89AB, Interface 12.
        - `1234:.*:[2-3]` - Vendor ID 1234, any Product Id, Interface 2 or 3.
        """
    def set_frame_size(self, smp_frame_size: builtins.int) -> None:
        r"""
        Configures the maximum SMP frame size that we can send to the device.
        
        Must not exceed [`MCUMGR_TRANSPORT_NETBUF_SIZE`](https://github.com/zephyrproject-rtos/zephyr/blob/v4.2.1/subsys/mgmt/mcumgr/transport/Kconfig#L40),
        otherwise we might crash the device.
        """
    def use_auto_frame_size(self) -> None:
        r"""
        Configures the maximum SMP frame size that we can send to the device automatically
        by reading the value of [`MCUMGR_TRANSPORT_NETBUF_SIZE`](https://github.com/zephyrproject-rtos/zephyr/blob/v4.2.1/subsys/mgmt/mcumgr/transport/Kconfig#L40)
        from the device.
        """
    def set_timeout_ms(self, timeout_ms: builtins.int) -> None:
        r"""
        Changes the communication timeout.
        
        When the device does not respond to packets within the set
        duration, an error will be raised.
        """
    def check_connection(self) -> None:
        r"""
        Checks if the device is alive and responding.
        
        Runs a simple echo with random data and checks if the response matches.
        
        Raises an error if the device is not alive and responding.
        """
    def os_echo(self, msg: builtins.str) -> builtins.str:
        r"""
        Sends a message to the device and expects the same message back as response.
        
        This can be used as a sanity check for whether the device is connected and responsive.
        """
    def os_task_statistics(self) -> 'builtins.dict[builtins.str, TaskStatistics]':
        r"""
        Queries live task statistics
        
        ### Note
        
        Converts `stkuse` and `stksiz` to bytes.
        Zephyr originally reports them as number of 4 byte words.
        
        ### Return
        
        A map of task names with their respective statistics
        """
    def os_set_datetime(self, datetime: datetime.datetime) -> None:
        r"""
        Sets the RTC of the device to the given datetime.
        
        Uses the contained local time and discards timezone information.
        """
    def os_get_datetime(self) -> datetime.datetime:
        r"""
        Retrieves the device RTC's datetime.
        
        Will not contain timezone information.
        """
    def os_system_reset(self, force: builtins.bool = False, boot_mode: typing.Optional[builtins.int] = None) -> None:
        r"""
        Issues a system reset.
        
        ### Arguments
        
        * `force` - Issues a force reset.
        * `boot_mode` - Overwrites the default boot mode.
        
        Known `boot_mode` values:
        * `0` - Normal system boot
        * `1` - Bootloader recovery mode
        
        Note that `boot_mode` only works if [`MCUMGR_GRP_OS_RESET_BOOT_MODE`](https://docs.zephyrproject.org/latest/kconfig.html#CONFIG_MCUMGR_GRP_OS_RESET_BOOT_MODE) is enabled.
        """
    def os_mcumgr_parameters(self) -> 'MCUmgrParameters':
        r"""
        Fetch parameters from the MCUmgr library
        """
    def os_application_info(self, format: typing.Optional[builtins.str] = None) -> builtins.str:
        r"""
        Fetch information on the running image
        
        Similar to Linux's `uname` command.
        
        ### Arguments
        
        * `format` - Format specifier for the returned response
        
        For more information about the format specifier fields, see
        the [SMP documentation](https://docs.zephyrproject.org/latest/services/device_mgmt/smp_groups/smp_group_0.html#os-application-info-request).
        """
    def os_bootloader_info(self) -> typing.Any:
        r"""
        Fetch information on the device's bootloader
        """
    def image_get_state(self) -> 'builtins.list[ImageState]':
        r"""
        Obtain a list of images with their current state.
        """
    def image_set_state(self, hash: typing.Optional[builtins.str | builtins.bytes] = None, confirm: builtins.bool = False) -> 'builtins.list[ImageState]':
        r"""
        Modify the current image state and return the new state
        
        ### Arguments
        
        * `hash` - the SHA256 id of the image.
        * `confirm` - mark the given image as 'confirmed'
        
        If `confirm` is `false`, perform a test boot with the given image and revert upon hard reset.
        
        If `confirm` is `true`, boot to the given image and mark it as `confirmed`. If `hash` is omitted,
        confirm the currently running image.
        
        Note that `hash` will not be the same as the SHA256 of the whole firmware image,
        it is the field in the MCUboot TLV section that contains a hash of the data
        which is used for signature verification purposes.
        """
    def image_upload(self, data: bytes, image: typing.Optional[builtins.int] = None, checksum: typing.Optional[builtins.str | builtins.bytes] = None, upgrade_only: builtins.bool = False, progress: typing.Optional[collections.abc.Callable[[builtins.int, builtins.int], None]] = None) -> None:
        r"""
        Upload a firmware image to an image slot.
        
        ### Arguments
        
        * `data` - The firmware image data
        * `image` - Selects target image on the device. Defaults to `0`.
        * `checksum` - The SHA256 checksum of the image. If missing, will be computed from the image data.
        * `upgrade_only` - If true, allow firmware upgrades only and reject downgrades.
        * `progress` - A callable object that takes (transmitted, total) values as parameters.
                       Any return value is ignored. Raising an exception aborts the operation.
        
        ### Performance
        
        Uploading files with Zephyr's default parameters is slow.
        You want to increase [`MCUMGR_TRANSPORT_NETBUF_SIZE`](https://github.com/zephyrproject-rtos/zephyr/blob/v4.2.1/subsys/mgmt/mcumgr/transport/Kconfig#L40)
        to maybe `4096` and then enable larger chunking through either `set_frame_size`
        or `use_auto_frame_size`.
        """
    def image_erase(self, slot: typing.Optional[builtins.int] = None) -> None:
        r"""
        Erase image slot on target device.
        
        ### Arguments
        
        * `slot` - The slot ID of the image to erase. Slot `1` if omitted.
        """
    def image_slot_info(self) -> 'builtins.list[SlotInfoImage]':
        r"""
        Obtain a list of available image slots.
        """
    def fs_file_download(self, name: builtins.str, progress: typing.Optional[collections.abc.Callable[[builtins.int, builtins.int], None]] = None) -> bytes:
        r"""
        Load a file from the device.
        
        ### Arguments
        
        * `name` - The full path of the file on the device.
        * `progress` - A callable object that takes (transmitted, total) values as parameters.
                       Any return value is ignored. Raising an exception aborts the operation.
        
        ### Return
        
        The file content
        
        ### Performance
        
        Downloading files with Zephyr's default parameters is slow.
        You want to increase [`MCUMGR_TRANSPORT_NETBUF_SIZE`](https://github.com/zephyrproject-rtos/zephyr/blob/v4.2.1/subsys/mgmt/mcumgr/transport/Kconfig#L40)
        to maybe `4096` or larger.
        """
    def fs_file_upload(self, name: builtins.str, data: bytes, progress: typing.Optional[collections.abc.Callable[[builtins.int, builtins.int], None]] = None) -> None:
        r"""
        Write a file to the device.
        
        ### Arguments
        
        * `name` - The full path of the file on the device.
        * `data` - The file content.
        * `progress` - A callable object that takes (transmitted, total) values as parameters.
                       Any return value is ignored. Raising an exception aborts the operation.
        
        ### Performance
        
        Uploading files with Zephyr's default parameters is slow.
        You want to increase [`MCUMGR_TRANSPORT_NETBUF_SIZE`](https://github.com/zephyrproject-rtos/zephyr/blob/v4.2.1/subsys/mgmt/mcumgr/transport/Kconfig#L40)
        to maybe `4096` and then enable larger chunking through either `set_frame_size`
        or `use_auto_frame_size`.
        """
    def fs_file_status(self, name: builtins.str) -> 'FileStatus':
        r"""
        Queries the file status
        """
    def fs_file_checksum(self, name: builtins.str, algorithm: typing.Optional[builtins.str] = None, offset: builtins.int = 0, length: typing.Optional[builtins.int] = None) -> 'FileChecksum':
        r"""
        Computes the hash/checksum of a file
        
        For available algorithms, see `fs_supported_checksum_types`.
        
        ### Arguments
        
        * `name` - The absolute path of the file on the device
        * `algorithm` - The hash/checksum algorithm to use, or default if None
        * `offset` - How many bytes of the file to skip
        * `length` - How many bytes to read after `offset`. None for the entire file.
        """
    def fs_supported_checksum_types(self) -> 'builtins.dict[builtins.str, FileChecksumProperties]':
        r"""
        Queries which hash/checksum algorithms are available on the target
        """
    def fs_file_close(self) -> None:
        r"""
        Close all device files MCUmgr has currently open
        """
    def shell_execute(self, argv: typing.Sequence[builtins.str]) -> builtins.str:
        r"""
        Run a shell command.
        
        ### Arguments
        
        * `argv` - The shell command to be executed.
        
        ### Return
        
        The command output
        """
    def zephyr_erase_storage(self) -> None:
        r"""
        Erase the `storage_partition` flash partition.
        """
    def raw_command(self, write_operation: builtins.bool, group_id: builtins.int, command_id: builtins.int, data: typing.Any) -> typing.Any:
        r"""
        Execute a raw MCUmgrCommand.
        
        Only returns if no error happened, so the
        user does not need to check for an `rc` or `err`
        field in the response.
        
        Read Zephyr's [SMP Protocol Specification](https://docs.zephyrproject.org/latest/services/device_mgmt/smp_protocol.html)
        for more information.
        
        ### Arguments
        
        * `write_operation` - Whether the command is a read or write operation.
        * `group_id` - The group ID of the command
        * `command_id` - The command ID
        * `data` - Anything that can be serialized as a proper packet payload.
        
        ### Example
        
        ```python
        client.raw_command(True, 0, 0, {"d": "Hello!"})
        # Returns: {'r': 'Hello!'}
        ```
        """
    def __enter__(self) -> 'MCUmgrClient': ...
    def __exit__(self, _exc_type: typing.Any, _exc_value: typing.Any, _traceback: typing.Any) -> builtins.bool:
        r"""
        Closes the connection
        """

@typing.final
class MCUmgrParameters:
    r"""
    Return value of `MCUmgrClient.os_mcumgr_parameters`.
    """
    @property
    def buf_size(self) -> builtins.int:
        r"""
        Single SMP buffer size, this includes SMP header and CBOR payload
        """
    @property
    def buf_count(self) -> builtins.int:
        r"""
        Number of SMP buffers supported
        """

@typing.final
class McubootImageInfo:
    r"""
    Information about an MCUboot firmware image
    """
    @property
    def version(self) -> builtins.str:
        r"""
        Firmware version
        """
    @property
    def hash(self) -> bytes:
        r"""
        The identifying hash for the firmware
        
        Note that this will not be the same as the SHA256 of the whole file, it is the field in the
        MCUboot TLV section that contains a hash of the data which is used for signature
        verification purposes.
        """

@typing.final
class SlotInfoImage:
    r"""
    Information about a firmware image type returned by `MCUmgrClient.image_slot_info`
    """
    @property
    def image(self) -> builtins.int:
        r"""
        number of the image
        """
    @property
    def slots(self) -> 'builtins.list[SlotInfoImageSlot]':
        r"""
        slots available for the image
        """
    @property
    def max_image_size(self) -> typing.Optional[builtins.int]:
        r"""
        maximum size of an application that can be uploaded to that image number
        """

@typing.final
class SlotInfoImageSlot:
    r"""
    Information about a slot that can hold a firmware image
    """
    @property
    def slot(self) -> builtins.int:
        r"""
        slot inside the image being enumerated
        """
    @property
    def size(self) -> builtins.int:
        r"""
        size of the slot
        """
    @property
    def upload_image_id(self) -> typing.Optional[builtins.int]:
        r"""
        specifies the image ID that can be used by external tools to upload an image to that slot
        """

@typing.final
class TaskStatistics:
    r"""
    Statistics of an MCU task/thread
    """
    @property
    def prio(self) -> builtins.int:
        r"""
        task priority
        """
    @property
    def tid(self) -> builtins.int:
        r"""
        numeric task ID
        """
    @property
    def state(self) -> builtins.int:
        r"""
        numeric task state
        """
    @property
    def stkuse(self) -> typing.Optional[builtins.int]:
        r"""
        task’s/thread’s stack usage
        """
    @property
    def stksiz(self) -> typing.Optional[builtins.int]:
        r"""
        task’s/thread’s stack size
        """
    @property
    def cswcnt(self) -> typing.Optional[builtins.int]:
        r"""
        task’s/thread’s context switches
        """
    @property
    def runtime(self) -> typing.Optional[builtins.int]:
        r"""
        task’s/thread’s runtime in “ticks”
        """

@typing.final
class FileChecksumDataFormat(enum.Enum):
    r"""
    Data format of the hash/checksum type
    """
    Numerical = ...
    r"""
    Data is a number
    """
    ByteArray = ...
    r"""
    Data is a bytes array
    """

def mcuboot_get_image_info(image_data: bytes) -> 'McubootImageInfo':
    r"""
    Extract information from an MCUboot image file
    """

