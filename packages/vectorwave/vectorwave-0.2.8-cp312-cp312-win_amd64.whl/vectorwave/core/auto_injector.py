import inspect
import importlib
import logging
from functools import wraps
from typing import Any, Optional

# VectorWave Core Modules
from .decorator import vectorize
from ..monitoring.tracer import trace_span, current_tracer_var

logger = logging.getLogger(__name__)

def create_smart_wrapper(original_func, root_wrapper):
    """
    Creates a wrapper that switches behavior based on the Tracing Context.

    Args:
        original_func: The original function (used when acting as a Child Span).
        root_wrapper: The wrapper generated by vectorize (used when acting as a Root Span, includes metadata).
    """
    @wraps(original_func)
    def wrapper(*args, **kwargs):
        # Check for existing tracer at runtime
        tracer = current_tracer_var.get()

        if tracer:
            # [Case A] Parent trace exists -> Act as Child Span
            # (Wrap original function with trace_span and execute)
            return trace_span(original_func, capture_return_value=True)(*args, **kwargs)
        else:
            # [Case B] No parent trace -> Act as Root Span
            # (Delegate to the already configured root_wrapper)
            return root_wrapper(*args, **kwargs)

    # Mark to prevent double injection
    wrapper._is_vectorized = True
    return wrapper


class VectorWaveAutoInjector:
    """
    Scans specified modules or packages to automatically inject (Monkey Patch) VectorWave functionality.
    """

    # Global default configuration
    _default_config = {}

    @classmethod
    def configure(cls, **kwargs):
        """
        Sets the default configuration to be applied to all inject calls.
        """
        cls._default_config.update(kwargs)
        logger.info(f"‚öôÔ∏è VectorWave AutoInjector Configured: {cls._default_config}")

    @classmethod
    def inject(cls, target_module_path: str, recursive: bool = False, **config):
        """
        Finds functions within a module and injects VectorWave functionality.
        **Metadata registration (DB save or Pending) is performed immediately at this point.**
        """
        try:
            module = importlib.import_module(target_module_path)
        except ImportError as e:
            logger.error(f"Failed to import module '{target_module_path}': {e}")
            return None

        # Merge configurations (Defaults < Individual Config)
        final_config = cls._default_config.copy()
        final_config.update(config)

        logger.info(f"üåä [AutoInjector] Injecting VectorWave into: {module.__name__}")

        patched_count = 0

        for name, obj in inspect.getmembers(module):
            # Target only functions defined within the module
            if inspect.isfunction(obj) and obj.__module__ == module.__name__:

                # Skip if already processed
                if getattr(obj, "_is_vectorized", False):
                    continue

                logger.info(f"  ‚îî‚îÄ Auto-wiring: {name}()")

                # [Key Change] Call vectorize immediately at injection time to perform metadata registration!
                # - If auto=False: Immediate DB save
                # - If auto=True: Add to PENDING list
                # The returned root_wrapper contains the execution logic (Root Span)
                root_wrapper = vectorize(**final_config)(obj)

                # Create smart wrapper to judge Context at runtime
                smart_wrapper = create_smart_wrapper(obj, root_wrapper)

                # Replace (Monkey Patching)
                setattr(module, name, smart_wrapper)
                patched_count += 1

        logger.info(f"‚ú® Injection Complete. {patched_count} functions registered & auto-wired.")
        return module