"""Generator for _warnings.py module in target packages."""

from __future__ import annotations

from pathlib import Path
from typing import TYPE_CHECKING

from zero_3rdparty import file_utils
from zero_3rdparty.humps import pascalize

from pkg_ext._internal.config import Stability
from pkg_ext._internal.settings import PkgSettings

if TYPE_CHECKING:
    from pkg_ext._internal.pkg_state import PkgExtState


def needs_warnings_module(tool_state: PkgExtState) -> bool:
    """Check if any group has non-GA stability (from changelog actions)."""
    return any(
        tool_state.get_group_stability(group.name) in (Stability.experimental, Stability.deprecated)
        for group in tool_state.groups.groups
    )


def get_warning_class_names(pkg_name: str) -> list[str]:
    """Return the 3 warning class names for a package."""
    pascal_name = pascalize(pkg_name)
    return [
        f"{pascal_name}Warning",
        f"{pascal_name}ExperimentalWarning",
        f"{pascal_name}DeprecationWarning",
    ]


def generate_warnings_content(pkg_name: str) -> str:
    pascal_name = pascalize(pkg_name)
    return f'''"""Warning classes and decorators for {pascal_name} stability levels.

Auto-generated by pkg-ext. Do not edit manually.
"""

import warnings
from functools import wraps
from inspect import signature
from typing import Any, Callable, TypeVar
from warnings import deprecated  # noqa: F401

F = TypeVar("F", bound=Callable[..., Any])


def _get_arg_names(func: Callable) -> set[str]:
    return {{p.name for p in signature(func).parameters.values() if p.name != "self"}}


def _validate_arg_names(func: Callable, names: set[str], context: str) -> None:
    valid_names = _get_arg_names(func)
    invalid = names - valid_names
    if invalid:
        raise ValueError(
            f"{{context}}: {{invalid}} not in {{func.__name__}} signature {{valid_names}}"
        )


class {pascal_name}Warning(UserWarning):
    """Base warning class for {pascal_name}."""


class {pascal_name}ExperimentalWarning({pascal_name}Warning):
    """Warning for experimental features."""


class {pascal_name}DeprecationWarning({pascal_name}Warning, DeprecationWarning):
    """Warning for deprecated features."""


def _warn_experimental(feature_name: str, *, stacklevel: int = 2) -> None:
    warnings.warn(
        f"'{{feature_name}}' is experimental and may change in future versions.",
        category={pascal_name}ExperimentalWarning,
        stacklevel=stacklevel,
    )


def _warn_deprecated(
    old_name: str,
    new_name: str | None = None,
    *,
    stacklevel: int = 2,
) -> None:
    msg = f"'{{old_name}}' is deprecated"
    msg += f", use '{{new_name}}' instead." if new_name else "."
    warnings.warn(msg, category={pascal_name}DeprecationWarning, stacklevel=stacklevel)


def _experimental(obj: type | F) -> type | F:
    if isinstance(obj, type):
        original_init = obj.__init__

        @wraps(original_init)
        def wrapped_init(self: Any, *args: Any, **kwargs: Any) -> None:
            _warn_experimental(obj.__name__, stacklevel=2)
            original_init(self, *args, **kwargs)

        obj.__init__ = wrapped_init  # type: ignore[method-assign]
        return obj

    @wraps(obj)
    def wrapper(*args: Any, **kwargs: Any) -> Any:
        _warn_experimental(obj.__name__, stacklevel=2)
        return obj(*args, **kwargs)

    return wrapper  # type: ignore[return-value]


def _experimental_args(*names: str) -> Callable[[F], F]:
    def decorator(func: F) -> F:
        _validate_arg_names(func, set(names), "@_experimental_args")

        @wraps(func)
        def wrapper(*args: Any, **kwargs: Any) -> Any:
            for name in names:
                if name in kwargs:
                    warnings.warn(
                        f"Argument '{{name}}' is experimental and may change in future versions.",
                        category={pascal_name}ExperimentalWarning,
                        stacklevel=2,
                    )
            return func(*args, **kwargs)

        return wrapper  # type: ignore[return-value]

    return decorator


def _deprecated_args(*names: str, **renames: str) -> Callable[[F], F]:
    def decorator(func: F) -> F:
        all_names = set(names) | set(renames.keys()) | set(renames.values())
        _validate_arg_names(func, all_names, "@_deprecated_args")

        @wraps(func)
        def wrapper(*args: Any, **kwargs: Any) -> Any:
            for name in names:
                if name in kwargs:
                    warnings.warn(
                        f"Argument '{{name}}' is deprecated.",
                        category={pascal_name}DeprecationWarning,
                        stacklevel=2,
                    )
            for old_name, new_name in renames.items():
                if old_name in kwargs:
                    warnings.warn(
                        f"Argument '{{old_name}}' is deprecated, use '{{new_name}}' instead.",
                        category={pascal_name}DeprecationWarning,
                        stacklevel=2,
                    )
            return func(*args, **kwargs)

        return wrapper  # type: ignore[return-value]

    return decorator


def _deprecated_arg(
    name: str,
    *,
    new_name: str | None = None,
    reason: str | None = None,
) -> Callable[[F], F]:
    def decorator(func: F) -> F:
        to_validate = {{name, new_name}} - {{None}}
        _validate_arg_names(func, to_validate, "@_deprecated_arg")  # type: ignore[arg-type]

        @wraps(func)
        def wrapper(*args: Any, **kwargs: Any) -> Any:
            if name in kwargs:
                msg = f"Argument '{{name}}' is deprecated"
                if new_name:
                    msg += f", use '{{new_name}}' instead"
                if reason:
                    msg += f": {{reason}}"
                elif not new_name:
                    msg += "."
                warnings.warn(msg, category={pascal_name}DeprecationWarning, stacklevel=2)
            return func(*args, **kwargs)

        return wrapper  # type: ignore[return-value]

    return decorator
'''


def write_warnings_module(settings: PkgSettings, tool_state: PkgExtState) -> Path | None:
    """Write _warnings.py if stability features are used. Returns path or None."""
    if not needs_warnings_module(tool_state):
        return None
    content = generate_warnings_content(settings.pkg_import_name)
    file_utils.ensure_parents_write_text(settings.warnings_file_path, content)
    return settings.warnings_file_path
