"""Configuration management for pkg-ext.

Supports two-tier configuration:
1. User-level settings from ~/.config/pkg-ext/config.toml (personal preferences)
2. Project-level settings from pyproject.toml [tool.pkg-ext] (team conventions)
"""

from __future__ import annotations

import logging
from dataclasses import dataclass
from enum import StrEnum
from pathlib import Path
from typing import TYPE_CHECKING, Any, ClassVar, Literal, Self

from model_lib import Entity
from pydantic import Field, model_validator

from pkg_ext._internal.changelog.actions import BumpType

if TYPE_CHECKING:
    from pkg_ext._internal.models.api_dump import GroupDump
    from pkg_ext._internal.models.groups import PublicGroups

logger = logging.getLogger(__name__)
ROOT_GROUP_NAME = "__ROOT__"
PKG_EXT_TOOL_NAME = "pkg-ext"


@dataclass
class UserConfig:
    """User-level preferences stored in ~/.config/pkg-ext/config.toml."""

    editor: str = "cursor"  # fallback to $EDITOR env var
    skip_open_in_editor: bool = False


class Stability(StrEnum):
    experimental = "experimental"
    ga = "ga"
    deprecated = "deprecated"


class GroupConfig(Entity):
    dependencies: list[str] = Field(default_factory=list)
    docs_exclude: list[str] = Field(default_factory=list)
    docstring: str = ""
    examples_enabled: bool | None = None  # None = inherit from project
    examples_include: list[str] = Field(default_factory=list)
    examples_exclude: list[str] = Field(default_factory=list)

    @model_validator(mode="after")
    def validate_examples_mutually_exclusive(self) -> Self:
        if self.examples_include and self.examples_exclude:
            raise ValueError("examples_include and examples_exclude are mutually exclusive")
        return self


def _detect_cycle(groups: dict[str, GroupConfig]) -> list[str] | None:
    """DFS cycle detection. Returns cycle path if found."""
    WHITE, GRAY, BLACK = 0, 1, 2
    color: dict[str, int] = {name: WHITE for name in groups}
    path: list[str] = []

    def dfs(node: str) -> list[str] | None:
        color[node] = GRAY
        path.append(node)
        for dep in groups.get(node, GroupConfig()).dependencies:
            if dep == ROOT_GROUP_NAME or dep not in groups:
                continue
            if color[dep] == GRAY:
                return path[path.index(dep) :] + [dep]
            if color[dep] == WHITE and (result := dfs(dep)):
                return result
        path.pop()
        color[node] = BLACK
        return None

    for node in groups:
        if color[node] == WHITE and (result := dfs(node)):
            return result
    return None


MaxBumpLiteral = Literal["patch", "minor", "major"]


class ProjectConfig(Entity):
    DEFAULT_CHANGELOG_CLEANUP_COUNT: ClassVar[int] = 30
    DEFAULT_CHANGELOG_KEEP_COUNT: ClassVar[int] = 10
    DEFAULT_FILE_HEADER: ClassVar[str] = f"# Generated by {PKG_EXT_TOOL_NAME}"
    DEFAULT_FORMAT_COMMAND: ClassVar[tuple[str, ...]] = ("ruff", "format")

    tag_prefix: str = ""
    file_header: str = DEFAULT_FILE_HEADER
    commit_fix_prefixes: tuple[str, ...] = ("fix:",)
    commit_diff_suffixes: tuple[str, ...] = (".py",)
    changelog_cleanup_count: int = DEFAULT_CHANGELOG_CLEANUP_COUNT
    changelog_keep_count: int = DEFAULT_CHANGELOG_KEEP_COUNT
    after_file_write_hooks: tuple[str, ...] | None = None
    keep_prerelease: bool = False
    ignored_symbols: tuple[str, ...] = ()
    mkdocs_skip_sections: tuple[str, ...] = ()
    format_command: tuple[str, ...] = DEFAULT_FORMAT_COMMAND
    examples_enabled: bool = False
    max_bump_type: MaxBumpLiteral | None = None
    groups: dict[str, GroupConfig] = Field(default_factory=dict)

    def get_max_bump(self) -> BumpType | None:
        if self.max_bump_type is None:
            return None
        return BumpType(self.max_bump_type)

    def is_examples_enabled(self, group_name: str) -> bool:
        group_cfg = self.groups.get(group_name)
        if group_cfg and group_cfg.examples_enabled is not None:
            return group_cfg.examples_enabled
        return self.examples_enabled

    def filter_example_symbols(self, group_name: str, symbol_names: list[str]) -> list[str]:
        if not self.is_examples_enabled(group_name):
            return []
        group_cfg = self.groups.get(group_name)
        if not group_cfg:
            return symbol_names
        symbol_set = set(symbol_names)
        if group_cfg.examples_include:
            unknown = set(group_cfg.examples_include) - symbol_set
            if unknown:
                raise ValueError(f"Group '{group_name}' examples_include has unknown symbols: {sorted(unknown)}")
            return [n for n in symbol_names if n in group_cfg.examples_include]
        if group_cfg.examples_exclude:
            unknown = set(group_cfg.examples_exclude) - symbol_set
            if unknown:
                raise ValueError(f"Group '{group_name}' examples_exclude has unknown symbols: {sorted(unknown)}")
            return [n for n in symbol_names if n not in group_cfg.examples_exclude]
        return symbol_names

    def filter_group_for_examples(self, group: GroupDump) -> GroupDump | None:
        """Filter a GroupDump to only include symbols with examples enabled."""
        symbol_names = [s.name for s in group.symbols]
        if not symbol_names:
            return None
        include_names = self.filter_example_symbols(group.name, symbol_names)
        if not include_names:
            return None
        return group.filter_symbols(set(include_names))

    @model_validator(mode="after")
    def validate_dependencies(self) -> Self:
        defined = set(self.groups.keys()) | {ROOT_GROUP_NAME}
        errors = [
            f"Group '{name}' has invalid dependency '{dep}'"
            for name, cfg in self.groups.items()
            for dep in cfg.dependencies
            if dep not in defined
        ]
        if errors:
            raise ValueError("\n".join(errors))
        if cycle := _detect_cycle(self.groups):
            raise ValueError(f"Circular dependency detected: {' -> '.join(cycle)}")
        return self


def _safe_load_toml(path: Path) -> dict[str, Any]:
    """Safely load TOML file, returning empty dict on any error."""
    try:
        import tomllib
    except ImportError:
        # Python < 3.11 fallback
        try:
            import tomli as tomllib  # type: ignore
        except ImportError:
            logger.warning("No TOML library available. Config loading disabled.")
            return {}

    if not path.exists():
        return {}

    try:
        with path.open("rb") as f:
            return tomllib.load(f)
    except Exception as e:
        logger.warning(f"Failed to load TOML config from {path}: {e}")
        return {}


def load_user_config() -> UserConfig:
    """Load user configuration from ~/.config/pkg-ext/config.toml."""
    config_path = Path.home() / ".config" / "pkg-ext" / "config.toml"
    data = _safe_load_toml(config_path)

    user_data = data.get("user", {})
    return UserConfig(
        editor=user_data.get("editor", UserConfig.editor),
        skip_open_in_editor=user_data.get("skip_open_in_editor", UserConfig.skip_open_in_editor),
    )


def _convert_tuple_fields(data: dict[str, Any]) -> dict[str, Any]:
    """Convert list fields that should be tuples."""
    tuple_fields = (
        "commit_fix_prefixes",
        "commit_diff_suffixes",
        "after_file_write_hooks",
        "ignored_symbols",
        "mkdocs_skip_sections",
        "format_command",
    )
    for field in tuple_fields:
        if field in data and isinstance(data[field], list):
            data[field] = tuple(data[field])
    return data


def load_project_config(repo_root: Path) -> ProjectConfig:
    """Load project configuration from pyproject.toml [tool.pkg-ext]."""
    pyproject_path = repo_root / "pyproject.toml"
    data = _safe_load_toml(pyproject_path)

    pkg_ext_data = data.get("tool", {}).get("pkg-ext", {})
    groups_data = pkg_ext_data.pop("groups", {})
    groups = {name: GroupConfig(**gdata) for name, gdata in groups_data.items()}

    pkg_ext_data = _convert_tuple_fields(pkg_ext_data)
    pkg_ext_data["groups"] = groups
    return ProjectConfig(**pkg_ext_data)


def validate_group_dependencies(config: ProjectConfig, groups: PublicGroups) -> None:
    """Validate config dependencies against runtime PublicGroups."""
    valid_names = set(groups.name_to_group.keys())
    errors = [
        f"Group '{name}' depends on unknown runtime group '{dep}'"
        for name, cfg in config.groups.items()
        for dep in cfg.dependencies
        if dep not in valid_names
    ]
    if errors:
        raise ValueError("\n".join(errors))
