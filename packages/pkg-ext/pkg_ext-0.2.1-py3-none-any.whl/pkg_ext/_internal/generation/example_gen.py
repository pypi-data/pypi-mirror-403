"""Generate example files for public API functions and classes."""

from __future__ import annotations

from zero_3rdparty.humps import pascalize
from zero_3rdparty.sections import CommentConfig, slug, wrap_section

from pkg_ext._internal.config import PKG_EXT_TOOL_NAME, Stability
from pkg_ext._internal.models.api_dump import (
    ClassDump,
    ClassFieldInfo,
    FuncParamInfo,
    FunctionDump,
    GroupDump,
    ParamKind,
    SymbolDump,
)
from pkg_ext._internal.pkg_state import PkgExtState

PY_CONFIG = CommentConfig("#")

EXAMPLE_NAME_FIELD = "example_name"
EXAMPLE_DESCRIPTION_FIELD = "example_description_md"
EXPECTED_FIELD = "expected"
EXAMPLE_BASE_FIELDS = frozenset({EXAMPLE_NAME_FIELD, EXAMPLE_DESCRIPTION_FIELD, EXPECTED_FIELD})


def _type_str(type_annotation: str | None) -> str:
    return type_annotation or "Any"


def _collect_type_imports(group: GroupDump) -> set[str]:
    """Collect all type_imports values from a group's symbols (parameters, fields, and return types)."""
    imports: set[str] = set()
    for symbol in group.symbols:
        match symbol:
            case FunctionDump():
                for p in symbol.signature.parameters:
                    imports.update(p.type_imports)
                imports.update(symbol.signature.return_type_imports)
            case ClassDump():
                if symbol.fields:
                    for f in symbol.fields:
                        imports.update(f.type_imports)
    return imports


def _generate_type_imports(group: GroupDump) -> tuple[list[str], list[str]]:
    """Generate import statements from collected type_imports values.

    Returns (stdlib_imports, pkg_imports) tuple for proper ordering.
    """
    type_imports = _collect_type_imports(group)

    # Group imports by module
    module_to_types: dict[str, list[str]] = {}
    for full_path in type_imports:
        # Split "pathlib.Path" into module="pathlib", name="Path"
        parts = full_path.rsplit(".", 1)
        if len(parts) != 2:
            continue
        module, name = parts
        module_to_types.setdefault(module, []).append(name)

    # Separate stdlib from package imports
    stdlib_imports: list[str] = []
    pkg_imports: list[str] = []

    for module in sorted(module_to_types):
        types_str = ", ".join(sorted(module_to_types[module]))
        import_line = f"from {module} import {types_str}"
        # Single-segment modules (no dots) are stdlib, multi-segment are package imports
        if "." not in module:
            stdlib_imports.append(import_line)
        else:
            pkg_imports.append(import_line)

    return stdlib_imports, pkg_imports


def _field_line(name: str, type_annotation: str | None) -> str:
    return f"    {name}: {_type_str(type_annotation)} = ... # type: ignore"


def _skip_param(param: FuncParamInfo) -> bool:
    if param.kind in (ParamKind.VAR_POSITIONAL, ParamKind.VAR_KEYWORD):
        return True
    return param.name == "self"


def _skip_class_field(field: ClassFieldInfo) -> bool:
    return field.is_class_var or field.is_computed


def generate_function_example_class(func: FunctionDump) -> str:
    """Generate Example subclass from FunctionDump.signature.parameters."""
    class_name = f"{pascalize(func.name)}Example"
    return_type = func.signature.return_annotation or "Any"
    fields = [_field_line(p.name, p.type_annotation) for p in func.signature.parameters if not _skip_param(p)]
    fields_str = "\n".join(fields) if fields else "    pass"
    return f"class {class_name}(Example[{return_type}]):\n{fields_str}"


def generate_class_example_class(cls: ClassDump) -> str:
    """Generate Example subclass from ClassDump.fields."""
    class_name = f"{pascalize(cls.name)}Example"
    if not cls.fields:
        return f"class {class_name}(Example[{cls.name}]):\n    pass"
    fields = [_field_line(f.name, f.type_annotation) for f in cls.fields if not _skip_class_field(f)]
    fields_str = "\n".join(fields) if fields else "    pass"
    return f"class {class_name}(Example[{cls.name}]):\n{fields_str}"


def _symbol_example_class(symbol: SymbolDump) -> str | None:
    match symbol:
        case FunctionDump():
            return generate_function_example_class(symbol)
        case ClassDump():
            return generate_class_example_class(symbol)
    return None


def generate_group_examples_file(group: GroupDump, pkg_import_name: str) -> str:
    """Generate standalone {group}_examples.py content."""
    stdlib_imports, pkg_imports = _generate_type_imports(group)

    stdlib_block = "\n".join(stdlib_imports)
    if stdlib_block:
        stdlib_block = f"{stdlib_block}\n"
    pkg_block = "\n".join(pkg_imports)
    if pkg_block:
        pkg_block = f"\n{pkg_block}"

    header = f'''\
"""Example classes for {group.name} group. Generated by pkg-ext."""

{stdlib_block}from collections.abc import Callable
from typing import Any, Generic, Self, TypeVar

from pydantic import BaseModel, Field
{pkg_block}

T = TypeVar("T")


class Example(BaseModel, Generic[T]):
    {EXAMPLE_NAME_FIELD}: str
    {EXAMPLE_DESCRIPTION_FIELD}: str = ""
    {EXPECTED_FIELD}: Callable[[Self, T], None] = Field(exclude=True)'''

    header_section = wrap_section(header, "header", PKG_EXT_TOOL_NAME, PY_CONFIG)

    sections = [header_section, ""]
    for symbol in group.symbols:
        if class_code := _symbol_example_class(symbol):
            section_id = f"class_{slug(symbol.name)}"
            sections.extend((wrap_section(class_code, section_id, PKG_EXT_TOOL_NAME, PY_CONFIG), ""))

    return "\n".join(sections)


def get_example_stability(
    tool_state: PkgExtState,
    group_name: str,
    symbol_name: str,
    used_args: set[str] | None = None,
) -> Stability:
    """Infer stability from symbol + args used.

    Priority:
    1. Any used arg experimental/deprecated -> that stability
    2. Symbol experimental/deprecated -> that stability
    3. Group stability (defaults to GA)
    """
    if used_args:
        for arg in used_args:
            arg_stability = tool_state.get_arg_stability(group_name, symbol_name, arg)
            if arg_stability != Stability.ga:
                return arg_stability
    symbol_stability = tool_state.get_symbol_stability(group_name, symbol_name)
    if symbol_stability != Stability.ga:
        return symbol_stability
    return tool_state.get_group_stability(group_name)
