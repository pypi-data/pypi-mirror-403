<!DOCTYPE html>

<html lang="en" data-content_root="../../../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>snowdrop.src.numeric.filters.kalman &#8212; Python Platform 1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../_static/pygments.css?v=61cd365c" />
    <link rel="stylesheet" type="text/css" href="../../../../../_static/alabaster.css?v=12dfc556" />
    <script src="../../../../../_static/documentation_options.js?v=f2a433a1"></script>
    <script src="../../../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for snowdrop.src.numeric.filters.kalman</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Basic implementation of the Kalman filter (and smoother).</span>

<span class="sd">Overview</span>
<span class="sd">=========</span>

<span class="sd">The Kalman filter/smoother is a well-known algorithm for computing recursively</span>
<span class="sd">the filtering/smoothing distributions of a linear Gaussian model, i.e. a model</span>
<span class="sd">of the form:</span>

<span class="sd">.. math::</span>
<span class="sd">    X_0 &amp; \sim N(\mu_0,C_0) \\</span>
<span class="sd">    X_t &amp; = F X_{t-1} + U_t, \quad   U_t \sim N(0, C_X) \\</span>
<span class="sd">    Y_t &amp; = G X_t + V_t,     \quad   V_t \sim N(0, C_Y)</span>

<span class="sd">Linear Gaussian models and the Kalman filter are covered in Chapter 7 of the</span>
<span class="sd">book.</span>

<span class="sd">MVLinearGauss class and subclasses</span>
<span class="sd">==================================</span>

<span class="sd">To define a specific linear Gaussian model, we instantiate class</span>
<span class="sd">`MVLinearGauss` (or one its subclass) as follows::</span>

<span class="sd">    import numpy as np</span>
<span class="sd">    from particles import kalman</span>

<span class="sd">    ssm = kalman.MVLinearGauss(F=np.ones((1, 2)), G=np.eye(2), covX=np.eye(2),</span>
<span class="sd">                               covY=.3)</span>

<span class="sd">where the parameters have the same meaning as above. It is also possible to</span>
<span class="sd">specify `mu0`and  `cov0` (the mean and covariance of the initial state X_0).</span>
<span class="sd">(See the documentation of the class for more details.)</span>

<span class="sd">Class `MVLinearGauss` is a sub-class of `StateSpaceModel` in module</span>
<span class="sd">`state_space_models`, so it inherits methods from its parent such as::</span>

<span class="sd">    true_states, data = ssm.simulate(30)</span>

<span class="sd">Class `MVLinearGauss` implements methods `proposal`, `proposal0` and `logeta`,</span>
<span class="sd">which correspond respectively to the optimal proposal distributions and</span>
<span class="sd">auxiliary function for a guided or auxiliary particle filter; see Chapter 11</span>
<span class="sd">and module `state_space_models` for more details. (That the optimal quantities</span>
<span class="sd">are tractable is, of course, due to the fact that the model is linear and</span>
<span class="sd">Gaussian.)</span>

<span class="sd">To define a univariate linear Gaussian model, you may want to use instead the</span>
<span class="sd">more conveniently parametrised class `LinearGauss` (which is a sub-class of</span>
<span class="sd">``MVLinearGauss``)::</span>

<span class="sd">    ssm = LinearGauss(rho=0.3, sigX=1., sigY=.2, sig0=1.)</span>

<span class="sd">which corresponds to model:</span>

<span class="sd">.. math::</span>
<span class="sd">    X_0                 &amp; \sim N(0, \sigma_0^2) \\</span>
<span class="sd">    X_t|X_{t-1}=x_{t-1} &amp; \sim N(\rho * X_{t-1},\sigma_X^2) \\</span>
<span class="sd">    Y_t |X_t=x_t        &amp; \sim N(x_t, \sigma_Y^2)</span>

<span class="sd">Another sub-class of `MVLinearGauss` defined in this module is</span>
<span class="sd">`MVLinearGauss_Guarniero_etal`, which implements a particular class of linear</span>
<span class="sd">Gaussian models often used as a benchmark (after Guarniero et al, 2016).</span>


<span class="sd">`Kalman` class</span>
<span class="sd">==============</span>

<span class="sd">The Kalman filter is implemented as a class, `Kalman`, with methods</span>
<span class="sd">`filter` and `smoother`. When instantiating the class, one passes</span>
<span class="sd">as arguments the data, and an object that represents the considered model (i.e.</span>
<span class="sd">an instance of MvLinearGauss, see above)::</span>

<span class="sd">    kf = kalman.Kalman(ssm=ssm, data=data)</span>
<span class="sd">    kf.filter()</span>

<span class="sd">The second line implements the forward pass of a Kalman filter. The results are</span>
<span class="sd">stored as lists of `MeanAndCov` objects, that is, named tuples with attributes</span>
<span class="sd">&#39;mean&#39; and &#39;cov&#39; that represent a Gaussian distribution. For instance::</span>

<span class="sd">    kf.filt[3].mean  # mean of the filtering distribution at time 3</span>
<span class="sd">    kf.pred[7].cov  # cov matrix of the predictive distribution at time 7</span>

<span class="sd">The forward pass also computes the log-likelihood of the data::</span>

<span class="sd">    kf.logpyt[5]  # log-density of Y_t | Y_{0:t-1} at time t=5</span>

<span class="sd">Smoothing works along the same lines::</span>

<span class="sd">    kf.smoother()</span>

<span class="sd">then object kf contains a list called smooth, which represents the successive</span>
<span class="sd">(marginal) smoothing distributions::</span>

<span class="sd">    kf.smth[8].mean  # mean of the smoothing dist at time 8</span>

<span class="sd">It is possible to call method `smoother` directly (without calling `filter`</span>
<span class="sd">first). In that case, the filtering step is automatically performed as a</span>
<span class="sd">preliminary step.</span>

<span class="sd">Kalman objects as iterators</span>
<span class="sd">===========================</span>

<span class="sd">It is possible to perform the forward pass step by step; in fact a `Kalman`</span>
<span class="sd">object is an iterator::</span>

<span class="sd">    kf = kalman.Kalman(ssm=ssm, data=data)</span>
<span class="sd">    next(kf)  # one step</span>
<span class="sd">    next(kf)  # one step</span>

<span class="sd">If you run the smoother after k such steps, you will obtain the smoothing</span>
<span class="sd">distribution based on the k first data-points. It is therefore possible to</span>
<span class="sd">compute recursively the successive smoothing distributions, but (a) at a high</span>
<span class="sd">CPU cost; and (b) at each time, you must save the results somewhere, as</span>
<span class="sd">attribute `kf.smth` gets written over and over.</span>

<span class="sd">Functions to perform a single step</span>
<span class="sd">==================================</span>

<span class="sd">The module also defines low-level functions that perform a single step of the</span>
<span class="sd">forward or backward step. Some of these function makes it possible to perform</span>
<span class="sd">such steps *in parallel* (e.g. for N predictive means).  The table below lists</span>
<span class="sd">these functions. Some of the required inputs are `MeanAndCov` objects, which</span>
<span class="sd">may be defined as follows::</span>

<span class="sd">    my_predictive_dist = kalman.MeanAndCov(mean=np.ones(2), cov=np.eye(2))</span>

<span class="sd">+----------------------------------------------+</span>
<span class="sd">| Function (with signature)                    |</span>
<span class="sd">+==============================================+</span>
<span class="sd">| predict_step(F, covX, filt)                  |</span>
<span class="sd">+----------------------------------------------+</span>
<span class="sd">| filter_step(G, covY, pred, yt)               |</span>
<span class="sd">+----------------------------------------------+</span>
<span class="sd">| filter_step_asarray(G, covY, pred, yt)       |</span>
<span class="sd">+----------------------------------------------+</span>
<span class="sd">| smoother_step(F, filt, next_pred, next_smth) |</span>
<span class="sd">+----------------------------------------------+</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">solve</span><span class="p">,</span> <span class="n">pinv</span>

<span class="kn">from</span> <span class="nn">particles</span> <span class="kn">import</span> <span class="n">distributions</span> <span class="k">as</span> <span class="n">dists</span>
<span class="kn">from</span> <span class="nn">particles</span> <span class="kn">import</span> <span class="n">state_space_models</span> <span class="k">as</span> <span class="n">ssms</span>

<span class="n">error_msg</span> <span class="o">=</span> <span class="s2">&quot;arguments of KalmanFilter.__init__ have inconsistent shapes&quot;</span>

<span class="c1">########################</span>
<span class="c1"># Low-level functions</span>
<span class="c1">########################</span>

<div class="viewcode-block" id="dotdot">
<a class="viewcode-back" href="../../../../../source/snowdrop.src.numeric.filters.html#snowdrop.src.numeric.filters.kalman.dotdot">[docs]</a>
<span class="k">def</span> <span class="nf">dotdot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">c</span><span class="p">)</span></div>


<div class="viewcode-block" id="dotdotinv">
<a class="viewcode-back" href="../../../../../source/snowdrop.src.numeric.filters.html#snowdrop.src.numeric.filters.kalman.dotdotinv">[docs]</a>
<span class="k">def</span> <span class="nf">dotdotinv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; a * b * c^{-1}, where c is symmetric positive</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#ag return solve(c, np.dot(a, b).T, assume_a=&#39;pos&#39;, overwrite_b=True).T</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">assume_a</span><span class="o">=</span><span class="s1">&#39;pos&#39;</span><span class="p">,</span> <span class="n">overwrite_b</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">pinv</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">x</span><span class="p">))</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">pinv</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">x</span><span class="p">))</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
    <span class="k">return</span> <span class="n">z</span><span class="o">.</span><span class="n">T</span></div>


<span class="n">MeanAndCov</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;MeanAndCov&#39;</span><span class="p">,</span> <span class="s1">&#39;mean cov&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="predict_step">
<a class="viewcode-back" href="../../../../../source/snowdrop.src.numeric.filters.html#snowdrop.src.numeric.filters.kalman.predict_step">[docs]</a>
<span class="k">def</span> <span class="nf">predict_step</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">covX</span><span class="p">,</span> <span class="n">filt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Predictive step of Kalman filter.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    F:  (dx, dx) numpy array</span>
<span class="sd">        Mean of X_t | X_{t-1} is F * X_{t-1}</span>
<span class="sd">    covX: (dx, dx) numpy array</span>
<span class="sd">        covariance of X_t | X_{t-1}</span>
<span class="sd">    filt: MeanAndCov object</span>
<span class="sd">        filtering distribution at time t-1</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pred: MeanAndCov object</span>
<span class="sd">        predictive distribution at time t</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    filt.mean may either be of shape (dx,) or (N, dx); in the latter case</span>
<span class="sd">    N predictive steps are performed in parallel.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pred_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">filt</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">pred_cov</span> <span class="o">=</span> <span class="n">dotdot</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">filt</span><span class="o">.</span><span class="n">cov</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">covX</span>
    <span class="k">return</span> <span class="n">MeanAndCov</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="n">pred_mean</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="n">pred_cov</span><span class="p">)</span></div>



<div class="viewcode-block" id="filter_step">
<a class="viewcode-back" href="../../../../../source/snowdrop.src.numeric.filters.html#snowdrop.src.numeric.filters.kalman.filter_step">[docs]</a>
<span class="k">def</span> <span class="nf">filter_step</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">covY</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">yt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Filtering step of Kalman filter.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G:  (dy, dx) numpy array</span>
<span class="sd">        mean of Y_t | X_t is G * X_t</span>
<span class="sd">    covX: (dx, dx) numpy array</span>
<span class="sd">        covariance of Y_t | X_t</span>
<span class="sd">    pred: MeanAndCov object</span>
<span class="sd">        predictive distribution at time t</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pred: MeanAndCov object</span>
<span class="sd">        filtering distribution at time t</span>
<span class="sd">    logpyt: float</span>
<span class="sd">        log density of Y_t | Y_{0:t-1}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># data prediction</span>
    <span class="n">data_pred_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">pred</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">G</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">data_pred_cov</span> <span class="o">=</span> <span class="n">dotdot</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pred</span><span class="o">.</span><span class="n">cov</span><span class="p">,</span> <span class="n">G</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">covY</span>
    <span class="k">if</span> <span class="n">covY</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">logpyt</span> <span class="o">=</span> <span class="n">dists</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">data_pred_mean</span><span class="p">,</span>
                              <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">data_pred_cov</span><span class="p">))</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span><span class="n">yt</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logpyt</span> <span class="o">=</span> <span class="n">dists</span><span class="o">.</span><span class="n">MvNormal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">data_pred_mean</span><span class="p">,</span>
                                <span class="n">cov</span><span class="o">=</span><span class="n">data_pred_cov</span><span class="p">)</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span><span class="n">yt</span><span class="p">)</span>
    <span class="c1"># filter</span>
    <span class="n">residual</span> <span class="o">=</span> <span class="n">yt</span> <span class="o">-</span> <span class="n">data_pred_mean</span>
    <span class="n">gain</span> <span class="o">=</span> <span class="n">dotdotinv</span><span class="p">(</span><span class="n">pred</span><span class="o">.</span><span class="n">cov</span><span class="p">,</span> <span class="n">G</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">data_pred_cov</span><span class="p">)</span>
    <span class="n">filt_mean</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="n">mean</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">residual</span><span class="p">,</span> <span class="n">gain</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">filt_cov</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="n">cov</span> <span class="o">-</span> <span class="n">dotdot</span><span class="p">(</span><span class="n">gain</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">pred</span><span class="o">.</span><span class="n">cov</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">MeanAndCov</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="n">filt_mean</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="n">filt_cov</span><span class="p">),</span> <span class="n">logpyt</span></div>



<div class="viewcode-block" id="filter_step_asarray">
<a class="viewcode-back" href="../../../../../source/snowdrop.src.numeric.filters.html#snowdrop.src.numeric.filters.kalman.filter_step_asarray">[docs]</a>
<span class="k">def</span> <span class="nf">filter_step_asarray</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">covY</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">yt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Filtering step of Kalman filter: array version.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G:  (dy, dx) numpy array</span>
<span class="sd">        mean of Y_t | X_t is G * X_t</span>
<span class="sd">    covX: (dx, dx) numpy array</span>
<span class="sd">        covariance of Y_t | X_t</span>
<span class="sd">    pred: MeanAndCov object</span>
<span class="sd">        predictive distribution at time t</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pred: MeanAndCov object</span>
<span class="sd">        filtering distribution at time t</span>
<span class="sd">    logpyt: float</span>
<span class="sd">        log density of Y_t | Y_{0:t-1}</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    This performs the filtering step for N distinctive predictive means:</span>
<span class="sd">    filt.mean should be a (N, dx) or (N) array; pred.mean in the output</span>
<span class="sd">    will have the same shape.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pm</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="n">mean</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="k">if</span> <span class="n">pred</span><span class="o">.</span><span class="n">mean</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">pred</span><span class="o">.</span><span class="n">mean</span>
    <span class="n">new_pred</span> <span class="o">=</span> <span class="n">MeanAndCov</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="n">pm</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="n">pred</span><span class="o">.</span><span class="n">cov</span><span class="p">)</span>
    <span class="n">filt</span><span class="p">,</span> <span class="n">logpyt</span> <span class="o">=</span> <span class="n">filter_step</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">covY</span><span class="p">,</span> <span class="n">new_pred</span><span class="p">,</span> <span class="n">yt</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">pred</span><span class="o">.</span><span class="n">mean</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">filt</span><span class="o">.</span><span class="n">mean</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">filt</span><span class="p">,</span> <span class="n">logpyt</span></div>



<div class="viewcode-block" id="smoother_step">
<a class="viewcode-back" href="../../../../../source/snowdrop.src.numeric.filters.html#snowdrop.src.numeric.filters.kalman.smoother_step">[docs]</a>
<span class="k">def</span> <span class="nf">smoother_step</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">filt</span><span class="p">,</span> <span class="n">next_pred</span><span class="p">,</span> <span class="n">next_smth</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Smoothing step of Kalman filter/smoother.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    F:  (dx, dx) numpy array</span>
<span class="sd">        Mean of X_t | X_{t-1} is F * X_{t-1}</span>
<span class="sd">    filt: MeanAndCov object</span>
<span class="sd">        filtering distribution at time t</span>
<span class="sd">    next_pred: MeanAndCov object</span>
<span class="sd">        predictive distribution at time t+1</span>
<span class="sd">    next_smth: MeanAndCov object</span>
<span class="sd">        smoothing distribution at time t+1</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    smth: MeanAndCov object</span>
<span class="sd">        smoothing distribution at time t</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">dotdotinv</span><span class="p">(</span><span class="n">filt</span><span class="o">.</span><span class="n">cov</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">next_pred</span><span class="o">.</span><span class="n">cov</span><span class="p">)</span>
    <span class="n">smth_cov</span> <span class="o">=</span> <span class="n">filt</span><span class="o">.</span><span class="n">cov</span> <span class="o">+</span> <span class="n">dotdot</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">next_smth</span><span class="o">.</span><span class="n">cov</span> <span class="o">-</span> <span class="n">next_pred</span><span class="o">.</span><span class="n">cov</span><span class="p">,</span> <span class="n">J</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">smth_mean</span> <span class="o">=</span> <span class="n">filt</span><span class="o">.</span><span class="n">mean</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">next_smth</span><span class="o">.</span><span class="n">mean</span> <span class="o">-</span> <span class="n">next_pred</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">J</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">MeanAndCov</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="n">smth_mean</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="n">smth_cov</span><span class="p">)</span></div>



<span class="c1">###############################</span>
<span class="c1"># State-space model classes</span>
<span class="c1">###############################</span>

<div class="viewcode-block" id="MVLinearGauss">
<a class="viewcode-back" href="../../../../../source/snowdrop.src.numeric.filters.html#snowdrop.src.numeric.filters.kalman.MVLinearGauss">[docs]</a>
<span class="k">class</span> <span class="nc">MVLinearGauss</span><span class="p">(</span><span class="n">ssms</span><span class="o">.</span><span class="n">StateSpaceModel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Multivariate linear Gaussian model.</span>

<span class="sd">    .. math::</span>
<span class="sd">        X_0 &amp; \sim N(\mu_0, cov_0) \\</span>
<span class="sd">        X_t &amp; = F * X_{t-1} + U_t, \quad   U_t\sim N(0, cov_X) \\</span>
<span class="sd">        Y_t &amp; = G * X_t + V_t,     \quad   V_t \sim N(0, cov_Y)</span>

<span class="sd">    The only mandatory parameters are `covX` and `covY` (from which the</span>
<span class="sd">    dimensions dx and dy of, respectively, X_t, and Y_t, are deduced). The</span>
<span class="sd">    default values for the other parameters are:</span>
<span class="sd">        * `mu0`:: an array of zeros (of size dx)</span>
<span class="sd">        * `cov0`: cov_X</span>
<span class="sd">        * `F`: Identity matrix of shape (dx, dx)</span>
<span class="sd">        * `G`: (dy, dx) matrix such that G[i, j] = 1[i=j]</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    The Kalman filter takes as an input an instance of this class (or one of</span>
<span class="sd">    its subclasses).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">G</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">covX</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">covY</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mu0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">cov0</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">covX</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">covY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">covX</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">covY</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">covX</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">covY</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mu0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span> <span class="k">if</span> <span class="n">mu0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">mu0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cov0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">covX</span> <span class="k">if</span> <span class="n">cov0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">cov0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span> <span class="k">if</span> <span class="n">F</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span> <span class="k">if</span> <span class="n">G</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_shapes</span><span class="p">()</span>

<div class="viewcode-block" id="MVLinearGauss.check_shapes">
<a class="viewcode-back" href="../../../../../source/snowdrop.src.numeric.filters.html#snowdrop.src.numeric.filters.kalman.MVLinearGauss.check_shapes">[docs]</a>
    <span class="k">def</span> <span class="nf">check_shapes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check all dimensions are correct.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">covX</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">),</span> <span class="n">error_msg</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">covY</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="p">),</span> <span class="n">error_msg</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">),</span> <span class="n">error_msg</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">),</span> <span class="n">error_msg</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu0</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">,),</span> <span class="n">error_msg</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov0</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">),</span> <span class="n">error_msg</span></div>


<div class="viewcode-block" id="MVLinearGauss.PX0">
<a class="viewcode-back" href="../../../../../source/snowdrop.src.numeric.filters.html#snowdrop.src.numeric.filters.kalman.MVLinearGauss.PX0">[docs]</a>
    <span class="k">def</span> <span class="nf">PX0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">dists</span><span class="o">.</span><span class="n">MvNormal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mu0</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cov0</span><span class="p">)</span></div>


<div class="viewcode-block" id="MVLinearGauss.PX">
<a class="viewcode-back" href="../../../../../source/snowdrop.src.numeric.filters.html#snowdrop.src.numeric.filters.kalman.MVLinearGauss.PX">[docs]</a>
    <span class="k">def</span> <span class="nf">PX</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">xp</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">dists</span><span class="o">.</span><span class="n">MvNormal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">cov</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">covX</span><span class="p">)</span></div>


<div class="viewcode-block" id="MVLinearGauss.PY">
<a class="viewcode-back" href="../../../../../source/snowdrop.src.numeric.filters.html#snowdrop.src.numeric.filters.kalman.MVLinearGauss.PY">[docs]</a>
    <span class="k">def</span> <span class="nf">PY</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">dists</span><span class="o">.</span><span class="n">MvNormal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">cov</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">covY</span><span class="p">)</span></div>


<div class="viewcode-block" id="MVLinearGauss.proposal">
<a class="viewcode-back" href="../../../../../source/snowdrop.src.numeric.filters.html#snowdrop.src.numeric.filters.kalman.MVLinearGauss.proposal">[docs]</a>
    <span class="k">def</span> <span class="nf">proposal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="n">MeanAndCov</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">cov</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">covX</span><span class="p">)</span>
        <span class="n">f</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">filter_step_asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">covY</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">t</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">dists</span><span class="o">.</span><span class="n">MvNormal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">f</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="n">f</span><span class="o">.</span><span class="n">cov</span><span class="p">)</span></div>


<div class="viewcode-block" id="MVLinearGauss.proposal0">
<a class="viewcode-back" href="../../../../../source/snowdrop.src.numeric.filters.html#snowdrop.src.numeric.filters.kalman.MVLinearGauss.proposal0">[docs]</a>
    <span class="k">def</span> <span class="nf">proposal0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">pred0</span> <span class="o">=</span> <span class="n">MeanAndCov</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mu0</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cov0</span><span class="p">)</span>
        <span class="n">f</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">filter_step</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">covY</span><span class="p">,</span> <span class="n">pred0</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">dists</span><span class="o">.</span><span class="n">MvNormal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">f</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="n">f</span><span class="o">.</span><span class="n">cov</span><span class="p">)</span></div>


<div class="viewcode-block" id="MVLinearGauss.logeta">
<a class="viewcode-back" href="../../../../../source/snowdrop.src.numeric.filters.html#snowdrop.src.numeric.filters.kalman.MVLinearGauss.logeta">[docs]</a>
    <span class="k">def</span> <span class="nf">logeta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="n">MeanAndCov</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">cov</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">covX</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">logpyt</span> <span class="o">=</span> <span class="n">filter_step_asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">covY</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">logpyt</span></div>
</div>


<div class="viewcode-block" id="MVLinearGauss_Guarniero_etal">
<a class="viewcode-back" href="../../../../../source/snowdrop.src.numeric.filters.html#snowdrop.src.numeric.filters.kalman.MVLinearGauss_Guarniero_etal">[docs]</a>
<span class="k">class</span> <span class="nc">MVLinearGauss_Guarniero_etal</span><span class="p">(</span><span class="n">MVLinearGauss</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Special case of a MV Linear Gaussian ssm from Guarnierio et al. (2016).</span>

<span class="sd">    .. math::</span>
<span class="sd">        G = cov_X = cov_Y = cov_0 = I_{d_x}</span>

<span class="sd">        F_{i, j} = \alpha^ { 1 + |i-j|}</span>

<span class="sd">    See `MVLinearGauss` for the definition of these quantities.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    alpha:  float (default: 0.4)</span>
<span class="sd">        value of alpha</span>
<span class="sd">    dx: int (must be &gt;1; default: 2)</span>
<span class="sd">        dimension of state-space</span>

<span class="sd">    Reference</span>
<span class="sd">    ---------</span>
<span class="sd">    Guarnierio et al (2016). The Iterated Auxiliary Particle Filter,</span>
<span class="sd">        arxiv:1511.06286, JASA.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">dx</span><span class="p">,</span> <span class="n">dx</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dx</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dx</span><span class="p">):</span>
                <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">))</span>
        <span class="n">MVLinearGauss</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="o">=</span><span class="n">F</span><span class="p">,</span> <span class="n">G</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dx</span><span class="p">),</span> <span class="n">covX</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dx</span><span class="p">),</span>
                               <span class="n">covY</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dx</span><span class="p">))</span></div>


<div class="viewcode-block" id="LinearGauss">
<a class="viewcode-back" href="../../../../../source/snowdrop.src.numeric.filters.html#snowdrop.src.numeric.filters.kalman.LinearGauss">[docs]</a>
<span class="k">class</span> <span class="nc">LinearGauss</span><span class="p">(</span><span class="n">MVLinearGauss</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;A basic (univariate) linear Gaussian model.</span>

<span class="sd">        .. math::</span>
<span class="sd">            X_0                 &amp; \sim N(0, \sigma_0^2) \\</span>
<span class="sd">            X_t|X_{t-1}=x_{t-1} &amp; \sim N(\rho * X_{t-1},\sigma_X^2) \\</span>
<span class="sd">            Y_t |X_t=x_t        &amp; \sim N(x_t, \sigma_Y^2)</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        If parameter sigma0 is set to None, it is replaced by the quantity that</span>
<span class="sd">        makes the state process invariant:</span>
<span class="sd">        :math:`\sigma_X^2 / (1 - \rho^2)`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">default_params</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;sigmaY&#39;</span><span class="p">:</span> <span class="mf">.2</span><span class="p">,</span> <span class="s1">&#39;rho&#39;</span><span class="p">:</span> <span class="mf">0.9</span><span class="p">,</span> <span class="s1">&#39;sigmaX&#39;</span><span class="p">:</span> <span class="mf">1.</span><span class="p">,</span>
                      <span class="s1">&#39;sigma0&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">ssms</span><span class="o">.</span><span class="n">StateSpaceModel</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sigma0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigmaX</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># arguments for Kalman</span>
        <span class="n">MVLinearGauss</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span> <span class="n">G</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">covX</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sigmaX</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
                               <span class="n">covY</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigmaY</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">cov0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma0</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<div class="viewcode-block" id="LinearGauss.PX0">
<a class="viewcode-back" href="../../../../../source/snowdrop.src.numeric.filters.html#snowdrop.src.numeric.filters.kalman.LinearGauss.PX0">[docs]</a>
    <span class="k">def</span> <span class="nf">PX0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">dists</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma0</span><span class="p">)</span></div>


<div class="viewcode-block" id="LinearGauss.PX">
<a class="viewcode-back" href="../../../../../source/snowdrop.src.numeric.filters.html#snowdrop.src.numeric.filters.kalman.LinearGauss.PX">[docs]</a>
    <span class="k">def</span> <span class="nf">PX</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">xp</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">dists</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">*</span> <span class="n">xp</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sigmaX</span><span class="p">)</span></div>


<div class="viewcode-block" id="LinearGauss.PY">
<a class="viewcode-back" href="../../../../../source/snowdrop.src.numeric.filters.html#snowdrop.src.numeric.filters.kalman.LinearGauss.PY">[docs]</a>
    <span class="k">def</span> <span class="nf">PY</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">dists</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sigmaY</span><span class="p">)</span></div>


<div class="viewcode-block" id="LinearGauss.proposal0">
<a class="viewcode-back" href="../../../../../source/snowdrop.src.numeric.filters.html#snowdrop.src.numeric.filters.kalman.LinearGauss.proposal0">[docs]</a>
    <span class="k">def</span> <span class="nf">proposal0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">sig2post</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma0</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">1.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigmaY</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">mupost</span> <span class="o">=</span> <span class="n">sig2post</span> <span class="o">*</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigmaY</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dists</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">mupost</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sig2post</span><span class="p">))</span></div>


<div class="viewcode-block" id="LinearGauss.proposal">
<a class="viewcode-back" href="../../../../../source/snowdrop.src.numeric.filters.html#snowdrop.src.numeric.filters.kalman.LinearGauss.proposal">[docs]</a>
    <span class="k">def</span> <span class="nf">proposal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">sig2post</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigmaX</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">1.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigmaY</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">mupost</span> <span class="o">=</span> <span class="n">sig2post</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">*</span> <span class="n">xp</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigmaX</span><span class="o">**</span><span class="mi">2</span>
                             <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigmaY</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dists</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">mupost</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sig2post</span><span class="p">))</span></div>


<div class="viewcode-block" id="LinearGauss.logeta">
<a class="viewcode-back" href="../../../../../source/snowdrop.src.numeric.filters.html#snowdrop.src.numeric.filters.kalman.LinearGauss.logeta">[docs]</a>
    <span class="k">def</span> <span class="nf">logeta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">law</span> <span class="o">=</span> <span class="n">dists</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span>
                           <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigmaX</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigmaY</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">law</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span></div>
</div>


<span class="c1">#################################</span>
<span class="c1"># Kalman filter/smoother class</span>
<span class="c1">#################################</span>

<div class="viewcode-block" id="Kalman">
<a class="viewcode-back" href="../../../../../source/snowdrop.src.numeric.filters.html#snowdrop.src.numeric.filters.kalman.Kalman">[docs]</a>
<span class="k">class</span> <span class="nc">Kalman</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Kalman filter/smoother.</span>


<span class="sd">    See the documentation of the module for more details.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ssm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ssm: MVLinearGaussian object</span>
<span class="sd">            the linear Gaussian model of interest</span>
<span class="sd">        data: list-like</span>
<span class="sd">            the data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span> <span class="o">=</span> <span class="n">ssm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pred</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">logpyt</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">t</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filt</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">yt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">pred</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pred</span> <span class="o">+=</span> <span class="p">[</span><span class="n">MeanAndCov</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">mu0</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">cov0</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pred</span> <span class="o">+=</span> <span class="p">[</span><span class="n">predict_step</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">F</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">covX</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filt</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span>
        <span class="n">new_filt</span><span class="p">,</span> <span class="n">new_logpyt</span> <span class="o">=</span> <span class="n">filter_step</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">covY</span><span class="p">,</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">pred</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">yt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_filt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logpyt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_logpyt</span><span class="p">)</span>

<div class="viewcode-block" id="Kalman.next">
<a class="viewcode-back" href="../../../../../source/snowdrop.src.numeric.filters.html#snowdrop.src.numeric.filters.kalman.Kalman.next">[docs]</a>
    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__next__</span><span class="p">()</span>  <span class="c1"># Python 2 compatibility</span></div>


    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

<div class="viewcode-block" id="Kalman.filter">
<a class="viewcode-back" href="../../../../../source/snowdrop.src.numeric.filters.html#snowdrop.src.numeric.filters.kalman.Kalman.filter">[docs]</a>
    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Forward recursion: compute mean/variance of filter and prediction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">pass</span></div>


<div class="viewcode-block" id="Kalman.smoother">
<a class="viewcode-back" href="../../../../../source/snowdrop.src.numeric.filters.html#snowdrop.src.numeric.filters.kalman.Kalman.smoother">[docs]</a>
    <span class="k">def</span> <span class="nf">smoother</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Backward recursion: compute mean/variance of marginal smoother.</span>

<span class="sd">        Performs the filter step in a preliminary step if needed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">filt</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">smth</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">filt</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filt</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">smth</span> <span class="o">+=</span> <span class="p">[</span><span class="n">smoother_step</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">F</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pred</span><span class="p">[</span><span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">smth</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">smth</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span></div>
</div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../index.html">Python Platform</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../source/modules.html">snowdrop</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../info.html">Python Platform</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../index.html">Documentation overview</a><ul>
  <li><a href="../../../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, Alexei Goumilevski.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.3.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
    </div>

    

    
  </body>
</html>