# -*- coding: utf-8 -*-
""" 
This is the Python translation of Mathematica code to determine what 
final equilibrium would arise from a lattice of possible couples of parameters defining 
the initial decisions by merchants (pic and pid). The code considers all possible 
couples for values of each parameters between 0 and 1, with a step width of 0.01 between 
successive values. However, we need to do some extra work:

1.	It would be useful to extend the code to identify all the steady state equilibria 
    that would emerge allowing the following parameters to vary within the ranges 
    indicated below (or other possible ranges to be defined), examining all the possible 
    combinations that would emerge:
	Cf between 0 and 1;
	Cd between 0  and 1;
	Rd between 0 and 1;
	W between 0 and 2;
	Qc between 0 and 1;
	Qd between 0 and 1;
	Xi between 0 and 2;
 
    Examining 100 possible values of these 7 variables would yield 10^14 = 100,000,000,000,000 possible combinations 
    and an equivalent number of steady state equilibria (not counting the corner ones 0,1 and 1,0). 
    The number could be reduced by considering only 10 possible values for each variable, but would still remain large (10,000,000). 
    
    The code would thus need to contain instructions to classify different types of equilibria, in particular:
	interior equilibria, where pic + pid < 1;
	mixed equilibria, where 0.5 < x, y < 1;
	equilibria satisfying both conditions above;
	boundary equilibria (pic + pid = 1) where 0.5 < x, y < 1 or where either x or y is positive but less than 1;
 
2.	It would also be useful to identify any configurations of parameters in which more than one interior or boundary equilibrium emerges.  
    A steady state equilibrium is defined here as a condition in which x, y, z, pic, and pic do not change over time. 

"""
import os
import numpy as np
import matplotlib.pyplot as plt
from numba import njit


path = os.path.dirname(os.path.abspath(__file__))

Plot = True; Save = True
ERROR = 1.e-4; EPS = 1.e-6
ITER = 100; itr = 0
step = 0.01; step2 = 0.01
N = int(1/step) + 1

def If(x,a,b):
    return a if bool(x) else b
    
def plot(x,y,z,descr="",plot=False,save=True):
    if save:
        figsize=(8, 4)
    else:
        figsize=(4, 2)
    
    fig = plt.figure(figsize=figsize)
    T = np.arange(len(x))
    plt.plot(T,x,label="X")
    plt.plot(T,y,label="Y")
    plt.plot(T,z,label="Z")
    plt.grid(True)
    plt.title('Customer Variables\n('+descr+")",fontsize = 'x-large')
    plt.xlabel('Iteration')
    plt.ylabel('X, Y, Z')
    plt.legend(loc="best",fontsize = 'medium')
    
    fpath = os.path.abspath(os.path.join(path,"../../../graphs/CBDC",descr+".png"))
    if save:
        plt.savefig(fpath)
    if plot:
        plt.show(block=False)
        plt.close(fig)
    
    
def img(title,mat,descr="",plot=False,save=True):
    plt.matshow(mat,cmap=plt.cm.viridis)
    plt.colorbar()
    plt.title(title)
    plt.figtext(0.5,0.03,descr,ha="center",fontsize=8,bbox={"facecolor":"orange","alpha":0.5,"pad":5})
    ax = plt.gca()
    # plt.xlabel('Pico')
    # plt.ylabel('Pido')
    labels = [item.get_text() for item in ax.get_xticklabels()]
    n = len(labels)
    xlabels = [f"{x/n:.1f}" for x in range(n)]
    ylabels = list(reversed(xlabels))
    ax.xaxis.set_ticklabels(xlabels)
    ax.tick_params(axis="x",bottom=True,top=False,labelbottom=True,labeltop=False)
    ax.yaxis.set_ticklabels(ylabels)
    
    fpath = os.path.abspath(os.path.join(path,"../../../graphs/CBDC",title+"_"+descr+".png"))
    if save:
        plt.savefig(fpath)
    if plot:
        plt.show(block=False)

@njit
def func(
       # Customer parameters
       cf=0.3,cd=0.3,w=0,rd=0.5,bl=0,bh=1,deb=1,
       # Merchant parameters
       pic=0.1,pid=0.1,xi=1,qc=0.3,qd=0.3,pch=1,pdh=1
       ):

    ### I. CUSTOMERS' DECISION PROBLEM
    
    # variables generated by the model
    beta1 = If(pid > 0, cd/max(1.e-10,pid) - w, 999)
    beta2 = If(pic > 0, cf/max(1.e-10,pic) - w, 999)
    cond1 = If(pic + pid == 0, 1, If(pic + pid < 1, 2, 3))
    cond2 = If(pic == 0, 1, If(pic < 1, 2, 3))
    cond3 = If(pid == 0, 1, If(pid < 1, 2, 3))
    conta1 = cond1*10 + cond2
    conta2 = cond2*10 + cond3
    
    beta1_star = If(conta2 == 22, rd - (beta1 - rd)*pid/max(1.e-10,1 - pic - pid), 999)
    beta2_star = If(conta1 < 23, rd + (beta2 - rd)*pic/max(1.e-10,1 - pid), 999)
    beta3_star = If(conta2 < 23, beta2_star + (beta1_star - rd)*(1 - pic - pid)/max(1.e-10,1 - pid), 999)
    
    cond4a = If(pid == 0, 999, If(beta1 >= rd, 1, 0))
    cond4b = If(pic == 0, 999, If(beta2 >= rd, 1, 0))
    cond4 = If(cond4a == 1, If(cond4b == 1, 1, 2), If(cond4b == 1, 3, 4))
    cond5 = If(pic*pid > 0, If(beta1_star >= beta2_star, 1, 2), 0)
    conta3 = cond1*10 + cond4
    conta4 = conta3*10 + cond5
    
    # customers' regime (definitions)
    regime = If(conta4 == 221, 1, 0)
    regime = If(conta4 == 222, 2, regime)
    regime = If(conta3 == 23, 3, regime)
    regime = If(conta3 == 24, 4, regime)
    regime = If(conta3 == 21, 5, regime)
    regime = If(conta3 > 32, If(pic*pid > 0, 6, regime), regime)
    regime = If(conta3 > 30, \
      If(pic*pid > 0, If(conta3 < 33, 7, regime), regime), regime)
    regime = If(cond2 == 1, If(cond4a == 1, 8, regime), regime)
    regime = If(cond2 == 1, If(cond4a == 0, 9, regime), regime)
    regime = If(cond3 == 1, If(cond4b == 1, 10, regime), regime)
    regime = If(cond3 == 1, \
      If(cond4b == 0, \
       If(pic < 1, If(beta2 >= rd - cd/max(1.e-10,1 - pic), 11, 12), 11), regime), \
      regime)
    regime = If(cond2*cond3 == 1, 13, regime)
    
    # caluclation of x and y, depending on the regime
    xa = If(regime == 1, (bh - beta2_star)/deb, 0)
    xa = If(regime == 2, (bh - beta3_star)/deb, xa)
    xa = If(regime == 3, (bh - beta2_star)/deb, xa)
    xa = If(regime == 4, (bh - beta2)/deb, xa)
    xa = If(regime == 5, (bh - beta3_star)/deb, xa)
    xa = If(regime == 6, (bh - beta2)/deb, xa)
    xa = If(regime == 7, (bh - beta2 + (beta1 - rd)*pid/max(1.e-10,1 - pid))/deb, xa)
    xa = If(regime == 8, \
      If(pid < 1, (bh - rd - ((beta1 - rd)*pid - cf)/max(1.e-10,1 - pid))/deb, xa), \
       xa)
    xa = If(regime == 9, If(pid < 1, (bh - rd - cf/max(1.e-10,1 - pid))/deb, 0), \
       xa)
    xa = If(regime == 10, 
      If(pic < 1, (bh - rd*(1 - pic) - cf + cd + w*pic)/deb, 1), xa)
    xa = If(regime == 11, 
      If(pic < 1, (bh - rd*(1 - pic) - cf + cd + w*pic)/deb, 1), xa)
    xa = If(regime == 12, If(pic < 1, (bh - beta2)/deb, 1), xa)
    xa = If(regime == 13, (bh - rd - cf + cd)/deb, xa)
    
    ya = If(regime == 1, (beta1_star - bl)/deb, 0)
    ya = If(regime == 2, (beta3_star - bl)/deb, ya)
    ya = If(regime == 3, 1, ya)
    ya = If(regime == 4, 1, ya)
    ya = If(regime == 5, (beta3_star - bl)/deb, ya)
    ya = If(regime == 6, 1, ya)
    ya = If(regime == 7, 1 - xa, ya)
    ya = If(regime == 8, 1 - xa, ya)
    ya = If(regime == 9, 1 - xa, ya)
    ya = If(regime == 10, 1 - xa, ya)
    ya = If(regime == 11, 1 - xa, ya)
    ya = If(regime == 12, (rd - cd/max(1.e-10,1 - pic) - bl)/deb, ya)
    ya = If(regime == 13, 1 - xa, ya)
    
    x = max(min(xa, 1), 0)
    y = max(min(ya, 1), 0)
    rdb = 1 - (bh - rd)/deb
    z = If(x > rdb, rdb, min(rdb, y))
    
    ### II. MERCHANTS' DECISION PROBLEM
    
    # variables generated by the model
    p1 = xi - qd + (qc - xi)*x + (qd - qc)*z
    p2 = xi - qd + (qd - xi)*y + (qd - qc)*z
    p3 = (qc - xi)*x - (qd - xi)*y
    
    bou1 = If(p1 < 0, 1, If(p1 >= pdh, 3, 2))
    bou2 = If(p2 < 0, 1, If(p2 >= pch, 3, 2))
    bou3 = If(p3 < -pch, 1, If(p3 >= pdh, 3, 2))
    boudec = bou1*100 + bou2*10 + bou3
    boudec2 = bou1*100 + bou2*10
    bou4 = If(p3 >= 0, 1, 2)
    boudec3 = bou1*100 + bou2*10 + bou4
    
    # merchant regime (definitions)
    outcome = If(boudec3 == 221, 1, 0)
    outcome = If(boudec3 == 222, 2, outcome)
    outcome = If(boudec == 122, 3, outcome)
    outcome = If(boudec == 121, 4, outcome)
    outcome = \
     If(boudec == 112, If(boudec3 == 112, 5, outcome), outcome)
    outcome = \
     If(boudec == 112, If(boudec3 == 111, 6, outcome), outcome)
    outcome = If(boudec == 111, 7, outcome)
    outcome = If(boudec == 113, 8, outcome)
    outcome = If(boudec2 == 130, 9, outcome)
    outcome = If(boudec == 212, 10, outcome)
    outcome = If(boudec == 213, 11, outcome)
    outcome = If(boudec2 == 230, 12, outcome)
    outcome = If(boudec2 == 310, 13, outcome)
    outcome = If(boudec2 == 320, 14, outcome)
    outcome = If(boudec2 == 330, 15, outcome)
    
    # calculation of pic and pid depending on the regime
    pict = If(outcome == 1, (p2 + pch - p3)*(pdh - p1)/2, 0)
    pict = \
     If(outcome == 2, (p2 + pch)*(pdh - p1 - p3)/2 + p3*pch, pict)
    pict = If(outcome == 3, pch*pdh - (pch + p3)**2/2, pict)
    pict = If(outcome == 4, pch*pdh, pict)
    pict = If(outcome == 5, pch*pdh - (pch - p3)**2/2, pict)
    pict = If(outcome == 6, (pdh - p3)**2/2, pict)
    pict = If(outcome == 7, pch*pdh, pict)
    pict = If(outcome == 8, 0, pict)
    pict = If(outcome == 9, pch*pdh, pict)
    pict = If(outcome == 10, (pdh - p3)**2/2, pict)
    pict = If(outcome == 11, 0, pict)
    pict = If(outcome == 12, (pdh - p1)*pch, pict)
    pict = If(outcome == 13, 0, pict)
    pict = If(outcome == 14, 0, pict)
    pict = If(outcome == 15, 0, pict)
    pict = pict/pch/pdh
    
    pidt = If(outcome == 1, (p1 + pdh)*(pch - p2 - p3)/2 + p3*pdh, 0)
    pidt = If(outcome == 2, (p1 + pdh - p3)*(pch - p2)/2, pidt)
    pidt = If(outcome == 3, pch*pdh*(1 - pict), pidt)
    pidt = If(outcome == 4, 0, pidt)
    pidt = If(outcome == 5, pch*pdh*(1 - pict), pidt)
    pidt = If(outcome == 6, pch*pdh*(1 - pict), pidt)
    pidt = If(outcome == 7, 0, pidt)
    pidt = If(outcome == 8, pch*pdh, pidt)
    pidt = If(outcome == 9, 0, pidt)
    pidt = If(outcome == 10, pch*pdh*(1 - pict), pidt)
    pidt = If(outcome == 11, pch*pdh, pidt)
    pidt = If(outcome == 12, 0, pidt)
    pidt = If(outcome == 13, pch*pdh, pidt)
    pidt = If(outcome == 14, (pch - p2)*pdh, pidt)
    pidt = If(outcome == 15, 0, pidt)
    pidt = pidt/pch/pdh
    
    # element of model dynamics
    pic = 0.7*pic + 0.3*pict
    pid = 0.7*pid + 0.3*pidt
    
    return x,xa,y,ya,z,pic,pid,regime,outcome


bHasAttr = hasattr(func,"py_func")
    
# Output matrices
d = np.zeros((N**2, 12))
Mpic = np.zeros((N, N))
Mpid = np.zeros((N, N))
Mx = np.zeros((N, N))
My = np.zeros((N, N))
Mz = np.zeros((N, N))
h = np.zeros((N, N))

xold = yold = zold = 0.5; pic_old = pid_old = pic = pid = 0.1

# Customer parameters
cf=0.3;cd=0.3;w=1;rd=0.5;bl=0;bh=1;deb=bh-bl
# Merchant parameters
xi=1;qc=0.3;qd=0.3;pch=1;pdh=1

### Iteration process to compute the final equilibrium reached from each starting point on the lattice  
### Explore a lattice of possible values of two parameters
# 	Cf between 0 and 1;
# 	Cd between 0  and 1;
# 	Rd = 0.5;
# 	W = 1;
# 	Qc between 0 and 1;
# 	Qd between 0 and 1;
# 	Xi = 1;

itr = 0
fpath2 = os.path.abspath(os.path.join(path,"../../../data/details.csv"))
fpath = os.path.abspath(os.path.join(path,"../../../data/equilibrium.csv"))
with open(fpath, 'w') as file:
    file.write('Qd,Qc,Cd,Cf,Number of Different Equilibria\n')
    with open(fpath2, 'w') as file2:
        file2.write('Qd,Qc,Cd,Cf,Pico,Pic,Pido,Pid,X,Y,Z,Equilibrium\n')
        for cf in np.arange(0,1,step2): 
            for cd in np.arange(0,1,step2):
                for qc in np.arange(0,1,step2):
                    for qd in np.arange(0,1,step2):
                        Neq = 0
                        for f in range(N):
                            pido = f*step
                            for j in range(N - f):
                                pico = j*step
                                pic = pico
                                pid = pido
                                err = 1; err_max = 0; it = 0
                                s = N*f + j + 1
                                xx = [];  yy = [];  zz = [];
                                # iterative processes - start
                                while  it < ITER and err > ERROR : 
                                    it += 1
                                    if bHasAttr:
                                        x,xa,y,ya,z,pic,pid,regime,outcome = \
                                        func.py_func(
                                            # Customer parameters
                                            cf=cf,cd=cd,w=w,rd=rd,bl=0,bh=1,deb=1,
                                            # Merchant parameters
                                            pic=pic,pid=pid,xi=xi,qc=qc,qd=qd,pch=1,pdh=1
                                        )
                                    else:
                                        x,xa,y,ya,z,pic,pid,regime,outcome = \
                                        func(
                                            # Customer parameters
                                            cf=cf,cd=cd,w=w,rd=rd,bl=0,bh=1,deb=1,
                                            # Merchant parameters
                                            pic=pic,pid=pid,xi=xi,qc=qc,qd=qd,pch=1,pdh=1
                                        )
                                    xx.append(x); yy.append(y); zz.append(z)    
                                    #print(f"it={it}, err={err:.2e}, x={x:.2f}, y={y:.2f}, z={z:.2f}, pic={pic:.2f}, pid={pid:.2f}, outcome={outcome}")
                                   
                                    err = abs(pic-pic_old)/max(1.e-10,abs(pic)) \
                                        + abs(pid-pid_old)/max(1.e-10,abs(pid)) \
                                        + abs(x-xold)/max(1.e-10,abs(x)) \
                                        + abs(y-yold)/max(1.e-10,abs(y)) \
                                        + abs(z-zold)/max(1.e-10,abs(z))
                                    err_max = max(err_max,err)
                        
                                    pic_old = pic
                                    pid_old = pid
                                    xold = x
                                    yold = y
                                    zold = z
                                # iterative processes - end
                                
                                b = abs(pic-pico) + abs(pid-pido) < ERROR
                                Neq += 1 if b else 0
                                
                                #if (EPS<x<1-EPS) or (EPS<y<1-EPS):
                                if pic+pid < 1-EPS:
                                    file2.write(f"{qd},{qc},{cd},{cf},{pico},{pic},{pido},{pid},{x},{y},{z},{b}\n")
                                    if itr%100 == 0:
                                        file2.flush()
                                        
                                # Loading results in Matrix d
                                d[s, 1] = f
                                d[s, 2] = j
                                d[s, 3] = s
                                d[s, 4] = pic
                                d[s, 5] = pid
                                d[s, 6] = pico
                                d[s, 7] = pido
                                d[s, 8] = x
                                d[s, 9] = y
                                d[s, 10] = z
                                
                                # itr += 1
                                # if itr%1000 == 0:
                                #     print(f"iter={it}, err={err:.0e}, pic={pico:.2f}, pid={pido:.2f}, x={x:.2f}, y={y:.2f}, xi={xi:.2f}, qd={qd:.2f}, qc={qc:.2f}, w={w:.2f}, rd={rd:.2f}, cd={cd:.2f}, cf={cf:.2f}")
                        
                        file.write(f"{qd},{qc},{cd},{cf},{Neq}\n")
                        if itr%100 == 0:
                            file.flush()
                        itr += 1
                        k = 0
                        Mpic[:] = Mpid[:] =  Mx[:] = My[:] = My[:] = 0
                        for i in range (N):
                          for j in range(N):
                            Mpic[i, j] = d[k, 4]
                            Mpid[i, j] = d[k, 5]
                            Mx[i, j] = d[k, 8]
                            My[i, j] = d[k, 9]
                            Mz[i, j] = d[k, 10]
                            k += 1
                            
                        # # Make matrices symmetric
                        # for i in range (N):
                        #   for j in range(i,N):
                        #     jj = N-1-j
                        #     Mpic[i, j] = Mpic[i, jj]
                        #     Mpid[i, j] = Mpid[i, jj]
                        #     Mx[i, j] = Mx[i, jj]
                        #     My[i, j] = My[i, jj]
                        #     Mz[i, j] = Mz[i, jj]
                              
                        pic_min = np.min(Mpic)
                        pic_max = np.max(Mpic)
                        delta_pic = pic_max - pic_min
                        pid_min = np.min(Mpid)
                        pid_max = np.max(Mpid)
                        delta_pid = pid_max - pid_min
                        x_min   = np.min(Mx)
                        x_max   = np.max(Mx)
                        delta_x = x_max - x_min
                        y_min   = np.min(My)
                        y_max   = np.max(My)
                        delta_y = y_max - y_min
                        z_min   = np.min(Mz)
                        z_max   = np.max(Mz)
                        delta_z = z_max - z_min
                        descr = f"qd={qd:.2f},qc={qc:.2f},cd={cd:.2f},cf={cf:.2f}"
                        print(descr)
                        print(f"max pic={pic_max:.2f}, min pic={pic_min:.2f}; max pid={pid_max:.2f}, min pid={pid_min:.2f}; max x={x_max:.2f}, min x={x_min:.2f}; max y={y_max:.2f}, min y={y_min:.2f}; max z={z_max:.2f}, min z={z_min:.2f}")
                
                        if err > ERROR:
                            plot(xx,yy,zz,descr=descr,save=Save)
                        img('Mpic',Mpic,descr,plot=Plot,save=Save)
                        img('Mpid',Mpid,descr,plot=Plot,save=Save)
                        img('Mx',Mx,descr,plot=Plot,save=Save)
                        img('My',My,descr,plot=Plot,save=Save)
                        img('Mz',Mz,descr,plot=Plot,save=Save)

     
### Presentation of the results

# k = 0
# for i in range (N):
#   for j in range(N):
#     Mpic[i, j] = d[k, 4]
#     Mpid[i, j] = d[k, 5]
#     Mx[i, j] = d[k, 8]
#     My[i, j] = d[k, 9]
#     h[i, j] = k
#     k += 1
  
# # print()
# # print(Mpic)
  
# img('Mpic',Mpic,plot=Plot,save=Save)
# img('Mpid',Mpid,plot=Plot,save=Save)
# img('Mdiff',Mpic-Mpid,plot=Plot,save=Save)
# img('Mx',Mx,plot=Plot,save=Save)
# img('My',My,plot=Plot,save=Save)
# img('Mz',Mz,plot=Plot,save=Save)

# N1 = int(np.ceil(N/10.))
# brief = np.zeros((N1,N1))
# breve = np.zeros((N1,N1))

# for i,ii in enumerate(range(0,N,10)):
#   for j,jj in enumerate(range(0,N,10)):
#     brief[i, j] = Mpic[ii, jj]
#     breve[i, j] = My[ii, jj]

# print()
# print(brief)
# print(breve)

