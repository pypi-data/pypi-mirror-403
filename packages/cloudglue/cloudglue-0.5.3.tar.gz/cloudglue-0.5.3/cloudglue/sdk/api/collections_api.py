# coding: utf-8

"""
    Cloudglue API

    API for Cloudglue

    The version of the OpenAPI document: 0.5.7
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from datetime import date, datetime
from pydantic import Field, StrictFloat, StrictInt, StrictStr, field_validator
from typing import List, Optional, Union
from typing_extensions import Annotated
from cloudglue.sdk.models.add_collection_file import AddCollectionFile
from cloudglue.sdk.models.add_you_tube_collection_file import AddYouTubeCollectionFile
from cloudglue.sdk.models.collection import Collection
from cloudglue.sdk.models.collection_delete import CollectionDelete
from cloudglue.sdk.models.collection_entities_list import CollectionEntitiesList
from cloudglue.sdk.models.collection_file import CollectionFile
from cloudglue.sdk.models.collection_file_delete import CollectionFileDelete
from cloudglue.sdk.models.collection_file_list import CollectionFileList
from cloudglue.sdk.models.collection_list import CollectionList
from cloudglue.sdk.models.collection_media_descriptions_list import CollectionMediaDescriptionsList
from cloudglue.sdk.models.collection_rich_transcripts_list import CollectionRichTranscriptsList
from cloudglue.sdk.models.collection_update import CollectionUpdate
from cloudglue.sdk.models.file_entities import FileEntities
from cloudglue.sdk.models.file_face_detections import FileFaceDetections
from cloudglue.sdk.models.media_description import MediaDescription
from cloudglue.sdk.models.new_collection import NewCollection
from cloudglue.sdk.models.rich_transcript import RichTranscript

from cloudglue.sdk.api_client import ApiClient, RequestSerialized
from cloudglue.sdk.api_response import ApiResponse
from cloudglue.sdk.rest import RESTResponseType


class CollectionsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def add_media(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection to add the media file to")],
        add_collection_file: Annotated[AddCollectionFile, Field(description="File association parameters")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CollectionFile:
        """Add a media file to a collection

        Add a video or audio file to a collection. This is the recommended endpoint for adding media files to collections.  **Media Type Handling:**  - **Video files**: Processed with full visual analysis (scene description, text extraction, etc.) - **Audio files**: Visual features automatically disabled; only speech and audio analysis available  **Audio File Restrictions:**  - Audio files cannot be added to face-analysis collections - Shot-detector segmentation is not available for audio files

        :param collection_id: The ID of the collection to add the media file to (required)
        :type collection_id: str
        :param add_collection_file: File association parameters (required)
        :type add_collection_file: AddCollectionFile
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_media_serialize(
            collection_id=collection_id,
            add_collection_file=add_collection_file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CollectionFile",
            '400': "Error",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def add_media_with_http_info(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection to add the media file to")],
        add_collection_file: Annotated[AddCollectionFile, Field(description="File association parameters")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CollectionFile]:
        """Add a media file to a collection

        Add a video or audio file to a collection. This is the recommended endpoint for adding media files to collections.  **Media Type Handling:**  - **Video files**: Processed with full visual analysis (scene description, text extraction, etc.) - **Audio files**: Visual features automatically disabled; only speech and audio analysis available  **Audio File Restrictions:**  - Audio files cannot be added to face-analysis collections - Shot-detector segmentation is not available for audio files

        :param collection_id: The ID of the collection to add the media file to (required)
        :type collection_id: str
        :param add_collection_file: File association parameters (required)
        :type add_collection_file: AddCollectionFile
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_media_serialize(
            collection_id=collection_id,
            add_collection_file=add_collection_file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CollectionFile",
            '400': "Error",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def add_media_without_preload_content(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection to add the media file to")],
        add_collection_file: Annotated[AddCollectionFile, Field(description="File association parameters")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Add a media file to a collection

        Add a video or audio file to a collection. This is the recommended endpoint for adding media files to collections.  **Media Type Handling:**  - **Video files**: Processed with full visual analysis (scene description, text extraction, etc.) - **Audio files**: Visual features automatically disabled; only speech and audio analysis available  **Audio File Restrictions:**  - Audio files cannot be added to face-analysis collections - Shot-detector segmentation is not available for audio files

        :param collection_id: The ID of the collection to add the media file to (required)
        :type collection_id: str
        :param add_collection_file: File association parameters (required)
        :type add_collection_file: AddCollectionFile
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_media_serialize(
            collection_id=collection_id,
            add_collection_file=add_collection_file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CollectionFile",
            '400': "Error",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _add_media_serialize(
        self,
        collection_id,
        add_collection_file,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if collection_id is not None:
            _path_params['collection_id'] = collection_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if add_collection_file is not None:
            _body_params = add_collection_file


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/collections/{collection_id}/media',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def add_video(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection to add the video file to")],
        add_collection_file: Annotated[AddCollectionFile, Field(description="File association parameters")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CollectionFile:
        """(Deprecated) [Deprecated] Add a video to a collection

        **DEPRECATED: Use POST /collections/\\{collection_id\\}/media instead.**  Add a video to a collection. This endpoint is deprecated - use the /media endpoint which supports both video and audio files.

        :param collection_id: The ID of the collection to add the video file to (required)
        :type collection_id: str
        :param add_collection_file: File association parameters (required)
        :type add_collection_file: AddCollectionFile
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("POST /collections/{collection_id}/videos is deprecated.", DeprecationWarning)

        _param = self._add_video_serialize(
            collection_id=collection_id,
            add_collection_file=add_collection_file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CollectionFile",
            '400': "Error",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def add_video_with_http_info(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection to add the video file to")],
        add_collection_file: Annotated[AddCollectionFile, Field(description="File association parameters")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CollectionFile]:
        """(Deprecated) [Deprecated] Add a video to a collection

        **DEPRECATED: Use POST /collections/\\{collection_id\\}/media instead.**  Add a video to a collection. This endpoint is deprecated - use the /media endpoint which supports both video and audio files.

        :param collection_id: The ID of the collection to add the video file to (required)
        :type collection_id: str
        :param add_collection_file: File association parameters (required)
        :type add_collection_file: AddCollectionFile
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("POST /collections/{collection_id}/videos is deprecated.", DeprecationWarning)

        _param = self._add_video_serialize(
            collection_id=collection_id,
            add_collection_file=add_collection_file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CollectionFile",
            '400': "Error",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def add_video_without_preload_content(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection to add the video file to")],
        add_collection_file: Annotated[AddCollectionFile, Field(description="File association parameters")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) [Deprecated] Add a video to a collection

        **DEPRECATED: Use POST /collections/\\{collection_id\\}/media instead.**  Add a video to a collection. This endpoint is deprecated - use the /media endpoint which supports both video and audio files.

        :param collection_id: The ID of the collection to add the video file to (required)
        :type collection_id: str
        :param add_collection_file: File association parameters (required)
        :type add_collection_file: AddCollectionFile
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("POST /collections/{collection_id}/videos is deprecated.", DeprecationWarning)

        _param = self._add_video_serialize(
            collection_id=collection_id,
            add_collection_file=add_collection_file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CollectionFile",
            '400': "Error",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _add_video_serialize(
        self,
        collection_id,
        add_collection_file,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if collection_id is not None:
            _path_params['collection_id'] = collection_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if add_collection_file is not None:
            _body_params = add_collection_file


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/collections/{collection_id}/videos',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def add_you_tube_video(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection to add the YouTube video to")],
        add_you_tube_collection_file: Annotated[AddYouTubeCollectionFile, Field(description="YouTube video URL parameters")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CollectionFile:
        """(Deprecated) Add a YouTube video to a collection

        Add a YouTube video to a collection by URL

        :param collection_id: The ID of the collection to add the YouTube video to (required)
        :type collection_id: str
        :param add_you_tube_collection_file: YouTube video URL parameters (required)
        :type add_you_tube_collection_file: AddYouTubeCollectionFile
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("POST /collections/{collection_id}/youtube is deprecated.", DeprecationWarning)

        _param = self._add_you_tube_video_serialize(
            collection_id=collection_id,
            add_you_tube_collection_file=add_you_tube_collection_file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CollectionFile",
            '400': "Error",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def add_you_tube_video_with_http_info(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection to add the YouTube video to")],
        add_you_tube_collection_file: Annotated[AddYouTubeCollectionFile, Field(description="YouTube video URL parameters")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CollectionFile]:
        """(Deprecated) Add a YouTube video to a collection

        Add a YouTube video to a collection by URL

        :param collection_id: The ID of the collection to add the YouTube video to (required)
        :type collection_id: str
        :param add_you_tube_collection_file: YouTube video URL parameters (required)
        :type add_you_tube_collection_file: AddYouTubeCollectionFile
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("POST /collections/{collection_id}/youtube is deprecated.", DeprecationWarning)

        _param = self._add_you_tube_video_serialize(
            collection_id=collection_id,
            add_you_tube_collection_file=add_you_tube_collection_file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CollectionFile",
            '400': "Error",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def add_you_tube_video_without_preload_content(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection to add the YouTube video to")],
        add_you_tube_collection_file: Annotated[AddYouTubeCollectionFile, Field(description="YouTube video URL parameters")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) Add a YouTube video to a collection

        Add a YouTube video to a collection by URL

        :param collection_id: The ID of the collection to add the YouTube video to (required)
        :type collection_id: str
        :param add_you_tube_collection_file: YouTube video URL parameters (required)
        :type add_you_tube_collection_file: AddYouTubeCollectionFile
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("POST /collections/{collection_id}/youtube is deprecated.", DeprecationWarning)

        _param = self._add_you_tube_video_serialize(
            collection_id=collection_id,
            add_you_tube_collection_file=add_you_tube_collection_file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CollectionFile",
            '400': "Error",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _add_you_tube_video_serialize(
        self,
        collection_id,
        add_you_tube_collection_file,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if collection_id is not None:
            _path_params['collection_id'] = collection_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if add_you_tube_collection_file is not None:
            _body_params = add_you_tube_collection_file


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/collections/{collection_id}/youtube',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_collection(
        self,
        new_collection: Annotated[NewCollection, Field(description="Collection creation parameters")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Collection:
        """Create a new collection to organize and process video files

        Create a new collection to organize and process video files. Collections are used to group files together and process them in a consistent way.

        :param new_collection: Collection creation parameters (required)
        :type new_collection: NewCollection
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_collection_serialize(
            new_collection=new_collection,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Collection",
            '400': "Error",
            '409': "Error",
            '429': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_collection_with_http_info(
        self,
        new_collection: Annotated[NewCollection, Field(description="Collection creation parameters")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Collection]:
        """Create a new collection to organize and process video files

        Create a new collection to organize and process video files. Collections are used to group files together and process them in a consistent way.

        :param new_collection: Collection creation parameters (required)
        :type new_collection: NewCollection
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_collection_serialize(
            new_collection=new_collection,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Collection",
            '400': "Error",
            '409': "Error",
            '429': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_collection_without_preload_content(
        self,
        new_collection: Annotated[NewCollection, Field(description="Collection creation parameters")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create a new collection to organize and process video files

        Create a new collection to organize and process video files. Collections are used to group files together and process them in a consistent way.

        :param new_collection: Collection creation parameters (required)
        :type new_collection: NewCollection
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_collection_serialize(
            new_collection=new_collection,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Collection",
            '400': "Error",
            '409': "Error",
            '429': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_collection_serialize(
        self,
        new_collection,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if new_collection is not None:
            _body_params = new_collection


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/collections',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_collection(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection to delete")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CollectionDelete:
        """Delete a collection

        Delete a collection

        :param collection_id: The ID of the collection to delete (required)
        :type collection_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_collection_serialize(
            collection_id=collection_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CollectionDelete",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_collection_with_http_info(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection to delete")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CollectionDelete]:
        """Delete a collection

        Delete a collection

        :param collection_id: The ID of the collection to delete (required)
        :type collection_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_collection_serialize(
            collection_id=collection_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CollectionDelete",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_collection_without_preload_content(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection to delete")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete a collection

        Delete a collection

        :param collection_id: The ID of the collection to delete (required)
        :type collection_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_collection_serialize(
            collection_id=collection_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CollectionDelete",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_collection_serialize(
        self,
        collection_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if collection_id is not None:
            _path_params['collection_id'] = collection_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/collections/{collection_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_video(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection")],
        file_id: Annotated[StrictStr, Field(description="The ID of the file to remove")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CollectionFileDelete:
        """Remove a video file from a collection

        Remove a video file from a collection

        :param collection_id: The ID of the collection (required)
        :type collection_id: str
        :param file_id: The ID of the file to remove (required)
        :type file_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_video_serialize(
            collection_id=collection_id,
            file_id=file_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CollectionFileDelete",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_video_with_http_info(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection")],
        file_id: Annotated[StrictStr, Field(description="The ID of the file to remove")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CollectionFileDelete]:
        """Remove a video file from a collection

        Remove a video file from a collection

        :param collection_id: The ID of the collection (required)
        :type collection_id: str
        :param file_id: The ID of the file to remove (required)
        :type file_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_video_serialize(
            collection_id=collection_id,
            file_id=file_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CollectionFileDelete",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_video_without_preload_content(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection")],
        file_id: Annotated[StrictStr, Field(description="The ID of the file to remove")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Remove a video file from a collection

        Remove a video file from a collection

        :param collection_id: The ID of the collection (required)
        :type collection_id: str
        :param file_id: The ID of the file to remove (required)
        :type file_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_video_serialize(
            collection_id=collection_id,
            file_id=file_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CollectionFileDelete",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_video_serialize(
        self,
        collection_id,
        file_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if collection_id is not None:
            _path_params['collection_id'] = collection_id
        if file_id is not None:
            _path_params['file_id'] = file_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/collections/{collection_id}/videos/{file_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_collection(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection to retrieve")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Collection:
        """Retrieve details about a specific collection

        Retrieve details about a specific collection

        :param collection_id: The ID of the collection to retrieve (required)
        :type collection_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_collection_serialize(
            collection_id=collection_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Collection",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_collection_with_http_info(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection to retrieve")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Collection]:
        """Retrieve details about a specific collection

        Retrieve details about a specific collection

        :param collection_id: The ID of the collection to retrieve (required)
        :type collection_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_collection_serialize(
            collection_id=collection_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Collection",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_collection_without_preload_content(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection to retrieve")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Retrieve details about a specific collection

        Retrieve details about a specific collection

        :param collection_id: The ID of the collection to retrieve (required)
        :type collection_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_collection_serialize(
            collection_id=collection_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Collection",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_collection_serialize(
        self,
        collection_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if collection_id is not None:
            _path_params['collection_id'] = collection_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/collections/{collection_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_entities(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection")],
        file_id: Annotated[StrictStr, Field(description="The ID of the file")],
        limit: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="Maximum number of segment entities to return")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Number of segment entities to skip")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FileEntities:
        """Retrieve extracted entities for a specific file in a collection

        Retrieve extracted entities for a specific file in a collection. Results are paginated with a default limit of 50 segment entities per request (maximum 100). Use limit and offset parameters to paginate through all results. This API is only available when the collection is created with collection_type 'entities'

        :param collection_id: The ID of the collection (required)
        :type collection_id: str
        :param file_id: The ID of the file (required)
        :type file_id: str
        :param limit: Maximum number of segment entities to return
        :type limit: int
        :param offset: Number of segment entities to skip
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_entities_serialize(
            collection_id=collection_id,
            file_id=file_id,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileEntities",
            '400': "Error",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_entities_with_http_info(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection")],
        file_id: Annotated[StrictStr, Field(description="The ID of the file")],
        limit: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="Maximum number of segment entities to return")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Number of segment entities to skip")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FileEntities]:
        """Retrieve extracted entities for a specific file in a collection

        Retrieve extracted entities for a specific file in a collection. Results are paginated with a default limit of 50 segment entities per request (maximum 100). Use limit and offset parameters to paginate through all results. This API is only available when the collection is created with collection_type 'entities'

        :param collection_id: The ID of the collection (required)
        :type collection_id: str
        :param file_id: The ID of the file (required)
        :type file_id: str
        :param limit: Maximum number of segment entities to return
        :type limit: int
        :param offset: Number of segment entities to skip
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_entities_serialize(
            collection_id=collection_id,
            file_id=file_id,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileEntities",
            '400': "Error",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_entities_without_preload_content(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection")],
        file_id: Annotated[StrictStr, Field(description="The ID of the file")],
        limit: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="Maximum number of segment entities to return")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Number of segment entities to skip")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Retrieve extracted entities for a specific file in a collection

        Retrieve extracted entities for a specific file in a collection. Results are paginated with a default limit of 50 segment entities per request (maximum 100). Use limit and offset parameters to paginate through all results. This API is only available when the collection is created with collection_type 'entities'

        :param collection_id: The ID of the collection (required)
        :type collection_id: str
        :param file_id: The ID of the file (required)
        :type file_id: str
        :param limit: Maximum number of segment entities to return
        :type limit: int
        :param offset: Number of segment entities to skip
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_entities_serialize(
            collection_id=collection_id,
            file_id=file_id,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileEntities",
            '400': "Error",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_entities_serialize(
        self,
        collection_id,
        file_id,
        limit,
        offset,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if collection_id is not None:
            _path_params['collection_id'] = collection_id
        if file_id is not None:
            _path_params['file_id'] = file_id
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/collections/{collection_id}/videos/{file_id}/entities',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_face_detections(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection")],
        file_id: Annotated[StrictStr, Field(description="The ID of the file")],
        limit: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="Maximum number of faces to return")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Number of faces to skip")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FileFaceDetections:
        """Retrieve face detections for a specific file in a collection

        Retrieve face detections for a specific file in a collection. Results are paginated with a default limit of 50 faces per request (maximum 100). Use limit and offset parameters to paginate through all results. This API is only available when the collection is created with collection_type 'face-analysis'

        :param collection_id: The ID of the collection (required)
        :type collection_id: str
        :param file_id: The ID of the file (required)
        :type file_id: str
        :param limit: Maximum number of faces to return
        :type limit: int
        :param offset: Number of faces to skip
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_face_detections_serialize(
            collection_id=collection_id,
            file_id=file_id,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileFaceDetections",
            '400': "Error",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_face_detections_with_http_info(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection")],
        file_id: Annotated[StrictStr, Field(description="The ID of the file")],
        limit: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="Maximum number of faces to return")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Number of faces to skip")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FileFaceDetections]:
        """Retrieve face detections for a specific file in a collection

        Retrieve face detections for a specific file in a collection. Results are paginated with a default limit of 50 faces per request (maximum 100). Use limit and offset parameters to paginate through all results. This API is only available when the collection is created with collection_type 'face-analysis'

        :param collection_id: The ID of the collection (required)
        :type collection_id: str
        :param file_id: The ID of the file (required)
        :type file_id: str
        :param limit: Maximum number of faces to return
        :type limit: int
        :param offset: Number of faces to skip
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_face_detections_serialize(
            collection_id=collection_id,
            file_id=file_id,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileFaceDetections",
            '400': "Error",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_face_detections_without_preload_content(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection")],
        file_id: Annotated[StrictStr, Field(description="The ID of the file")],
        limit: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="Maximum number of faces to return")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Number of faces to skip")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Retrieve face detections for a specific file in a collection

        Retrieve face detections for a specific file in a collection. Results are paginated with a default limit of 50 faces per request (maximum 100). Use limit and offset parameters to paginate through all results. This API is only available when the collection is created with collection_type 'face-analysis'

        :param collection_id: The ID of the collection (required)
        :type collection_id: str
        :param file_id: The ID of the file (required)
        :type file_id: str
        :param limit: Maximum number of faces to return
        :type limit: int
        :param offset: Number of faces to skip
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_face_detections_serialize(
            collection_id=collection_id,
            file_id=file_id,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileFaceDetections",
            '400': "Error",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_face_detections_serialize(
        self,
        collection_id,
        file_id,
        limit,
        offset,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if collection_id is not None:
            _path_params['collection_id'] = collection_id
        if file_id is not None:
            _path_params['file_id'] = file_id
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/collections/{collection_id}/videos/{file_id}/face-detections',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_media_descriptions(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection")],
        file_id: Annotated[StrictStr, Field(description="The ID of the file")],
        response_format: Annotated[Optional[StrictStr], Field(description="Format for the response")] = None,
        start_time_seconds: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Start time in seconds to filter out results by")] = None,
        end_time_seconds: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="End time in seconds to filter out results by")] = None,
        modalities: Optional[List[StrictStr]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> MediaDescription:
        """Retrieve media description data for a specific file in a collection

        Retrieve media description data for a specific file in a collection. This API is only available when the collection is created with collection_type 'media-descriptions'

        :param collection_id: The ID of the collection (required)
        :type collection_id: str
        :param file_id: The ID of the file (required)
        :type file_id: str
        :param response_format: Format for the response
        :type response_format: str
        :param start_time_seconds: Start time in seconds to filter out results by
        :type start_time_seconds: float
        :param end_time_seconds: End time in seconds to filter out results by
        :type end_time_seconds: float
        :param modalities:
        :type modalities: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_media_descriptions_serialize(
            collection_id=collection_id,
            file_id=file_id,
            response_format=response_format,
            start_time_seconds=start_time_seconds,
            end_time_seconds=end_time_seconds,
            modalities=modalities,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MediaDescription",
            '400': "Error",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_media_descriptions_with_http_info(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection")],
        file_id: Annotated[StrictStr, Field(description="The ID of the file")],
        response_format: Annotated[Optional[StrictStr], Field(description="Format for the response")] = None,
        start_time_seconds: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Start time in seconds to filter out results by")] = None,
        end_time_seconds: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="End time in seconds to filter out results by")] = None,
        modalities: Optional[List[StrictStr]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[MediaDescription]:
        """Retrieve media description data for a specific file in a collection

        Retrieve media description data for a specific file in a collection. This API is only available when the collection is created with collection_type 'media-descriptions'

        :param collection_id: The ID of the collection (required)
        :type collection_id: str
        :param file_id: The ID of the file (required)
        :type file_id: str
        :param response_format: Format for the response
        :type response_format: str
        :param start_time_seconds: Start time in seconds to filter out results by
        :type start_time_seconds: float
        :param end_time_seconds: End time in seconds to filter out results by
        :type end_time_seconds: float
        :param modalities:
        :type modalities: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_media_descriptions_serialize(
            collection_id=collection_id,
            file_id=file_id,
            response_format=response_format,
            start_time_seconds=start_time_seconds,
            end_time_seconds=end_time_seconds,
            modalities=modalities,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MediaDescription",
            '400': "Error",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_media_descriptions_without_preload_content(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection")],
        file_id: Annotated[StrictStr, Field(description="The ID of the file")],
        response_format: Annotated[Optional[StrictStr], Field(description="Format for the response")] = None,
        start_time_seconds: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Start time in seconds to filter out results by")] = None,
        end_time_seconds: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="End time in seconds to filter out results by")] = None,
        modalities: Optional[List[StrictStr]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Retrieve media description data for a specific file in a collection

        Retrieve media description data for a specific file in a collection. This API is only available when the collection is created with collection_type 'media-descriptions'

        :param collection_id: The ID of the collection (required)
        :type collection_id: str
        :param file_id: The ID of the file (required)
        :type file_id: str
        :param response_format: Format for the response
        :type response_format: str
        :param start_time_seconds: Start time in seconds to filter out results by
        :type start_time_seconds: float
        :param end_time_seconds: End time in seconds to filter out results by
        :type end_time_seconds: float
        :param modalities:
        :type modalities: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_media_descriptions_serialize(
            collection_id=collection_id,
            file_id=file_id,
            response_format=response_format,
            start_time_seconds=start_time_seconds,
            end_time_seconds=end_time_seconds,
            modalities=modalities,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MediaDescription",
            '400': "Error",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_media_descriptions_serialize(
        self,
        collection_id,
        file_id,
        response_format,
        start_time_seconds,
        end_time_seconds,
        modalities,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'modalities': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if collection_id is not None:
            _path_params['collection_id'] = collection_id
        if file_id is not None:
            _path_params['file_id'] = file_id
        # process the query parameters
        if response_format is not None:
            
            _query_params.append(('response_format', response_format))
            
        if start_time_seconds is not None:
            
            _query_params.append(('start_time_seconds', start_time_seconds))
            
        if end_time_seconds is not None:
            
            _query_params.append(('end_time_seconds', end_time_seconds))
            
        if modalities is not None:
            
            _query_params.append(('modalities', modalities))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/collections/{collection_id}/videos/{file_id}/media-descriptions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_transcripts(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection")],
        file_id: Annotated[StrictStr, Field(description="The ID of the file")],
        response_format: Annotated[Optional[StrictStr], Field(description="Format for the response")] = None,
        start_time_seconds: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Start time in seconds to filter out results by")] = None,
        end_time_seconds: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="End time in seconds to filter out results by")] = None,
        modalities: Optional[List[StrictStr]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RichTranscript:
        """Retrieve rich transcription data for a specific file in a collection

        Retrieve rich transcription data for a specific file in a collection. This API is only available when the a collection is created with collection_type 'rich-transcripts'

        :param collection_id: The ID of the collection (required)
        :type collection_id: str
        :param file_id: The ID of the file (required)
        :type file_id: str
        :param response_format: Format for the response
        :type response_format: str
        :param start_time_seconds: Start time in seconds to filter out results by
        :type start_time_seconds: float
        :param end_time_seconds: End time in seconds to filter out results by
        :type end_time_seconds: float
        :param modalities:
        :type modalities: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_transcripts_serialize(
            collection_id=collection_id,
            file_id=file_id,
            response_format=response_format,
            start_time_seconds=start_time_seconds,
            end_time_seconds=end_time_seconds,
            modalities=modalities,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RichTranscript",
            '400': "Error",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_transcripts_with_http_info(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection")],
        file_id: Annotated[StrictStr, Field(description="The ID of the file")],
        response_format: Annotated[Optional[StrictStr], Field(description="Format for the response")] = None,
        start_time_seconds: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Start time in seconds to filter out results by")] = None,
        end_time_seconds: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="End time in seconds to filter out results by")] = None,
        modalities: Optional[List[StrictStr]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RichTranscript]:
        """Retrieve rich transcription data for a specific file in a collection

        Retrieve rich transcription data for a specific file in a collection. This API is only available when the a collection is created with collection_type 'rich-transcripts'

        :param collection_id: The ID of the collection (required)
        :type collection_id: str
        :param file_id: The ID of the file (required)
        :type file_id: str
        :param response_format: Format for the response
        :type response_format: str
        :param start_time_seconds: Start time in seconds to filter out results by
        :type start_time_seconds: float
        :param end_time_seconds: End time in seconds to filter out results by
        :type end_time_seconds: float
        :param modalities:
        :type modalities: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_transcripts_serialize(
            collection_id=collection_id,
            file_id=file_id,
            response_format=response_format,
            start_time_seconds=start_time_seconds,
            end_time_seconds=end_time_seconds,
            modalities=modalities,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RichTranscript",
            '400': "Error",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_transcripts_without_preload_content(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection")],
        file_id: Annotated[StrictStr, Field(description="The ID of the file")],
        response_format: Annotated[Optional[StrictStr], Field(description="Format for the response")] = None,
        start_time_seconds: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Start time in seconds to filter out results by")] = None,
        end_time_seconds: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="End time in seconds to filter out results by")] = None,
        modalities: Optional[List[StrictStr]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Retrieve rich transcription data for a specific file in a collection

        Retrieve rich transcription data for a specific file in a collection. This API is only available when the a collection is created with collection_type 'rich-transcripts'

        :param collection_id: The ID of the collection (required)
        :type collection_id: str
        :param file_id: The ID of the file (required)
        :type file_id: str
        :param response_format: Format for the response
        :type response_format: str
        :param start_time_seconds: Start time in seconds to filter out results by
        :type start_time_seconds: float
        :param end_time_seconds: End time in seconds to filter out results by
        :type end_time_seconds: float
        :param modalities:
        :type modalities: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_transcripts_serialize(
            collection_id=collection_id,
            file_id=file_id,
            response_format=response_format,
            start_time_seconds=start_time_seconds,
            end_time_seconds=end_time_seconds,
            modalities=modalities,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RichTranscript",
            '400': "Error",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_transcripts_serialize(
        self,
        collection_id,
        file_id,
        response_format,
        start_time_seconds,
        end_time_seconds,
        modalities,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'modalities': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if collection_id is not None:
            _path_params['collection_id'] = collection_id
        if file_id is not None:
            _path_params['file_id'] = file_id
        # process the query parameters
        if response_format is not None:
            
            _query_params.append(('response_format', response_format))
            
        if start_time_seconds is not None:
            
            _query_params.append(('start_time_seconds', start_time_seconds))
            
        if end_time_seconds is not None:
            
            _query_params.append(('end_time_seconds', end_time_seconds))
            
        if modalities is not None:
            
            _query_params.append(('modalities', modalities))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/collections/{collection_id}/videos/{file_id}/rich-transcripts',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_video(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection")],
        file_id: Annotated[StrictStr, Field(description="The ID of the file")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CollectionFile:
        """Retrieve information about a specific video file in a collection

        Retrieve information about a specific video file in a collection

        :param collection_id: The ID of the collection (required)
        :type collection_id: str
        :param file_id: The ID of the file (required)
        :type file_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_video_serialize(
            collection_id=collection_id,
            file_id=file_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CollectionFile",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_video_with_http_info(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection")],
        file_id: Annotated[StrictStr, Field(description="The ID of the file")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CollectionFile]:
        """Retrieve information about a specific video file in a collection

        Retrieve information about a specific video file in a collection

        :param collection_id: The ID of the collection (required)
        :type collection_id: str
        :param file_id: The ID of the file (required)
        :type file_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_video_serialize(
            collection_id=collection_id,
            file_id=file_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CollectionFile",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_video_without_preload_content(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection")],
        file_id: Annotated[StrictStr, Field(description="The ID of the file")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Retrieve information about a specific video file in a collection

        Retrieve information about a specific video file in a collection

        :param collection_id: The ID of the collection (required)
        :type collection_id: str
        :param file_id: The ID of the file (required)
        :type file_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_video_serialize(
            collection_id=collection_id,
            file_id=file_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CollectionFile",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_video_serialize(
        self,
        collection_id,
        file_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if collection_id is not None:
            _path_params['collection_id'] = collection_id
        if file_id is not None:
            _path_params['file_id'] = file_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/collections/{collection_id}/videos/{file_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_collection_entities(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection")],
        limit: Annotated[Optional[Annotated[int, Field(le=100, strict=True)]], Field(description="Maximum number of files to return")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="Number of files to skip")] = None,
        order: Annotated[Optional[StrictStr], Field(description="Order the files by a specific field")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Sort the files in ascending or descending order")] = None,
        added_before: Annotated[Optional[date], Field(description="Filter files added before a specific date (YYYY-MM-DD format), in UTC timezone")] = None,
        added_after: Annotated[Optional[date], Field(description="Filter files added after a specific date (YYYY-MM-DD format), in UTC timezone")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CollectionEntitiesList:
        """List all extracted entities for files in a collection

        List all extracted entities for files in a collection. This API is only available when a collection is created with collection_type 'entities'

        :param collection_id: The ID of the collection (required)
        :type collection_id: str
        :param limit: Maximum number of files to return
        :type limit: int
        :param offset: Number of files to skip
        :type offset: int
        :param order: Order the files by a specific field
        :type order: str
        :param sort: Sort the files in ascending or descending order
        :type sort: str
        :param added_before: Filter files added before a specific date (YYYY-MM-DD format), in UTC timezone
        :type added_before: date
        :param added_after: Filter files added after a specific date (YYYY-MM-DD format), in UTC timezone
        :type added_after: date
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_collection_entities_serialize(
            collection_id=collection_id,
            limit=limit,
            offset=offset,
            order=order,
            sort=sort,
            added_before=added_before,
            added_after=added_after,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CollectionEntitiesList",
            '400': "Error",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_collection_entities_with_http_info(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection")],
        limit: Annotated[Optional[Annotated[int, Field(le=100, strict=True)]], Field(description="Maximum number of files to return")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="Number of files to skip")] = None,
        order: Annotated[Optional[StrictStr], Field(description="Order the files by a specific field")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Sort the files in ascending or descending order")] = None,
        added_before: Annotated[Optional[date], Field(description="Filter files added before a specific date (YYYY-MM-DD format), in UTC timezone")] = None,
        added_after: Annotated[Optional[date], Field(description="Filter files added after a specific date (YYYY-MM-DD format), in UTC timezone")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CollectionEntitiesList]:
        """List all extracted entities for files in a collection

        List all extracted entities for files in a collection. This API is only available when a collection is created with collection_type 'entities'

        :param collection_id: The ID of the collection (required)
        :type collection_id: str
        :param limit: Maximum number of files to return
        :type limit: int
        :param offset: Number of files to skip
        :type offset: int
        :param order: Order the files by a specific field
        :type order: str
        :param sort: Sort the files in ascending or descending order
        :type sort: str
        :param added_before: Filter files added before a specific date (YYYY-MM-DD format), in UTC timezone
        :type added_before: date
        :param added_after: Filter files added after a specific date (YYYY-MM-DD format), in UTC timezone
        :type added_after: date
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_collection_entities_serialize(
            collection_id=collection_id,
            limit=limit,
            offset=offset,
            order=order,
            sort=sort,
            added_before=added_before,
            added_after=added_after,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CollectionEntitiesList",
            '400': "Error",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_collection_entities_without_preload_content(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection")],
        limit: Annotated[Optional[Annotated[int, Field(le=100, strict=True)]], Field(description="Maximum number of files to return")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="Number of files to skip")] = None,
        order: Annotated[Optional[StrictStr], Field(description="Order the files by a specific field")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Sort the files in ascending or descending order")] = None,
        added_before: Annotated[Optional[date], Field(description="Filter files added before a specific date (YYYY-MM-DD format), in UTC timezone")] = None,
        added_after: Annotated[Optional[date], Field(description="Filter files added after a specific date (YYYY-MM-DD format), in UTC timezone")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List all extracted entities for files in a collection

        List all extracted entities for files in a collection. This API is only available when a collection is created with collection_type 'entities'

        :param collection_id: The ID of the collection (required)
        :type collection_id: str
        :param limit: Maximum number of files to return
        :type limit: int
        :param offset: Number of files to skip
        :type offset: int
        :param order: Order the files by a specific field
        :type order: str
        :param sort: Sort the files in ascending or descending order
        :type sort: str
        :param added_before: Filter files added before a specific date (YYYY-MM-DD format), in UTC timezone
        :type added_before: date
        :param added_after: Filter files added after a specific date (YYYY-MM-DD format), in UTC timezone
        :type added_after: date
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_collection_entities_serialize(
            collection_id=collection_id,
            limit=limit,
            offset=offset,
            order=order,
            sort=sort,
            added_before=added_before,
            added_after=added_after,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CollectionEntitiesList",
            '400': "Error",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_collection_entities_serialize(
        self,
        collection_id,
        limit,
        offset,
        order,
        sort,
        added_before,
        added_after,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if collection_id is not None:
            _path_params['collection_id'] = collection_id
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if order is not None:
            
            _query_params.append(('order', order))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if added_before is not None:
            if isinstance(added_before, date):
                _query_params.append(
                    (
                        'added_before',
                        added_before.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('added_before', added_before))
            
        if added_after is not None:
            if isinstance(added_after, date):
                _query_params.append(
                    (
                        'added_after',
                        added_after.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('added_after', added_after))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/collections/{collection_id}/entities',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_collection_media_descriptions(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection")],
        limit: Annotated[Optional[Annotated[int, Field(le=100, strict=True)]], Field(description="Maximum number of files to return")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="Number of files to skip")] = None,
        order: Annotated[Optional[StrictStr], Field(description="Order the files by a specific field")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Sort the files in ascending or descending order")] = None,
        added_before: Annotated[Optional[date], Field(description="Filter files added before a specific date (YYYY-MM-DD format), in UTC timezone")] = None,
        added_after: Annotated[Optional[date], Field(description="Filter files added after a specific date (YYYY-MM-DD format), in UTC timezone")] = None,
        response_format: Annotated[Optional[StrictStr], Field(description="Format for the response")] = None,
        modalities: Optional[List[StrictStr]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CollectionMediaDescriptionsList:
        """List all media description data for files in a collection

        List all media description data for files in a collection. This API is only available when a collection is created with collection_type 'media-descriptions'

        :param collection_id: The ID of the collection (required)
        :type collection_id: str
        :param limit: Maximum number of files to return
        :type limit: int
        :param offset: Number of files to skip
        :type offset: int
        :param order: Order the files by a specific field
        :type order: str
        :param sort: Sort the files in ascending or descending order
        :type sort: str
        :param added_before: Filter files added before a specific date (YYYY-MM-DD format), in UTC timezone
        :type added_before: date
        :param added_after: Filter files added after a specific date (YYYY-MM-DD format), in UTC timezone
        :type added_after: date
        :param response_format: Format for the response
        :type response_format: str
        :param modalities:
        :type modalities: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_collection_media_descriptions_serialize(
            collection_id=collection_id,
            limit=limit,
            offset=offset,
            order=order,
            sort=sort,
            added_before=added_before,
            added_after=added_after,
            response_format=response_format,
            modalities=modalities,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CollectionMediaDescriptionsList",
            '400': "Error",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_collection_media_descriptions_with_http_info(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection")],
        limit: Annotated[Optional[Annotated[int, Field(le=100, strict=True)]], Field(description="Maximum number of files to return")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="Number of files to skip")] = None,
        order: Annotated[Optional[StrictStr], Field(description="Order the files by a specific field")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Sort the files in ascending or descending order")] = None,
        added_before: Annotated[Optional[date], Field(description="Filter files added before a specific date (YYYY-MM-DD format), in UTC timezone")] = None,
        added_after: Annotated[Optional[date], Field(description="Filter files added after a specific date (YYYY-MM-DD format), in UTC timezone")] = None,
        response_format: Annotated[Optional[StrictStr], Field(description="Format for the response")] = None,
        modalities: Optional[List[StrictStr]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CollectionMediaDescriptionsList]:
        """List all media description data for files in a collection

        List all media description data for files in a collection. This API is only available when a collection is created with collection_type 'media-descriptions'

        :param collection_id: The ID of the collection (required)
        :type collection_id: str
        :param limit: Maximum number of files to return
        :type limit: int
        :param offset: Number of files to skip
        :type offset: int
        :param order: Order the files by a specific field
        :type order: str
        :param sort: Sort the files in ascending or descending order
        :type sort: str
        :param added_before: Filter files added before a specific date (YYYY-MM-DD format), in UTC timezone
        :type added_before: date
        :param added_after: Filter files added after a specific date (YYYY-MM-DD format), in UTC timezone
        :type added_after: date
        :param response_format: Format for the response
        :type response_format: str
        :param modalities:
        :type modalities: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_collection_media_descriptions_serialize(
            collection_id=collection_id,
            limit=limit,
            offset=offset,
            order=order,
            sort=sort,
            added_before=added_before,
            added_after=added_after,
            response_format=response_format,
            modalities=modalities,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CollectionMediaDescriptionsList",
            '400': "Error",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_collection_media_descriptions_without_preload_content(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection")],
        limit: Annotated[Optional[Annotated[int, Field(le=100, strict=True)]], Field(description="Maximum number of files to return")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="Number of files to skip")] = None,
        order: Annotated[Optional[StrictStr], Field(description="Order the files by a specific field")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Sort the files in ascending or descending order")] = None,
        added_before: Annotated[Optional[date], Field(description="Filter files added before a specific date (YYYY-MM-DD format), in UTC timezone")] = None,
        added_after: Annotated[Optional[date], Field(description="Filter files added after a specific date (YYYY-MM-DD format), in UTC timezone")] = None,
        response_format: Annotated[Optional[StrictStr], Field(description="Format for the response")] = None,
        modalities: Optional[List[StrictStr]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List all media description data for files in a collection

        List all media description data for files in a collection. This API is only available when a collection is created with collection_type 'media-descriptions'

        :param collection_id: The ID of the collection (required)
        :type collection_id: str
        :param limit: Maximum number of files to return
        :type limit: int
        :param offset: Number of files to skip
        :type offset: int
        :param order: Order the files by a specific field
        :type order: str
        :param sort: Sort the files in ascending or descending order
        :type sort: str
        :param added_before: Filter files added before a specific date (YYYY-MM-DD format), in UTC timezone
        :type added_before: date
        :param added_after: Filter files added after a specific date (YYYY-MM-DD format), in UTC timezone
        :type added_after: date
        :param response_format: Format for the response
        :type response_format: str
        :param modalities:
        :type modalities: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_collection_media_descriptions_serialize(
            collection_id=collection_id,
            limit=limit,
            offset=offset,
            order=order,
            sort=sort,
            added_before=added_before,
            added_after=added_after,
            response_format=response_format,
            modalities=modalities,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CollectionMediaDescriptionsList",
            '400': "Error",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_collection_media_descriptions_serialize(
        self,
        collection_id,
        limit,
        offset,
        order,
        sort,
        added_before,
        added_after,
        response_format,
        modalities,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'modalities': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if collection_id is not None:
            _path_params['collection_id'] = collection_id
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if order is not None:
            
            _query_params.append(('order', order))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if added_before is not None:
            if isinstance(added_before, date):
                _query_params.append(
                    (
                        'added_before',
                        added_before.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('added_before', added_before))
            
        if added_after is not None:
            if isinstance(added_after, date):
                _query_params.append(
                    (
                        'added_after',
                        added_after.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('added_after', added_after))
            
        if response_format is not None:
            
            _query_params.append(('response_format', response_format))
            
        if modalities is not None:
            
            _query_params.append(('modalities', modalities))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/collections/{collection_id}/media-descriptions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_collection_rich_transcripts(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection")],
        limit: Annotated[Optional[Annotated[int, Field(le=100, strict=True)]], Field(description="Maximum number of files to return")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="Number of files to skip")] = None,
        order: Annotated[Optional[StrictStr], Field(description="Order the files by a specific field")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Sort the files in ascending or descending order")] = None,
        added_before: Annotated[Optional[date], Field(description="Filter files added before a specific date (YYYY-MM-DD format), in UTC timezone")] = None,
        added_after: Annotated[Optional[date], Field(description="Filter files added after a specific date (YYYY-MM-DD format), in UTC timezone")] = None,
        response_format: Annotated[Optional[StrictStr], Field(description="Format for the response")] = None,
        modalities: Optional[List[StrictStr]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CollectionRichTranscriptsList:
        """List all rich transcription data for files in a collection

        List all rich transcription data for files in a collection. This API is only available when a collection is created with collection_type 'rich-transcripts'

        :param collection_id: The ID of the collection (required)
        :type collection_id: str
        :param limit: Maximum number of files to return
        :type limit: int
        :param offset: Number of files to skip
        :type offset: int
        :param order: Order the files by a specific field
        :type order: str
        :param sort: Sort the files in ascending or descending order
        :type sort: str
        :param added_before: Filter files added before a specific date (YYYY-MM-DD format), in UTC timezone
        :type added_before: date
        :param added_after: Filter files added after a specific date (YYYY-MM-DD format), in UTC timezone
        :type added_after: date
        :param response_format: Format for the response
        :type response_format: str
        :param modalities:
        :type modalities: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_collection_rich_transcripts_serialize(
            collection_id=collection_id,
            limit=limit,
            offset=offset,
            order=order,
            sort=sort,
            added_before=added_before,
            added_after=added_after,
            response_format=response_format,
            modalities=modalities,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CollectionRichTranscriptsList",
            '400': "Error",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_collection_rich_transcripts_with_http_info(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection")],
        limit: Annotated[Optional[Annotated[int, Field(le=100, strict=True)]], Field(description="Maximum number of files to return")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="Number of files to skip")] = None,
        order: Annotated[Optional[StrictStr], Field(description="Order the files by a specific field")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Sort the files in ascending or descending order")] = None,
        added_before: Annotated[Optional[date], Field(description="Filter files added before a specific date (YYYY-MM-DD format), in UTC timezone")] = None,
        added_after: Annotated[Optional[date], Field(description="Filter files added after a specific date (YYYY-MM-DD format), in UTC timezone")] = None,
        response_format: Annotated[Optional[StrictStr], Field(description="Format for the response")] = None,
        modalities: Optional[List[StrictStr]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CollectionRichTranscriptsList]:
        """List all rich transcription data for files in a collection

        List all rich transcription data for files in a collection. This API is only available when a collection is created with collection_type 'rich-transcripts'

        :param collection_id: The ID of the collection (required)
        :type collection_id: str
        :param limit: Maximum number of files to return
        :type limit: int
        :param offset: Number of files to skip
        :type offset: int
        :param order: Order the files by a specific field
        :type order: str
        :param sort: Sort the files in ascending or descending order
        :type sort: str
        :param added_before: Filter files added before a specific date (YYYY-MM-DD format), in UTC timezone
        :type added_before: date
        :param added_after: Filter files added after a specific date (YYYY-MM-DD format), in UTC timezone
        :type added_after: date
        :param response_format: Format for the response
        :type response_format: str
        :param modalities:
        :type modalities: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_collection_rich_transcripts_serialize(
            collection_id=collection_id,
            limit=limit,
            offset=offset,
            order=order,
            sort=sort,
            added_before=added_before,
            added_after=added_after,
            response_format=response_format,
            modalities=modalities,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CollectionRichTranscriptsList",
            '400': "Error",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_collection_rich_transcripts_without_preload_content(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection")],
        limit: Annotated[Optional[Annotated[int, Field(le=100, strict=True)]], Field(description="Maximum number of files to return")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="Number of files to skip")] = None,
        order: Annotated[Optional[StrictStr], Field(description="Order the files by a specific field")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Sort the files in ascending or descending order")] = None,
        added_before: Annotated[Optional[date], Field(description="Filter files added before a specific date (YYYY-MM-DD format), in UTC timezone")] = None,
        added_after: Annotated[Optional[date], Field(description="Filter files added after a specific date (YYYY-MM-DD format), in UTC timezone")] = None,
        response_format: Annotated[Optional[StrictStr], Field(description="Format for the response")] = None,
        modalities: Optional[List[StrictStr]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List all rich transcription data for files in a collection

        List all rich transcription data for files in a collection. This API is only available when a collection is created with collection_type 'rich-transcripts'

        :param collection_id: The ID of the collection (required)
        :type collection_id: str
        :param limit: Maximum number of files to return
        :type limit: int
        :param offset: Number of files to skip
        :type offset: int
        :param order: Order the files by a specific field
        :type order: str
        :param sort: Sort the files in ascending or descending order
        :type sort: str
        :param added_before: Filter files added before a specific date (YYYY-MM-DD format), in UTC timezone
        :type added_before: date
        :param added_after: Filter files added after a specific date (YYYY-MM-DD format), in UTC timezone
        :type added_after: date
        :param response_format: Format for the response
        :type response_format: str
        :param modalities:
        :type modalities: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_collection_rich_transcripts_serialize(
            collection_id=collection_id,
            limit=limit,
            offset=offset,
            order=order,
            sort=sort,
            added_before=added_before,
            added_after=added_after,
            response_format=response_format,
            modalities=modalities,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CollectionRichTranscriptsList",
            '400': "Error",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_collection_rich_transcripts_serialize(
        self,
        collection_id,
        limit,
        offset,
        order,
        sort,
        added_before,
        added_after,
        response_format,
        modalities,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'modalities': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if collection_id is not None:
            _path_params['collection_id'] = collection_id
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if order is not None:
            
            _query_params.append(('order', order))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if added_before is not None:
            if isinstance(added_before, date):
                _query_params.append(
                    (
                        'added_before',
                        added_before.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('added_before', added_before))
            
        if added_after is not None:
            if isinstance(added_after, date):
                _query_params.append(
                    (
                        'added_after',
                        added_after.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('added_after', added_after))
            
        if response_format is not None:
            
            _query_params.append(('response_format', response_format))
            
        if modalities is not None:
            
            _query_params.append(('modalities', modalities))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/collections/{collection_id}/rich-transcripts',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_collections(
        self,
        limit: Annotated[Optional[Annotated[int, Field(le=100, strict=True)]], Field(description="Maximum number of collections to return")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="Number of collections to skip")] = None,
        order: Annotated[Optional[StrictStr], Field(description="Order the collections by a specific field")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Sort the collections in ascending or descending order")] = None,
        collection_type: Annotated[Optional[StrictStr], Field(description="Filter collections by type")] = None,
        created_after: Annotated[Optional[datetime], Field(description="Filter collections created after this date (ISO 8601 format)")] = None,
        created_before: Annotated[Optional[datetime], Field(description="Filter collections created before this date (ISO 8601 format)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CollectionList:
        """List all collections

        List all collections

        :param limit: Maximum number of collections to return
        :type limit: int
        :param offset: Number of collections to skip
        :type offset: int
        :param order: Order the collections by a specific field
        :type order: str
        :param sort: Sort the collections in ascending or descending order
        :type sort: str
        :param collection_type: Filter collections by type
        :type collection_type: str
        :param created_after: Filter collections created after this date (ISO 8601 format)
        :type created_after: datetime
        :param created_before: Filter collections created before this date (ISO 8601 format)
        :type created_before: datetime
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_collections_serialize(
            limit=limit,
            offset=offset,
            order=order,
            sort=sort,
            collection_type=collection_type,
            created_after=created_after,
            created_before=created_before,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CollectionList",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_collections_with_http_info(
        self,
        limit: Annotated[Optional[Annotated[int, Field(le=100, strict=True)]], Field(description="Maximum number of collections to return")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="Number of collections to skip")] = None,
        order: Annotated[Optional[StrictStr], Field(description="Order the collections by a specific field")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Sort the collections in ascending or descending order")] = None,
        collection_type: Annotated[Optional[StrictStr], Field(description="Filter collections by type")] = None,
        created_after: Annotated[Optional[datetime], Field(description="Filter collections created after this date (ISO 8601 format)")] = None,
        created_before: Annotated[Optional[datetime], Field(description="Filter collections created before this date (ISO 8601 format)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CollectionList]:
        """List all collections

        List all collections

        :param limit: Maximum number of collections to return
        :type limit: int
        :param offset: Number of collections to skip
        :type offset: int
        :param order: Order the collections by a specific field
        :type order: str
        :param sort: Sort the collections in ascending or descending order
        :type sort: str
        :param collection_type: Filter collections by type
        :type collection_type: str
        :param created_after: Filter collections created after this date (ISO 8601 format)
        :type created_after: datetime
        :param created_before: Filter collections created before this date (ISO 8601 format)
        :type created_before: datetime
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_collections_serialize(
            limit=limit,
            offset=offset,
            order=order,
            sort=sort,
            collection_type=collection_type,
            created_after=created_after,
            created_before=created_before,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CollectionList",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_collections_without_preload_content(
        self,
        limit: Annotated[Optional[Annotated[int, Field(le=100, strict=True)]], Field(description="Maximum number of collections to return")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="Number of collections to skip")] = None,
        order: Annotated[Optional[StrictStr], Field(description="Order the collections by a specific field")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Sort the collections in ascending or descending order")] = None,
        collection_type: Annotated[Optional[StrictStr], Field(description="Filter collections by type")] = None,
        created_after: Annotated[Optional[datetime], Field(description="Filter collections created after this date (ISO 8601 format)")] = None,
        created_before: Annotated[Optional[datetime], Field(description="Filter collections created before this date (ISO 8601 format)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List all collections

        List all collections

        :param limit: Maximum number of collections to return
        :type limit: int
        :param offset: Number of collections to skip
        :type offset: int
        :param order: Order the collections by a specific field
        :type order: str
        :param sort: Sort the collections in ascending or descending order
        :type sort: str
        :param collection_type: Filter collections by type
        :type collection_type: str
        :param created_after: Filter collections created after this date (ISO 8601 format)
        :type created_after: datetime
        :param created_before: Filter collections created before this date (ISO 8601 format)
        :type created_before: datetime
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_collections_serialize(
            limit=limit,
            offset=offset,
            order=order,
            sort=sort,
            collection_type=collection_type,
            created_after=created_after,
            created_before=created_before,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CollectionList",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_collections_serialize(
        self,
        limit,
        offset,
        order,
        sort,
        collection_type,
        created_after,
        created_before,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if order is not None:
            
            _query_params.append(('order', order))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if collection_type is not None:
            
            _query_params.append(('collection_type', collection_type))
            
        if created_after is not None:
            if isinstance(created_after, datetime):
                _query_params.append(
                    (
                        'created_after',
                        created_after.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('created_after', created_after))
            
        if created_before is not None:
            if isinstance(created_before, datetime):
                _query_params.append(
                    (
                        'created_before',
                        created_before.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('created_before', created_before))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/collections',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_videos(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection")],
        limit: Annotated[Optional[Annotated[int, Field(le=100, strict=True)]], Field(description="Maximum number of files to return")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="Number of files to skip")] = None,
        status: Annotated[Optional[StrictStr], Field(description="Filter by processing status")] = None,
        added_before: Annotated[Optional[date], Field(description="Filter files added before a specific date (YYYY-MM-DD format), in UTC timezone")] = None,
        added_after: Annotated[Optional[date], Field(description="Filter files added after a specific date (YYYY-MM-DD format), in UTC timezone")] = None,
        order: Annotated[Optional[StrictStr], Field(description="Order the files by a specific field")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Sort the files in ascending or descending order")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="JSON string containing filter criteria to constrain file search results. This is the JSON string version of the SearchFilter object used in the search API.  **Supported Filter Types:**   **metadata** - Filter by file metadata using JSON path expressions (e.g., 'metadata.speaker', 'metadata.category.subcategory')  **video_info** - Filter by video information properties   - `duration_seconds` - Video duration in seconds   - `has_audio` - Whether the video has audio (true/false)   **file** - Filter by file properties   - `filename` - File name (string)   - `uri` - File URI (string)   - `id` - File ID (UUID string)   - `created_at` - Creation timestamp (ISO 8601 string)   - `bytes` - File size in bytes (number)  **Supported Operators:**  **Equal** - Exact match (requires valueText)  **NotEqual** - Not equal to value (requires valueText)  **LessThan** - Less than value (requires valueText)  **GreaterThan** - Greater than value (requires valueText)  **Like** - Case-insensitive pattern matching with wildcards (requires valueText)  **In** - Value is in array (requires valueTextArray)  **ContainsAny** - Array contains any of the values (requires valueTextArray)  **ContainsAll** - Array contains all of the values (requires valueTextArray)  **Examples:**  **Metadata filtering:** ```json {\"metadata\":[{\"path\":\"speaker\",\"operator\":\"Like\",\"valueText\":\"YO%\"}]} ```  **Video info filtering:** ```json {\"video_info\":[{\"path\":\"duration_seconds\",\"operator\":\"GreaterThan\",\"valueText\":\"60\"}]} ```  **File property filtering:** ```json {\"file\":[{\"path\":\"filename\",\"operator\":\"Like\",\"valueText\":\"%.mp4\"}]} ``` ```json {\"file\":[{\"path\":\"bytes\",\"operator\":\"GreaterThan\",\"valueText\":\"1048576\"}]} ``` ```json {\"file\":[{\"path\":\"created_at\",\"operator\":\"GreaterThan\",\"valueText\":\"2024-01-01T00:00:00Z\"}]} ```  **Combined filtering:** ```json {\"metadata\":[{\"path\":\"speaker\",\"operator\":\"Equal\",\"valueText\":\"John\"}],\"video_info\":[{\"path\":\"has_audio\",\"operator\":\"Equal\",\"valueText\":\"true\"}],\"file\":[{\"path\":\"filename\",\"operator\":\"Like\",\"valueText\":\"%.mp4\"}]} ```")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CollectionFileList:
        """List all files in a collection

        List all files in a collection

        :param collection_id: The ID of the collection (required)
        :type collection_id: str
        :param limit: Maximum number of files to return
        :type limit: int
        :param offset: Number of files to skip
        :type offset: int
        :param status: Filter by processing status
        :type status: str
        :param added_before: Filter files added before a specific date (YYYY-MM-DD format), in UTC timezone
        :type added_before: date
        :param added_after: Filter files added after a specific date (YYYY-MM-DD format), in UTC timezone
        :type added_after: date
        :param order: Order the files by a specific field
        :type order: str
        :param sort: Sort the files in ascending or descending order
        :type sort: str
        :param filter: JSON string containing filter criteria to constrain file search results. This is the JSON string version of the SearchFilter object used in the search API.  **Supported Filter Types:**   **metadata** - Filter by file metadata using JSON path expressions (e.g., 'metadata.speaker', 'metadata.category.subcategory')  **video_info** - Filter by video information properties   - `duration_seconds` - Video duration in seconds   - `has_audio` - Whether the video has audio (true/false)   **file** - Filter by file properties   - `filename` - File name (string)   - `uri` - File URI (string)   - `id` - File ID (UUID string)   - `created_at` - Creation timestamp (ISO 8601 string)   - `bytes` - File size in bytes (number)  **Supported Operators:**  **Equal** - Exact match (requires valueText)  **NotEqual** - Not equal to value (requires valueText)  **LessThan** - Less than value (requires valueText)  **GreaterThan** - Greater than value (requires valueText)  **Like** - Case-insensitive pattern matching with wildcards (requires valueText)  **In** - Value is in array (requires valueTextArray)  **ContainsAny** - Array contains any of the values (requires valueTextArray)  **ContainsAll** - Array contains all of the values (requires valueTextArray)  **Examples:**  **Metadata filtering:** ```json {\"metadata\":[{\"path\":\"speaker\",\"operator\":\"Like\",\"valueText\":\"YO%\"}]} ```  **Video info filtering:** ```json {\"video_info\":[{\"path\":\"duration_seconds\",\"operator\":\"GreaterThan\",\"valueText\":\"60\"}]} ```  **File property filtering:** ```json {\"file\":[{\"path\":\"filename\",\"operator\":\"Like\",\"valueText\":\"%.mp4\"}]} ``` ```json {\"file\":[{\"path\":\"bytes\",\"operator\":\"GreaterThan\",\"valueText\":\"1048576\"}]} ``` ```json {\"file\":[{\"path\":\"created_at\",\"operator\":\"GreaterThan\",\"valueText\":\"2024-01-01T00:00:00Z\"}]} ```  **Combined filtering:** ```json {\"metadata\":[{\"path\":\"speaker\",\"operator\":\"Equal\",\"valueText\":\"John\"}],\"video_info\":[{\"path\":\"has_audio\",\"operator\":\"Equal\",\"valueText\":\"true\"}],\"file\":[{\"path\":\"filename\",\"operator\":\"Like\",\"valueText\":\"%.mp4\"}]} ```
        :type filter: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_videos_serialize(
            collection_id=collection_id,
            limit=limit,
            offset=offset,
            status=status,
            added_before=added_before,
            added_after=added_after,
            order=order,
            sort=sort,
            filter=filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CollectionFileList",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_videos_with_http_info(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection")],
        limit: Annotated[Optional[Annotated[int, Field(le=100, strict=True)]], Field(description="Maximum number of files to return")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="Number of files to skip")] = None,
        status: Annotated[Optional[StrictStr], Field(description="Filter by processing status")] = None,
        added_before: Annotated[Optional[date], Field(description="Filter files added before a specific date (YYYY-MM-DD format), in UTC timezone")] = None,
        added_after: Annotated[Optional[date], Field(description="Filter files added after a specific date (YYYY-MM-DD format), in UTC timezone")] = None,
        order: Annotated[Optional[StrictStr], Field(description="Order the files by a specific field")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Sort the files in ascending or descending order")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="JSON string containing filter criteria to constrain file search results. This is the JSON string version of the SearchFilter object used in the search API.  **Supported Filter Types:**   **metadata** - Filter by file metadata using JSON path expressions (e.g., 'metadata.speaker', 'metadata.category.subcategory')  **video_info** - Filter by video information properties   - `duration_seconds` - Video duration in seconds   - `has_audio` - Whether the video has audio (true/false)   **file** - Filter by file properties   - `filename` - File name (string)   - `uri` - File URI (string)   - `id` - File ID (UUID string)   - `created_at` - Creation timestamp (ISO 8601 string)   - `bytes` - File size in bytes (number)  **Supported Operators:**  **Equal** - Exact match (requires valueText)  **NotEqual** - Not equal to value (requires valueText)  **LessThan** - Less than value (requires valueText)  **GreaterThan** - Greater than value (requires valueText)  **Like** - Case-insensitive pattern matching with wildcards (requires valueText)  **In** - Value is in array (requires valueTextArray)  **ContainsAny** - Array contains any of the values (requires valueTextArray)  **ContainsAll** - Array contains all of the values (requires valueTextArray)  **Examples:**  **Metadata filtering:** ```json {\"metadata\":[{\"path\":\"speaker\",\"operator\":\"Like\",\"valueText\":\"YO%\"}]} ```  **Video info filtering:** ```json {\"video_info\":[{\"path\":\"duration_seconds\",\"operator\":\"GreaterThan\",\"valueText\":\"60\"}]} ```  **File property filtering:** ```json {\"file\":[{\"path\":\"filename\",\"operator\":\"Like\",\"valueText\":\"%.mp4\"}]} ``` ```json {\"file\":[{\"path\":\"bytes\",\"operator\":\"GreaterThan\",\"valueText\":\"1048576\"}]} ``` ```json {\"file\":[{\"path\":\"created_at\",\"operator\":\"GreaterThan\",\"valueText\":\"2024-01-01T00:00:00Z\"}]} ```  **Combined filtering:** ```json {\"metadata\":[{\"path\":\"speaker\",\"operator\":\"Equal\",\"valueText\":\"John\"}],\"video_info\":[{\"path\":\"has_audio\",\"operator\":\"Equal\",\"valueText\":\"true\"}],\"file\":[{\"path\":\"filename\",\"operator\":\"Like\",\"valueText\":\"%.mp4\"}]} ```")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CollectionFileList]:
        """List all files in a collection

        List all files in a collection

        :param collection_id: The ID of the collection (required)
        :type collection_id: str
        :param limit: Maximum number of files to return
        :type limit: int
        :param offset: Number of files to skip
        :type offset: int
        :param status: Filter by processing status
        :type status: str
        :param added_before: Filter files added before a specific date (YYYY-MM-DD format), in UTC timezone
        :type added_before: date
        :param added_after: Filter files added after a specific date (YYYY-MM-DD format), in UTC timezone
        :type added_after: date
        :param order: Order the files by a specific field
        :type order: str
        :param sort: Sort the files in ascending or descending order
        :type sort: str
        :param filter: JSON string containing filter criteria to constrain file search results. This is the JSON string version of the SearchFilter object used in the search API.  **Supported Filter Types:**   **metadata** - Filter by file metadata using JSON path expressions (e.g., 'metadata.speaker', 'metadata.category.subcategory')  **video_info** - Filter by video information properties   - `duration_seconds` - Video duration in seconds   - `has_audio` - Whether the video has audio (true/false)   **file** - Filter by file properties   - `filename` - File name (string)   - `uri` - File URI (string)   - `id` - File ID (UUID string)   - `created_at` - Creation timestamp (ISO 8601 string)   - `bytes` - File size in bytes (number)  **Supported Operators:**  **Equal** - Exact match (requires valueText)  **NotEqual** - Not equal to value (requires valueText)  **LessThan** - Less than value (requires valueText)  **GreaterThan** - Greater than value (requires valueText)  **Like** - Case-insensitive pattern matching with wildcards (requires valueText)  **In** - Value is in array (requires valueTextArray)  **ContainsAny** - Array contains any of the values (requires valueTextArray)  **ContainsAll** - Array contains all of the values (requires valueTextArray)  **Examples:**  **Metadata filtering:** ```json {\"metadata\":[{\"path\":\"speaker\",\"operator\":\"Like\",\"valueText\":\"YO%\"}]} ```  **Video info filtering:** ```json {\"video_info\":[{\"path\":\"duration_seconds\",\"operator\":\"GreaterThan\",\"valueText\":\"60\"}]} ```  **File property filtering:** ```json {\"file\":[{\"path\":\"filename\",\"operator\":\"Like\",\"valueText\":\"%.mp4\"}]} ``` ```json {\"file\":[{\"path\":\"bytes\",\"operator\":\"GreaterThan\",\"valueText\":\"1048576\"}]} ``` ```json {\"file\":[{\"path\":\"created_at\",\"operator\":\"GreaterThan\",\"valueText\":\"2024-01-01T00:00:00Z\"}]} ```  **Combined filtering:** ```json {\"metadata\":[{\"path\":\"speaker\",\"operator\":\"Equal\",\"valueText\":\"John\"}],\"video_info\":[{\"path\":\"has_audio\",\"operator\":\"Equal\",\"valueText\":\"true\"}],\"file\":[{\"path\":\"filename\",\"operator\":\"Like\",\"valueText\":\"%.mp4\"}]} ```
        :type filter: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_videos_serialize(
            collection_id=collection_id,
            limit=limit,
            offset=offset,
            status=status,
            added_before=added_before,
            added_after=added_after,
            order=order,
            sort=sort,
            filter=filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CollectionFileList",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_videos_without_preload_content(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection")],
        limit: Annotated[Optional[Annotated[int, Field(le=100, strict=True)]], Field(description="Maximum number of files to return")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="Number of files to skip")] = None,
        status: Annotated[Optional[StrictStr], Field(description="Filter by processing status")] = None,
        added_before: Annotated[Optional[date], Field(description="Filter files added before a specific date (YYYY-MM-DD format), in UTC timezone")] = None,
        added_after: Annotated[Optional[date], Field(description="Filter files added after a specific date (YYYY-MM-DD format), in UTC timezone")] = None,
        order: Annotated[Optional[StrictStr], Field(description="Order the files by a specific field")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Sort the files in ascending or descending order")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="JSON string containing filter criteria to constrain file search results. This is the JSON string version of the SearchFilter object used in the search API.  **Supported Filter Types:**   **metadata** - Filter by file metadata using JSON path expressions (e.g., 'metadata.speaker', 'metadata.category.subcategory')  **video_info** - Filter by video information properties   - `duration_seconds` - Video duration in seconds   - `has_audio` - Whether the video has audio (true/false)   **file** - Filter by file properties   - `filename` - File name (string)   - `uri` - File URI (string)   - `id` - File ID (UUID string)   - `created_at` - Creation timestamp (ISO 8601 string)   - `bytes` - File size in bytes (number)  **Supported Operators:**  **Equal** - Exact match (requires valueText)  **NotEqual** - Not equal to value (requires valueText)  **LessThan** - Less than value (requires valueText)  **GreaterThan** - Greater than value (requires valueText)  **Like** - Case-insensitive pattern matching with wildcards (requires valueText)  **In** - Value is in array (requires valueTextArray)  **ContainsAny** - Array contains any of the values (requires valueTextArray)  **ContainsAll** - Array contains all of the values (requires valueTextArray)  **Examples:**  **Metadata filtering:** ```json {\"metadata\":[{\"path\":\"speaker\",\"operator\":\"Like\",\"valueText\":\"YO%\"}]} ```  **Video info filtering:** ```json {\"video_info\":[{\"path\":\"duration_seconds\",\"operator\":\"GreaterThan\",\"valueText\":\"60\"}]} ```  **File property filtering:** ```json {\"file\":[{\"path\":\"filename\",\"operator\":\"Like\",\"valueText\":\"%.mp4\"}]} ``` ```json {\"file\":[{\"path\":\"bytes\",\"operator\":\"GreaterThan\",\"valueText\":\"1048576\"}]} ``` ```json {\"file\":[{\"path\":\"created_at\",\"operator\":\"GreaterThan\",\"valueText\":\"2024-01-01T00:00:00Z\"}]} ```  **Combined filtering:** ```json {\"metadata\":[{\"path\":\"speaker\",\"operator\":\"Equal\",\"valueText\":\"John\"}],\"video_info\":[{\"path\":\"has_audio\",\"operator\":\"Equal\",\"valueText\":\"true\"}],\"file\":[{\"path\":\"filename\",\"operator\":\"Like\",\"valueText\":\"%.mp4\"}]} ```")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List all files in a collection

        List all files in a collection

        :param collection_id: The ID of the collection (required)
        :type collection_id: str
        :param limit: Maximum number of files to return
        :type limit: int
        :param offset: Number of files to skip
        :type offset: int
        :param status: Filter by processing status
        :type status: str
        :param added_before: Filter files added before a specific date (YYYY-MM-DD format), in UTC timezone
        :type added_before: date
        :param added_after: Filter files added after a specific date (YYYY-MM-DD format), in UTC timezone
        :type added_after: date
        :param order: Order the files by a specific field
        :type order: str
        :param sort: Sort the files in ascending or descending order
        :type sort: str
        :param filter: JSON string containing filter criteria to constrain file search results. This is the JSON string version of the SearchFilter object used in the search API.  **Supported Filter Types:**   **metadata** - Filter by file metadata using JSON path expressions (e.g., 'metadata.speaker', 'metadata.category.subcategory')  **video_info** - Filter by video information properties   - `duration_seconds` - Video duration in seconds   - `has_audio` - Whether the video has audio (true/false)   **file** - Filter by file properties   - `filename` - File name (string)   - `uri` - File URI (string)   - `id` - File ID (UUID string)   - `created_at` - Creation timestamp (ISO 8601 string)   - `bytes` - File size in bytes (number)  **Supported Operators:**  **Equal** - Exact match (requires valueText)  **NotEqual** - Not equal to value (requires valueText)  **LessThan** - Less than value (requires valueText)  **GreaterThan** - Greater than value (requires valueText)  **Like** - Case-insensitive pattern matching with wildcards (requires valueText)  **In** - Value is in array (requires valueTextArray)  **ContainsAny** - Array contains any of the values (requires valueTextArray)  **ContainsAll** - Array contains all of the values (requires valueTextArray)  **Examples:**  **Metadata filtering:** ```json {\"metadata\":[{\"path\":\"speaker\",\"operator\":\"Like\",\"valueText\":\"YO%\"}]} ```  **Video info filtering:** ```json {\"video_info\":[{\"path\":\"duration_seconds\",\"operator\":\"GreaterThan\",\"valueText\":\"60\"}]} ```  **File property filtering:** ```json {\"file\":[{\"path\":\"filename\",\"operator\":\"Like\",\"valueText\":\"%.mp4\"}]} ``` ```json {\"file\":[{\"path\":\"bytes\",\"operator\":\"GreaterThan\",\"valueText\":\"1048576\"}]} ``` ```json {\"file\":[{\"path\":\"created_at\",\"operator\":\"GreaterThan\",\"valueText\":\"2024-01-01T00:00:00Z\"}]} ```  **Combined filtering:** ```json {\"metadata\":[{\"path\":\"speaker\",\"operator\":\"Equal\",\"valueText\":\"John\"}],\"video_info\":[{\"path\":\"has_audio\",\"operator\":\"Equal\",\"valueText\":\"true\"}],\"file\":[{\"path\":\"filename\",\"operator\":\"Like\",\"valueText\":\"%.mp4\"}]} ```
        :type filter: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_videos_serialize(
            collection_id=collection_id,
            limit=limit,
            offset=offset,
            status=status,
            added_before=added_before,
            added_after=added_after,
            order=order,
            sort=sort,
            filter=filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CollectionFileList",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_videos_serialize(
        self,
        collection_id,
        limit,
        offset,
        status,
        added_before,
        added_after,
        order,
        sort,
        filter,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if collection_id is not None:
            _path_params['collection_id'] = collection_id
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if status is not None:
            
            _query_params.append(('status', status))
            
        if added_before is not None:
            if isinstance(added_before, date):
                _query_params.append(
                    (
                        'added_before',
                        added_before.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('added_before', added_before))
            
        if added_after is not None:
            if isinstance(added_after, date):
                _query_params.append(
                    (
                        'added_after',
                        added_after.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('added_after', added_after))
            
        if order is not None:
            
            _query_params.append(('order', order))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/collections/{collection_id}/videos',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_collection(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection to update")],
        collection_update: Annotated[CollectionUpdate, Field(description="Collection update parameters")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Collection:
        """Update a collection

        Update a collection

        :param collection_id: The ID of the collection to update (required)
        :type collection_id: str
        :param collection_update: Collection update parameters (required)
        :type collection_update: CollectionUpdate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_collection_serialize(
            collection_id=collection_id,
            collection_update=collection_update,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Collection",
            '400': "Error",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_collection_with_http_info(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection to update")],
        collection_update: Annotated[CollectionUpdate, Field(description="Collection update parameters")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Collection]:
        """Update a collection

        Update a collection

        :param collection_id: The ID of the collection to update (required)
        :type collection_id: str
        :param collection_update: Collection update parameters (required)
        :type collection_update: CollectionUpdate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_collection_serialize(
            collection_id=collection_id,
            collection_update=collection_update,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Collection",
            '400': "Error",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_collection_without_preload_content(
        self,
        collection_id: Annotated[StrictStr, Field(description="The ID of the collection to update")],
        collection_update: Annotated[CollectionUpdate, Field(description="Collection update parameters")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update a collection

        Update a collection

        :param collection_id: The ID of the collection to update (required)
        :type collection_id: str
        :param collection_update: Collection update parameters (required)
        :type collection_update: CollectionUpdate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_collection_serialize(
            collection_id=collection_id,
            collection_update=collection_update,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Collection",
            '400': "Error",
            '404': "Error",
            '500': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_collection_serialize(
        self,
        collection_id,
        collection_update,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if collection_id is not None:
            _path_params['collection_id'] = collection_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if collection_update is not None:
            _body_params = collection_update


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/collections/{collection_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


