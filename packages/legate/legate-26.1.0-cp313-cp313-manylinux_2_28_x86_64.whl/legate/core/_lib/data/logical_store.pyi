# SPDX-FileCopyrightText: Copyright (c) 2023-2026 NVIDIA CORPORATION & AFFILIATES.
#                         All rights reserved.
# SPDX-License-Identifier: Apache-2.0

from collections.abc import Iterable
from typing import Any

from ...data_interface import LegateDataInterfaceItem
from ..mapping.mapping import StoreTarget
from ..type.types import Type
from ..utilities.unconstructable import Unconstructable
from .physical_store import PhysicalStore
from .shape import Shape

class LogicalStore(Unconstructable):
    @property
    def shape(self) -> Shape: ...
    @property
    def ndim(self) -> int: ...
    @property
    def has_scalar_storage(self) -> bool: ...
    def overlaps(self, other: LogicalStore) -> bool: ...
    @property
    def type(self) -> Type: ...
    @property
    def extents(self) -> tuple[int, ...]: ...
    @property
    def volume(self) -> int: ...
    @property
    def size(self) -> int: ...
    @property
    def unbound(self) -> int: ...
    @property
    def transformed(self) -> bool: ...
    @property
    def __legate_data_interface__(self) -> LegateDataInterfaceItem: ...
    def __getitem__(
        self, indices: int | slice | tuple[int | slice | None, ...]
    ) -> LogicalStore: ...
    def promote(self, extra_dim: int, dim_size: int) -> LogicalStore: ...
    def project(self, dim: int, index: int) -> LogicalStore: ...
    def broadcast(self, dim: int, dim_size: int) -> LogicalStore: ...
    def slice(self, dim: int, sl: slice) -> LogicalStore: ...
    def transpose(self, axes: Iterable[int]) -> LogicalStore: ...
    def delinearize(self, dim: int, shape: Iterable[int]) -> LogicalStore: ...
    def fill(self, value: Any) -> None: ...
    @property
    def partition(self) -> LogicalStorePartition | None: ...
    def partition_by_tiling(
        self,
        tile_shape: Iterable[int],
        color_shape: Iterable[int] | None = None,
    ) -> LogicalStorePartition: ...
    def get_physical_store(
        self, target: StoreTarget = ...
    ) -> PhysicalStore: ...
    def detach(self) -> None: ...
    def offload_to(self, target_mem: StoreTarget) -> None: ...
    def equal_storage(self, other: LogicalStore) -> bool: ...
    @property
    def raw_handle(self) -> int: ...
    @property
    def __array_interface__(self) -> dict[str, Any]: ...
    @property
    def __cuda_array_interface__(self) -> dict[str, Any]: ...

class LogicalStorePartition:
    def store(self) -> LogicalStore: ...
    @property
    def color_shape(self) -> tuple[int, ...]: ...
    def get_child_store(self, *color: int) -> LogicalStore: ...
