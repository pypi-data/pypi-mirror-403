/* Copyright 2025 Stanford University, NVIDIA Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __LEGION_CONFIG_H__
#define __LEGION_CONFIG_H__

// legion_defines.h is auto-generated by both the make and cmake builds
#include "legion_defines.h"

#ifndef LEGION_USE_PYTHON_CFFI
#include <limits.h>
#endif  // LEGION_USE_PYTHON_CFFI

// Define a prefix for annotating functions for CUDA compilation
#if defined(__CUDACC__) || defined(__HIPCC__)
#define __LEGION_CUDA_HD__ __host__ __device__
#else
#define __LEGION_CUDA_HD__
#endif

/**
 * \file config.h
 */

// ******************** IMPORTANT **************************
//
// This file is PURE C, **NOT** C++. Keep any C++-isms in
// legion_types.h, or elsewhere.
//
// ******************** IMPORTANT **************************

#include "realm/realm_c.h"

//==========================================================================
//                                Constants
//==========================================================================

#ifndef LEGION_AUTO_GENERATE_ID
#define LEGION_AUTO_GENERATE_ID UINT_MAX
#else
#error \
    "legion.h requires the ability to define the macro 'LEGION_AUTO_GENERATE_ID' but it has already been defined"
#endif
// This is for backwards compatibility
// Try to be nice in case someone else defined this
#ifndef LEGION_DISABLE_DEPRECATED_ENUMS
#ifndef AUTO_GENERATE_ID
#define AUTO_GENERATE_ID LEGION_AUTO_GENERATE_ID
#endif
#endif

#ifndef LEGION_GC_MIN_PRIORITY
#define LEGION_GC_MIN_PRIORITY INT_MIN
#else
#error \
    "legion.h requires the ability to define the macro 'LEGION_GC_MIN_PRIORITY' but it has already been defined"
#endif
// This is for backwards compatibility
// Try to be nice in case someone else defined this
#ifndef LEGION_DISABLE_DEPRECATED_ENUMS
#ifndef GC_MIN_PRIORITY
#define GC_MIN_PRIORITY LEGION_GC_MIN_PRIORITY
#endif
#endif

#ifndef LEGION_GC_MAX_PRIORITY
#define LEGION_GC_MAX_PRIORITY (INT_MAX - 1)
#else
#error \
    "legion.h requires the ability to define the macro 'LEGION_GC_MAX_PRIORITY' but it has already been defined"
#endif
// This is for backwards compatibility
// Try to be nice in case someone else defined this
#ifndef LEGION_DISABLE_DEPRECATED_ENUMS
#ifndef GC_MAX_PRIORITY
#define GC_MAX_PRIORITY LEGION_GC_MAX_PRIORITY
#endif
#endif

#ifndef LEGION_GC_NEVER_PRIORITY
#define LEGION_GC_NEVER_PRIORITY LEGION_GC_MIN_PRIORITY
#else
#error \
    "legion.h requires the ability to define the macro 'LEGION_GC_NEVER_PRIORITY' but it has already been defined"
#endif

#ifndef LEGION_GC_EAGER_PRIORITY
#define LEGION_GC_EAGER_PRIORITY INT_MAX
#else
#error \
    "legion.h requires the ability to define the macro 'LEGION_GC_EAGER_PRIORITY' but it has already been defined"
#endif

// This is for backwards compatibility
// Try to be nice in case someone else defined this
#ifndef LEGION_DISABLE_DEPRECATED_ENUMS
#ifndef GC_NEVER_PRIORITY
#define GC_NEVER_PRIORITY LEGION_GC_NEVER_PRIORITY
#endif
#endif
// This is for backwards compatibility
// Try to be nice in case someone else defined this
#ifdef BOUNDS_CHECKS
#ifndef LEGION_BOUNDS_CHECKS
#define LEGION_BOUNDS_CHECKS
#endif
#endif
// This is for backwards compatibility
// Try to be nice in case someone else defined this
#ifdef PRIVILEGE_CHECKS
#ifndef LEGION_PRIVILEGE_CHECKS
#define LEGION_PRIVILEGE_CHECKS
#endif
#endif

#ifndef LEGION_GC_FIRST_PRIORITY
#define LEGION_GC_FIRST_PRIORITY LEGION_GC_MAX_PRIORITY
#endif
#ifndef LEGION_GC_DEFAULT_PRIORITY
#define LEGION_GC_DEFAULT_PRIORITY 0
#endif
#ifndef LEGION_GC_LAST_PRIORITY
#define LEGION_GC_LAST_PRIORITY (LEGION_GC_MIN_PRIORITY + 1)
#endif
// This is for backwards compatibility
// Try to be nice in case someone else defined this
#ifndef LEGION_DISABLE_DEPRECATED_ENUMS
#ifndef GC_FIRST_PRIORITY
#define GC_FIRST_PRIORITY LEGION_GC_FIRST_PRIORITY
#endif
#ifndef GC_DEFAULT_PRIORITY
#define GC_DEFAULT_PRIORITY LEGION_GC_DEFAULT_PRIORITY
#endif
#ifndef GC_LAST_PRIORITY
#define GC_LAST_PRIORITY LEGION_GC_LAST_PRIORITY
#endif
#endif

#ifndef LEGION_MAX_DIM
#define LEGION_MAX_DIM 3  // maximum number of dimensions for index spaces
#endif

// This value used to describe the maximum return size that Legion would
// permit for future values. We've since relaxed this so futures could
// return large opaque buffers. This value now specifies the maximum size
// that Legion will all for future values to be passed by value without
// the Realm DMA system being used for actually moving the data.
#ifndef MAX_RETURN_SIZE  // For backwards compatibility
#ifndef LEGION_MAX_RETURN_SIZE
#define LEGION_MAX_RETURN_SIZE 2048  // maximum return type size in bytes
#endif
#else
#ifndef LEGION_MAX_RETURN_SIZE
#define LEGION_MAX_RETURN_SIZE (MAX_RETURN_SIZE)
#endif
#endif

#ifndef MAX_FIELDS  // For backwards compatibility
#ifndef LEGION_MAX_FIELDS
#define LEGION_MAX_FIELDS 256  // must be a power of 2
#endif
#else
#ifndef LEGION_MAX_FIELDS
#define LEGION_MAX_FIELDS (MAX_FIELDS)
#endif
#endif

// Some default values

// The maximum number of nodes to be run on
#ifndef MAX_NUM_NODES  // For backwards compatibility
#ifndef LEGION_MAX_NUM_NODES
#define LEGION_MAX_NUM_NODES 1024  // must be a power of 2
#endif
#else
#ifndef LEGION_MAX_NUM_NODES
#define LEGION_MAX_NUM_NODES (MAX_NUM_NODES)
#endif
#endif
// The maximum number of processors on a node
#ifndef MAX_NUM_PROCS  // For backwards compatibility
#ifndef LEGION_MAX_NUM_PROCS
#define LEGION_MAX_NUM_PROCS 64  // must be a power of 2
#endif
#else
#ifndef LEGION_MAX_NUM_PROCS
#define LEGION_MAX_NUM_PROCS (MAX_NUM_PROCS)
#endif
#endif
// Maximum ID for an application task ID
#ifndef MAX_APPLICATION_TASK_ID  // For backwards compatibility
#ifndef LEGION_MAX_APPLICATION_TASK_ID
#define LEGION_MAX_APPLICATION_TASK_ID (1 << 20)
#endif
#else
#ifndef LEGION_MAX_APPLICATION_TASK_ID
#define LEGION_MAX_APPLICATION_TASK_ID (MAX_APPLICATION_TASK_ID)
#endif
#endif
// Maximum ID for an application field ID
#ifndef MAX_APPLICATION_FIELD_ID  // For backwards compatibility
#ifndef LEGION_MAX_APPLICATION_FIELD_ID
#define LEGION_MAX_APPLICATION_FIELD_ID (1 << 20)
#endif
#else
#ifndef LEGION_MAX_APPLICATION_FIELD_ID
#define LEGION_MAX_APPLICATION_FIELD_ID (MAX_APPLICATION_FIELD_ID)
#endif
#endif
// Maximum ID for an application mapper ID
#ifndef MAX_APPLICATION_MAPPER_ID  // For backwards compatibility
#ifndef LEGION_MAX_APPLICATION_MAPPER_ID
#define LEGION_MAX_APPLICATION_MAPPER_ID (1 << 20)
#endif
#else
#ifndef LEGION_MAX_APPLICATION_MAPPER_ID
#define LEGION_MAX_APPLICATION_MAPPER_ID (MAX_APPLICATION_MAPPER_ID)
#endif
#endif
// Maximum ID for an application reduction ID
#ifndef MAX_APPLICATION_REDUCTION_ID
#define MAX_APPLICATION_REDUCTION_ID (1 << 20)
#endif
// Maximum ID for an application trace ID
#ifndef LEGION_MAX_APPLICATION_TRACE_ID
#define LEGION_MAX_APPLICATION_TRACE_ID (1 << 20)
#endif
// Maximum ID for an application projection ID
#ifndef MAX_APPLICATION_PROJECTION_ID  // For backwards compatibility
#ifndef LEGION_MAX_APPLICATION_PROJECTION_ID
#define LEGION_MAX_APPLICATION_PROJECTION_ID (1 << 20)
#endif
#else
#ifndef LEGION_MAX_APPLICATION_PROJECTION_ID
#define LEGION_MAX_APPLICATION_PROJECTION_ID (MAX_APPLICATION_PROJECTION_ID)
#endif
#endif
// Maximum ID for an application sharding ID
#ifndef MAX_APPLICATION_SHARDING_ID  // For backwards compatibility
#ifndef LEGION_MAX_APPLICATION_SHARDING_ID
#define LEGION_MAX_APPLICATION_SHARDING_ID (1 << 20)
#endif
#else
#ifndef LEGION_MAX_APPLICATION_SHARDING_ID
#define LEGION_MAX_APPLICATION_SHARDING_ID (MAX_APPLICATION_SHARDING_ID)
#endif
#endif
#ifndef LEGION_MAX_APPLICATION_CONCURRENT_ID
#define LEGION_MAX_APPLICATION_CONCURRENT_ID (1 << 20)
#endif
#ifndef LEGION_MAX_APPLICATION_EXCEPTION_HANDLER_ID
#define LEGION_MAX_APPLICATION_EXCEPTION_HANDLER_ID (1 << 20)
#endif
// Maximum ID for an application reduction ID
#ifndef LEGION_MAX_APPLICATION_REDOP_ID
#ifdef LEGION_USE_PYTHON_CFFI
#define LEGION_MAX_APPLICATION_REDOP_ID 1048576
#else
#define LEGION_MAX_APPLICATION_REDOP_ID \
  (1 << 20)  // Python CFFI can't do this math
#endif
#endif
// Maximum ID for an application serdez ID
#ifndef LEGION_MAX_APPLICATION_SERDEZ_ID
#define LEGION_MAX_APPLICATION_SERDEZ_ID (1 << 20)
#endif
// Maximum ID for layout constraint ID
#ifndef LEGION_MAX_APPLICATION_LAYOUT_ID
#define LEGION_MAX_APPLICATION_LAYOUT_ID (1 << 20)
#endif
// Default number of local fields per field space
#ifndef DEFAULT_LOCAL_FIELDS  // For backwards compatibility
#ifndef LEGION_DEFAULT_LOCAL_FIELDS
#define LEGION_DEFAULT_LOCAL_FIELDS 4
#endif
#else
#ifndef LEGION_DEFAULT_LOCAL_FIELDS
#define LEGION_DEFAULT_LOCAL_FIELDS (DEFAULT_LOCAL_FIELDS)
#endif
#endif
// Default number of mapper slots
#ifndef DEFAULT_MAPPER_SLOTS  // For backwards compatibility
#ifndef LEGION_DEFAULT_MAPPER_SLOTS
#define LEGION_DEFAULT_MAPPER_SLOTS 8
#endif
#else
#ifndef LEGION_DEFAULT_MAPPER_SLOTS
#define LEGION_DEFAULT_MAPPER_SLOTS (DEFAULT_MAPPER_SLOTS)
#endif
#endif
// Default number of contexts made for each runtime instance
// Ideally this is a power of 2 (better for performance)
#ifndef DEFAULT_CONTEXTS  // For backwards compatibility
#ifndef LEGION_DEFAULT_CONTEXTS
#define LEGION_DEFAULT_CONTEXTS 8
#endif
#else
#ifndef LEGION_DEFAULT_CONTEXTS
#define LEGION_DEFAULT_CONTEXTS (DEFAULT_CONTEXTS)
#endif
#endif
// Maximum number of sub-tasks per task at a time
#ifndef DEFAULT_MAX_TASK_WINDOW  // For backwards compatibility
#ifndef LEGION_DEFAULT_MAX_TASK_WINDOW
#define LEGION_DEFAULT_MAX_TASK_WINDOW 1024
#endif
#else
#ifndef LEGION_DEFAULT_MAX_TASK_WINDOW
#define LEGION_DEFAULT_MAX_TASK_WINDOW (DEFAULT_MAX_TASK_WINDOW)
#endif
#endif
// Default amount of hysteresis on the task window in the
// form of a percentage (must be between 0 and 100)
#ifndef DEFAULT_TASK_WINDOW_HYSTERESIS  // For backwards compatibility
#ifndef LEGION_DEFAULT_TASK_WINDOW_HYSTERESIS
#define LEGION_DEFAULT_TASK_WINDOW_HYSTERESIS 25
#endif
#else
#ifndef LEGION_DEFAULT_TASK_WINDOW_HYSTERESIS
#define LEGION_DEFAULT_TASK_WINDOW_HYSTERESIS (DEFAULT_TASK_WINDOW_HYSTERESIS)
#endif
#endif
// Default number of tasks to have in flight before applying
// back pressure to the mapping process for a context
#ifndef DEFAULT_MIN_TASKS_TO_SCHEDULE  // For backwards compatibility
#ifndef LEGION_DEFAULT_MIN_TASKS_TO_SCHEDULE
#define LEGION_DEFAULT_MIN_TASKS_TO_SCHEDULE 32
#endif
#else
#ifndef LEGION_DEFAULT_MIN_TASKS_TO_SCHEDULE
#define LEGION_DEFAULT_MIN_TASKS_TO_SCHEDULE (DEFAULT_MIN_TASKS_TO_SCHEDULE)
#endif
#endif
// How many tasks to group together for runtime operations
#ifndef DEFAULT_META_TASK_VECTOR_WIDTH  // For backwards compatibility
#ifndef LEGION_DEFAULT_META_TASK_VECTOR_WIDTH
#define LEGION_DEFAULT_META_TASK_VECTOR_WIDTH 16
#endif
#else
#ifndef LEGION_DEFAULT_META_TASK_VECTOR_WIDTH
#define LEGION_DEFAULT_META_TASK_VECTOR_WIDTH (DEFAULT_META_TASK_VECTOR_WIDTH)
#endif
#endif
// Maximum number of templates to keep around in traces
#ifndef LEGION_DEFAULT_MAX_TEMPLATES_PER_TRACE
#define LEGION_DEFAULT_MAX_TEMPLATES_PER_TRACE 16
#endif
// Default number of replay tasks to run in parallel
#ifndef DEFAULT_MAX_REPLAY_PARALLELISM  // For backwards compatibility
#ifndef LEGION_DEFAULT_MAX_REPLAY_PARALLELISM
#define LEGION_DEFAULT_MAX_REPLAY_PARALLELISM 2
#endif
#else
#ifndef LEGION_DEFAULT_MAX_REPLAY_PARALLELISM
#define LEGION_DEFAULT_MAX_REPLAY_PARALLELISM (DEFAULT_MAX_REPLAY_PARALLELISM)
#endif
#endif
// The maximum size of active messages sent by the runtime in bytes
// Note this value was picked based on making a tradeoff between
// latency and bandwidth numbers on both Cray and Infiniband
// interconnect networks.
#ifndef DEFAULT_MAX_MESSAGE_SIZE  // For backwards compatibility
#ifndef LEGION_DEFAULT_MAX_MESSAGE_SIZE
#define LEGION_DEFAULT_MAX_MESSAGE_SIZE 16384
#endif
#else
#ifndef LEGION_DEFAULT_MAX_MESSAGE_SIZE
#define LEGION_DEFAULT_MAX_MESSAGE_SIZE (DEFAULT_MAX_MESSAGE_SIZE)
#endif
#endif
// Number of events to place in each GC epoch
// Large counts improve efficiency but add latency to
// garbage collection.  Smaller count reduce efficiency
// but improve latency of collection.
#ifndef DEFAULT_GC_EPOCH_SIZE  // For backwards compatibility
#ifndef LEGION_DEFAULT_GC_EPOCH_SIZE
#define LEGION_DEFAULT_GC_EPOCH_SIZE 64
#endif
#else
#ifndef LEGION_DEFAULT_GC_EPOCH_SIZE
#define LEGION_DEFAULT_GC_EPOCH_SIZE (DEFAULT_GC_EPOCH_SIZE)
#endif
#endif
// Number of control replications to be supported
#ifndef LEGION_DEFAULT_MAX_CONTROL_REPLICATION_CONTEXTS
#define LEGION_DEFAULT_MAX_CONTROL_REPLICATION_CONTEXTS 1
#endif
// Number of phase barriers for communication of
// close operation composite view meta data
#ifndef LEGION_CONTROL_REPLICATION_COMMUNICATION_BARRIERS
#define LEGION_CONTROL_REPLICATION_COMMUNICATION_BARRIERS 32
#endif

// Used for debugging memory leaks
// How often tracing information is dumped
// based on the number of scheduler invocations
#ifndef TRACE_ALLOCATION_FREQUENCY  // For backwards compatibility
#ifndef LEGION_TRACE_ALLOCATION_FREQUENCY
#define LEGION_TRACE_ALLOCATION_FREQUENCY 1024
#endif
#else
#ifndef LEGION_TRACE_ALLOCATION_FREQUENCY
#define LEGION_TRACE_ALLOCATION_FREQUENCY (TRACE_ALLOCATION_FREQUENCY)
#endif
#endif

// The maximum alignment guaranteed on the target
// machine in bytes.  On linux systems, this is
// (at least) twice the size of a pointer.
#ifndef LEGION_MAX_ALIGNMENT
#define LEGION_MAX_ALIGNMENT (2 * sizeof(void*))
#endif

// Give an ideal upper bound on the maximum
// number of operations Legion should keep
// available for recycling. Where possible
// the runtime will delete objects to keep
// overall memory usage down.
#ifndef LEGION_MAX_RECYCLABLE_OBJECTS
#define LEGION_MAX_RECYCLABLE_OBJECTS 1024
#endif

// An initial seed for random numbers
// generated by the high-level runtime.
#ifndef LEGION_INIT_SEED
#define LEGION_INIT_SEED 0x221B
#endif

// The radix for the runtime to use when
// performing collective operations internally
#ifndef LEGION_COLLECTIVE_RADIX
#define LEGION_COLLECTIVE_RADIX 8
#endif

// The radix for the broadcast tree
// when attempting to shutdown the runtime
#ifndef LEGION_SHUTDOWN_RADIX
#define LEGION_SHUTDOWN_RADIX 8
#endif

// Maximum number of equivalence subsets in the bounding volume hierarchy
#ifndef LEGION_MAX_BVH_FANOUT
#define LEGION_MAX_BVH_FANOUT 16
#endif

// Maximum number of non-replayable templates before warnings
#ifndef LEGION_NON_REPLAYABLE_WARNING
#define LEGION_NON_REPLAYABLE_WARNING 5
#endif

// Maximum number of new templates allowed
#ifndef LEGION_NEW_TEMPLATE_WARNING_COUNT
#define LEGION_NEW_TEMPLATE_WARNING_COUNT 8
#endif

// Initial offset for library IDs
// Controls how many IDs are available for dynamic use
#ifndef LEGION_INITIAL_LIBRARY_ID_OFFSET
#define LEGION_INITIAL_LIBRARY_ID_OFFSET (1 << 30)
#endif

// Default percentage of the number of children in a
// disjoint+complete partition that need to be accessed
// before we consider the whole partition as accessed
#ifndef LEGION_REFINEMENT_PARTITION_PERCENTAGE
#define LEGION_REFINEMENT_PARTITION_PERCENTAGE 50
#endif

// Some helper macros

// This statically computes an integer log base 2 for a number
// which is guaranteed to be a power of 2. Adapted from
// http://graphics.stanford.edu/~seander/bithacks.html#IntegerLogDeBruijn
#define STATIC_LOG2(x) (LOG2_LOOKUP(uint32_t(x * 0x077CB531U) >> 27))
#define LOG2_LOOKUP(x) \
  ((x == 0)  ? 0 :     \
   (x == 1)  ? 1 :     \
   (x == 2)  ? 28 :    \
   (x == 3)  ? 2 :     \
   (x == 4)  ? 29 :    \
   (x == 5)  ? 14 :    \
   (x == 6)  ? 24 :    \
   (x == 7)  ? 3 :     \
   (x == 8)  ? 30 :    \
   (x == 9)  ? 22 :    \
   (x == 10) ? 20 :    \
   (x == 11) ? 15 :    \
   (x == 12) ? 25 :    \
   (x == 13) ? 17 :    \
   (x == 14) ? 4 :     \
   (x == 15) ? 8 :     \
   (x == 16) ? 31 :    \
   (x == 17) ? 27 :    \
   (x == 18) ? 13 :    \
   (x == 19) ? 23 :    \
   (x == 20) ? 21 :    \
   (x == 21) ? 19 :    \
   (x == 22) ? 16 :    \
   (x == 23) ? 7 :     \
   (x == 24) ? 26 :    \
   (x == 25) ? 12 :    \
   (x == 26) ? 18 :    \
   (x == 27) ? 6 :     \
   (x == 28) ? 11 :    \
   (x == 29) ? 5 :     \
   (x == 30) ? 10 :    \
               9)

// log2(LEGION_MAX_FIELDS)
#ifndef LEGION_FIELD_LOG2
#define LEGION_FIELD_LOG2 STATIC_LOG2(LEGION_MAX_FIELDS)
#endif

#define LEGION_STRINGIFY(x) #x
#define LEGION_MACRO_TO_STRING(x) LEGION_STRINGIFY(x)

#define LEGION_DISTRIBUTED_ID_MASK 0x00FFFFFFFFFFFFFFULL
#define LEGION_DISTRIBUTED_ID_FILTER(x) ((x) & LEGION_DISTRIBUTED_ID_MASK)
#define LEGION_DISTRIBUTED_HELP_DECODE(x) ((x) >> 56)
#define LEGION_DISTRIBUTED_HELP_ENCODE(x, y) ((x) | (((long long)(y)) << 56))

// clang-format off
#if LEGION_MAX_DIM == 1

#define LEGION_FOREACH_N(__func__) \
  __func__(1)
#define LEGION_FOREACH_NN(__func__) \
  __func__(1,1)

#elif LEGION_MAX_DIM == 2

#define LEGION_FOREACH_N(__func__) \
  __func__(1) \
  __func__(2)
#define LEGION_FOREACH_NN(__func__) \
  __func__(1,1) \
  __func__(1,2) \
  __func__(2,1) \
  __func__(2,2)

#elif LEGION_MAX_DIM == 3

#define LEGION_FOREACH_N(__func__) \
  __func__(1) \
  __func__(2) \
  __func__(3)
#define LEGION_FOREACH_NN(__func__) \
  __func__(1,1) \
  __func__(1,2) \
  __func__(1,3) \
  __func__(2,1) \
  __func__(2,2) \
  __func__(2,3) \
  __func__(3,1) \
  __func__(3,2) \
  __func__(3,3)

#elif LEGION_MAX_DIM == 4

#define LEGION_FOREACH_N(__func__) \
  __func__(1) \
  __func__(2) \
  __func__(3) \
  __func__(4)
#define LEGION_FOREACH_NN(__func__) \
  __func__(1,1) \
  __func__(1,2) \
  __func__(1,3) \
  __func__(1,4) \
  __func__(2,1) \
  __func__(2,2) \
  __func__(2,3) \
  __func__(2,4) \
  __func__(3,1) \
  __func__(3,2) \
  __func__(3,3) \
  __func__(3,4) \
  __func__(4,1) \
  __func__(4,2) \
  __func__(4,3) \
  __func__(4,4)

#elif LEGION_MAX_DIM == 5

#define LEGION_FOREACH_N(__func__) \
  __func__(1) \
  __func__(2) \
  __func__(3) \
  __func__(4) \
  __func__(5)
#define LEGION_FOREACH_NN(__func__) \
  __func__(1,1) \
  __func__(1,2) \
  __func__(1,3) \
  __func__(1,4) \
  __func__(1,5) \
  __func__(2,1) \
  __func__(2,2) \
  __func__(2,3) \
  __func__(2,4) \
  __func__(2,5) \
  __func__(3,1) \
  __func__(3,2) \
  __func__(3,3) \
  __func__(3,4) \
  __func__(3,5) \
  __func__(4,1) \
  __func__(4,2) \
  __func__(4,3) \
  __func__(4,4) \
  __func__(4,5) \
  __func__(5,1) \
  __func__(5,2) \
  __func__(5,3) \
  __func__(5,4) \
  __func__(5,5)

#elif LEGION_MAX_DIM == 6

#define LEGION_FOREACH_N(__func__) \
  __func__(1) \
  __func__(2) \
  __func__(3) \
  __func__(4) \
  __func__(5) \
  __func__(6)
#define LEGION_FOREACH_NN(__func__) \
  __func__(1,1) \
  __func__(1,2) \
  __func__(1,3) \
  __func__(1,4) \
  __func__(1,5) \
  __func__(1,6) \
  __func__(2,1) \
  __func__(2,2) \
  __func__(2,3) \
  __func__(2,4) \
  __func__(2,5) \
  __func__(2,6) \
  __func__(3,1) \
  __func__(3,2) \
  __func__(3,3) \
  __func__(3,4) \
  __func__(3,5) \
  __func__(3,6) \
  __func__(4,1) \
  __func__(4,2) \
  __func__(4,3) \
  __func__(4,4) \
  __func__(4,5) \
  __func__(4,6) \
  __func__(5,1) \
  __func__(5,2) \
  __func__(5,3) \
  __func__(5,4) \
  __func__(5,5) \
  __func__(5,6) \
  __func__(6,1) \
  __func__(6,2) \
  __func__(6,3) \
  __func__(6,4) \
  __func__(6,5) \
  __func__(6,6)

#elif LEGION_MAX_DIM == 7

#define LEGION_FOREACH_N(__func__) \
  __func__(1) \
  __func__(2) \
  __func__(3) \
  __func__(4) \
  __func__(5) \
  __func__(6) \
  __func__(7)
#define LEGION_FOREACH_NN(__func__) \
  __func__(1,1) \
  __func__(1,2) \
  __func__(1,3) \
  __func__(1,4) \
  __func__(1,5) \
  __func__(1,6) \
  __func__(1,7) \
  __func__(2,1) \
  __func__(2,2) \
  __func__(2,3) \
  __func__(2,4) \
  __func__(2,5) \
  __func__(2,6) \
  __func__(2,7) \
  __func__(3,1) \
  __func__(3,2) \
  __func__(3,3) \
  __func__(3,4) \
  __func__(3,5) \
  __func__(3,6) \
  __func__(3,7) \
  __func__(4,1) \
  __func__(4,2) \
  __func__(4,3) \
  __func__(4,4) \
  __func__(4,5) \
  __func__(4,6) \
  __func__(4,7) \
  __func__(5,1) \
  __func__(5,2) \
  __func__(5,3) \
  __func__(5,4) \
  __func__(5,5) \
  __func__(5,6) \
  __func__(5,7) \
  __func__(6,1) \
  __func__(6,2) \
  __func__(6,3) \
  __func__(6,4) \
  __func__(6,5) \
  __func__(6,6) \
  __func__(6,7) \
  __func__(7,1) \
  __func__(7,2) \
  __func__(7,3) \
  __func__(7,4) \
  __func__(7,5) \
  __func__(7,6) \
  __func__(7,7)

#elif LEGION_MAX_DIM == 8

#define LEGION_FOREACH_N(__func__) \
  __func__(1) \
  __func__(2) \
  __func__(3) \
  __func__(4) \
  __func__(5) \
  __func__(6) \
  __func__(7) \
  __func__(8)
#define LEGION_FOREACH_NN(__func__) \
  __func__(1,1) \
  __func__(1,2) \
  __func__(1,3) \
  __func__(1,4) \
  __func__(1,5) \
  __func__(1,6) \
  __func__(1,7) \
  __func__(1,8) \
  __func__(2,1) \
  __func__(2,2) \
  __func__(2,3) \
  __func__(2,4) \
  __func__(2,5) \
  __func__(2,6) \
  __func__(2,7) \
  __func__(2,8) \
  __func__(3,1) \
  __func__(3,2) \
  __func__(3,3) \
  __func__(3,4) \
  __func__(3,5) \
  __func__(3,6) \
  __func__(3,7) \
  __func__(3,8) \
  __func__(4,1) \
  __func__(4,2) \
  __func__(4,3) \
  __func__(4,4) \
  __func__(4,5) \
  __func__(4,6) \
  __func__(4,7) \
  __func__(4,8) \
  __func__(5,1) \
  __func__(5,2) \
  __func__(5,3) \
  __func__(5,4) \
  __func__(5,5) \
  __func__(5,6) \
  __func__(5,7) \
  __func__(5,8) \
  __func__(6,1) \
  __func__(6,2) \
  __func__(6,3) \
  __func__(6,4) \
  __func__(6,5) \
  __func__(6,6) \
  __func__(6,7) \
  __func__(6,8) \
  __func__(7,1) \
  __func__(7,2) \
  __func__(7,3) \
  __func__(7,4) \
  __func__(7,5) \
  __func__(7,6) \
  __func__(7,7) \
  __func__(7,8) \
  __func__(8,1) \
  __func__(8,2) \
  __func__(8,3) \
  __func__(8,4) \
  __func__(8,5) \
  __func__(8,6) \
  __func__(8,7) \
  __func__(8,8)

#elif LEGION_MAX_DIM == 9

#define LEGION_FOREACH_N(__func__) \
  __func__(1) \
  __func__(2) \
  __func__(3) \
  __func__(4) \
  __func__(5) \
  __func__(6) \
  __func__(7) \
  __func__(8) \
  __func__(9)
#define LEGION_FOREACH_NN(__func__) \
  __func__(1,1) \
  __func__(1,2) \
  __func__(1,3) \
  __func__(1,4) \
  __func__(1,5) \
  __func__(1,6) \
  __func__(1,7) \
  __func__(1,8) \
  __func__(1,9) \
  __func__(2,1) \
  __func__(2,2) \
  __func__(2,3) \
  __func__(2,4) \
  __func__(2,5) \
  __func__(2,6) \
  __func__(2,7) \
  __func__(2,8) \
  __func__(2,9) \
  __func__(3,1) \
  __func__(3,2) \
  __func__(3,3) \
  __func__(3,4) \
  __func__(3,5) \
  __func__(3,6) \
  __func__(3,7) \
  __func__(3,8) \
  __func__(3,9) \
  __func__(4,1) \
  __func__(4,2) \
  __func__(4,3) \
  __func__(4,4) \
  __func__(4,5) \
  __func__(4,6) \
  __func__(4,7) \
  __func__(4,8) \
  __func__(4,9) \
  __func__(5,1) \
  __func__(5,2) \
  __func__(5,3) \
  __func__(5,4) \
  __func__(5,5) \
  __func__(5,6) \
  __func__(5,7) \
  __func__(5,8) \
  __func__(5,9) \
  __func__(6,1) \
  __func__(6,2) \
  __func__(6,3) \
  __func__(6,4) \
  __func__(6,5) \
  __func__(6,6) \
  __func__(6,7) \
  __func__(6,8) \
  __func__(6,9) \
  __func__(7,1) \
  __func__(7,2) \
  __func__(7,3) \
  __func__(7,4) \
  __func__(7,5) \
  __func__(7,6) \
  __func__(7,7) \
  __func__(7,8) \
  __func__(7,9) \
  __func__(8,1) \
  __func__(8,2) \
  __func__(8,3) \
  __func__(8,4) \
  __func__(8,5) \
  __func__(8,6) \
  __func__(8,7) \
  __func__(8,8) \
  __func__(8,9) \
  __func__(9,1) \
  __func__(9,2) \
  __func__(9,3) \
  __func__(9,4) \
  __func__(9,5) \
  __func__(9,6) \
  __func__(9,7) \
  __func__(9,8) \
  __func__(9,9)

#else
#error "Unsupported LEGION_MAX_DIM"
#endif
// clang-format on

#ifdef LEGION_DISABLE_DEPRECATED_ENUMS
#define LEGION_DEPRECATED_ENUM(x)
#define LEGION_DEPRECATED_ENUM_REAL(x)
#define LEGION_DEPRECATED_ENUM_FROM(x, y)
#elif defined(LEGION_WARN_DEPRECATED_ENUMS)
#if defined(__cplusplus) && __cplusplus >= 201402L
// c++14 and higher has nice deprecated warnings
#define LEGION_DEPRECATED_ENUM(x) \
  x [[deprecated("use LEGION_" #x " instead")]] = LEGION_##x,
#define LEGION_DEPRECATED_ENUM_REAL(x) \
  x [[deprecated(#x " is no longer supported")]],
#define LEGION_DEPRECATED_ENUM_FROM(x, y) \
  x [[deprecated("use " #y " instead")]] = y,
#else
// C and older versions of c++
#define LEGION_DEPRECATED_ENUM(x) \
  x __attribute__((deprecated("use LEGION_" #x " instead"))) = LEGION_##x,
#define LEGION_DEPRECATED_ENUM_REAL(x) \
  x __attribute__((deprecated(#x " is no longer supported")))
#define LEGION_DEPRECATED_ENUM_FROM(x, y) \
  x __attribute__((deprecated("use " #y " instead"))) = y,
#endif
#else
#define LEGION_DEPRECATED_ENUM(x) x = LEGION_##x,
#define LEGION_DEPRECATED_ENUM_REAL(x) x,
#define LEGION_DEPRECATED_ENUM_FROM(x, y) x = y,
#endif

#ifdef __cplusplus
#include <cstdint>
#endif

// enum and namepsaces don't really get along well
// We would like to make these associations explicit
// but the python cffi parser is stupid as hell
typedef enum legion_privilege_mode_t
#ifdef __cplusplus
  : std::uint32_t
#endif
{
  LEGION_NO_ACCESS = 0x00000000,
  LEGION_READ_PRIV = 0x00000001,
  LEGION_READ_ONLY = 0x00000001,  // READ_PRIV,
  LEGION_WRITE_PRIV = 0x00000002,
  LEGION_REDUCE_PRIV = 0x00000004,
  LEGION_REDUCE = 0x00000004,        // REDUCE_PRIV,
  LEGION_READ_WRITE = 0x00000007,    // READ_PRIV | WRITE_PRIV | REDUCE_PRIV,
  LEGION_DISCARD_MASK = 0x10000000,  // For marking we don't need inputs
  LEGION_DISCARD_INPUT_MASK = 0x10000000,   // Rename of the old discard mask
  LEGION_DISCARD_OUTPUT_MASK = 0x20000000,  // For marking we don't need outputs
  LEGION_WRITE_ONLY = 0x10000002,           // WRITE_PRIV | DISCARD_INPUT_MASK
  LEGION_WRITE_DISCARD = 0x10000007,        // READ_WRITE | DISCARD_INPUT_MASK
  LEGION_READ_DISCARD = 0x20000001,         // READ_PRIV | DISCARD_OUTPUT_MASK
  // for backwards compatibility
  // clang-format off
  LEGION_DEPRECATED_ENUM(NO_ACCESS)
  LEGION_DEPRECATED_ENUM(READ_PRIV)
  LEGION_DEPRECATED_ENUM(READ_ONLY)
  LEGION_DEPRECATED_ENUM(WRITE_PRIV)
  LEGION_DEPRECATED_ENUM(REDUCE_PRIV)
  LEGION_DEPRECATED_ENUM(REDUCE)
  LEGION_DEPRECATED_ENUM(READ_WRITE)
  LEGION_DEPRECATED_ENUM(DISCARD_MASK)
  LEGION_DEPRECATED_ENUM(WRITE_ONLY)
  LEGION_DEPRECATED_ENUM(WRITE_DISCARD)
  // clang-format on
} legion_privilege_mode_t;

#ifdef __cplusplus
static_assert(sizeof(legion_privilege_mode_t) == sizeof(unsigned));
#endif

typedef enum legion_allocate_mode_t {
  LEGION_NO_MEMORY = 0x00000000,
  LEGION_ALLOCABLE = 0x00000001,
  LEGION_FREEABLE = 0x00000002,
  LEGION_MUTABLE = 0x00000003,
  LEGION_REGION_CREATION = 0x00000004,
  LEGION_REGION_DELETION = 0x00000008,
  LEGION_ALL_MEMORY = 0x0000000F,
  // for backwards compatibility
  // clang-format off
  LEGION_DEPRECATED_ENUM(NO_MEMORY)
  LEGION_DEPRECATED_ENUM(ALLOCABLE)
  LEGION_DEPRECATED_ENUM(FREEABLE)
  LEGION_DEPRECATED_ENUM(MUTABLE)
  LEGION_DEPRECATED_ENUM(REGION_CREATION)
  LEGION_DEPRECATED_ENUM(REGION_DELETION)
  LEGION_DEPRECATED_ENUM(ALL_MEMORY)
  // clang-format on
} legion_allocate_mode_t;

typedef enum legion_coherence_property_t {
  LEGION_EXCLUSIVE = 0x00000000,
  LEGION_ATOMIC = 0x00000001,
  LEGION_SIMULTANEOUS = 0x00000002,
  LEGION_RELAXED = 0x00000003,
  LEGION_COLLECTIVE_MASK = 0x10000000,
  // Can't make these associations explicit because the Python CFFI parser is
  // stupid
  LEGION_COLLECTIVE_EXCLUSIVE =
      0x10000000,  // LEGION_EXCLUSIVE | LEGION_COLLECTIVE_MASK,
  LEGION_COLLECTIVE_ATOMIC =
      0x10000001,  // LEGION_ATOMIC | LEGION_COLLECTIVE_MASK,
  LEGION_COLLECTIVE_SIMULTANEOUS =
      0x10000002,  // LEGION_SIMULTANEOUS | LEGION_COLLECTIVE_MASK,
  LEGION_COLLECTIVE_RELAXED =
      0x10000003,  // LEGION_RELAXED | LEGION_COLLECTIVE_MASK,
  // for backwards compatibility
  // clang-format off
  LEGION_DEPRECATED_ENUM(EXCLUSIVE)
  LEGION_DEPRECATED_ENUM(ATOMIC)
  LEGION_DEPRECATED_ENUM(SIMULTANEOUS)
  LEGION_DEPRECATED_ENUM(RELAXED)
  // clang-format on
} legion_coherence_property_t;

// Optional region requirement flags
typedef enum legion_region_flags_t {
  LEGION_NO_FLAG = 0x00000000,
  LEGION_VERIFIED_FLAG = 0x00000001,
  LEGION_NO_ACCESS_FLAG = 0x00000002,  // Deprecated, user SpecializedConstraint
  LEGION_RESTRICTED_FLAG = 0x00000004,
  LEGION_MUST_PREMAP_FLAG = 0x00000008,  // Deprecated, no longer used
  // For non-trivial projection functions:
  // tell the runtime the write is complete,
  // will be ignored for non-index space launches
  // and for privileges that aren't WRITE
  // Note that if you use this incorrectly it could
  // break the correctness of your code so be sure
  // you know what you are doing
  LEGION_COMPLETE_PROJECTION_WRITE_FLAG = 0x00000010,
  // for indicating created output region requirements
  LEGION_CREATED_OUTPUT_REQUIREMENT_FLAG = 0x00000020,
  // Suppress warnings on this region requirement
  LEGION_SUPPRESS_WARNINGS_FLAG = 0x00000040,
  // for backwards compatibility
  // clang-format off
  LEGION_DEPRECATED_ENUM(NO_FLAG)
  LEGION_DEPRECATED_ENUM(VERIFIED_FLAG)
  LEGION_DEPRECATED_ENUM(NO_ACCESS_FLAG)
  LEGION_DEPRECATED_ENUM(RESTRICTED_FLAG)
  LEGION_DEPRECATED_ENUM(MUST_PREMAP_FLAG)
  LEGION_DEPRECATED_ENUM(COMPLETE_PROJECTION_WRITE_FLAG)
  // clang-format on
} legion_region_flags_t;

typedef enum legion_projection_type_t {
  LEGION_SINGULAR_PROJECTION,   // a single logical region
  LEGION_PARTITION_PROJECTION,  // projection from a partition
  LEGION_REGION_PROJECTION,     // projection from a region
  // for backwards compatibility
  // clang-format off
  LEGION_DEPRECATED_ENUM_FROM(SINGULAR, LEGION_SINGULAR_PROJECTION)
  LEGION_DEPRECATED_ENUM_FROM(PART_PROJECTION, LEGION_PARTITION_PROJECTION)
  LEGION_DEPRECATED_ENUM_FROM(REG_PROJECTION, LEGION_REGION_PROJECTION)
  // clang-format on
} legion_projection_type_t;
// For backwards compatibility
typedef legion_projection_type_t legion_handle_type_t;

typedef enum legion_partition_kind_t {
  LEGION_DISJOINT_KIND,             // disjoint and unknown
  LEGION_ALIASED_KIND,              // aliased and unknown
  LEGION_COMPUTE_KIND,              // unknown and unknown
  LEGION_DISJOINT_COMPLETE_KIND,    // disjoint and complete
  LEGION_ALIASED_COMPLETE_KIND,     // aliased and complete
  LEGION_COMPUTE_COMPLETE_KIND,     // unknown and complete
  LEGION_DISJOINT_INCOMPLETE_KIND,  // disjoint and incomplete
  LEGION_ALIASED_INCOMPLETE_KIND,   // aliased and incomplete
  LEGION_COMPUTE_INCOMPLETE_KIND,   // unknown and incomplete
  // for backwards compatibility
  // clang-format off
  LEGION_DEPRECATED_ENUM(DISJOINT_KIND)
  LEGION_DEPRECATED_ENUM(ALIASED_KIND)
  LEGION_DEPRECATED_ENUM(COMPUTE_KIND)
  LEGION_DEPRECATED_ENUM(DISJOINT_COMPLETE_KIND)
  LEGION_DEPRECATED_ENUM(ALIASED_COMPLETE_KIND)
  LEGION_DEPRECATED_ENUM(COMPUTE_COMPLETE_KIND)
  LEGION_DEPRECATED_ENUM(DISJOINT_INCOMPLETE_KIND)
  LEGION_DEPRECATED_ENUM(ALIASED_INCOMPLETE_KIND)
  LEGION_DEPRECATED_ENUM(COMPUTE_INCOMPLETE_KIND)
  // clang-format on
} legion_partition_kind_t;

typedef enum legion_external_resource_t {
  LEGION_EXTERNAL_POSIX_FILE,
  LEGION_EXTERNAL_HDF5_FILE,
  LEGION_EXTERNAL_INSTANCE,
  // for backwards compatibility
  // clang-format off
  LEGION_DEPRECATED_ENUM(EXTERNAL_POSIX_FILE)
  LEGION_DEPRECATED_ENUM(EXTERNAL_HDF5_FILE)
  LEGION_DEPRECATED_ENUM(EXTERNAL_INSTANCE)
  // clang-format on
} legion_external_resource_t;

typedef enum legion_timing_measurement_t {
  LEGION_MEASURE_SECONDS,
  LEGION_MEASURE_MICRO_SECONDS,
  LEGION_MEASURE_NANO_SECONDS,
  // for backwards compatibility
  // clang-format off
  LEGION_DEPRECATED_ENUM(MEASURE_SECONDS)
  LEGION_DEPRECATED_ENUM(MEASURE_MICRO_SECONDS)
  LEGION_DEPRECATED_ENUM(MEASURE_NANO_SECONDS)
  // clang-format on
} legion_timing_measurement_t;

typedef enum legion_dependence_type_t {
  LEGION_NO_DEPENDENCE = 0,
  LEGION_TRUE_DEPENDENCE = 1,
  LEGION_ANTI_DEPENDENCE = 2,  // WAR or WAW with Write-Only privilege
  LEGION_ATOMIC_DEPENDENCE = 3,
  LEGION_SIMULTANEOUS_DEPENDENCE = 4,
  // for backwards compatibility
  // clang-format off
  LEGION_DEPRECATED_ENUM(NO_DEPENDENCE)
  LEGION_DEPRECATED_ENUM(TRUE_DEPENDENCE)
  LEGION_DEPRECATED_ENUM(ANTI_DEPENDENCE)
  LEGION_DEPRECATED_ENUM(ATOMIC_DEPENDENCE)
  LEGION_DEPRECATED_ENUM(SIMULTANEOUS_DEPENDENCE)
  // clang-format on
} legion_dependence_type_t;

enum {
  LEGION_NAME_SEMANTIC_TAG = 0,
  LEGION_SOURCE_FILE_TAG = 1,
  LEGION_SOURCE_LINE_TAG = 2,
  LEGION_FIRST_AVAILABLE_SEMANTIC_TAG = 3,
  // for backwards compatibility
  // clang-format off
  LEGION_DEPRECATED_ENUM(NAME_SEMANTIC_TAG)
  LEGION_DEPRECATED_ENUM(SOURCE_FILE_TAG)
  LEGION_DEPRECATED_ENUM(SOURCE_LINE_TAG)
  LEGION_DEPRECATED_ENUM(FIRST_AVAILABLE_SEMANTIC_TAG)
  // clang-format on
};

typedef enum legion_mappable_type_id_t {
  LEGION_TASK_MAPPABLE = 0,
  LEGION_COPY_MAPPABLE = 1,
  LEGION_INLINE_MAPPABLE = 2,
  LEGION_ACQUIRE_MAPPABLE = 3,
  LEGION_RELEASE_MAPPABLE = 4,
  LEGION_CLOSE_MAPPABLE = 5,
  LEGION_FILL_MAPPABLE = 6,
  LEGION_PARTITION_MAPPABLE = 7,
  LEGION_MUST_EPOCH_MAPPABLE = 9,
  // for backwards compatibility
  // clang-format off
  LEGION_DEPRECATED_ENUM(TASK_MAPPABLE)
  LEGION_DEPRECATED_ENUM(COPY_MAPPABLE)
  LEGION_DEPRECATED_ENUM(INLINE_MAPPABLE)
  LEGION_DEPRECATED_ENUM(ACQUIRE_MAPPABLE)
  LEGION_DEPRECATED_ENUM(RELEASE_MAPPABLE)
  LEGION_DEPRECATED_ENUM(CLOSE_MAPPABLE)
  LEGION_DEPRECATED_ENUM(FILL_MAPPABLE)
  LEGION_DEPRECATED_ENUM(PARTITION_MAPPABLE)
  LEGION_DEPRECATED_ENUM(MUST_EPOCH_MAPPABLE)
  // clang-format on
} legion_mappable_type_id;

typedef enum legion_type_id_t {
  LEGION_TYPE_BOOL = 0,
  LEGION_TYPE_INT8 = 1,
  LEGION_TYPE_INT16 = 2,
  LEGION_TYPE_INT32 = 3,
  LEGION_TYPE_INT64 = 4,
  LEGION_TYPE_UINT8 = 5,
  LEGION_TYPE_UINT16 = 6,
  LEGION_TYPE_UINT32 = 7,
  LEGION_TYPE_UINT64 = 8,
  LEGION_TYPE_FLOAT16 = 9,
  LEGION_TYPE_FLOAT32 = 10,
  LEGION_TYPE_FLOAT64 = 11,
  LEGION_TYPE_COMPLEX32 = 12,
  LEGION_TYPE_COMPLEX64 = 13,
  LEGION_TYPE_COMPLEX128 = 14,
  LEGION_TYPE_TOTAL = 15,  // must be last
} legion_type_id_t;

// Do it like this because the Python CFFI parser is stupid
#define LEGION_REDOP_KIND_SUM_VALUE 0
#define LEGION_REDOP_KIND_DIFF_VALUE 1
#define LEGION_REDOP_KIND_PROD_VALUE 2
#define LEGION_REDOP_KIND_DIV_VALUE 3
#define LEGION_REDOP_KIND_MAX_VALUE 4
#define LEGION_REDOP_KIND_MIN_VALUE 5
#define LEGION_REDOP_KIND_OR_VALUE 6
#define LEGION_REDOP_KIND_AND_VALUE 7
#define LEGION_REDOP_KIND_XOR_VALUE 8
#define LEGION_REDOP_KIND_TOTAL_VALUE 9
// Don't forget to undef after the legion_builtin_redop_t enum

typedef enum legion_redop_kind_t {
  LEGION_REDOP_KIND_SUM = LEGION_REDOP_KIND_SUM_VALUE,
  LEGION_REDOP_KIND_DIFF = LEGION_REDOP_KIND_DIFF_VALUE,
  LEGION_REDOP_KIND_PROD = LEGION_REDOP_KIND_PROD_VALUE,
  LEGION_REDOP_KIND_DIV = LEGION_REDOP_KIND_DIV_VALUE,
  LEGION_REDOP_KIND_MAX = LEGION_REDOP_KIND_MAX_VALUE,
  LEGION_REDOP_KIND_MIN = LEGION_REDOP_KIND_MIN_VALUE,
  LEGION_REDOP_KIND_OR = LEGION_REDOP_KIND_OR_VALUE,
  LEGION_REDOP_KIND_AND = LEGION_REDOP_KIND_AND_VALUE,
  LEGION_REDOP_KIND_XOR = LEGION_REDOP_KIND_XOR_VALUE,
  LEGION_REDOP_KIND_TOTAL = LEGION_REDOP_KIND_TOTAL_VALUE,
} legion_redop_kind_t;

#ifndef LEGION_USE_PYTHON_CFFI
// Normal way of doing things for sane compilers
#define LEGION_REDOP_VALUE(kind, type)                        \
  (LEGION_REDOP_BASE +                                        \
   ((int)LEGION_REDOP_KIND_##kind * (int)LEGION_TYPE_TOTAL) + \
   (int)LEGION_TYPE_##type)
#else
// Dumb stuff for the Python CFFI parser which can't multiply
// so we'll do it the old-school way for them from a time
// before multiplication existed and all we had was addition
#define MULTIPLY0(x) 0
#define MULTIPLY1(x) (x)
#define MULTIPLY2(x) (x) + (x)
#define MULTIPLY3(x) (x) + MULTIPLY2(x)
#define MULTIPLY4(x) (x) + MULTIPLY3(x)
#define MULTIPLY5(x) (x) + MULTIPLY4(x)
#define MULTIPLY6(x) (x) + MULTIPLY5(x)
#define MULTIPLY7(x) (x) + MULTIPLY6(x)
#define MULTIPLY8(x) (x) + MULTIPLY7(x)
#define MULTIPLY9(x) (x) + MULTIPLY8(x)

#define MULTIPLY_(x, y) MULTIPLY##x(y)
#define MULTIPLY(x, y) MULTIPLY_(x, y)

#define LEGION_REDOP_VALUE(kind, type)                                \
  LEGION_REDOP_BASE +                                                 \
      MULTIPLY(LEGION_REDOP_KIND_##kind##_VALUE, LEGION_TYPE_TOTAL) + \
      LEGION_TYPE_##type
#endif
typedef enum legion_builtin_redop_t {
  // LEGION_MAX_APPLICATION_REDOP_ID has been claimed by BarrierArrivalReduction
  LEGION_REDOP_BASE = LEGION_MAX_APPLICATION_REDOP_ID + 1,
  ////////////////////////////////////////
  // Sum reductions
  ////////////////////////////////////////
  LEGION_REDOP_OR_BOOL = LEGION_REDOP_VALUE(SUM, BOOL),
  LEGION_REDOP_SUM_INT8 = LEGION_REDOP_VALUE(SUM, INT8),
  LEGION_REDOP_SUM_INT16 = LEGION_REDOP_VALUE(SUM, INT16),
  LEGION_REDOP_SUM_INT32 = LEGION_REDOP_VALUE(SUM, INT32),
  LEGION_REDOP_SUM_INT64 = LEGION_REDOP_VALUE(SUM, INT64),
  LEGION_REDOP_SUM_UINT8 = LEGION_REDOP_VALUE(SUM, UINT8),
  LEGION_REDOP_SUM_UINT16 = LEGION_REDOP_VALUE(SUM, UINT16),
  LEGION_REDOP_SUM_UINT32 = LEGION_REDOP_VALUE(SUM, UINT32),
  LEGION_REDOP_SUM_UINT64 = LEGION_REDOP_VALUE(SUM, UINT64),
#ifdef LEGION_REDOP_HALF
  LEGION_REDOP_SUM_FLOAT16 = LEGION_REDOP_VALUE(SUM, FLOAT16),
#endif
  LEGION_REDOP_SUM_FLOAT32 = LEGION_REDOP_VALUE(SUM, FLOAT32),
  LEGION_REDOP_SUM_FLOAT64 = LEGION_REDOP_VALUE(SUM, FLOAT64),
#ifdef LEGION_REDOP_COMPLEX
#ifdef LEGION_REDOP_HALF
  LEGION_REDOP_SUM_COMPLEX32 = LEGION_REDOP_VALUE(SUM, COMPLEX32),
#endif
  LEGION_REDOP_SUM_COMPLEX64 = LEGION_REDOP_VALUE(SUM, COMPLEX64),
  LEGION_REDOP_SUM_COMPLEX128 = LEGION_REDOP_VALUE(SUM, COMPLEX128),
#endif
  ////////////////////////////////////////
  // Difference reductions
  ////////////////////////////////////////
  // No difference for bools
  LEGION_REDOP_DIFF_INT8 = LEGION_REDOP_VALUE(DIFF, INT8),
  LEGION_REDOP_DIFF_INT16 = LEGION_REDOP_VALUE(DIFF, INT16),
  LEGION_REDOP_DIFF_INT32 = LEGION_REDOP_VALUE(DIFF, INT32),
  LEGION_REDOP_DIFF_INT64 = LEGION_REDOP_VALUE(DIFF, INT64),
  LEGION_REDOP_DIFF_UINT8 = LEGION_REDOP_VALUE(DIFF, UINT8),
  LEGION_REDOP_DIFF_UINT16 = LEGION_REDOP_VALUE(DIFF, UINT16),
  LEGION_REDOP_DIFF_UINT32 = LEGION_REDOP_VALUE(DIFF, UINT32),
  LEGION_REDOP_DIFF_UINT64 = LEGION_REDOP_VALUE(DIFF, UINT64),
#ifdef LEGION_REDOP_HALF
  LEGION_REDOP_DIFF_FLOAT16 = LEGION_REDOP_VALUE(DIFF, FLOAT16),
#endif
  LEGION_REDOP_DIFF_FLOAT32 = LEGION_REDOP_VALUE(DIFF, FLOAT32),
  LEGION_REDOP_DIFF_FLOAT64 = LEGION_REDOP_VALUE(DIFF, FLOAT64),
#ifdef LEGION_REDOP_COMPLEX
#ifdef LEGION_REDOP_HALF
  LEGION_REDOP_DIFF_COMPLEX32 = LEGION_REDOP_VALUE(DIFF, COMPLEX32),
#endif
  LEGION_REDOP_DIFF_COMPLEX64 = LEGION_REDOP_VALUE(DIFF, COMPLEX64),
  // TODO: LEGION_REDOP_DIFF_COMPLEX128,
#endif
  ////////////////////////////////////////
  // Product reductions
  ////////////////////////////////////////
  LEGION_REDOP_AND_BOOL = LEGION_REDOP_VALUE(PROD, BOOL),
  LEGION_REDOP_PROD_INT8 = LEGION_REDOP_VALUE(PROD, INT8),
  LEGION_REDOP_PROD_INT16 = LEGION_REDOP_VALUE(PROD, INT16),
  LEGION_REDOP_PROD_INT32 = LEGION_REDOP_VALUE(PROD, INT32),
  LEGION_REDOP_PROD_INT64 = LEGION_REDOP_VALUE(PROD, INT64),
  LEGION_REDOP_PROD_UINT8 = LEGION_REDOP_VALUE(PROD, UINT8),
  LEGION_REDOP_PROD_UINT16 = LEGION_REDOP_VALUE(PROD, UINT16),
  LEGION_REDOP_PROD_UINT32 = LEGION_REDOP_VALUE(PROD, UINT32),
  LEGION_REDOP_PROD_UINT64 = LEGION_REDOP_VALUE(PROD, UINT64),
#ifdef LEGION_REDOP_HALF
  LEGION_REDOP_PROD_FLOAT16 = LEGION_REDOP_VALUE(PROD, FLOAT16),
#endif
  LEGION_REDOP_PROD_FLOAT32 = LEGION_REDOP_VALUE(PROD, FLOAT32),
  LEGION_REDOP_PROD_FLOAT64 = LEGION_REDOP_VALUE(PROD, FLOAT64),
#ifdef LEGION_REDOP_COMPLEX
#ifdef LEGION_REDOP_HALF
  LEGION_REDOP_PROD_COMPLEX32 = LEGION_REDOP_VALUE(PROD, COMPLEX32),
#endif
  LEGION_REDOP_PROD_COMPLEX64 = LEGION_REDOP_VALUE(PROD, COMPLEX64),
  // TODO: LEGION_REDOP_PROD_COMPLEX128,
#endif
  ////////////////////////////////////////
  // Division reductions
  ////////////////////////////////////////
  // No division for bools
  LEGION_REDOP_DIV_INT8 = LEGION_REDOP_VALUE(DIV, INT8),
  LEGION_REDOP_DIV_INT16 = LEGION_REDOP_VALUE(DIV, INT16),
  LEGION_REDOP_DIV_INT32 = LEGION_REDOP_VALUE(DIV, INT32),
  LEGION_REDOP_DIV_INT64 = LEGION_REDOP_VALUE(DIV, INT64),
  LEGION_REDOP_DIV_UINT8 = LEGION_REDOP_VALUE(DIV, UINT8),
  LEGION_REDOP_DIV_UINT16 = LEGION_REDOP_VALUE(DIV, UINT16),
  LEGION_REDOP_DIV_UINT32 = LEGION_REDOP_VALUE(DIV, UINT32),
  LEGION_REDOP_DIV_UINT64 = LEGION_REDOP_VALUE(DIV, UINT64),
#ifdef LEGION_REDOP_HALF
  LEGION_REDOP_DIV_FLOAT16 = LEGION_REDOP_VALUE(DIV, FLOAT16),
#endif
  LEGION_REDOP_DIV_FLOAT32 = LEGION_REDOP_VALUE(DIV, FLOAT32),
  LEGION_REDOP_DIV_FLOAT64 = LEGION_REDOP_VALUE(DIV, FLOAT64),
#ifdef LEGION_REDOP_COMPLEX
#ifdef LEGION_REDOP_HALF
  LEGION_REDOP_DIV_COMPLEX32 = LEGION_REDOP_VALUE(DIV, COMPLEX32),
#endif
  LEGION_REDOP_DIV_COMPLEX64 = LEGION_REDOP_VALUE(DIV, COMPLEX64),
  // TODO: LEGION_REDOP_DIV_COMPLEX128,
#endif
  ////////////////////////////////////////
  // Max reductions
  ////////////////////////////////////////
  LEGION_REDOP_MAX_BOOL = LEGION_REDOP_VALUE(MAX, BOOL),
  LEGION_REDOP_MAX_INT8 = LEGION_REDOP_VALUE(MAX, INT8),
  LEGION_REDOP_MAX_INT16 = LEGION_REDOP_VALUE(MAX, INT16),
  LEGION_REDOP_MAX_INT32 = LEGION_REDOP_VALUE(MAX, INT32),
  LEGION_REDOP_MAX_INT64 = LEGION_REDOP_VALUE(MAX, INT64),
  LEGION_REDOP_MAX_UINT8 = LEGION_REDOP_VALUE(MAX, UINT8),
  LEGION_REDOP_MAX_UINT16 = LEGION_REDOP_VALUE(MAX, UINT16),
  LEGION_REDOP_MAX_UINT32 = LEGION_REDOP_VALUE(MAX, UINT32),
  LEGION_REDOP_MAX_UINT64 = LEGION_REDOP_VALUE(MAX, UINT64),
#ifdef LEGION_REDOP_HALF
  LEGION_REDOP_MAX_FLOAT16 = LEGION_REDOP_VALUE(MAX, FLOAT16),
#endif
  LEGION_REDOP_MAX_FLOAT32 = LEGION_REDOP_VALUE(MAX, FLOAT32),
  LEGION_REDOP_MAX_FLOAT64 = LEGION_REDOP_VALUE(MAX, FLOAT64),
#ifdef LEGION_REDOP_COMPLEX
#ifdef LEGION_REDOP_HALF
  LEGION_REDOP_MAX_COMPLEX32 = LEGION_REDOP_VALUE(MAX, COMPLEX32),
#endif
  LEGION_REDOP_MAX_COMPLEX64 = LEGION_REDOP_VALUE(MAX, COMPLEX64),
  // TODO: LEGION_REDOP_MAX_COMPLEX128,
#endif
  ////////////////////////////////////////
  // Min reductions
  ////////////////////////////////////////
  LEGION_REDOP_MIN_BOOL = LEGION_REDOP_VALUE(MIN, BOOL),
  LEGION_REDOP_MIN_INT8 = LEGION_REDOP_VALUE(MIN, INT8),
  LEGION_REDOP_MIN_INT16 = LEGION_REDOP_VALUE(MIN, INT16),
  LEGION_REDOP_MIN_INT32 = LEGION_REDOP_VALUE(MIN, INT32),
  LEGION_REDOP_MIN_INT64 = LEGION_REDOP_VALUE(MIN, INT64),
  LEGION_REDOP_MIN_UINT8 = LEGION_REDOP_VALUE(MIN, UINT8),
  LEGION_REDOP_MIN_UINT16 = LEGION_REDOP_VALUE(MIN, UINT16),
  LEGION_REDOP_MIN_UINT32 = LEGION_REDOP_VALUE(MIN, UINT32),
  LEGION_REDOP_MIN_UINT64 = LEGION_REDOP_VALUE(MIN, UINT64),
#ifdef LEGION_REDOP_HALF
  LEGION_REDOP_MIN_FLOAT16 = LEGION_REDOP_VALUE(MIN, FLOAT16),
#endif
  LEGION_REDOP_MIN_FLOAT32 = LEGION_REDOP_VALUE(MIN, FLOAT32),
  LEGION_REDOP_MIN_FLOAT64 = LEGION_REDOP_VALUE(MIN, FLOAT64),
#ifdef LEGION_REDOP_COMPLEX
#ifdef LEGION_REDOP_HALF
  LEGION_REDOP_MIN_COMPLEX32 = LEGION_REDOP_VALUE(MIN, COMPLEX32),
#endif
  LEGION_REDOP_MIN_COMPLEX64 = LEGION_REDOP_VALUE(MIN, COMPLEX64),
  // TODO: LEGION_REDOP_MIN_COMPLEX128
#endif
  ////////////////////////////////////////
  // Bitwise-OR reductions
  ////////////////////////////////////////
  LEGION_REDOP_OR_INT8 = LEGION_REDOP_VALUE(OR, INT8),
  LEGION_REDOP_OR_INT16 = LEGION_REDOP_VALUE(OR, INT16),
  LEGION_REDOP_OR_INT32 = LEGION_REDOP_VALUE(OR, INT32),
  LEGION_REDOP_OR_INT64 = LEGION_REDOP_VALUE(OR, INT64),
  LEGION_REDOP_OR_UINT8 = LEGION_REDOP_VALUE(OR, UINT8),
  LEGION_REDOP_OR_UINT16 = LEGION_REDOP_VALUE(OR, UINT16),
  LEGION_REDOP_OR_UINT32 = LEGION_REDOP_VALUE(OR, UINT32),
  LEGION_REDOP_OR_UINT64 = LEGION_REDOP_VALUE(OR, UINT64),
  // No bitwise-or for float or complex types
  ////////////////////////////////////////
  // Bitwise-AND reductions
  ////////////////////////////////////////
  LEGION_REDOP_AND_INT8 = LEGION_REDOP_VALUE(AND, INT8),
  LEGION_REDOP_AND_INT16 = LEGION_REDOP_VALUE(AND, INT16),
  LEGION_REDOP_AND_INT32 = LEGION_REDOP_VALUE(AND, INT32),
  LEGION_REDOP_AND_INT64 = LEGION_REDOP_VALUE(AND, INT64),
  LEGION_REDOP_AND_UINT8 = LEGION_REDOP_VALUE(AND, UINT8),
  LEGION_REDOP_AND_UINT16 = LEGION_REDOP_VALUE(AND, UINT16),
  LEGION_REDOP_AND_UINT32 = LEGION_REDOP_VALUE(AND, UINT32),
  LEGION_REDOP_AND_UINT64 = LEGION_REDOP_VALUE(AND, UINT64),
  // No bitwise-and for float or complex types
  ////////////////////////////////////////
  // Bitwise-XOR reductions
  ////////////////////////////////////////
  LEGION_REDOP_XOR_BOOL = LEGION_REDOP_VALUE(XOR, BOOL),
  LEGION_REDOP_XOR_INT8 = LEGION_REDOP_VALUE(XOR, INT8),
  LEGION_REDOP_XOR_INT16 = LEGION_REDOP_VALUE(XOR, INT16),
  LEGION_REDOP_XOR_INT32 = LEGION_REDOP_VALUE(XOR, INT32),
  LEGION_REDOP_XOR_INT64 = LEGION_REDOP_VALUE(XOR, INT64),
  LEGION_REDOP_XOR_UINT8 = LEGION_REDOP_VALUE(XOR, UINT8),
  LEGION_REDOP_XOR_UINT16 = LEGION_REDOP_VALUE(XOR, UINT16),
  LEGION_REDOP_XOR_UINT32 = LEGION_REDOP_VALUE(XOR, UINT32),
  LEGION_REDOP_XOR_UINT64 = LEGION_REDOP_VALUE(XOR, UINT64),
  // No bitwise-xor for float or complex types
  LEGION_REDOP_LAST,
} legion_builtin_redop_t;

#undef LEGION_REDOP_KIND_SUM_VALUE
#undef LEGION_REDOP_KIND_DIFF_VALUE
#undef LEGION_REDOP_KIND_PROD_VALUE
#undef LEGION_REDOP_KIND_DIV_VALUE
#undef LEGION_REDOP_KIND_MAX_VALUE
#undef LEGION_REDOP_KIND_MIN_VALUE
#undef LEGION_REDOP_KIND_TOTAL_VALUE

#ifdef LEGION_USE_PYTHON_CFFI
#undef MULTIPLY0
#undef MULTIPLY1
#undef MULTIPLY2
#undef MULTIPLY3
#undef MULTIPLY4
#undef MULTIPLY5
#undef MULTIPLY6
#undef MULTIPLY7
#undef MULTIPLY8
#undef MULTIPLY9
#undef MULTIPLY_
#undef MULTIPLY
#endif

typedef enum legion_execution_constraint_t {
  LEGION_ISA_CONSTRAINT = 0,         // instruction set architecture
  LEGION_PROCESSOR_CONSTRAINT = 1,   // processor kind constraint
  LEGION_RESOURCE_CONSTRAINT = 2,    // physical resources
  LEGION_LAUNCH_CONSTRAINT = 3,      // launch configuration
  LEGION_COLOCATION_CONSTRAINT = 4,  // region requirements in same instance
  // for backwards compatibility
  // clang-format off
  LEGION_DEPRECATED_ENUM(ISA_CONSTRAINT)
  LEGION_DEPRECATED_ENUM(PROCESSOR_CONSTRAINT)
  LEGION_DEPRECATED_ENUM(RESOURCE_CONSTRAINT)
  LEGION_DEPRECATED_ENUM(LAUNCH_CONSTRAINT)
  LEGION_DEPRECATED_ENUM(COLOCATION_CONSTRAINT)
  // clang-format on
} legion_execution_constraint_t;

typedef enum legion_layout_constraint_t {
  LEGION_SPECIALIZED_CONSTRAINT =
      0,                         // normal or speicalized (e.g. reduction-fold)
  LEGION_MEMORY_CONSTRAINT = 1,  // constraint on the kind of memory
  LEGION_FIELD_CONSTRAINT = 2,   // ordering of fields
  LEGION_ORDERING_CONSTRAINT = 3,   // ordering of dimensions
  LEGION_TILING_CONSTRAINT = 4,     // splitting of dimensions
  LEGION_DIMENSION_CONSTRAINT = 5,  // dimension size constraint
  LEGION_ALIGNMENT_CONSTRAINT = 6,  // alignment of a field
  LEGION_OFFSET_CONSTRAINT = 7,     // offset of a field
  LEGION_POINTER_CONSTRAINT = 8,    // pointer of a field
  LEGION_PADDING_CONSTRAINT = 9,    // scratch padding
  // for backwards compatibility
  // clang-format off
  LEGION_DEPRECATED_ENUM(SPECIALIZED_CONSTRAINT)
  LEGION_DEPRECATED_ENUM(MEMORY_CONSTRAINT)
  LEGION_DEPRECATED_ENUM(FIELD_CONSTRAINT)
  LEGION_DEPRECATED_ENUM(ORDERING_CONSTRAINT)
  LEGION_DEPRECATED_ENUM(DIMENSION_CONSTRAINT)
  LEGION_DEPRECATED_ENUM(ALIGNMENT_CONSTRAINT)
  LEGION_DEPRECATED_ENUM(OFFSET_CONSTRAINT)
  LEGION_DEPRECATED_ENUM(POINTER_CONSTRAINT)
  // clang-format on
} legion_layout_constraint_t;

typedef enum legion_equality_kind_t {
  LEGION_LT_EK = 0,  // <
  LEGION_LE_EK = 1,  // <=
  LEGION_GT_EK = 2,  // >
  LEGION_GE_EK = 3,  // >=
  LEGION_EQ_EK = 4,  // ==
  LEGION_NE_EK = 5,  // !=
  // for backwards compatibility
  // clang-format off
  LEGION_DEPRECATED_ENUM(LT_EK)
  LEGION_DEPRECATED_ENUM(LE_EK)
  LEGION_DEPRECATED_ENUM(GT_EK)
  LEGION_DEPRECATED_ENUM(GE_EK)
  LEGION_DEPRECATED_ENUM(EQ_EK)
  LEGION_DEPRECATED_ENUM(NE_EK)
  // clang-format on
} legion_equality_kind_t;

typedef enum legion_dimension_kind_t {
  LEGION_DIM_X = 0,  // first logical index space dimension
  LEGION_DIM_Y = 1,  // second logical index space dimension
  LEGION_DIM_Z = 2,  // ...
  // field dimension (this is here for legacy reasons: Regent has hard coded it)
  LEGION_DIM_W = 3,  // fourth logical index space dimension
  LEGION_DIM_V = 4,  // fifth logical index space dimension
  LEGION_DIM_U = 5,  // ...
  LEGION_DIM_T = 6,
  LEGION_DIM_S = 7,
  LEGION_DIM_R = 8,
  LEGION_DIM_F = 9,
  // Numerical names for users that want them
  LEGION_DIM_0 = LEGION_DIM_X,
  LEGION_DIM_1 = LEGION_DIM_Y,
  LEGION_DIM_2 = LEGION_DIM_Z,
  LEGION_DIM_3 = LEGION_DIM_W,
  LEGION_DIM_4 = LEGION_DIM_V,
  LEGION_DIM_5 = LEGION_DIM_U,
  LEGION_DIM_6 = LEGION_DIM_T,
  LEGION_DIM_7 = LEGION_DIM_S,
  LEGION_DIM_8 = LEGION_DIM_R,
  // for backwards compatibility
  // clang-format off
  LEGION_DEPRECATED_ENUM(DIM_X)
  LEGION_DEPRECATED_ENUM(DIM_Y)
  LEGION_DEPRECATED_ENUM(DIM_Z)
  LEGION_DEPRECATED_ENUM(DIM_W)
  LEGION_DEPRECATED_ENUM(DIM_V)
  LEGION_DEPRECATED_ENUM(DIM_U)
  LEGION_DEPRECATED_ENUM(DIM_T)
  LEGION_DEPRECATED_ENUM(DIM_S)
  LEGION_DEPRECATED_ENUM(DIM_R)
  LEGION_DEPRECATED_ENUM(DIM_F)
  // clang-format on
} legion_dimension_kind_t;

// Make all flags 1-hot encoding so we can logically-or them together
typedef enum legion_isa_kind_t {
  // Top-level ISA Kinds
  LEGION_X86_ISA = 0x00000001,
  LEGION_ARM_ISA = 0x00000002,
  LEGION_PPC_ISA = 0x00000004,    // Power PC
  LEGION_PTX_ISA = 0x00000008,    // auto-launch by runtime
  LEGION_CUDA_ISA = 0x00000010,   // run on CPU thread bound to CUDA context
  LEGION_LUA_ISA = 0x00000020,    // run on Lua processor
  LEGION_TERRA_ISA = 0x00000040,  // JIT to target processor kind
  LEGION_LLVM_ISA = 0x00000080,   // JIT to target processor kind
  LEGION_GL_ISA = 0x00000100,     // run on CPU thread with OpenGL context
  // x86 Vector Instructions
  LEGION_SSE_ISA = 0x00000200,
  LEGION_SSE2_ISA = 0x00000400,
  LEGION_SSE3_ISA = 0x00000800,
  LEGION_SSE4_ISA = 0x00001000,
  LEGION_AVX_ISA = 0x00002000,
  LEGION_AVX2_ISA = 0x00004000,
  LEGION_FMA_ISA = 0x00008000,
  // PowerPC Vector Insructions
  LEGION_VSX_ISA = 0x00010000,
  // GPU variants
  LEGION_SM_10_ISA = 0x00020000,
  LEGION_SM_20_ISA = 0x00040000,
  LEGION_SM_30_ISA = 0x00080000,
  LEGION_SM_35_ISA = 0x00100000,
  // ARM Vector Instructions
  LEGION_NEON_ISA = 0x00200000,
  // for backwards compatibility
  // clang-format off
  LEGION_DEPRECATED_ENUM(X86_ISA)
  LEGION_DEPRECATED_ENUM(ARM_ISA)
  LEGION_DEPRECATED_ENUM(PPC_ISA)
  LEGION_DEPRECATED_ENUM(PTX_ISA) 
  LEGION_DEPRECATED_ENUM(CUDA_ISA)
  LEGION_DEPRECATED_ENUM(LUA_ISA)
  LEGION_DEPRECATED_ENUM(TERRA_ISA)
  LEGION_DEPRECATED_ENUM(LLVM_ISA)
  LEGION_DEPRECATED_ENUM(GL_ISA)
  LEGION_DEPRECATED_ENUM(SSE_ISA)
  LEGION_DEPRECATED_ENUM(SSE2_ISA)
  LEGION_DEPRECATED_ENUM(SSE3_ISA)
  LEGION_DEPRECATED_ENUM(SSE4_ISA)
  LEGION_DEPRECATED_ENUM(AVX_ISA)
  LEGION_DEPRECATED_ENUM(AVX2_ISA)
  LEGION_DEPRECATED_ENUM(FMA_ISA)
  LEGION_DEPRECATED_ENUM(VSX_ISA)
  LEGION_DEPRECATED_ENUM(SM_10_ISA)
  LEGION_DEPRECATED_ENUM(SM_20_ISA)
  LEGION_DEPRECATED_ENUM(SM_30_ISA)
  LEGION_DEPRECATED_ENUM(SM_35_ISA)
  LEGION_DEPRECATED_ENUM(NEON_ISA)
  // clang-format on
} legion_isa_kind_t;

typedef enum legion_resource_constraint_t {
  LEGION_L1_CACHE_SIZE = 0,
  LEGION_L2_CACHE_SIZE = 1,
  LEGION_L3_CACHE_SIZE = 2,
  LEGION_L1_CACHE_ASSOCIATIVITY = 3,
  LEGION_L2_CACHE_ASSOCIATIVITY = 4,
  LEGION_L3_CACHE_ASSOCIATIVITY = 5,
  LEGION_REGISTER_FILE_SIZE = 6,
  LEGION_SHARED_MEMORY_SIZE = 7,
  LEGION_TEXTURE_CACHE_SIZE = 8,
  LEGION_CONSTANT_CACHE_SIZE = 9,
  LEGION_NAMED_BARRIERS = 10,
  LEGION_SM_COUNT = 11,       // total SMs on the device
  LEGION_MAX_OCCUPANCY = 12,  // max warps per SM
  // for backwards compatibility
  // clang-format off
  LEGION_DEPRECATED_ENUM(L1_CACHE_SIZE)
  LEGION_DEPRECATED_ENUM(L2_CACHE_SIZE)
  LEGION_DEPRECATED_ENUM(L3_CACHE_SIZE)
  LEGION_DEPRECATED_ENUM(L1_CACHE_ASSOCIATIVITY)
  LEGION_DEPRECATED_ENUM(L2_CACHE_ASSOCIATIVITY)
  LEGION_DEPRECATED_ENUM(L3_CACHE_ASSOCIATIVITY)
  LEGION_DEPRECATED_ENUM(REGISTER_FILE_SIZE)
  LEGION_DEPRECATED_ENUM(SHARED_MEMORY_SIZE)
  LEGION_DEPRECATED_ENUM(TEXTURE_CACHE_SIZE)
  LEGION_DEPRECATED_ENUM(CONSTANT_CACHE_SIZE)
  LEGION_DEPRECATED_ENUM(NAMED_BARRIERS)
  LEGION_DEPRECATED_ENUM(SM_COUNT)
  LEGION_DEPRECATED_ENUM(MAX_OCCUPANCY)
  // clang-format on
} legion_resource_constraint_t;

typedef enum legion_launch_constraint_t {
  LEGION_CTA_SHAPE = 0,
  LEGION_GRID_SHAPE = 1,
  LEGION_DYNAMIC_SHARED_MEMORY = 2,
  LEGION_REGISTERS_PER_THREAD = 3,
  LEGION_CTAS_PER_SM = 4,
  LEGION_NAMED_BARRIERS_PER_CTA = 5,
} legion_launch_constraint_t;

typedef enum legion_specialized_constraint_t {
  LEGION_NO_SPECIALIZE = 0,
  LEGION_AFFINE_SPECIALIZE = 1,   // affine layout
  LEGION_COMPACT_SPECIALIZE = 2,  // compacted sparsity
  LEGION_AFFINE_REDUCTION_SPECIALIZE = 3,
  LEGION_COMPACT_REDUCTION_SPECIALIZE = 4,
  LEGION_VIRTUAL_SPECIALIZE = 5,
  // All file types must go below here, everything else above
  LEGION_GENERIC_FILE_SPECIALIZE,
  LEGION_HDF5_FILE_SPECIALIZE,
  // for backards compatibility
  // clang-format off
  LEGION_DEPRECATED_ENUM(NO_SPECIALIZE)
  LEGION_DEPRECATED_ENUM(AFFINE_SPECIALIZE)
  LEGION_DEPRECATED_ENUM_FROM(NORMAL_SPECIALIZE, LEGION_AFFINE_SPECIALIZE)
  LEGION_DEPRECATED_ENUM(COMPACT_SPECIALIZE)
  LEGION_DEPRECATED_ENUM(AFFINE_REDUCTION_SPECIALIZE)
  LEGION_DEPRECATED_ENUM_FROM(REDUCTION_FOLD_SPECIALIZE, LEGION_AFFINE_REDUCTION_SPECIALIZE)
  LEGION_DEPRECATED_ENUM(COMPACT_REDUCTION_SPECIALIZE)
  LEGION_DEPRECATED_ENUM_FROM(REDUCTION_LIST_SPECIALIZE, LEGION_COMPACT_REDUCTION_SPECIALIZE)
  LEGION_DEPRECATED_ENUM(VIRTUAL_SPECIALIZE)
  LEGION_DEPRECATED_ENUM(GENERIC_FILE_SPECIALIZE)
  LEGION_DEPRECATED_ENUM(HDF5_FILE_SPECIALIZE)
  // clang-format on
} legion_specialized_constraint_t;

// Keep this in sync with Domain::MAX_RECT_DIM in legion_domain.h
// these have to be macros for interacting with the preprocessor
#define LEGION_MAX_POINT_DIM (LEGION_MAX_DIM)
#define LEGION_MAX_RECT_DIM (LEGION_MAX_DIM)
typedef enum legion_domain_max_rect_dim_t {
  // for backwards compatibility
  // clang-format off
  LEGION_DEPRECATED_ENUM(MAX_POINT_DIM)
  LEGION_DEPRECATED_ENUM(MAX_RECT_DIM)
  // clang-format on
} legion_domain_max_rect_dim_t;

#undef LEGION_DEPRECATED_ENUM
#undef LEGION_DEPRECATED_ENUM_FROM

typedef enum legion_unbound_pool_scope_t {
  // Bounded pool so other allocations always permitted in parallel
  LEGION_BOUNDED_POOL,
  // Only allocations for the same task are permitted in parallel
  LEGION_STRICT_UNBOUNDED_POOL,
  // Only tasks in the same index space task launch
  // are allowed to allocate in parallel
  LEGION_INDEX_TASK_UNBOUNDED_POOL,
  // Anything else is allowed to allocate in parallel
  LEGION_PERMISSIVE_UNBOUNDED_POOL,
} legion_unbounded_pool_scope_t;

//==========================================================================
//                                Types
//==========================================================================

typedef realm_processor_kind_t legion_processor_kind_t;
typedef realm_memory_kind_t legion_memory_kind_t;
typedef realm_reduction_op_id_t legion_reduction_op_id_t;
typedef realm_custom_serdez_id_t legion_custom_serdez_id_t;
typedef realm_address_space_t legion_address_space_t;
typedef realm_file_mode_t legion_file_mode_t;
typedef realm_id_t legion_proc_id_t;
typedef realm_id_t legion_memory_id_t;
typedef int legion_task_priority_t;
typedef int legion_garbage_collection_priority_t;
typedef long long legion_coord_t;
typedef unsigned int legion_color_t;
typedef unsigned int legion_field_id_t;
typedef unsigned int legion_trace_id_t;
typedef unsigned int legion_mapper_id_t;
typedef unsigned int legion_context_id_t;
typedef unsigned int legion_instance_id_t;
typedef unsigned int legion_type_tag_t;
typedef unsigned int legion_index_tree_id_t;
typedef unsigned int legion_generation_id_t;
typedef unsigned int legion_type_handle;
typedef unsigned int legion_projection_id_t;
typedef unsigned int legion_sharding_id_t;
typedef unsigned int legion_concurrent_id_t;
typedef unsigned int legion_exception_handler_id_t;
typedef unsigned int legion_tunable_id_t;
typedef unsigned int legion_local_variable_id_t;
typedef unsigned int legion_shard_id_t;
typedef unsigned int legion_variant_id_t;
typedef unsigned long long legion_distributed_id_t;
typedef unsigned long legion_mapping_tag_id_t;
typedef unsigned long legion_code_descriptor_id_t;
typedef unsigned long legion_semantic_tag_t;
typedef unsigned long long legion_unique_id_t;
typedef unsigned long long legion_version_id_t;
typedef unsigned long long legion_projection_epoch_id_t;
typedef unsigned long long legion_provenance_id_t;
typedef realm_task_func_id_t legion_task_id_t;
typedef unsigned long legion_layout_constraint_id_t;
typedef long long legion_internal_color_t;
typedef legion_distributed_id_t legion_region_tree_id_t;

#endif  // __LEGION_CONFIG_H__
