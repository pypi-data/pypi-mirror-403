# coding: utf-8

"""
    BioT File Service

    APIs document description for file service

    The version of the OpenAPI document: 2.6.3
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field
from typing import Optional
from typing_extensions import Annotated
from uuid import UUID
from biotmed_file_sdk.models.complete_multiple_part_upload_file_request import CompleteMultiplePartUploadFileRequest
from biotmed_file_sdk.models.download_file_url_response import DownloadFileUrlResponse
from biotmed_file_sdk.models.multiple_part_upload_file_generate_signed_urls_request import MultiplePartUploadFileGenerateSignedUrlsRequest
from biotmed_file_sdk.models.multiple_part_upload_file_save_e_tag_request import MultiplePartUploadFileSaveETagRequest
from biotmed_file_sdk.models.multiple_part_upload_file_url_request import MultiplePartUploadFileUrlRequest
from biotmed_file_sdk.models.multiple_part_upload_file_url_response import MultiplePartUploadFileUrlResponse

from biotmed_file_sdk.api_client import ApiClient, RequestSerialized
from biotmed_file_sdk.api_response import ApiResponse
from biotmed_file_sdk.rest import RESTResponseType


class MultiplePartFileAPIApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def cancel_multiple_part_upload_file(
        self,
        id: Annotated[UUID, Field(description="File ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Cancel multiple part file upload

        Cancel multiple part file upload    May only be used on uncompleted multiple part uploads.   Path Parameters:  | Parameter   |Type   | Mandatory| Description          | Example   | |-------------|-------|----------|----------------------|-----------| |id|string|true|File ID|3fa85f64-5717-4562-b3fc-2c963f66afa6|   This API requires **PROTECTED_API** permission(s).  

        :param id: File ID (required)
        :type id: UUID
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cancel_multiple_part_upload_file_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '204': None,
            '500': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '504': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cancel_multiple_part_upload_file_with_http_info(
        self,
        id: Annotated[UUID, Field(description="File ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Cancel multiple part file upload

        Cancel multiple part file upload    May only be used on uncompleted multiple part uploads.   Path Parameters:  | Parameter   |Type   | Mandatory| Description          | Example   | |-------------|-------|----------|----------------------|-----------| |id|string|true|File ID|3fa85f64-5717-4562-b3fc-2c963f66afa6|   This API requires **PROTECTED_API** permission(s).  

        :param id: File ID (required)
        :type id: UUID
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cancel_multiple_part_upload_file_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '204': None,
            '500': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '504': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cancel_multiple_part_upload_file_without_preload_content(
        self,
        id: Annotated[UUID, Field(description="File ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Cancel multiple part file upload

        Cancel multiple part file upload    May only be used on uncompleted multiple part uploads.   Path Parameters:  | Parameter   |Type   | Mandatory| Description          | Example   | |-------------|-------|----------|----------------------|-----------| |id|string|true|File ID|3fa85f64-5717-4562-b3fc-2c963f66afa6|   This API requires **PROTECTED_API** permission(s).  

        :param id: File ID (required)
        :type id: UUID
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cancel_multiple_part_upload_file_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '204': None,
            '500': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '504': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cancel_multiple_part_upload_file_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/v1/files/upload/parts/{id}/cancel',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def complete_multiple_part_upload_file(
        self,
        id: Annotated[UUID, Field(description="File ID")],
        complete_multiple_part_upload_file_request: Optional[CompleteMultiplePartUploadFileRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> DownloadFileUrlResponse:
        """Complete multiple part file upload

        Complete multiple part file upload    If this API is called before the file is completely uploaded, then the file will be assembled incorrectly. Only parts that have an ETag sent using this API or saveETagsForMultiplePartFileUpload API will be combined to a file. At least one ETag must be sent using this API or saveETagsForMultiplePartFileUpload API. The body for this request is optional. May only be used on uncompleted multiple part uploads. Part numbers must be only for existing parts in the system, and cannot repeat in the same request.   (*)This parameter is mandatory only if its optional parent attribute is defined. Click <a href=\"https://docs.biot-med.com/docs/biot-rest-api#api-optional-parameters\" target=\"_blank\">here</a> for more information.  Request Body Parameters:  | Parameter   |Type   | Mandatory| Description          | Example   | |-------------|-------|----------|----------------------|-----------| |parts|array|true||| |parts[index]|array|false||| |parts[index].partNumber|integer|true(*)|The part number for which to save the eTag|5| |parts[index].etag|string|false||| Path Parameters:  | Parameter   |Type   | Mandatory| Description          | Example   | |-------------|-------|----------|----------------------|-----------| |id|string|true|File ID|3fa85f64-5717-4562-b3fc-2c963f66afa6|   This API requires **PROTECTED_API** permission(s).  

        :param id: File ID (required)
        :type id: UUID
        :param complete_multiple_part_upload_file_request:
        :type complete_multiple_part_upload_file_request: CompleteMultiplePartUploadFileRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._complete_multiple_part_upload_file_serialize(
            id=id,
            complete_multiple_part_upload_file_request=complete_multiple_part_upload_file_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '200': "DownloadFileUrlResponse",
            '500': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '504': "ErrorResponse",
            '409': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def complete_multiple_part_upload_file_with_http_info(
        self,
        id: Annotated[UUID, Field(description="File ID")],
        complete_multiple_part_upload_file_request: Optional[CompleteMultiplePartUploadFileRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[DownloadFileUrlResponse]:
        """Complete multiple part file upload

        Complete multiple part file upload    If this API is called before the file is completely uploaded, then the file will be assembled incorrectly. Only parts that have an ETag sent using this API or saveETagsForMultiplePartFileUpload API will be combined to a file. At least one ETag must be sent using this API or saveETagsForMultiplePartFileUpload API. The body for this request is optional. May only be used on uncompleted multiple part uploads. Part numbers must be only for existing parts in the system, and cannot repeat in the same request.   (*)This parameter is mandatory only if its optional parent attribute is defined. Click <a href=\"https://docs.biot-med.com/docs/biot-rest-api#api-optional-parameters\" target=\"_blank\">here</a> for more information.  Request Body Parameters:  | Parameter   |Type   | Mandatory| Description          | Example   | |-------------|-------|----------|----------------------|-----------| |parts|array|true||| |parts[index]|array|false||| |parts[index].partNumber|integer|true(*)|The part number for which to save the eTag|5| |parts[index].etag|string|false||| Path Parameters:  | Parameter   |Type   | Mandatory| Description          | Example   | |-------------|-------|----------|----------------------|-----------| |id|string|true|File ID|3fa85f64-5717-4562-b3fc-2c963f66afa6|   This API requires **PROTECTED_API** permission(s).  

        :param id: File ID (required)
        :type id: UUID
        :param complete_multiple_part_upload_file_request:
        :type complete_multiple_part_upload_file_request: CompleteMultiplePartUploadFileRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._complete_multiple_part_upload_file_serialize(
            id=id,
            complete_multiple_part_upload_file_request=complete_multiple_part_upload_file_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '200': "DownloadFileUrlResponse",
            '500': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '504': "ErrorResponse",
            '409': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def complete_multiple_part_upload_file_without_preload_content(
        self,
        id: Annotated[UUID, Field(description="File ID")],
        complete_multiple_part_upload_file_request: Optional[CompleteMultiplePartUploadFileRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Complete multiple part file upload

        Complete multiple part file upload    If this API is called before the file is completely uploaded, then the file will be assembled incorrectly. Only parts that have an ETag sent using this API or saveETagsForMultiplePartFileUpload API will be combined to a file. At least one ETag must be sent using this API or saveETagsForMultiplePartFileUpload API. The body for this request is optional. May only be used on uncompleted multiple part uploads. Part numbers must be only for existing parts in the system, and cannot repeat in the same request.   (*)This parameter is mandatory only if its optional parent attribute is defined. Click <a href=\"https://docs.biot-med.com/docs/biot-rest-api#api-optional-parameters\" target=\"_blank\">here</a> for more information.  Request Body Parameters:  | Parameter   |Type   | Mandatory| Description          | Example   | |-------------|-------|----------|----------------------|-----------| |parts|array|true||| |parts[index]|array|false||| |parts[index].partNumber|integer|true(*)|The part number for which to save the eTag|5| |parts[index].etag|string|false||| Path Parameters:  | Parameter   |Type   | Mandatory| Description          | Example   | |-------------|-------|----------|----------------------|-----------| |id|string|true|File ID|3fa85f64-5717-4562-b3fc-2c963f66afa6|   This API requires **PROTECTED_API** permission(s).  

        :param id: File ID (required)
        :type id: UUID
        :param complete_multiple_part_upload_file_request:
        :type complete_multiple_part_upload_file_request: CompleteMultiplePartUploadFileRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._complete_multiple_part_upload_file_serialize(
            id=id,
            complete_multiple_part_upload_file_request=complete_multiple_part_upload_file_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '200': "DownloadFileUrlResponse",
            '500': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '504': "ErrorResponse",
            '409': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _complete_multiple_part_upload_file_serialize(
        self,
        id,
        complete_multiple_part_upload_file_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if complete_multiple_part_upload_file_request is not None:
            _body_params = complete_multiple_part_upload_file_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/files/upload/parts/{id}/complete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_multiple_part_upload_file_url(
        self,
        multiple_part_upload_file_url_request: MultiplePartUploadFileUrlRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> MultiplePartUploadFileUrlResponse:
        """Create a new File

        Create a new File    This API returns a list of links to upload file parts. The number of parts requested must be between 1 and 10000. It can be changed later, so you don't have to know the file size in advance. If a link for a part is used more than once, the data that was previously uploaded to that link will be overwritten (and the ETag should be updated in the service). You don't have to use all of the links, but must use at least one. Each link has an expiry time, after which it cannot be used. To generate new links and request links for more parts use generateSignedUrlsForMultiplePartFileUpload. File uploads are done with the links returned in from this API as PUT requests with the data as a binary stream in the body. Each file upload to the links returned from this API will return an 'ETag' header. This header must be sent to the bioT API saveETagsForMultiplePartFileUpload, if it is not sent, the part will be ignored when the file is combined. The file must be split and uploaded to the links provided on the client's side. Parts may be uploaded in any order, but must be uploaded using the correct part number and link (E.g. file=abc with 3 parts - you can upload in any order p1=a, p3=c, p2=b). Each file part must be between 5MiB and 5GiB, the last part has no minimum size. 100MiB is recommended if possible. Max supported file size is 5TiB.   Request Body Parameters:  | Parameter   |Type   | Mandatory| Description          | Example   | |-------------|-------|----------|----------------------|-----------| |name|string|true||| |mimeType|string|true||| |parts|integer|true|For how many parts to initially generate links, not all must be used and more can be generated later|100|   This API requires **PROTECTED_API** permission(s).  

        :param multiple_part_upload_file_url_request: (required)
        :type multiple_part_upload_file_url_request: MultiplePartUploadFileUrlRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_multiple_part_upload_file_url_serialize(
            multiple_part_upload_file_url_request=multiple_part_upload_file_url_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '200': "MultiplePartUploadFileUrlResponse",
            '500': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '504': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_multiple_part_upload_file_url_with_http_info(
        self,
        multiple_part_upload_file_url_request: MultiplePartUploadFileUrlRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[MultiplePartUploadFileUrlResponse]:
        """Create a new File

        Create a new File    This API returns a list of links to upload file parts. The number of parts requested must be between 1 and 10000. It can be changed later, so you don't have to know the file size in advance. If a link for a part is used more than once, the data that was previously uploaded to that link will be overwritten (and the ETag should be updated in the service). You don't have to use all of the links, but must use at least one. Each link has an expiry time, after which it cannot be used. To generate new links and request links for more parts use generateSignedUrlsForMultiplePartFileUpload. File uploads are done with the links returned in from this API as PUT requests with the data as a binary stream in the body. Each file upload to the links returned from this API will return an 'ETag' header. This header must be sent to the bioT API saveETagsForMultiplePartFileUpload, if it is not sent, the part will be ignored when the file is combined. The file must be split and uploaded to the links provided on the client's side. Parts may be uploaded in any order, but must be uploaded using the correct part number and link (E.g. file=abc with 3 parts - you can upload in any order p1=a, p3=c, p2=b). Each file part must be between 5MiB and 5GiB, the last part has no minimum size. 100MiB is recommended if possible. Max supported file size is 5TiB.   Request Body Parameters:  | Parameter   |Type   | Mandatory| Description          | Example   | |-------------|-------|----------|----------------------|-----------| |name|string|true||| |mimeType|string|true||| |parts|integer|true|For how many parts to initially generate links, not all must be used and more can be generated later|100|   This API requires **PROTECTED_API** permission(s).  

        :param multiple_part_upload_file_url_request: (required)
        :type multiple_part_upload_file_url_request: MultiplePartUploadFileUrlRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_multiple_part_upload_file_url_serialize(
            multiple_part_upload_file_url_request=multiple_part_upload_file_url_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '200': "MultiplePartUploadFileUrlResponse",
            '500': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '504': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_multiple_part_upload_file_url_without_preload_content(
        self,
        multiple_part_upload_file_url_request: MultiplePartUploadFileUrlRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create a new File

        Create a new File    This API returns a list of links to upload file parts. The number of parts requested must be between 1 and 10000. It can be changed later, so you don't have to know the file size in advance. If a link for a part is used more than once, the data that was previously uploaded to that link will be overwritten (and the ETag should be updated in the service). You don't have to use all of the links, but must use at least one. Each link has an expiry time, after which it cannot be used. To generate new links and request links for more parts use generateSignedUrlsForMultiplePartFileUpload. File uploads are done with the links returned in from this API as PUT requests with the data as a binary stream in the body. Each file upload to the links returned from this API will return an 'ETag' header. This header must be sent to the bioT API saveETagsForMultiplePartFileUpload, if it is not sent, the part will be ignored when the file is combined. The file must be split and uploaded to the links provided on the client's side. Parts may be uploaded in any order, but must be uploaded using the correct part number and link (E.g. file=abc with 3 parts - you can upload in any order p1=a, p3=c, p2=b). Each file part must be between 5MiB and 5GiB, the last part has no minimum size. 100MiB is recommended if possible. Max supported file size is 5TiB.   Request Body Parameters:  | Parameter   |Type   | Mandatory| Description          | Example   | |-------------|-------|----------|----------------------|-----------| |name|string|true||| |mimeType|string|true||| |parts|integer|true|For how many parts to initially generate links, not all must be used and more can be generated later|100|   This API requires **PROTECTED_API** permission(s).  

        :param multiple_part_upload_file_url_request: (required)
        :type multiple_part_upload_file_url_request: MultiplePartUploadFileUrlRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_multiple_part_upload_file_url_serialize(
            multiple_part_upload_file_url_request=multiple_part_upload_file_url_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '200': "MultiplePartUploadFileUrlResponse",
            '500': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '504': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_multiple_part_upload_file_url_serialize(
        self,
        multiple_part_upload_file_url_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if multiple_part_upload_file_url_request is not None:
            _body_params = multiple_part_upload_file_url_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/files/upload/parts',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def generate_signed_urls_for_multiple_part_file_upload(
        self,
        multiple_part_upload_file_generate_signed_urls_request: MultiplePartUploadFileGenerateSignedUrlsRequest,
        id: Annotated[UUID, Field(description="File ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> MultiplePartUploadFileUrlResponse:
        """Generate signed URLs for multiple part file upload

        Generate signed URLs for multiple part file upload    This API returns the same response as createMultiplePartUploadFileUrl API, but it does so for existing multiple part file uploads. It creates new signed urls and can be used in a situation where the signed urls have expired. It can also create signed urls for new parts not originally requested. It will return signedUrls only for parts in the requested range. May only be used on uncompleted multiple part uploads.   Request Body Parameters:  | Parameter   |Type   | Mandatory| Description          | Example   | |-------------|-------|----------|----------------------|-----------| |fromPart|integer|true|The part number to generate from, inclusive|5| |toPart|integer|true|The part number to generate to, inclusive|10| Path Parameters:  | Parameter   |Type   | Mandatory| Description          | Example   | |-------------|-------|----------|----------------------|-----------| |id|string|true|File ID|3fa85f64-5717-4562-b3fc-2c963f66afa6|   This API requires **PROTECTED_API** permission(s).  

        :param multiple_part_upload_file_generate_signed_urls_request: (required)
        :type multiple_part_upload_file_generate_signed_urls_request: MultiplePartUploadFileGenerateSignedUrlsRequest
        :param id: File ID (required)
        :type id: UUID
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._generate_signed_urls_for_multiple_part_file_upload_serialize(
            multiple_part_upload_file_generate_signed_urls_request=multiple_part_upload_file_generate_signed_urls_request,
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '200': "MultiplePartUploadFileUrlResponse",
            '500': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '504': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def generate_signed_urls_for_multiple_part_file_upload_with_http_info(
        self,
        multiple_part_upload_file_generate_signed_urls_request: MultiplePartUploadFileGenerateSignedUrlsRequest,
        id: Annotated[UUID, Field(description="File ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[MultiplePartUploadFileUrlResponse]:
        """Generate signed URLs for multiple part file upload

        Generate signed URLs for multiple part file upload    This API returns the same response as createMultiplePartUploadFileUrl API, but it does so for existing multiple part file uploads. It creates new signed urls and can be used in a situation where the signed urls have expired. It can also create signed urls for new parts not originally requested. It will return signedUrls only for parts in the requested range. May only be used on uncompleted multiple part uploads.   Request Body Parameters:  | Parameter   |Type   | Mandatory| Description          | Example   | |-------------|-------|----------|----------------------|-----------| |fromPart|integer|true|The part number to generate from, inclusive|5| |toPart|integer|true|The part number to generate to, inclusive|10| Path Parameters:  | Parameter   |Type   | Mandatory| Description          | Example   | |-------------|-------|----------|----------------------|-----------| |id|string|true|File ID|3fa85f64-5717-4562-b3fc-2c963f66afa6|   This API requires **PROTECTED_API** permission(s).  

        :param multiple_part_upload_file_generate_signed_urls_request: (required)
        :type multiple_part_upload_file_generate_signed_urls_request: MultiplePartUploadFileGenerateSignedUrlsRequest
        :param id: File ID (required)
        :type id: UUID
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._generate_signed_urls_for_multiple_part_file_upload_serialize(
            multiple_part_upload_file_generate_signed_urls_request=multiple_part_upload_file_generate_signed_urls_request,
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '200': "MultiplePartUploadFileUrlResponse",
            '500': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '504': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def generate_signed_urls_for_multiple_part_file_upload_without_preload_content(
        self,
        multiple_part_upload_file_generate_signed_urls_request: MultiplePartUploadFileGenerateSignedUrlsRequest,
        id: Annotated[UUID, Field(description="File ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Generate signed URLs for multiple part file upload

        Generate signed URLs for multiple part file upload    This API returns the same response as createMultiplePartUploadFileUrl API, but it does so for existing multiple part file uploads. It creates new signed urls and can be used in a situation where the signed urls have expired. It can also create signed urls for new parts not originally requested. It will return signedUrls only for parts in the requested range. May only be used on uncompleted multiple part uploads.   Request Body Parameters:  | Parameter   |Type   | Mandatory| Description          | Example   | |-------------|-------|----------|----------------------|-----------| |fromPart|integer|true|The part number to generate from, inclusive|5| |toPart|integer|true|The part number to generate to, inclusive|10| Path Parameters:  | Parameter   |Type   | Mandatory| Description          | Example   | |-------------|-------|----------|----------------------|-----------| |id|string|true|File ID|3fa85f64-5717-4562-b3fc-2c963f66afa6|   This API requires **PROTECTED_API** permission(s).  

        :param multiple_part_upload_file_generate_signed_urls_request: (required)
        :type multiple_part_upload_file_generate_signed_urls_request: MultiplePartUploadFileGenerateSignedUrlsRequest
        :param id: File ID (required)
        :type id: UUID
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._generate_signed_urls_for_multiple_part_file_upload_serialize(
            multiple_part_upload_file_generate_signed_urls_request=multiple_part_upload_file_generate_signed_urls_request,
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '200': "MultiplePartUploadFileUrlResponse",
            '500': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '504': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _generate_signed_urls_for_multiple_part_file_upload_serialize(
        self,
        multiple_part_upload_file_generate_signed_urls_request,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if multiple_part_upload_file_generate_signed_urls_request is not None:
            _body_params = multiple_part_upload_file_generate_signed_urls_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/files/upload/parts/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def save_e_tags_for_multiple_part_file_upload(
        self,
        multiple_part_upload_file_save_e_tag_request: MultiplePartUploadFileSaveETagRequest,
        id: Annotated[UUID, Field(description="File ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Upload ETags for parts of a multiple part file upload

        Upload ETags for parts of a multiple part file upload    Each file upload to the links returned from this API will return an 'ETag' header. This header must be sent to this API, if it is not sent, the part will be ignored when the file is combined. Multiple ETags can be passed here, although ideally after each part is uploaded the returned ETag is sent to the service (to prevent data loss). If sending a tag for a part that was already sent, the previous tag for that part number will be overridden. This can also be done in completeMultiplePartUploadFile API. Part numbers must be only for existing parts in the system, and cannot repeat in the same request. May only be used on uncompleted multiple part uploads. At least one part must be sent in the list.   (*)This parameter is mandatory only if its optional parent attribute is defined. Click <a href=\"https://docs.biot-med.com/docs/biot-rest-api#api-optional-parameters\" target=\"_blank\">here</a> for more information.  Request Body Parameters:  | Parameter   |Type   | Mandatory| Description          | Example   | |-------------|-------|----------|----------------------|-----------| |parts|array|true||| |parts[index]|array|false||| |parts[index].partNumber|integer|true(*)|The part number for which to save the eTag|5| |parts[index].etag|string|false||| Path Parameters:  | Parameter   |Type   | Mandatory| Description          | Example   | |-------------|-------|----------|----------------------|-----------| |id|string|true|File ID|3fa85f64-5717-4562-b3fc-2c963f66afa6|   This API requires **PROTECTED_API** permission(s).  

        :param multiple_part_upload_file_save_e_tag_request: (required)
        :type multiple_part_upload_file_save_e_tag_request: MultiplePartUploadFileSaveETagRequest
        :param id: File ID (required)
        :type id: UUID
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._save_e_tags_for_multiple_part_file_upload_serialize(
            multiple_part_upload_file_save_e_tag_request=multiple_part_upload_file_save_e_tag_request,
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '200': None,
            '500': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '504': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def save_e_tags_for_multiple_part_file_upload_with_http_info(
        self,
        multiple_part_upload_file_save_e_tag_request: MultiplePartUploadFileSaveETagRequest,
        id: Annotated[UUID, Field(description="File ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Upload ETags for parts of a multiple part file upload

        Upload ETags for parts of a multiple part file upload    Each file upload to the links returned from this API will return an 'ETag' header. This header must be sent to this API, if it is not sent, the part will be ignored when the file is combined. Multiple ETags can be passed here, although ideally after each part is uploaded the returned ETag is sent to the service (to prevent data loss). If sending a tag for a part that was already sent, the previous tag for that part number will be overridden. This can also be done in completeMultiplePartUploadFile API. Part numbers must be only for existing parts in the system, and cannot repeat in the same request. May only be used on uncompleted multiple part uploads. At least one part must be sent in the list.   (*)This parameter is mandatory only if its optional parent attribute is defined. Click <a href=\"https://docs.biot-med.com/docs/biot-rest-api#api-optional-parameters\" target=\"_blank\">here</a> for more information.  Request Body Parameters:  | Parameter   |Type   | Mandatory| Description          | Example   | |-------------|-------|----------|----------------------|-----------| |parts|array|true||| |parts[index]|array|false||| |parts[index].partNumber|integer|true(*)|The part number for which to save the eTag|5| |parts[index].etag|string|false||| Path Parameters:  | Parameter   |Type   | Mandatory| Description          | Example   | |-------------|-------|----------|----------------------|-----------| |id|string|true|File ID|3fa85f64-5717-4562-b3fc-2c963f66afa6|   This API requires **PROTECTED_API** permission(s).  

        :param multiple_part_upload_file_save_e_tag_request: (required)
        :type multiple_part_upload_file_save_e_tag_request: MultiplePartUploadFileSaveETagRequest
        :param id: File ID (required)
        :type id: UUID
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._save_e_tags_for_multiple_part_file_upload_serialize(
            multiple_part_upload_file_save_e_tag_request=multiple_part_upload_file_save_e_tag_request,
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '200': None,
            '500': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '504': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def save_e_tags_for_multiple_part_file_upload_without_preload_content(
        self,
        multiple_part_upload_file_save_e_tag_request: MultiplePartUploadFileSaveETagRequest,
        id: Annotated[UUID, Field(description="File ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Upload ETags for parts of a multiple part file upload

        Upload ETags for parts of a multiple part file upload    Each file upload to the links returned from this API will return an 'ETag' header. This header must be sent to this API, if it is not sent, the part will be ignored when the file is combined. Multiple ETags can be passed here, although ideally after each part is uploaded the returned ETag is sent to the service (to prevent data loss). If sending a tag for a part that was already sent, the previous tag for that part number will be overridden. This can also be done in completeMultiplePartUploadFile API. Part numbers must be only for existing parts in the system, and cannot repeat in the same request. May only be used on uncompleted multiple part uploads. At least one part must be sent in the list.   (*)This parameter is mandatory only if its optional parent attribute is defined. Click <a href=\"https://docs.biot-med.com/docs/biot-rest-api#api-optional-parameters\" target=\"_blank\">here</a> for more information.  Request Body Parameters:  | Parameter   |Type   | Mandatory| Description          | Example   | |-------------|-------|----------|----------------------|-----------| |parts|array|true||| |parts[index]|array|false||| |parts[index].partNumber|integer|true(*)|The part number for which to save the eTag|5| |parts[index].etag|string|false||| Path Parameters:  | Parameter   |Type   | Mandatory| Description          | Example   | |-------------|-------|----------|----------------------|-----------| |id|string|true|File ID|3fa85f64-5717-4562-b3fc-2c963f66afa6|   This API requires **PROTECTED_API** permission(s).  

        :param multiple_part_upload_file_save_e_tag_request: (required)
        :type multiple_part_upload_file_save_e_tag_request: MultiplePartUploadFileSaveETagRequest
        :param id: File ID (required)
        :type id: UUID
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._save_e_tags_for_multiple_part_file_upload_serialize(
            multiple_part_upload_file_save_e_tag_request=multiple_part_upload_file_save_e_tag_request,
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '200': None,
            '500': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '504': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _save_e_tags_for_multiple_part_file_upload_serialize(
        self,
        multiple_part_upload_file_save_e_tag_request,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if multiple_part_upload_file_save_e_tag_request is not None:
            _body_params = multiple_part_upload_file_save_e_tag_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/v1/files/upload/parts/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


