
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "seq"

@_ods_cext.register_operation(_Dialect)
class ClockDividerOp(_ods_ir.OpView):
  r"""
  The output clock is phase-aligned to the input clock.
  
  ```
  %div_clock = seq.clock_div %clock by 1
  ```
  """

  OPERATION_NAME = "seq.clock_div"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, pow2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["pow2"] = (pow2 if (
    isinstance(pow2, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(pow2, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def pow2(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["pow2"]

  @pow2.setter
  def pow2(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pow2"] = value

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def clock_div(input, pow2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ClockDividerOp(input=input, pow2=pow2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ClockGateOp(_ods_ir.OpView):
  r"""
  The `seq.clock_gate` enables and disables a clock safely, without glitches,
  based on a boolean enable value. If the enable operand is 1, the output
  clock produced by the clock gate is identical to the input clock. If the
  enable operand is 0, the output clock is a constant zero.
  
  The `enable` operand is sampled at the rising edge of the input clock; any
  changes on the enable before or after that edge are ignored and do not
  affect the output clock.
  
  The `test_enable` operand is optional and if present is OR'd together with
  the `enable` operand to determine whether the output clock is gated or not.
  
  The op can be referred to using an inner symbol. Upon translation, the
  symbol will target the instance to the external module it lowers to.
  
  ```
  %gatedClock = seq.clock_gate %clock, %enable
  %gatedClock = seq.clock_gate %clock, %enable, %test_enable
  ```
  """

  OPERATION_NAME = "seq.clock_gate"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, enable, *, test_enable=None, inner_sym=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(enable)
    if test_enable is not None: operands.append(test_enable)
    _ods_context = _ods_get_default_loc_context(loc)
    if inner_sym is not None: attributes["inner_sym"] = (inner_sym if (
        isinstance(inner_sym, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('InnerSymAttr')) else
          _ods_ir.AttrBuilder.get('InnerSymAttr')(inner_sym, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def enable(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def test_enable(self) -> _Optional[_ods_ir.Value[_ods_ir.IntegerType]]:
    return None if len(self.operation.operands) < 3 else self.operation.operands[2]

  @builtins.property
  def inner_sym(self) -> _Optional[_ods_ir.Attribute]:
    if "inner_sym" not in self.operation.attributes:
      return None
    return self.operation.attributes["inner_sym"]

  @inner_sym.setter
  def inner_sym(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["inner_sym"] = value
    elif "inner_sym" in self.operation.attributes:
      del self.operation.attributes["inner_sym"]

  @inner_sym.deleter
  def inner_sym(self):
    del self.operation.attributes["inner_sym"]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def clock_gate(input, enable, *, test_enable=None, inner_sym=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ClockGateOp(input=input, enable=enable, test_enable=test_enable, inner_sym=inner_sym, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ClockInverterOp(_ods_ir.OpView):
  r"""
  Note that the compiler can optimize inverters away, preventing their
  use as part of explicit clock buffers.
  
  ```
  %inv_clock = seq.clock_inv %clock
  ```
  """

  OPERATION_NAME = "seq.clock_inv"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def clock_inv(input, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ClockInverterOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ClockMuxOp(_ods_ir.OpView):
  r"""
  The `seq.clock_mux` op selects a clock from two options. If `cond` is
  true, the first clock operand is selected to drive downstream logic.
  Otherwise, the second clock is used.
  
  ```
  %clock = seq.clock_mux %cond, %trueClock, %falseClock
  ```
  """

  OPERATION_NAME = "seq.clock_mux"

  _ODS_REGIONS = (0, True)

  def __init__(self, cond, trueClock, falseClock, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(cond)
    operands.append(trueClock)
    operands.append(falseClock)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def cond(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def trueClock(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def falseClock(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def clock_mux(cond, true_clock, false_clock, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ClockMuxOp(cond=cond, trueClock=true_clock, falseClock=false_clock, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CompRegClockEnabledOp(_ods_ir.OpView):
  r"""
  See the Seq dialect rationale for a longer description
  """

  OPERATION_NAME = "seq.compreg.ce"

  _ODS_OPERAND_SEGMENTS = [1,1,1,0,0,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, input, clk, clockEnable, *, name=None, reset=None, resetValue=None, initialValue=None, inner_sym=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(clk)
    operands.append(clockEnable)
    operands.append(reset)
    operands.append(resetValue)
    operands.append(initialValue)
    _ods_context = _ods_get_default_loc_context(loc)
    if name is not None: attributes["name"] = (name if (
        isinstance(name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    if inner_sym is not None: attributes["inner_sym"] = (inner_sym if (
        isinstance(inner_sym, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('InnerSymAttr')) else
          _ods_ir.AttrBuilder.get('InnerSymAttr')(inner_sym, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def clk(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def clockEnable(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def reset(self) -> _Optional[_ods_ir.Value[_ods_ir.IntegerType]]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def resetValue(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def initialValue(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 5)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def name(self) -> _Optional[_ods_ir.StringAttr]:
    if "name" not in self.operation.attributes:
      return None
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["name"] = value
    elif "name" in self.operation.attributes:
      del self.operation.attributes["name"]

  @name.deleter
  def name(self):
    del self.operation.attributes["name"]

  @builtins.property
  def inner_sym(self) -> _Optional[_ods_ir.Attribute]:
    if "inner_sym" not in self.operation.attributes:
      return None
    return self.operation.attributes["inner_sym"]

  @inner_sym.setter
  def inner_sym(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["inner_sym"] = value
    elif "inner_sym" in self.operation.attributes:
      del self.operation.attributes["inner_sym"]

  @inner_sym.deleter
  def inner_sym(self):
    del self.operation.attributes["inner_sym"]

  @builtins.property
  def data(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def compreg_ce(input, clk, clock_enable, *, name=None, reset=None, reset_value=None, initial_value=None, inner_sym=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CompRegClockEnabledOp(input=input, clk=clk, clockEnable=clock_enable, name=name, reset=reset, resetValue=reset_value, initialValue=initial_value, inner_sym=inner_sym, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CompRegOp(_ods_ir.OpView):
  r"""
  See the Seq dialect rationale for a longer description
  """

  OPERATION_NAME = "seq.compreg"

  _ODS_OPERAND_SEGMENTS = [1,1,0,0,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, input, clk, *, name=None, reset=None, resetValue=None, initialValue=None, inner_sym=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(clk)
    operands.append(reset)
    operands.append(resetValue)
    operands.append(initialValue)
    _ods_context = _ods_get_default_loc_context(loc)
    if name is not None: attributes["name"] = (name if (
        isinstance(name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    if inner_sym is not None: attributes["inner_sym"] = (inner_sym if (
        isinstance(inner_sym, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('InnerSymAttr')) else
          _ods_ir.AttrBuilder.get('InnerSymAttr')(inner_sym, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def clk(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def reset(self) -> _Optional[_ods_ir.Value[_ods_ir.IntegerType]]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def resetValue(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def initialValue(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def name(self) -> _Optional[_ods_ir.StringAttr]:
    if "name" not in self.operation.attributes:
      return None
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["name"] = value
    elif "name" in self.operation.attributes:
      del self.operation.attributes["name"]

  @name.deleter
  def name(self):
    del self.operation.attributes["name"]

  @builtins.property
  def inner_sym(self) -> _Optional[_ods_ir.Attribute]:
    if "inner_sym" not in self.operation.attributes:
      return None
    return self.operation.attributes["inner_sym"]

  @inner_sym.setter
  def inner_sym(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["inner_sym"] = value
    elif "inner_sym" in self.operation.attributes:
      del self.operation.attributes["inner_sym"]

  @inner_sym.deleter
  def inner_sym(self):
    del self.operation.attributes["inner_sym"]

  @builtins.property
  def data(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def compreg(input, clk, *, name=None, reset=None, reset_value=None, initial_value=None, inner_sym=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CompRegOp(input=input, clk=clk, name=name, reset=reset, resetValue=reset_value, initialValue=initial_value, inner_sym=inner_sym, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConstClockOp(_ods_ir.OpView):
  r"""
  The constant operation produces a constant clock value.
  ```
    %clock = seq.const_clock low
  ```
  """

  OPERATION_NAME = "seq.const_clock"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ClockConstAttr')) else
      _ods_ir.AttrBuilder.get('ClockConstAttr')(value, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Attribute:
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def const_clock(value, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConstClockOp(value=value, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FIFOOp(_ods_ir.OpView):
  r"""
  This operation represents a high-level abstraction of a FIFO. Access to the
  FIFO is structural, and thus may be composed with other core RTL dialect
  operations.
  The fifo operation is configurable with the following parameters:
  1. Depth (cycles)
  2. Read latency (cycles) is the number of cycles it takes for a read to
     return data after the read enable signal is asserted.
  3. Almost full/empty thresholds (optional). If not provided, these will
     be asserted when the FIFO is full/empty.
  
  Like `seq.hlmem` there are no guarantees that all possible fifo configuration
  are able to be lowered. Available lowering passes will pattern match on the
  requested fifo configuration and attempt to provide a legal lowering.
  """

  OPERATION_NAME = "seq.fifo"

  _ODS_RESULT_SEGMENTS = [1,1,1,0,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, output, full, empty, almostFull, almostEmpty, input, rdEn, wrEn, clk, rst, depth, *, rdLatency=None, almostFullThreshold=None, almostEmptyThreshold=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(rdEn)
    operands.append(wrEn)
    operands.append(clk)
    operands.append(rst)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["depth"] = (depth if (
    isinstance(depth, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(depth, context=_ods_context))
    if rdLatency is not None: attributes["rdLatency"] = (rdLatency if (
        isinstance(rdLatency, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(rdLatency, context=_ods_context))
    if almostFullThreshold is not None: attributes["almostFullThreshold"] = (almostFullThreshold if (
        isinstance(almostFullThreshold, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(almostFullThreshold, context=_ods_context))
    if almostEmptyThreshold is not None: attributes["almostEmptyThreshold"] = (almostEmptyThreshold if (
        isinstance(almostEmptyThreshold, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(almostEmptyThreshold, context=_ods_context))
    results = []
    results.append(output)
    results.append(full)
    results.append(empty)
    if almostFull is not None: results.append(almostFull)
    if almostEmpty is not None: results.append(almostEmpty)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rdEn(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def wrEn(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

  @builtins.property
  def clk(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def rst(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[4]

  @builtins.property
  def depth(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["depth"]

  @depth.setter
  def depth(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["depth"] = value

  @builtins.property
  def rdLatency(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "rdLatency" not in self.operation.attributes:
      return None
    return self.operation.attributes["rdLatency"]

  @rdLatency.setter
  def rdLatency(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["rdLatency"] = value
    elif "rdLatency" in self.operation.attributes:
      del self.operation.attributes["rdLatency"]

  @rdLatency.deleter
  def rdLatency(self):
    del self.operation.attributes["rdLatency"]

  @builtins.property
  def almostFullThreshold(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "almostFullThreshold" not in self.operation.attributes:
      return None
    return self.operation.attributes["almostFullThreshold"]

  @almostFullThreshold.setter
  def almostFullThreshold(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["almostFullThreshold"] = value
    elif "almostFullThreshold" in self.operation.attributes:
      del self.operation.attributes["almostFullThreshold"]

  @almostFullThreshold.deleter
  def almostFullThreshold(self):
    del self.operation.attributes["almostFullThreshold"]

  @builtins.property
  def almostEmptyThreshold(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "almostEmptyThreshold" not in self.operation.attributes:
      return None
    return self.operation.attributes["almostEmptyThreshold"]

  @almostEmptyThreshold.setter
  def almostEmptyThreshold(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["almostEmptyThreshold"] = value
    elif "almostEmptyThreshold" in self.operation.attributes:
      del self.operation.attributes["almostEmptyThreshold"]

  @almostEmptyThreshold.deleter
  def almostEmptyThreshold(self):
    del self.operation.attributes["almostEmptyThreshold"]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    result_range = _ods_segmented_accessor(
         self.operation.results,
         self.operation.attributes["resultSegmentSizes"], 0)
    return result_range[0]

  @builtins.property
  def full(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    result_range = _ods_segmented_accessor(
         self.operation.results,
         self.operation.attributes["resultSegmentSizes"], 1)
    return result_range[0]

  @builtins.property
  def empty(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    result_range = _ods_segmented_accessor(
         self.operation.results,
         self.operation.attributes["resultSegmentSizes"], 2)
    return result_range[0]

  @builtins.property
  def almostFull(self) -> _Optional[_ods_ir.OpResult[_ods_ir.IntegerType]]:
    result_range = _ods_segmented_accessor(
         self.operation.results,
         self.operation.attributes["resultSegmentSizes"], 3)
    return result_range[0] if len(result_range) > 0 else None

  @builtins.property
  def almostEmpty(self) -> _Optional[_ods_ir.OpResult[_ods_ir.IntegerType]]:
    result_range = _ods_segmented_accessor(
         self.operation.results,
         self.operation.attributes["resultSegmentSizes"], 4)
    return result_range[0] if len(result_range) > 0 else None

def fifo(output, full, empty, almost_full, almost_empty, input, rd_en, wr_en, clk, rst, depth, *, rd_latency=None, almost_full_threshold=None, almost_empty_threshold=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, FIFOOp]:
  op = FIFOOp(output=output, full=full, empty=empty, almostFull=almost_full, almostEmpty=almost_empty, input=input, rdEn=rd_en, wrEn=wr_en, clk=clk, rst=rst, depth=depth, rdLatency=rd_latency, almostFullThreshold=almost_full_threshold, almostEmptyThreshold=almost_empty_threshold, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class FirMemOp(_ods_ir.OpView):
  r"""
  The `seq.firmem` op represents memories lowered from the FIRRTL dialect. It
  is used to capture some of the peculiarities of what FIRRTL expects from
  memories, while still representing them at the HW dialect level.
  
  A `seq.firmem` declares the memory and captures the memory-level parameters
  such as width and depth or how read/write collisions are resolved. The read,
  write, and read-write ports are expressed as separate operations that take
  the declared memory as an operand.
  """

  OPERATION_NAME = "seq.firmem"

  _ODS_REGIONS = (0, True)

  def __init__(self, memory, readLatency, writeLatency, ruw, wuw, *, name=None, inner_sym=None, init=None, prefix=None, output_file=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["readLatency"] = (readLatency if (
    isinstance(readLatency, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(readLatency, context=_ods_context))
    attributes["writeLatency"] = (writeLatency if (
    isinstance(writeLatency, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(writeLatency, context=_ods_context))
    attributes["ruw"] = (ruw if (
    isinstance(ruw, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('RUWAttr')) else
      _ods_ir.AttrBuilder.get('RUWAttr')(ruw, context=_ods_context))
    attributes["wuw"] = (wuw if (
    isinstance(wuw, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('WUWAttr')) else
      _ods_ir.AttrBuilder.get('WUWAttr')(wuw, context=_ods_context))
    if name is not None: attributes["name"] = (name if (
        isinstance(name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    if inner_sym is not None: attributes["inner_sym"] = (inner_sym if (
        isinstance(inner_sym, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('InnerSymAttr')) else
          _ods_ir.AttrBuilder.get('InnerSymAttr')(inner_sym, context=_ods_context))
    if init is not None: attributes["init"] = (init if (
        isinstance(init, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('FirMemInitAttr')) else
          _ods_ir.AttrBuilder.get('FirMemInitAttr')(init, context=_ods_context))
    if prefix is not None: attributes["prefix"] = (prefix if (
        isinstance(prefix, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(prefix, context=_ods_context))
    if output_file is not None: attributes["output_file"] = (output_file if (
        isinstance(output_file, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('AnyAttr')) else
          _ods_ir.AttrBuilder.get('AnyAttr')(output_file, context=_ods_context))
    results = []
    results.append(memory)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def readLatency(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["readLatency"]

  @readLatency.setter
  def readLatency(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["readLatency"] = value

  @builtins.property
  def writeLatency(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["writeLatency"]

  @writeLatency.setter
  def writeLatency(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["writeLatency"] = value

  @builtins.property
  def ruw(self) -> _ods_ir.Attribute:
    return self.operation.attributes["ruw"]

  @ruw.setter
  def ruw(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ruw"] = value

  @builtins.property
  def wuw(self) -> _ods_ir.Attribute:
    return self.operation.attributes["wuw"]

  @wuw.setter
  def wuw(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["wuw"] = value

  @builtins.property
  def name(self) -> _Optional[_ods_ir.StringAttr]:
    if "name" not in self.operation.attributes:
      return None
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["name"] = value
    elif "name" in self.operation.attributes:
      del self.operation.attributes["name"]

  @name.deleter
  def name(self):
    del self.operation.attributes["name"]

  @builtins.property
  def inner_sym(self) -> _Optional[_ods_ir.Attribute]:
    if "inner_sym" not in self.operation.attributes:
      return None
    return self.operation.attributes["inner_sym"]

  @inner_sym.setter
  def inner_sym(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["inner_sym"] = value
    elif "inner_sym" in self.operation.attributes:
      del self.operation.attributes["inner_sym"]

  @inner_sym.deleter
  def inner_sym(self):
    del self.operation.attributes["inner_sym"]

  @builtins.property
  def init(self) -> _Optional[_ods_ir.Attribute]:
    if "init" not in self.operation.attributes:
      return None
    return self.operation.attributes["init"]

  @init.setter
  def init(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["init"] = value
    elif "init" in self.operation.attributes:
      del self.operation.attributes["init"]

  @init.deleter
  def init(self):
    del self.operation.attributes["init"]

  @builtins.property
  def prefix(self) -> _Optional[_ods_ir.StringAttr]:
    if "prefix" not in self.operation.attributes:
      return None
    return self.operation.attributes["prefix"]

  @prefix.setter
  def prefix(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["prefix"] = value
    elif "prefix" in self.operation.attributes:
      del self.operation.attributes["prefix"]

  @prefix.deleter
  def prefix(self):
    del self.operation.attributes["prefix"]

  @builtins.property
  def output_file(self) -> _Optional[_ods_ir.Attribute]:
    if "output_file" not in self.operation.attributes:
      return None
    return self.operation.attributes["output_file"]

  @output_file.setter
  def output_file(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["output_file"] = value
    elif "output_file" in self.operation.attributes:
      del self.operation.attributes["output_file"]

  @output_file.deleter
  def output_file(self):
    del self.operation.attributes["output_file"]

  @builtins.property
  def memory(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def firmem(memory, read_latency, write_latency, ruw, wuw, *, name=None, inner_sym=None, init=None, prefix=None, output_file=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FirMemOp(memory=memory, readLatency=read_latency, writeLatency=write_latency, ruw=ruw, wuw=wuw, name=name, inner_sym=inner_sym, init=init, prefix=prefix, output_file=output_file, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FirMemReadOp(_ods_ir.OpView):
  r"""
  The `seq.firmem.read_port` op represents a read port on a `seq.firmem`
  memory. It takes the memory as an operand, together with the address to
  be read, the clock on which the read is synchronized, and an optional
  enable. Omitting the enable operand has the same effect as passing a
  constant `true` to it.
  """

  OPERATION_NAME = "seq.firmem.read_port"

  _ODS_REGIONS = (0, True)

  def __init__(self, memory, address, clk, *, enable=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(memory)
    operands.append(address)
    operands.append(clk)
    if enable is not None: operands.append(enable)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def memory(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def address(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def clk(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def enable(self) -> _Optional[_ods_ir.Value[_ods_ir.IntegerType]]:
    return None if len(self.operation.operands) < 4 else self.operation.operands[3]

  @builtins.property
  def data(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def firmem_read_port(memory, address, clk, *, enable=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FirMemReadOp(memory=memory, address=address, clk=clk, enable=enable, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FirMemReadWriteOp(_ods_ir.OpView):
  r"""
  The `seq.firmem.read_write_port` op represents a read-write port on a
  `seq.firmem` memory. It takes the memory as an operand, together with the
  address and data to be written, a mode operand indicating whether the port
  should perform a read (`mode=0`) or a write (`mode=1`), the clock on which
  the read and write is synchronized, an optional enable, and and optional
  write mask. Omitting the enable operand has the same effect as passing a
  constant `true` to it. Omitting the write mask operand has the same effect
  as passing an all-ones value to it. A write mask operand can only be present
  if the `seq.firmem` specifies a mask width; otherwise it must be omitted.
  """

  OPERATION_NAME = "seq.firmem.read_write_port"

  _ODS_OPERAND_SEGMENTS = [1,1,1,0,1,1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, memory, address, clk, writeData, mode, *, enable=None, mask=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(memory)
    operands.append(address)
    operands.append(clk)
    operands.append(enable)
    operands.append(writeData)
    operands.append(mode)
    operands.append(mask)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def memory(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def address(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def clk(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def enable(self) -> _Optional[_ods_ir.Value[_ods_ir.IntegerType]]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def writeData(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range[0]

  @builtins.property
  def mode(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 5)
    return operand_range[0]

  @builtins.property
  def mask(self) -> _Optional[_ods_ir.Value[_ods_ir.IntegerType]]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 6)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def readData(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def firmem_read_write_port(memory, address, clk, write_data, mode, *, enable=None, mask=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FirMemReadWriteOp(memory=memory, address=address, clk=clk, writeData=write_data, mode=mode, enable=enable, mask=mask, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FirMemWriteOp(_ods_ir.OpView):
  r"""
  The `seq.firmem.write_port` op represents a write port on a `seq.firmem`
  memory. It takes the memory as an operand, together with the address and
  data to be written, the clock on which the write is synchronized, an
  optional enable, and and optional write mask. Omitting the enable operand
  has the same effect as passing a constant `true` to it. Omitting the write
  mask operand has the same effect as passing an all-ones value to it. A write
  mask operand can only be present if the `seq.firmem` specifies a mask width;
  otherwise it must be omitted.
  """

  OPERATION_NAME = "seq.firmem.write_port"

  _ODS_OPERAND_SEGMENTS = [1,1,1,0,1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, memory, address, clk, data, *, enable=None, mask=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(memory)
    operands.append(address)
    operands.append(clk)
    operands.append(enable)
    operands.append(data)
    operands.append(mask)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def memory(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def address(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def clk(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def enable(self) -> _Optional[_ods_ir.Value[_ods_ir.IntegerType]]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def data(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range[0]

  @builtins.property
  def mask(self) -> _Optional[_ods_ir.Value[_ods_ir.IntegerType]]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 5)
    return operand_range[0] if len(operand_range) > 0 else None

def firmem_write_port(memory, address, clk, data, *, enable=None, mask=None, loc=None, ip=None) -> FirMemWriteOp:
  return FirMemWriteOp(memory=memory, address=address, clk=clk, data=data, enable=enable, mask=mask, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class FirRegOp(_ods_ir.OpView):
  r"""
  `firreg` represents registers originating from FIRRTL after the lowering
  of the IR to HW.  The register is used as an intermediary in the process
  of lowering to SystemVerilog to facilitate optimisation at the HW level,
  compactly representing a register with a single operation instead of
  composing it from register definitions, always blocks and if statements.
  
  The `data` output of the register accesses the value it stores.  On the
  rising edge of the `clk` input, the register takes a new value provided
  by the `next` signal.  Optionally, the register can also be provided with
  a synchronous or an asynchronous `reset` signal and `resetValue`, as shown
  in the example below.
  
  ```
  %name = seq.firreg %next clock %clk [ sym @sym ]
      [ reset (sync|async) %reset, %value ]
      [ preset value ] : type
  ```
  
  Implicitly, all registers are pre-set to a randomized value.
  
  A register implementing a counter starting at 0 from reset can be defined
  as follows:
  
  ```
  %zero = hw.constant 0 : i32
  %reg = seq.firreg %next clock %clk reset sync %reset, %zero : i32
  %one = hw.constant 1 : i32
  %next = comb.add %reg, %one : i32
  ```
  """

  OPERATION_NAME = "seq.firreg"

  _ODS_REGIONS = (0, True)

  def __init__(self, next, clk, name, *, inner_sym=None, preset=None, reset=None, resetValue=None, isAsync=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(next)
    operands.append(clk)
    if reset is not None: operands.append(reset)
    if resetValue is not None: operands.append(resetValue)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["name"] = (name if (
    isinstance(name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    if inner_sym is not None: attributes["inner_sym"] = (inner_sym if (
        isinstance(inner_sym, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('InnerSymAttr')) else
          _ods_ir.AttrBuilder.get('InnerSymAttr')(inner_sym, context=_ods_context))
    if preset is not None: attributes["preset"] = (preset if (
        isinstance(preset, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('APIntAttr')) else
          _ods_ir.AttrBuilder.get('APIntAttr')(preset, context=_ods_context))
    if bool(isAsync): attributes["isAsync"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def next(self) -> _ods_ir.Value:
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 2, 2, 0, 0)
    return self.operation.operands[start]

  @builtins.property
  def clk(self) -> _ods_ir.Value:
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 2, 2, 1, 0)
    return self.operation.operands[start]

  @builtins.property
  def reset(self) -> _ods_ir.OpOperandList:
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 2, 2, 2, 0)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def resetValue(self) -> _ods_ir.OpOperandList:
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 2, 2, 2, 1)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

  @builtins.property
  def inner_sym(self) -> _Optional[_ods_ir.Attribute]:
    if "inner_sym" not in self.operation.attributes:
      return None
    return self.operation.attributes["inner_sym"]

  @inner_sym.setter
  def inner_sym(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["inner_sym"] = value
    elif "inner_sym" in self.operation.attributes:
      del self.operation.attributes["inner_sym"]

  @inner_sym.deleter
  def inner_sym(self):
    del self.operation.attributes["inner_sym"]

  @builtins.property
  def preset(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "preset" not in self.operation.attributes:
      return None
    return self.operation.attributes["preset"]

  @preset.setter
  def preset(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["preset"] = value
    elif "preset" in self.operation.attributes:
      del self.operation.attributes["preset"]

  @preset.deleter
  def preset(self):
    del self.operation.attributes["preset"]

  @builtins.property
  def isAsync(self) -> bool:
    return "isAsync" in self.operation.attributes

  @isAsync.setter
  def isAsync(self, value):
    if bool(value):
      self.operation.attributes["isAsync"] = _ods_ir.UnitAttr.get()
    elif "isAsync" in self.operation.attributes:
      del self.operation.attributes["isAsync"]

  @isAsync.deleter
  def isAsync(self):
    del self.operation.attributes["isAsync"]

  @builtins.property
  def data(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def firreg(next, clk, name, *, inner_sym=None, preset=None, reset=None, reset_value=None, is_async=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FirRegOp(next=next, clk=clk, name=name, inner_sym=inner_sym, preset=preset, reset=reset, resetValue=reset_value, isAsync=is_async, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FromClockOp(_ods_ir.OpView):
  OPERATION_NAME = "seq.from_clock"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def from_clock(input, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FromClockOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FromImmutableOp(_ods_ir.OpView):
  OPERATION_NAME = "seq.from_immutable"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def from_immutable(output, input, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return FromImmutableOp(output=output, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class HLMemOp(_ods_ir.OpView):
  r"""
  See the Seq dialect rationale for a longer description
  """

  OPERATION_NAME = "seq.hlmem"

  _ODS_REGIONS = (0, True)

  def __init__(self, handle, clk, rst, name, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(clk)
    operands.append(rst)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["name"] = (name if (
    isinstance(name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(name, context=_ods_context))
    results = []
    results.append(handle)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def clk(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rst(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

  @builtins.property
  def handle(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def hlmem(handle, clk, rst, name, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return HLMemOp(handle=handle, clk=clk, rst=rst, name=name, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class InitialOp(_ods_ir.OpView):
  r"""
  `seq.initial` op creates values wrapped types with !seq.immutable.
  See the Seq dialect rationale for a longer description.
  """

  OPERATION_NAME = "seq.initial"

  _ODS_REGIONS = (1, True)

  def __init__(self, result, inputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def initial(result, inputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, InitialOp]:
  op = InitialOp(result=result, inputs=inputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class ReadPortOp(_ods_ir.OpView):
  OPERATION_NAME = "seq.read"

  _ODS_OPERAND_SEGMENTS = [1,-1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, readData, memory, addresses, latency, *, rdEn=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(memory)
    operands.append(_get_op_results_or_values(addresses))
    operands.append(rdEn)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["latency"] = (latency if (
    isinstance(latency, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(latency, context=_ods_context))
    results = []
    results.append(readData)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def memory(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def addresses(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def rdEn(self) -> _Optional[_ods_ir.Value[_ods_ir.IntegerType]]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def latency(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["latency"]

  @latency.setter
  def latency(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["latency"] = value

  @builtins.property
  def readData(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def read(read_data, memory, addresses, latency, *, rd_en=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ReadPortOp(readData=read_data, memory=memory, addresses=addresses, latency=latency, rdEn=rd_en, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ShiftRegOp(_ods_ir.OpView):
  r"""
  The `seq.shiftreg` op represents a shift register. It takes the input
  value and shifts it every cycle when `clockEnable` is asserted.
  The `reset` and `resetValue` operands are optional and if present, every
  entry in the shift register will be initialized to `resetValue` upon
  assertion of the reset signal. Exact reset behavior (sync/async) is
  implementation defined.
  """

  OPERATION_NAME = "seq.shiftreg"

  _ODS_OPERAND_SEGMENTS = [1,1,1,0,0,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, numElements, input, clk, clockEnable, *, name=None, reset=None, resetValue=None, powerOnValue=None, inner_sym=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(clk)
    operands.append(clockEnable)
    operands.append(reset)
    operands.append(resetValue)
    operands.append(powerOnValue)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["numElements"] = (numElements if (
    isinstance(numElements, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(numElements, context=_ods_context))
    if name is not None: attributes["name"] = (name if (
        isinstance(name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    if inner_sym is not None: attributes["inner_sym"] = (inner_sym if (
        isinstance(inner_sym, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('InnerSymAttr')) else
          _ods_ir.AttrBuilder.get('InnerSymAttr')(inner_sym, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def clk(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def clockEnable(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def reset(self) -> _Optional[_ods_ir.Value[_ods_ir.IntegerType]]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def resetValue(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def powerOnValue(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 5)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def numElements(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["numElements"]

  @numElements.setter
  def numElements(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["numElements"] = value

  @builtins.property
  def name(self) -> _Optional[_ods_ir.StringAttr]:
    if "name" not in self.operation.attributes:
      return None
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["name"] = value
    elif "name" in self.operation.attributes:
      del self.operation.attributes["name"]

  @name.deleter
  def name(self):
    del self.operation.attributes["name"]

  @builtins.property
  def inner_sym(self) -> _Optional[_ods_ir.Attribute]:
    if "inner_sym" not in self.operation.attributes:
      return None
    return self.operation.attributes["inner_sym"]

  @inner_sym.setter
  def inner_sym(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["inner_sym"] = value
    elif "inner_sym" in self.operation.attributes:
      del self.operation.attributes["inner_sym"]

  @inner_sym.deleter
  def inner_sym(self):
    del self.operation.attributes["inner_sym"]

  @builtins.property
  def data(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def shiftreg(num_elements, input, clk, clock_enable, *, name=None, reset=None, reset_value=None, power_on_value=None, inner_sym=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ShiftRegOp(numElements=num_elements, input=input, clk=clk, clockEnable=clock_enable, name=name, reset=reset, resetValue=reset_value, powerOnValue=power_on_value, inner_sym=inner_sym, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ToClockOp(_ods_ir.OpView):
  OPERATION_NAME = "seq.to_clock"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def to_clock(input, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ToClockOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class WritePortOp(_ods_ir.OpView):
  OPERATION_NAME = "seq.write"

  _ODS_REGIONS = (0, True)

  def __init__(self, memory, addresses, inData, wrEn, latency, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(memory)
    operands.extend(_get_op_results_or_values(addresses))
    operands.append(inData)
    operands.append(wrEn)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["latency"] = (latency if (
    isinstance(latency, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(latency, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def memory(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def addresses(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 4 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def inData(self) -> _ods_ir.Value:
    _ods_variadic_group_length = len(self.operation.operands) - 4 + 1
    return self.operation.operands[2 + _ods_variadic_group_length - 1]

  @builtins.property
  def wrEn(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    _ods_variadic_group_length = len(self.operation.operands) - 4 + 1
    return self.operation.operands[3 + _ods_variadic_group_length - 1]

  @builtins.property
  def latency(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["latency"]

  @latency.setter
  def latency(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["latency"] = value

def write(memory, addresses, in_data, wr_en, latency, *, loc=None, ip=None) -> WritePortOp:
  return WritePortOp(memory=memory, addresses=addresses, inData=in_data, wrEn=wr_en, latency=latency, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class YieldOp(_ods_ir.OpView):
  OPERATION_NAME = "seq.yield"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def yield_(operands_, *, loc=None, ip=None) -> YieldOp:
  return YieldOp(operands_=operands_, loc=loc, ip=ip)
