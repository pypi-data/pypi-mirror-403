
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "index"

@_ods_cext.register_operation(_Dialect)
class AddOp(_ods_ir.OpView):
  r"""
  The `index.add` operation takes two index values and computes their sum.
  
  Example:
  
  ```mlir
  // c = a + b
  %c = index.add %a, %b
  ```
  """

  OPERATION_NAME = "index.add"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def add(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AddOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AndOp(_ods_ir.OpView):
  r"""
  The `index.and` operation takes two index values and computes their bitwise
  and.
  
  Example:
  
  ```mlir
  // c = a & b
  %c = index.and %a, %b
  ```
  """

  OPERATION_NAME = "index.and"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def and_(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AndOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BoolConstantOp(_ods_ir.OpView):
  r"""
  The `index.bool.constant` operation produces an bool-typed SSA value equal
  to either `true` or `false`.
  
  This operation is used to materialize bool constants that arise when folding
  `index.cmp`.
  
  Example:
  
  ```mlir
  %0 = index.bool.constant true
  ```
  """

  OPERATION_NAME = "index.bool.constant"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(value, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def bool_constant(value, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BoolConstantOp(value=value, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CastSOp(_ods_ir.OpView):
  r"""
  The `index.casts` operation enables conversions between values of index type
  and concrete fixed-width integer types. If casting to a wider integer, the
  value is sign-extended. If casting to a narrower integer, the value is
  truncated.
  
  Example:
  
  ```mlir
  // Cast to i32
  %0 = index.casts %a : index to i32
  
  // Cast from i64
  %1 = index.casts %b : i64 to index
  ```
  """

  OPERATION_NAME = "index.casts"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def casts(output, input, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CastSOp(output=output, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CastUOp(_ods_ir.OpView):
  r"""
  The `index.castu` operation enables conversions between values of index type
  and concrete fixed-width integer types. If casting to a wider integer, the
  value is zero-extended. If casting to a narrower integer, the value is
  truncated.
  
  Example:
  
  ```mlir
  // Cast to i32
  %0 = index.castu %a : index to i32
  
  // Cast from i64
  %1 = index.castu %b : i64 to index
  ```
  """

  OPERATION_NAME = "index.castu"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def castu(output, input, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CastUOp(output=output, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CeilDivSOp(_ods_ir.OpView):
  r"""
  The `index.ceildivs` operation takes two index values and computes their
  signed quotient. Treats the leading bit as the sign and rounds towards
  positive infinity, i.e. `7 / -2 = -3`.
  
  Note: division by zero and signed division overflow are undefined behaviour.
  
  Example:
  
  ```mlir
  // c = ceil(a / b)
  %c = index.ceildivs %a, %b
  ```
  """

  OPERATION_NAME = "index.ceildivs"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def ceildivs(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CeilDivSOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CeilDivUOp(_ods_ir.OpView):
  r"""
  The `index.ceildivu` operation takes two index values and computes their
  unsigned quotient. Treats the leading bit as the most significant and rounds
  towards positive infinity, i.e. `6 / -2 = 1`.
  
  Note: division by zero is undefined behaviour.
  
  Example:
  
  ```mlir
  // c = ceil(a / b)
  %c = index.ceildivu %a, %b
  ```
  """

  OPERATION_NAME = "index.ceildivu"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def ceildivu(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CeilDivUOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpOp(_ods_ir.OpView):
  r"""
  The `index.cmp` operation takes two index values and compares them according
  to the comparison predicate and returns an `i1`. The following comparisons
  are supported:
  
  -   `eq`:  equal
  -   `ne`:  not equal
  -   `slt`: signed less than
  -   `sle`: signed less than or equal
  -   `sgt`: signed greater than
  -   `sge`: signed greater than or equal
  -   `ult`: unsigned less than
  -   `ule`: unsigned less than or equal
  -   `ugt`: unsigned greater than
  -   `uge`: unsigned greater than or equal
  
  The result is `1` if the comparison is true and `0` otherwise.
  
  Example:
  
  ```mlir
  // Signed less than comparison.
  %0 = index.cmp slt(%a, %b)
  
  // Unsigned greater than or equal comparison.
  %1 = index.cmp uge(%a, %b)
  
  // Not equal comparison.
  %2 = index.cmp ne(%a, %b)
  ```
  """

  OPERATION_NAME = "index.cmp"

  _ODS_REGIONS = (0, True)

  def __init__(self, pred, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["pred"] = (pred if (
    isinstance(pred, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexCmpPredicateAttr')) else
      _ods_ir.AttrBuilder.get('IndexCmpPredicateAttr')(pred, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def pred(self) -> _ods_ir.Attribute:
    return self.operation.attributes["pred"]

  @pred.setter
  def pred(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pred"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def cmp(pred, lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CmpOp(pred=pred, lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConstantOp(_ods_ir.OpView):
  r"""
  The `index.constant` operation produces an index-typed SSA value equal to
  some index-typed integer constant.
  
  Example:
  
  ```mlir
  %0 = index.constant 42
  ```
  """

  OPERATION_NAME = "index.constant"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(value, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def constant(value, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConstantOp(value=value, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DivSOp(_ods_ir.OpView):
  r"""
  The `index.divs` operation takes two index values and computes their signed
  quotient. Treats the leading bit as the sign and rounds towards zero, i.e.
  `6 / -2 = -3`.
  
  Note: division by zero and signed division overflow are undefined behaviour.
  
  Example:
  
  ```mlir
  // c = a / b
  %c = index.divs %a, %b
  ```
  """

  OPERATION_NAME = "index.divs"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def divs(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return DivSOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DivUOp(_ods_ir.OpView):
  r"""
  The `index.divu` operation takes two index values and computes their
  unsigned quotient. Treats the leading bit as the most significant and rounds
  towards zero, i.e. `6 / -2 = 0`.
  
  Note: division by zero is undefined behaviour.
  
  Example:
  
  ```mlir
  // c = a / b
  %c = index.divu %a, %b
  ```
  """

  OPERATION_NAME = "index.divu"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def divu(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return DivUOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FloorDivSOp(_ods_ir.OpView):
  r"""
  The `index.floordivs` operation takes two index values and computes their
  signed quotient. Treats the leading bit as the sign and rounds towards
  negative infinity, i.e. `5 / -2 = -3`.
  
  Note: division by zero and signed division overflow are undefined behaviour.
  
  Example:
  
  ```mlir
  // c = floor(a / b)
  %c = index.floordivs %a, %b
  ```
  """

  OPERATION_NAME = "index.floordivs"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def floordivs(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FloorDivSOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MaxSOp(_ods_ir.OpView):
  r"""
  The `index.maxs` operation takes two index values and computes their signed
  maximum value. Treats the leading bit as the sign, i.e. `max(-2, 6) = 6`.
  
  Example:
  
  ```mlir
  // c = max(a, b)
  %c = index.maxs %a, %b
  ```
  """

  OPERATION_NAME = "index.maxs"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def maxs(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MaxSOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MaxUOp(_ods_ir.OpView):
  r"""
  The `index.maxu` operation takes two index values and computes their
  unsigned maximum value. Treats the leading bit as the most significant, i.e.
  `max(15, 6) = 15` or `max(-2, 6) = -2`.
  
  Example:
  
  ```mlir
  // c = max(a, b)
  %c = index.maxu %a, %b
  ```
  """

  OPERATION_NAME = "index.maxu"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def maxu(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MaxUOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MinSOp(_ods_ir.OpView):
  r"""
  The `index.mins` operation takes two index values and computes their signed
  minimum value. Treats the leading bit as the sign, i.e. `min(-2, 6) = -2`.
  
  Example:
  
  ```mlir
  // c = min(a, b)
  %c = index.mins %a, %b
  ```
  """

  OPERATION_NAME = "index.mins"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def mins(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MinSOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MinUOp(_ods_ir.OpView):
  r"""
  The `index.minu` operation takes two index values and computes their
  unsigned minimum value. Treats the leading bit as the most significant, i.e.
  `min(15, 6) = 6` or `min(-2, 6) = 6`.
  
  Example:
  
  ```mlir
  // c = min(a, b)
  %c = index.minu %a, %b
  ```
  """

  OPERATION_NAME = "index.minu"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def minu(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MinUOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MulOp(_ods_ir.OpView):
  r"""
  The `index.mul` operation takes two index values and computes their product.
  
  Example:
  
  ```mlir
  // c = a * b
  %c = index.mul %a, %b
  ```
  """

  OPERATION_NAME = "index.mul"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def mul(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MulOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class OrOp(_ods_ir.OpView):
  r"""
  The `index.or` operation takes two index values and computes their bitwise
  or.
  
  Example:
  
  ```mlir
  // c = a | b
  %c = index.or %a, %b
  ```
  """

  OPERATION_NAME = "index.or"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def or_(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return OrOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RemSOp(_ods_ir.OpView):
  r"""
  The `index.rems` operation takes two index values and computes their signed
  remainder. Treats the leading bit as the sign, i.e. `6 % -2 = 0`.
  
  Example:
  
  ```mlir
  // c = a % b
  %c = index.rems %a, %b
  ```
  """

  OPERATION_NAME = "index.rems"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def rems(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return RemSOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RemUOp(_ods_ir.OpView):
  r"""
  The `index.remu` operation takes two index values and computes their
  unsigned remainder. Treats the leading bit as the most significant, i.e.
  `6 % -2 = 6`.
  
  Example:
  
  ```mlir
  // c = a % b
  %c = index.remu %a, %b
  ```
  """

  OPERATION_NAME = "index.remu"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def remu(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return RemUOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ShlOp(_ods_ir.OpView):
  r"""
  The `index.shl` operation shifts an index value to the left by a variable
  amount. The low order bits are filled with zeroes. The RHS operand is always
  treated as unsigned. If the RHS operand is equal to or greater than the
  index bitwidth, the result is a poison value.
  
  Example:
  
  ```mlir
  // c = a << b
  %c = index.shl %a, %b
  ```
  """

  OPERATION_NAME = "index.shl"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def shl(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ShlOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ShrSOp(_ods_ir.OpView):
  r"""
  The `index.shrs` operation shifts an index value to the right by a variable
  amount. The LHS operand is treated as signed. The high order bits are filled
  with copies of the most significant bit. If the RHS operand is equal to or
  greater than the index bitwidth, the result is a poison value.
  
  Example:
  
  ```mlir
  // c = a >> b
  %c = index.shrs %a, %b
  ```
  """

  OPERATION_NAME = "index.shrs"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def shrs(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ShrSOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ShrUOp(_ods_ir.OpView):
  r"""
  The `index.shru` operation shifts an index value to the right by a variable
  amount. The LHS operand is treated as unsigned. The high order bits are
  filled with zeroes. If the RHS operand is equal to or greater than the index
  bitwidth, the result is a poison value.
  
  Example:
  
  ```mlir
  // c = a >> b
  %c = index.shru %a, %b
  ```
  """

  OPERATION_NAME = "index.shru"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def shru(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ShrUOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SizeOfOp(_ods_ir.OpView):
  r"""
  The `index.sizeof` operation produces an index-typed SSA value equal to the
  size in bits of the `index` type. For example, on 32-bit systems, the result
  is `32 : index`, and on 64-bit systems, the result is `64 : index`.
  
  Example:
  
  ```mlir
  %0 = index.sizeof
  ```
  """

  OPERATION_NAME = "index.sizeof"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def sizeof(*, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return SizeOfOp(results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SubOp(_ods_ir.OpView):
  r"""
  The `index.sub` operation takes two index values and computes the difference
  of the first from the second operand.
  
  Example:
  
  ```mlir
  // c = a - b
  %c = index.sub %a, %b
  ```
  """

  OPERATION_NAME = "index.sub"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def sub(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return SubOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class XOrOp(_ods_ir.OpView):
  r"""
  The `index.xor` operation takes two index values and computes their bitwise
  xor.
  
  Example:
  
  ```mlir
  // c = a ^ b
  %c = index.xor %a, %b
  ```
  """

  OPERATION_NAME = "index.xor"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def xor(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return XOrOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result
