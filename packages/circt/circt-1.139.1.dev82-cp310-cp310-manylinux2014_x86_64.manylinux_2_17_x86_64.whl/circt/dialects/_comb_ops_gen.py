
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "comb"

@_ods_cext.register_operation(_Dialect)
class AddOp(_ods_ir.OpView):
  OPERATION_NAME = "comb.add"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, *, twoState=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(twoState): attributes["twoState"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def twoState(self) -> bool:
    return "twoState" in self.operation.attributes

  @twoState.setter
  def twoState(self, value):
    if bool(value):
      self.operation.attributes["twoState"] = _ods_ir.UnitAttr.get()
    elif "twoState" in self.operation.attributes:
      del self.operation.attributes["twoState"]

  @twoState.deleter
  def twoState(self):
    del self.operation.attributes["twoState"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def add(inputs, *, two_state=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AddOp(inputs=inputs, twoState=two_state, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AndOp(_ods_ir.OpView):
  OPERATION_NAME = "comb.and"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, *, twoState=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(twoState): attributes["twoState"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def twoState(self) -> bool:
    return "twoState" in self.operation.attributes

  @twoState.setter
  def twoState(self, value):
    if bool(value):
      self.operation.attributes["twoState"] = _ods_ir.UnitAttr.get()
    elif "twoState" in self.operation.attributes:
      del self.operation.attributes["twoState"]

  @twoState.deleter
  def twoState(self):
    del self.operation.attributes["twoState"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def and_(inputs, *, two_state=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AndOp(inputs=inputs, twoState=two_state, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConcatOp(_ods_ir.OpView):
  r"""
  See the comb rationale document for details on operand ordering.
  """

  OPERATION_NAME = "comb.concat"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def concat(inputs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConcatOp(inputs=inputs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DivSOp(_ods_ir.OpView):
  OPERATION_NAME = "comb.divs"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, twoState=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(twoState): attributes["twoState"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def twoState(self) -> bool:
    return "twoState" in self.operation.attributes

  @twoState.setter
  def twoState(self, value):
    if bool(value):
      self.operation.attributes["twoState"] = _ods_ir.UnitAttr.get()
    elif "twoState" in self.operation.attributes:
      del self.operation.attributes["twoState"]

  @twoState.deleter
  def twoState(self):
    del self.operation.attributes["twoState"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def divs(lhs, rhs, *, two_state=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return DivSOp(lhs=lhs, rhs=rhs, twoState=two_state, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DivUOp(_ods_ir.OpView):
  OPERATION_NAME = "comb.divu"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, twoState=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(twoState): attributes["twoState"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def twoState(self) -> bool:
    return "twoState" in self.operation.attributes

  @twoState.setter
  def twoState(self, value):
    if bool(value):
      self.operation.attributes["twoState"] = _ods_ir.UnitAttr.get()
    elif "twoState" in self.operation.attributes:
      del self.operation.attributes["twoState"]

  @twoState.deleter
  def twoState(self):
    del self.operation.attributes["twoState"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def divu(lhs, rhs, *, two_state=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return DivUOp(lhs=lhs, rhs=rhs, twoState=two_state, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExtractOp(_ods_ir.OpView):
  OPERATION_NAME = "comb.extract"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, lowBit, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["lowBit"] = (lowBit if (
    isinstance(lowBit, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(lowBit, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def lowBit(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["lowBit"]

  @lowBit.setter
  def lowBit(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["lowBit"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def extract(result, input, low_bit, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ExtractOp(result=result, input=input, lowBit=low_bit, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ICmpOp(_ods_ir.OpView):
  r"""
  This operation compares two integers using a predicate.  If the predicate is
  true, returns 1, otherwise returns 0. This operation always returns a one
  bit wide result.
  
  ```
      %r = comb.icmp eq %a, %b : i4
  ```
  """

  OPERATION_NAME = "comb.icmp"

  _ODS_REGIONS = (0, True)

  def __init__(self, predicate, lhs, rhs, *, twoState=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["predicate"] = (predicate if (
    isinstance(predicate, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ICmpPredicate')) else
      _ods_ir.AttrBuilder.get('ICmpPredicate')(predicate, context=_ods_context))
    if bool(twoState): attributes["twoState"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def predicate(self) -> _ods_ir.Attribute:
    return self.operation.attributes["predicate"]

  @predicate.setter
  def predicate(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["predicate"] = value

  @builtins.property
  def twoState(self) -> bool:
    return "twoState" in self.operation.attributes

  @twoState.setter
  def twoState(self, value):
    if bool(value):
      self.operation.attributes["twoState"] = _ods_ir.UnitAttr.get()
    elif "twoState" in self.operation.attributes:
      del self.operation.attributes["twoState"]

  @twoState.deleter
  def twoState(self):
    del self.operation.attributes["twoState"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def icmp(predicate, lhs, rhs, *, two_state=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ICmpOp(predicate=predicate, lhs=lhs, rhs=rhs, twoState=two_state, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ModSOp(_ods_ir.OpView):
  OPERATION_NAME = "comb.mods"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, twoState=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(twoState): attributes["twoState"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def twoState(self) -> bool:
    return "twoState" in self.operation.attributes

  @twoState.setter
  def twoState(self, value):
    if bool(value):
      self.operation.attributes["twoState"] = _ods_ir.UnitAttr.get()
    elif "twoState" in self.operation.attributes:
      del self.operation.attributes["twoState"]

  @twoState.deleter
  def twoState(self):
    del self.operation.attributes["twoState"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mods(lhs, rhs, *, two_state=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ModSOp(lhs=lhs, rhs=rhs, twoState=two_state, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ModUOp(_ods_ir.OpView):
  OPERATION_NAME = "comb.modu"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, twoState=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(twoState): attributes["twoState"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def twoState(self) -> bool:
    return "twoState" in self.operation.attributes

  @twoState.setter
  def twoState(self, value):
    if bool(value):
      self.operation.attributes["twoState"] = _ods_ir.UnitAttr.get()
    elif "twoState" in self.operation.attributes:
      del self.operation.attributes["twoState"]

  @twoState.deleter
  def twoState(self):
    del self.operation.attributes["twoState"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def modu(lhs, rhs, *, two_state=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ModUOp(lhs=lhs, rhs=rhs, twoState=two_state, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MulOp(_ods_ir.OpView):
  OPERATION_NAME = "comb.mul"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, *, twoState=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(twoState): attributes["twoState"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def twoState(self) -> bool:
    return "twoState" in self.operation.attributes

  @twoState.setter
  def twoState(self, value):
    if bool(value):
      self.operation.attributes["twoState"] = _ods_ir.UnitAttr.get()
    elif "twoState" in self.operation.attributes:
      del self.operation.attributes["twoState"]

  @twoState.deleter
  def twoState(self):
    del self.operation.attributes["twoState"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mul(inputs, *, two_state=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MulOp(inputs=inputs, twoState=two_state, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MuxOp(_ods_ir.OpView):
  r"""
  ```
    %0 = mux %pred, %tvalue, %fvalue : i4
  ```
  """

  OPERATION_NAME = "comb.mux"

  _ODS_REGIONS = (0, True)

  def __init__(self, cond, trueValue, falseValue, *, twoState=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(cond)
    operands.append(trueValue)
    operands.append(falseValue)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(twoState): attributes["twoState"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def cond(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def trueValue(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def falseValue(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def twoState(self) -> bool:
    return "twoState" in self.operation.attributes

  @twoState.setter
  def twoState(self, value):
    if bool(value):
      self.operation.attributes["twoState"] = _ods_ir.UnitAttr.get()
    elif "twoState" in self.operation.attributes:
      del self.operation.attributes["twoState"]

  @twoState.deleter
  def twoState(self):
    del self.operation.attributes["twoState"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mux(cond, true_value, false_value, *, two_state=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MuxOp(cond=cond, trueValue=true_value, falseValue=false_value, twoState=two_state, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class OrOp(_ods_ir.OpView):
  OPERATION_NAME = "comb.or"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, *, twoState=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(twoState): attributes["twoState"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def twoState(self) -> bool:
    return "twoState" in self.operation.attributes

  @twoState.setter
  def twoState(self, value):
    if bool(value):
      self.operation.attributes["twoState"] = _ods_ir.UnitAttr.get()
    elif "twoState" in self.operation.attributes:
      del self.operation.attributes["twoState"]

  @twoState.deleter
  def twoState(self):
    del self.operation.attributes["twoState"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def or_(inputs, *, two_state=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return OrOp(inputs=inputs, twoState=two_state, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ParityOp(_ods_ir.OpView):
  OPERATION_NAME = "comb.parity"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, twoState=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(twoState): attributes["twoState"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def twoState(self) -> bool:
    return "twoState" in self.operation.attributes

  @twoState.setter
  def twoState(self, value):
    if bool(value):
      self.operation.attributes["twoState"] = _ods_ir.UnitAttr.get()
    elif "twoState" in self.operation.attributes:
      del self.operation.attributes["twoState"]

  @twoState.deleter
  def twoState(self):
    del self.operation.attributes["twoState"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def parity(input, *, two_state=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ParityOp(input=input, twoState=two_state, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReplicateOp(_ods_ir.OpView):
  OPERATION_NAME = "comb.replicate"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def replicate(result, input, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ReplicateOp(result=result, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReverseOp(_ods_ir.OpView):
  r"""
  Reverses the bit ordering of a value. The LSB becomes the MSB and vice versa.
  
  Example:
  ```mlir
    %out = comb.reverse %in : i4
  ```
  If %in is 4'b1101, then %out is 4'b1011.
  """

  OPERATION_NAME = "comb.reverse"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def reverse(input, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ReverseOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ShlOp(_ods_ir.OpView):
  OPERATION_NAME = "comb.shl"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, twoState=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(twoState): attributes["twoState"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def twoState(self) -> bool:
    return "twoState" in self.operation.attributes

  @twoState.setter
  def twoState(self, value):
    if bool(value):
      self.operation.attributes["twoState"] = _ods_ir.UnitAttr.get()
    elif "twoState" in self.operation.attributes:
      del self.operation.attributes["twoState"]

  @twoState.deleter
  def twoState(self):
    del self.operation.attributes["twoState"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def shl(lhs, rhs, *, two_state=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ShlOp(lhs=lhs, rhs=rhs, twoState=two_state, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ShrSOp(_ods_ir.OpView):
  OPERATION_NAME = "comb.shrs"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, twoState=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(twoState): attributes["twoState"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def twoState(self) -> bool:
    return "twoState" in self.operation.attributes

  @twoState.setter
  def twoState(self, value):
    if bool(value):
      self.operation.attributes["twoState"] = _ods_ir.UnitAttr.get()
    elif "twoState" in self.operation.attributes:
      del self.operation.attributes["twoState"]

  @twoState.deleter
  def twoState(self):
    del self.operation.attributes["twoState"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def shrs(lhs, rhs, *, two_state=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ShrSOp(lhs=lhs, rhs=rhs, twoState=two_state, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ShrUOp(_ods_ir.OpView):
  OPERATION_NAME = "comb.shru"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, twoState=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(twoState): attributes["twoState"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def twoState(self) -> bool:
    return "twoState" in self.operation.attributes

  @twoState.setter
  def twoState(self, value):
    if bool(value):
      self.operation.attributes["twoState"] = _ods_ir.UnitAttr.get()
    elif "twoState" in self.operation.attributes:
      del self.operation.attributes["twoState"]

  @twoState.deleter
  def twoState(self):
    del self.operation.attributes["twoState"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def shru(lhs, rhs, *, two_state=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ShrUOp(lhs=lhs, rhs=rhs, twoState=two_state, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SubOp(_ods_ir.OpView):
  OPERATION_NAME = "comb.sub"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, twoState=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(twoState): attributes["twoState"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def twoState(self) -> bool:
    return "twoState" in self.operation.attributes

  @twoState.setter
  def twoState(self, value):
    if bool(value):
      self.operation.attributes["twoState"] = _ods_ir.UnitAttr.get()
    elif "twoState" in self.operation.attributes:
      del self.operation.attributes["twoState"]

  @twoState.deleter
  def twoState(self):
    del self.operation.attributes["twoState"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def sub(lhs, rhs, *, two_state=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return SubOp(lhs=lhs, rhs=rhs, twoState=two_state, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TruthTableOp(_ods_ir.OpView):
  r"""
  ```
    %a = ... : i1
    %b = ... : i1
    %0 = comb.truth_table %a, %b -> [false, true, true, false]
  ```
  
  This operation assumes a fully elaborated table -- 2^n entries. Inputs are
  sorted MSB -> LSB from left to right and the offset into `lookupTable` is
  computed from them. The table is sorted from 0 -> (2^n - 1) from left to
  right.
  
  No difference from array_get into an array of constants except for xprop
  behavior. If one of the inputs is unknown, but said input doesn't make a
  difference in the output (based on the lookup table) the result should not
  be 'x' -- it should be the well-known result.
  """

  OPERATION_NAME = "comb.truth_table"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, lookupTable, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["lookupTable"] = (lookupTable if (
    isinstance(lookupTable, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseBoolArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseBoolArrayAttr')(lookupTable, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def lookupTable(self) -> _ods_ir.DenseBoolArrayAttr:
    return self.operation.attributes["lookupTable"]

  @lookupTable.setter
  def lookupTable(self, value: _ods_ir.DenseBoolArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["lookupTable"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def truth_table(inputs, lookup_table, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return TruthTableOp(inputs=inputs, lookupTable=lookup_table, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class XorOp(_ods_ir.OpView):
  OPERATION_NAME = "comb.xor"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, *, twoState=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(twoState): attributes["twoState"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def twoState(self) -> bool:
    return "twoState" in self.operation.attributes

  @twoState.setter
  def twoState(self, value):
    if bool(value):
      self.operation.attributes["twoState"] = _ods_ir.UnitAttr.get()
    elif "twoState" in self.operation.attributes:
      del self.operation.attributes["twoState"]

  @twoState.deleter
  def twoState(self):
    del self.operation.attributes["twoState"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def xor(inputs, *, two_state=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return XorOp(inputs=inputs, twoState=two_state, results=results, loc=loc, ip=ip).result
