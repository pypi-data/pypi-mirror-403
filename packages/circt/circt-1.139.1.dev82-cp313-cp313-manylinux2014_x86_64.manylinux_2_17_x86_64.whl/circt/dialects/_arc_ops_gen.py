
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "arc"

@_ods_cext.register_operation(_Dialect)
class AllocMemoryOp(_ods_ir.OpView):
  OPERATION_NAME = "arc.alloc_memory"

  _ODS_REGIONS = (0, True)

  def __init__(self, memory, storage, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(storage)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(memory)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def storage(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def memory(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def alloc_memory(memory, storage, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return AllocMemoryOp(memory=memory, storage=storage, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AllocStateOp(_ods_ir.OpView):
  OPERATION_NAME = "arc.alloc_state"

  _ODS_REGIONS = (0, True)

  def __init__(self, state, storage, *, tap=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(storage)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(tap): attributes["tap"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    results.append(state)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def storage(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def tap(self) -> bool:
    return "tap" in self.operation.attributes

  @tap.setter
  def tap(self, value):
    if bool(value):
      self.operation.attributes["tap"] = _ods_ir.UnitAttr.get()
    elif "tap" in self.operation.attributes:
      del self.operation.attributes["tap"]

  @tap.deleter
  def tap(self):
    del self.operation.attributes["tap"]

  @builtins.property
  def state(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def alloc_state(state, storage, *, tap=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AllocStateOp(state=state, storage=storage, tap=tap, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AllocStorageOp(_ods_ir.OpView):
  OPERATION_NAME = "arc.alloc_storage"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, offset=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if offset is not None: attributes["offset"] = (offset if (
        isinstance(offset, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(offset, context=_ods_context))
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def offset(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "offset" not in self.operation.attributes:
      return None
    return self.operation.attributes["offset"]

  @offset.setter
  def offset(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["offset"] = value
    elif "offset" in self.operation.attributes:
      del self.operation.attributes["offset"]

  @offset.deleter
  def offset(self):
    del self.operation.attributes["offset"]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def alloc_storage(output, input, *, offset=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AllocStorageOp(output=output, input=input, offset=offset, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CallOp(_ods_ir.OpView):
  OPERATION_NAME = "arc.call"

  _ODS_REGIONS = (0, True)

  def __init__(self, outputs, arc, inputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["arc"] = (arc if (
    isinstance(arc, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(arc, context=_ods_context))
    results = []
    results.extend(outputs)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def arc(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["arc"]

  @arc.setter
  def arc(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["arc"] = value

  @builtins.property
  def outputs(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def call(outputs, arc, inputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, CallOp]:
  op = CallOp(outputs=outputs, arc=arc, inputs=inputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class ClockDomainOp(_ods_ir.OpView):
  OPERATION_NAME = "arc.clock_domain"

  _ODS_REGIONS = (1, True)

  def __init__(self, outputs, inputs, clock, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    operands.append(clock)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(outputs)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def clock(self) -> _ods_ir.Value:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1 + _ods_variadic_group_length - 1]

  @builtins.property
  def outputs(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def clock_domain(outputs, inputs, clock, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, ClockDomainOp]:
  op = ClockDomainOp(outputs=outputs, inputs=inputs, clock=clock, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class DefineOp(_ods_ir.OpView):
  OPERATION_NAME = "arc.define"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, function_type, *, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["function_type"] = (function_type if (
    isinstance(function_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_505')) else
      _ods_ir.AttrBuilder.get('anonymous_505')(function_type, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def function_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["function_type"]

  @function_type.setter
  def function_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["function_type"] = value

  @builtins.property
  def arg_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def define(sym_name, function_type, *, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> DefineOp:
  return DefineOp(sym_name=sym_name, function_type=function_type, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ExecuteOp(_ods_ir.OpView):
  r"""
  The `arc.execute` op allows an SSACFG region to be embedded in a parent
  graph region, or another SSACFG region. Whenever execution reaches this op,
  its body region is executed and the results yielded from the body are
  produced as the `arc.execute` op's results. The op is isolated from above.
  Any SSA values defined outside the op that are used inside the body have to
  be captured as operands and then referred to as entry block arguments in the
  body.
  """

  OPERATION_NAME = "arc.execute"

  _ODS_REGIONS = (1, True)

  def __init__(self, results_, inputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def execute(results_, inputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, ExecuteOp]:
  op = ExecuteOp(results_=results_, inputs=inputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class FinalOp(_ods_ir.OpView):
  OPERATION_NAME = "arc.final"

  _ODS_REGIONS = (1, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def final(*, loc=None, ip=None) -> FinalOp:
  return FinalOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class InitialOp(_ods_ir.OpView):
  OPERATION_NAME = "arc.initial"

  _ODS_REGIONS = (1, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def initial(*, loc=None, ip=None) -> InitialOp:
  return InitialOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class LutOp(_ods_ir.OpView):
  r"""
  Represents a lookup-table as one operation. The operations that map the
  lookup/input values to the corresponding table-entry are collected inside
  the body of this operation.
  Note that the operation is marked to be isolated from above to guarantee
  that all input values have to be passed as an operand. This allows for
  simpler analyses and canonicalizations of the LUT as well as lowering.
  Only combinational operations are allowed inside the LUT, i.e., no
  side-effects, state, time delays, etc.
  """

  OPERATION_NAME = "arc.lut"

  _ODS_REGIONS = (1, True)

  def __init__(self, output, inputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def output(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def lut(output, inputs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return LutOp(output=output, inputs=inputs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MemoryOp(_ods_ir.OpView):
  OPERATION_NAME = "arc.memory"

  _ODS_REGIONS = (0, True)

  def __init__(self, memory, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(memory)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def memory(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def memory(memory, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return MemoryOp(memory=memory, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MemoryReadOp(_ods_ir.OpView):
  OPERATION_NAME = "arc.memory_read"

  _ODS_REGIONS = (0, True)

  def __init__(self, memory, address, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(memory)
    operands.append(address)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def memory(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def address(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def data(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def memory_read(memory, address, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MemoryReadOp(memory=memory, address=address, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MemoryReadPortOp(_ods_ir.OpView):
  r"""
  Represents a combinatorial memory read port. No memory read side-effect
  trait is necessary because at the stage of the Arc lowering where this
  operation is legal to be present, it is guaranteed that all reads from the
  same address produce the same output. This is because all writes are
  reordered to happen at the end of the cycle in LegalizeStateUpdates (or
  alternatively produce the necessary temporaries).
  """

  OPERATION_NAME = "arc.memory_read_port"

  _ODS_REGIONS = (0, True)

  def __init__(self, memory, address, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(memory)
    operands.append(address)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def memory(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def address(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def data(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def memory_read_port(memory, address, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MemoryReadPortOp(memory=memory, address=address, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MemoryWriteOp(_ods_ir.OpView):
  OPERATION_NAME = "arc.memory_write"

  _ODS_REGIONS = (0, True)

  def __init__(self, memory, address, data, *, enable=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(memory)
    operands.append(address)
    if enable is not None: operands.append(enable)
    operands.append(data)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def memory(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def address(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def enable(self) -> _Optional[_ods_ir.Value[_ods_ir.IntegerType]]:
    return None if len(self.operation.operands) < 4 else self.operation.operands[2]

  @builtins.property
  def data(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    _ods_variadic_group_length = len(self.operation.operands) - 4 + 1
    return self.operation.operands[3 + _ods_variadic_group_length - 1]

def memory_write(memory, address, data, *, enable=None, loc=None, ip=None) -> MemoryWriteOp:
  return MemoryWriteOp(memory=memory, address=address, data=data, enable=enable, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class MemoryWritePortOp(_ods_ir.OpView):
  OPERATION_NAME = "arc.memory_write_port"

  _ODS_OPERAND_SEGMENTS = [1,-1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, memory, arc, inputs, *, clock=None, enable=None, mask=None, latency=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(memory)
    operands.append(_get_op_results_or_values(inputs))
    operands.append(clock)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["arc"] = (arc if (
    isinstance(arc, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(arc, context=_ods_context))
    if bool(enable): attributes["enable"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(mask): attributes["mask"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if latency is not None: attributes["latency"] = (latency if (
        isinstance(latency, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(latency, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def memory(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def clock(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def arc(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["arc"]

  @arc.setter
  def arc(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["arc"] = value

  @builtins.property
  def enable(self) -> bool:
    return "enable" in self.operation.attributes

  @enable.setter
  def enable(self, value):
    if bool(value):
      self.operation.attributes["enable"] = _ods_ir.UnitAttr.get()
    elif "enable" in self.operation.attributes:
      del self.operation.attributes["enable"]

  @enable.deleter
  def enable(self):
    del self.operation.attributes["enable"]

  @builtins.property
  def mask(self) -> bool:
    return "mask" in self.operation.attributes

  @mask.setter
  def mask(self, value):
    if bool(value):
      self.operation.attributes["mask"] = _ods_ir.UnitAttr.get()
    elif "mask" in self.operation.attributes:
      del self.operation.attributes["mask"]

  @mask.deleter
  def mask(self):
    del self.operation.attributes["mask"]

  @builtins.property
  def latency(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["latency"]

  @latency.setter
  def latency(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["latency"] = value

def memory_write_port(memory, arc, inputs, *, clock=None, enable=None, mask=None, latency=None, loc=None, ip=None) -> MemoryWritePortOp:
  return MemoryWritePortOp(memory=memory, arc=arc, inputs=inputs, clock=clock, enable=enable, mask=mask, latency=latency, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ModelOp(_ods_ir.OpView):
  r"""
  A model with stratified clocks. The `io` optional attribute
  specifies the I/O of the module associated to this model.
  """

  OPERATION_NAME = "arc.model"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, io, *, initialFn=None, finalFn=None, traceTaps=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["io"] = (io if (
    isinstance(io, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_554')) else
      _ods_ir.AttrBuilder.get('anonymous_554')(io, context=_ods_context))
    if initialFn is not None: attributes["initialFn"] = (initialFn if (
        isinstance(initialFn, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
          _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(initialFn, context=_ods_context))
    if finalFn is not None: attributes["finalFn"] = (finalFn if (
        isinstance(finalFn, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
          _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(finalFn, context=_ods_context))
    if traceTaps is not None: attributes["traceTaps"] = (traceTaps if (
        isinstance(traceTaps, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('TraceTapArrayAttr')) else
          _ods_ir.AttrBuilder.get('TraceTapArrayAttr')(traceTaps, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def io(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["io"]

  @io.setter
  def io(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["io"] = value

  @builtins.property
  def initialFn(self) -> _Optional[_ods_ir.FlatSymbolRefAttr]:
    if "initialFn" not in self.operation.attributes:
      return None
    return self.operation.attributes["initialFn"]

  @initialFn.setter
  def initialFn(self, value: _Optional[_ods_ir.FlatSymbolRefAttr]):
    if value is not None:
      self.operation.attributes["initialFn"] = value
    elif "initialFn" in self.operation.attributes:
      del self.operation.attributes["initialFn"]

  @initialFn.deleter
  def initialFn(self):
    del self.operation.attributes["initialFn"]

  @builtins.property
  def finalFn(self) -> _Optional[_ods_ir.FlatSymbolRefAttr]:
    if "finalFn" not in self.operation.attributes:
      return None
    return self.operation.attributes["finalFn"]

  @finalFn.setter
  def finalFn(self, value: _Optional[_ods_ir.FlatSymbolRefAttr]):
    if value is not None:
      self.operation.attributes["finalFn"] = value
    elif "finalFn" in self.operation.attributes:
      del self.operation.attributes["finalFn"]

  @finalFn.deleter
  def finalFn(self):
    del self.operation.attributes["finalFn"]

  @builtins.property
  def traceTaps(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "traceTaps" not in self.operation.attributes:
      return None
    return self.operation.attributes["traceTaps"]

  @traceTaps.setter
  def traceTaps(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["traceTaps"] = value
    elif "traceTaps" in self.operation.attributes:
      del self.operation.attributes["traceTaps"]

  @traceTaps.deleter
  def traceTaps(self):
    del self.operation.attributes["traceTaps"]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def model(sym_name, io, *, initial_fn=None, final_fn=None, trace_taps=None, loc=None, ip=None) -> ModelOp:
  return ModelOp(sym_name=sym_name, io=io, initialFn=initial_fn, finalFn=final_fn, traceTaps=trace_taps, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class OutputOp(_ods_ir.OpView):
  OPERATION_NAME = "arc.output"

  _ODS_REGIONS = (0, True)

  def __init__(self, outputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def output(outputs, *, loc=None, ip=None) -> OutputOp:
  return OutputOp(outputs=outputs, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RootInputOp(_ods_ir.OpView):
  OPERATION_NAME = "arc.root_input"

  _ODS_REGIONS = (0, True)

  def __init__(self, state, name, storage, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(storage)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["name"] = (name if (
    isinstance(name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    results = []
    results.append(state)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def storage(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

  @builtins.property
  def state(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def root_input(state, name, storage, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return RootInputOp(state=state, name=name, storage=storage, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RootOutputOp(_ods_ir.OpView):
  OPERATION_NAME = "arc.root_output"

  _ODS_REGIONS = (0, True)

  def __init__(self, state, name, storage, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(storage)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["name"] = (name if (
    isinstance(name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    results = []
    results.append(state)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def storage(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

  @builtins.property
  def state(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def root_output(state, name, storage, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return RootOutputOp(state=state, name=name, storage=storage, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RuntimeModelOp(_ods_ir.OpView):
  r"""
  Collection of static metadata for a specific Arc model accessed by the
  arcilator runtime library:
  - name: Name of the model
  - numStateBytes: Number of bytes required to store the model's internal
      state
  """

  OPERATION_NAME = "arc.runtime.model"

  _ODS_REGIONS = (0, True)

  def __init__(self, sym_name, name, numStateBytes, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["name"] = (name if (
    isinstance(name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    attributes["numStateBytes"] = (numStateBytes if (
    isinstance(numStateBytes, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(numStateBytes, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

  @builtins.property
  def numStateBytes(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["numStateBytes"]

  @numStateBytes.setter
  def numStateBytes(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["numStateBytes"] = value

def runtime_model(sym_name, name, num_state_bytes, *, loc=None, ip=None) -> RuntimeModelOp:
  return RuntimeModelOp(sym_name=sym_name, name=name, numStateBytes=num_state_bytes, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SimEmitValueOp(_ods_ir.OpView):
  r"""
  Sends a named value to the simulation driver. This is notably useful
  for printing values during simulation.
  """

  OPERATION_NAME = "arc.sim.emit"

  _ODS_REGIONS = (0, True)

  def __init__(self, valueName, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["valueName"] = (valueName if (
    isinstance(valueName, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(valueName, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def valueName(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["valueName"]

  @valueName.setter
  def valueName(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["valueName"] = value

def sim_emit(value_name, value, *, loc=None, ip=None) -> SimEmitValueOp:
  return SimEmitValueOp(valueName=value_name, value=value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SimGetPortOp(_ods_ir.OpView):
  r"""
  Gets the value of the given port in a specific instance of a model. The
  provided port must be of the type of the expected value.
  """

  OPERATION_NAME = "arc.sim.get_port"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, instance, port, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(instance)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["port"] = (port if (
    isinstance(port, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(port, context=_ods_context))
    results = []
    results.append(value)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def instance(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def port(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["port"]

  @port.setter
  def port(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["port"] = value

  @builtins.property
  def value(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def sim_get_port(value, instance, port, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return SimGetPortOp(value=value, instance=instance, port=port, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SimInstantiateOp(_ods_ir.OpView):
  r"""
  Creates an instance of an Arc model in scope, in order to simulate it.
  The model can be used from within the associated region, modelling its
  lifetime.
  """

  OPERATION_NAME = "arc.sim.instantiate"

  _ODS_REGIONS = (1, True)

  def __init__(self, *, runtimeModel=None, runtimeArgs=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if runtimeModel is not None: attributes["runtimeModel"] = (runtimeModel if (
        isinstance(runtimeModel, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
          _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(runtimeModel, context=_ods_context))
    if runtimeArgs is not None: attributes["runtimeArgs"] = (runtimeArgs if (
        isinstance(runtimeArgs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(runtimeArgs, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def runtimeModel(self) -> _Optional[_ods_ir.FlatSymbolRefAttr]:
    if "runtimeModel" not in self.operation.attributes:
      return None
    return self.operation.attributes["runtimeModel"]

  @runtimeModel.setter
  def runtimeModel(self, value: _Optional[_ods_ir.FlatSymbolRefAttr]):
    if value is not None:
      self.operation.attributes["runtimeModel"] = value
    elif "runtimeModel" in self.operation.attributes:
      del self.operation.attributes["runtimeModel"]

  @runtimeModel.deleter
  def runtimeModel(self):
    del self.operation.attributes["runtimeModel"]

  @builtins.property
  def runtimeArgs(self) -> _Optional[_ods_ir.StringAttr]:
    if "runtimeArgs" not in self.operation.attributes:
      return None
    return self.operation.attributes["runtimeArgs"]

  @runtimeArgs.setter
  def runtimeArgs(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["runtimeArgs"] = value
    elif "runtimeArgs" in self.operation.attributes:
      del self.operation.attributes["runtimeArgs"]

  @runtimeArgs.deleter
  def runtimeArgs(self):
    del self.operation.attributes["runtimeArgs"]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def sim_instantiate(*, runtime_model=None, runtime_args=None, loc=None, ip=None) -> SimInstantiateOp:
  return SimInstantiateOp(runtimeModel=runtime_model, runtimeArgs=runtime_args, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SimSetInputOp(_ods_ir.OpView):
  r"""
  Sets the value of an input port in a specific instance of a model. The
  provided input port must be of input type on the model and its type must
  match the type of the value operand.
  """

  OPERATION_NAME = "arc.sim.set_input"

  _ODS_REGIONS = (0, True)

  def __init__(self, instance, input, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(instance)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["input"] = (input if (
    isinstance(input, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(input, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def instance(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def input(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["input"]

  @input.setter
  def input(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["input"] = value

def sim_set_input(instance, input, value, *, loc=None, ip=None) -> SimSetInputOp:
  return SimSetInputOp(instance=instance, input=input, value=value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SimStepOp(_ods_ir.OpView):
  r"""
  Evaluates one step of the simulation for the provided model instance,
  updating ports accordingly.
  """

  OPERATION_NAME = "arc.sim.step"

  _ODS_REGIONS = (0, True)

  def __init__(self, instance, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(instance)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def instance(self) -> _ods_ir.Value:
    return self.operation.operands[0]

def sim_step(instance, *, loc=None, ip=None) -> SimStepOp:
  return SimStepOp(instance=instance, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class StateOp(_ods_ir.OpView):
  OPERATION_NAME = "arc.state"

  _ODS_OPERAND_SEGMENTS = [0,0,0,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, outputs, arc, latency, inputs, initials, *, clock=None, enable=None, reset=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(clock)
    operands.append(enable)
    operands.append(reset)
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(initials))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["arc"] = (arc if (
    isinstance(arc, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(arc, context=_ods_context))
    attributes["latency"] = (latency if (
    isinstance(latency, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(latency, context=_ods_context))
    results = []
    results.extend(outputs)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def clock(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def enable(self) -> _Optional[_ods_ir.Value[_ods_ir.IntegerType]]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def reset(self) -> _Optional[_ods_ir.Value[_ods_ir.IntegerType]]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def initials(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range

  @builtins.property
  def arc(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["arc"]

  @arc.setter
  def arc(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["arc"] = value

  @builtins.property
  def latency(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["latency"]

  @latency.setter
  def latency(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["latency"] = value

  @builtins.property
  def outputs(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def state(outputs, arc, latency, inputs, initials, *, clock=None, enable=None, reset=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, StateOp]:
  op = StateOp(outputs=outputs, arc=arc, latency=latency, inputs=inputs, initials=initials, clock=clock, enable=enable, reset=reset, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class StateReadOp(_ods_ir.OpView):
  OPERATION_NAME = "arc.state_read"

  _ODS_REGIONS = (0, True)

  def __init__(self, state, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(state)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def state(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def value(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def state_read(state, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return StateReadOp(state=state, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class StateWriteOp(_ods_ir.OpView):
  OPERATION_NAME = "arc.state_write"

  _ODS_REGIONS = (0, True)

  def __init__(self, state, value, *, condition=None, traceTapModel=None, traceTapIndex=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(state)
    operands.append(value)
    if condition is not None: operands.append(condition)
    _ods_context = _ods_get_default_loc_context(loc)
    if traceTapModel is not None: attributes["traceTapModel"] = (traceTapModel if (
        isinstance(traceTapModel, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
          _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(traceTapModel, context=_ods_context))
    if traceTapIndex is not None: attributes["traceTapIndex"] = (traceTapIndex if (
        isinstance(traceTapIndex, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('UI64Attr')) else
          _ods_ir.AttrBuilder.get('UI64Attr')(traceTapIndex, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def state(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def condition(self) -> _Optional[_ods_ir.Value[_ods_ir.IntegerType]]:
    return None if len(self.operation.operands) < 3 else self.operation.operands[2]

  @builtins.property
  def traceTapModel(self) -> _Optional[_ods_ir.FlatSymbolRefAttr]:
    if "traceTapModel" not in self.operation.attributes:
      return None
    return self.operation.attributes["traceTapModel"]

  @traceTapModel.setter
  def traceTapModel(self, value: _Optional[_ods_ir.FlatSymbolRefAttr]):
    if value is not None:
      self.operation.attributes["traceTapModel"] = value
    elif "traceTapModel" in self.operation.attributes:
      del self.operation.attributes["traceTapModel"]

  @traceTapModel.deleter
  def traceTapModel(self):
    del self.operation.attributes["traceTapModel"]

  @builtins.property
  def traceTapIndex(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "traceTapIndex" not in self.operation.attributes:
      return None
    return self.operation.attributes["traceTapIndex"]

  @traceTapIndex.setter
  def traceTapIndex(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["traceTapIndex"] = value
    elif "traceTapIndex" in self.operation.attributes:
      del self.operation.attributes["traceTapIndex"]

  @traceTapIndex.deleter
  def traceTapIndex(self):
    del self.operation.attributes["traceTapIndex"]

def state_write(state, value, *, condition=None, trace_tap_model=None, trace_tap_index=None, loc=None, ip=None) -> StateWriteOp:
  return StateWriteOp(state=state, value=value, condition=condition, traceTapModel=trace_tap_model, traceTapIndex=trace_tap_index, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class StorageGetOp(_ods_ir.OpView):
  OPERATION_NAME = "arc.storage.get"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, storage, offset, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(storage)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["offset"] = (offset if (
    isinstance(offset, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(offset, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def storage(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def offset(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["offset"]

  @offset.setter
  def offset(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["offset"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def storage_get(result, storage, offset, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return StorageGetOp(result=result, storage=storage, offset=offset, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TapOp(_ods_ir.OpView):
  OPERATION_NAME = "arc.tap"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, names, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["names"] = (names if (
    isinstance(names, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
      _ods_ir.AttrBuilder.get('StrArrayAttr')(names, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def names(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["names"]

  @names.setter
  def names(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["names"] = value

def tap(value, names, *, loc=None, ip=None) -> TapOp:
  return TapOp(value=value, names=names, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class VectorizeOp(_ods_ir.OpView):
  r"""
  This operation represents a vectorized computation DAG. It places a
  convenient boundary between the subgraph to be vectorized and the
  surrounding non-vectorizable parts of the original graph.
  
  This allows us to split the vectorization transformations into multiple
  parts/passes:
    * Finding an initial set of operations to be vectorized
    * Optimizing this set by pulling in more operations into the nested block,
      splitting it such that the vector width does not exceed a given limit,
      applying a cost model and potentially reverting the decision to
      vectorize this subgraph (e.g., because not enough ops could be pulled
      in)
    * Performing the actual vectorization by lowering this operation. This
      operation allows to perform the lowering of the boundary and the body
      separately and either via 1D `vector` types for SIMD vectorization or
      plain integers for manual vectorization within a scalar register.
  
  For each block argument of the nested block, there is a list of operands
  that represent the elements of the vector. If the boundary is already
  vectorized each list will only contain a single SSA value of either vector
  type or an integer representing the concatenation of all original operands
  of that vector.
  
  Example:
  
  Given the following two AND operations in the IR
  ```mlir
  %0 = arith.and %in0, %in1 : i1
  %1 = arith.and %in2, %in2 : i1
  ```
  they could be vectorized by putting one such AND operation in the body block
  of the `arc.vectorize` operation and forwarding the operands accordingly.
  ```mlir
  %0:2 = arc.vectorize (%in0, %in1), (%in2, %in2) :
    (i1, i1, i1, i1) -> (i1, i1) {
  ^bb0(%arg0: i1, %arg1: i1):
    %1 = arith.and %arg0, %arg1 : i1
    arc.output %1 : i1
  }
  ```
  In a next step, the boundary could be lowered/vectorized. This can happen
  in terms of integers for vectorization within scalar registers:
  ```mlir
  %0 = comb.concat %in0, %in1 : i1, i1
  %1 = comb.replicate %in2 : (i1) -> i2
  %2 = arc.vectorize (%0), (%1) : (i2, i2) -> (i2) {
  ^bb0(%arg0: i1, %arg1: i1):
    %1 = arith.and %arg0, %arg1 : i1
    arc.output %1 : i1
  }
  %3 = comb.extract %2 from 1 : (i2) -> i1
  %4 = comb.extract %2 from 0 : (i2) -> i1
  ```
  Or via `vector` types for SIMD vectorization:
  ```mlir
  %cst = arith.constant dense<0> : vector<2xi1>
  %0 = vector.insert %in0, %cst[0] : i1 into vector<2xi1>
  %1 = vector.insert %in1, %0[1] : i1 into vector<2xi1>
  %2 = vector.broadcast %in2 : i1 to vector<2xi1>
  %3 = arc.vectorize (%1), (%2) :
    (vector<2xi1>, vector<2xi1>) -> (vector<2xi1>) {
  ^bb0(%arg0: i1, %arg1: i1):
    %1 = arith.and %arg0, %arg1 : i1
    arc.output %1 : i1
  }
  %4 = vector.extract %2[0] : vector<2xi1>
  %5 = vector.extract %2[1] : vector<2xi1>
  ```
  Alternatively, the body could be vectorized first. Again, as integers
  ```mlir
  %0:2 = arc.vectorize (%in0, %in1), (%in2, %in2) :
    (i1, i1, i1, i1) -> (i1, i1) {
  ^bb0(%arg0: i2, %arg1: i2):
    %1 = arith.and %arg0, %arg1 : i2
    arc.output %1 : i2
  }
  ```
  or SIMD vectors.
  ```mlir
  %0:2 = arc.vectorize (%in0, %in1), (%in2, %in3) :
    (i1, i1, i1, i1) -> (i1, i1) {
  ^bb0(%arg0: vector<2xi1>, %arg1: vector<2xi1>):
    %1 = arith.and %arg0, %arg1 : vector<2xi1>
    arc.output %1 : vector<2xi1>
  }
  ```
  Once both sides are lowered, the `arc.vectorize` op simply becomes a
  passthrough for the operands and can be removed by inlining the nested
  block. The integer based vectorization would then look like the following:
  ```mlir
  %0 = comb.concat %in0, %in1 : i1, i1
  %1 = comb.replicate %in2 : (i1) -> i2
  %2 = arith.and %0, %1 : i2
  %3 = comb.extract %2 from 1 : (i2) -> i1
  %4 = comb.extract %2 from 0 : (i2) -> i1
  ```
  The SIMD vector based lowering would result in the following IR:
  ```mlir
  %cst = arith.constant dense<0> : vector<2xi1>
  %0 = vector.insert %in0, %cst[0] : i1 into vector<2xi1>
  %1 = vector.insert %in1, %0[1] : i1 into vector<2xi1>
  %2 = vector.broadcast %in2 : i1 to vector<2xi1>
  %3 = arith.and %1, %2 : vector<2xi1>
  %4 = vector.extract %3[0] : vector<2xi1>
  %5 = vector.extract %3[1] : vector<2xi1>
  ```
  """

  OPERATION_NAME = "arc.vectorize"

  _ODS_REGIONS = (1, True)

  def __init__(self, results_, inputs, inputOperandSegments, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["inputOperandSegments"] = (inputOperandSegments if (
    isinstance(inputOperandSegments, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI32ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI32ArrayAttr')(inputOperandSegments, context=_ods_context))
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def inputOperandSegments(self) -> _ods_ir.DenseI32ArrayAttr:
    return self.operation.attributes["inputOperandSegments"]

  @inputOperandSegments.setter
  def inputOperandSegments(self, value: _ods_ir.DenseI32ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["inputOperandSegments"] = value

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def vectorize(results_, inputs, input_operand_segments, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, VectorizeOp]:
  op = VectorizeOp(results_=results_, inputs=inputs, inputOperandSegments=input_operand_segments, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class VectorizeReturnOp(_ods_ir.OpView):
  OPERATION_NAME = "arc.vectorize.return"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

def vectorize_return(value, *, loc=None, ip=None) -> VectorizeReturnOp:
  return VectorizeReturnOp(value=value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ZeroCountOp(_ods_ir.OpView):
  OPERATION_NAME = "arc.zero_count"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, predicate, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["predicate"] = (predicate if (
    isinstance(predicate, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ZeroCountPredicate')) else
      _ods_ir.AttrBuilder.get('ZeroCountPredicate')(predicate, context=_ods_context))
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def predicate(self) -> _ods_ir.Attribute:
    return self.operation.attributes["predicate"]

  @predicate.setter
  def predicate(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["predicate"] = value

  @builtins.property
  def output(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def zero_count(input, predicate, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ZeroCountOp(input=input, predicate=predicate, results=results, loc=loc, ip=ip).result
