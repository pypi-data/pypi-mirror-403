
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "verif"

@_ods_cext.register_operation(_Dialect)
class AssertOp(_ods_ir.OpView):
  OPERATION_NAME = "verif.assert"

  _ODS_REGIONS = (0, True)

  def __init__(self, property, *, enable=None, label=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(property)
    if enable is not None: operands.append(enable)
    _ods_context = _ods_get_default_loc_context(loc)
    if label is not None: attributes["label"] = (label if (
        isinstance(label, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(label, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def property(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def enable(self) -> _Optional[_ods_ir.Value[_ods_ir.IntegerType]]:
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def label(self) -> _Optional[_ods_ir.StringAttr]:
    if "label" not in self.operation.attributes:
      return None
    return self.operation.attributes["label"]

  @label.setter
  def label(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["label"] = value
    elif "label" in self.operation.attributes:
      del self.operation.attributes["label"]

  @label.deleter
  def label(self):
    del self.operation.attributes["label"]

def assert_(property, *, enable=None, label=None, loc=None, ip=None) -> AssertOp:
  return AssertOp(property=property, enable=enable, label=label, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class AssumeOp(_ods_ir.OpView):
  OPERATION_NAME = "verif.assume"

  _ODS_REGIONS = (0, True)

  def __init__(self, property, *, enable=None, label=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(property)
    if enable is not None: operands.append(enable)
    _ods_context = _ods_get_default_loc_context(loc)
    if label is not None: attributes["label"] = (label if (
        isinstance(label, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(label, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def property(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def enable(self) -> _Optional[_ods_ir.Value[_ods_ir.IntegerType]]:
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def label(self) -> _Optional[_ods_ir.StringAttr]:
    if "label" not in self.operation.attributes:
      return None
    return self.operation.attributes["label"]

  @label.setter
  def label(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["label"] = value
    elif "label" in self.operation.attributes:
      del self.operation.attributes["label"]

  @label.deleter
  def label(self):
    del self.operation.attributes["label"]

def assume(property, *, enable=None, label=None, loc=None, ip=None) -> AssumeOp:
  return AssumeOp(property=property, enable=enable, label=label, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BoundedModelCheckingOp(_ods_ir.OpView):
  r"""
  This operation represents a bounded model checking problem explicitly in
  the IR. The `bound` attribute indicates how many times the `circuit` region
  should be executed, and `num_regs` indicates the number of registers in the
  design that have been externalized and appended to the region's
  inputs/outputs (these values are fed from each `circuit` region execution
  to the next, as they represent register state, rather than being
  overwritten with fresh variables like other inputs). `initial_values` is an
  array containing the initial value of each register - where the register
  has no initial value, a unit attribute is given. The `circuit` region
  contains the circuit (alongside the `verif` property checking operations)
  to be checked.
  
  The `init` region contains the logic to initialize the clock signals, and
  will be executed once before any other region - it cannot take any
  arguments, and should return as many `!seq.clock` values as the `circuit`
  region has `!seq.clock` arguments, followed by any initial arguments of
  'state' arguments to be fed to the `loop` region (see below).
  
  The `loop` region contains the logic to advance the clock signals, and will
  be executed after each execution of the `circuit` region. It should take as
  arguments as many `!seq.clock` values as the `circuit` region has, and
  these can be followed by additional 'state' arguments to represent e.g.
  which clock should be toggled next. The types yielded should be the same,
  as this region yields the updated clock and state values (this should also
  match the types yielded by the `init` region).
  """

  OPERATION_NAME = "verif.bmc"

  _ODS_REGIONS = (3, True)

  def __init__(self, result, bound, num_regs, initial_values, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["bound"] = (bound if (
    isinstance(bound, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(bound, context=_ods_context))
    attributes["num_regs"] = (num_regs if (
    isinstance(num_regs, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(num_regs, context=_ods_context))
    attributes["initial_values"] = (initial_values if (
    isinstance(initial_values, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(initial_values, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def bound(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["bound"]

  @bound.setter
  def bound(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["bound"] = value

  @builtins.property
  def num_regs(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["num_regs"]

  @num_regs.setter
  def num_regs(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_regs"] = value

  @builtins.property
  def initial_values(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["initial_values"]

  @initial_values.setter
  def initial_values(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["initial_values"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

  @builtins.property
  def init(self) -> _ods_ir.Region:
    return self.regions[0]

  @builtins.property
  def loop(self) -> _ods_ir.Region:
    return self.regions[1]

  @builtins.property
  def circuit(self) -> _ods_ir.Region:
    return self.regions[2]

def bmc(result, bound, num_regs, initial_values, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return BoundedModelCheckingOp(result=result, bound=bound, num_regs=num_regs, initial_values=initial_values, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ClockedAssertOp(_ods_ir.OpView):
  OPERATION_NAME = "verif.clocked_assert"

  _ODS_REGIONS = (0, True)

  def __init__(self, property, edge, clock, *, enable=None, label=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(property)
    operands.append(clock)
    if enable is not None: operands.append(enable)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["edge"] = (edge if (
    isinstance(edge, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ClockEdgeAttr')) else
      _ods_ir.AttrBuilder.get('ClockEdgeAttr')(edge, context=_ods_context))
    if label is not None: attributes["label"] = (label if (
        isinstance(label, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(label, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def property(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def clock(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def enable(self) -> _Optional[_ods_ir.Value[_ods_ir.IntegerType]]:
    return None if len(self.operation.operands) < 3 else self.operation.operands[2]

  @builtins.property
  def edge(self) -> _ods_ir.Attribute:
    return self.operation.attributes["edge"]

  @edge.setter
  def edge(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["edge"] = value

  @builtins.property
  def label(self) -> _Optional[_ods_ir.StringAttr]:
    if "label" not in self.operation.attributes:
      return None
    return self.operation.attributes["label"]

  @label.setter
  def label(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["label"] = value
    elif "label" in self.operation.attributes:
      del self.operation.attributes["label"]

  @label.deleter
  def label(self):
    del self.operation.attributes["label"]

def clocked_assert(property, edge, clock, *, enable=None, label=None, loc=None, ip=None) -> ClockedAssertOp:
  return ClockedAssertOp(property=property, edge=edge, clock=clock, enable=enable, label=label, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ClockedAssumeOp(_ods_ir.OpView):
  OPERATION_NAME = "verif.clocked_assume"

  _ODS_REGIONS = (0, True)

  def __init__(self, property, edge, clock, *, enable=None, label=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(property)
    operands.append(clock)
    if enable is not None: operands.append(enable)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["edge"] = (edge if (
    isinstance(edge, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ClockEdgeAttr')) else
      _ods_ir.AttrBuilder.get('ClockEdgeAttr')(edge, context=_ods_context))
    if label is not None: attributes["label"] = (label if (
        isinstance(label, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(label, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def property(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def clock(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def enable(self) -> _Optional[_ods_ir.Value[_ods_ir.IntegerType]]:
    return None if len(self.operation.operands) < 3 else self.operation.operands[2]

  @builtins.property
  def edge(self) -> _ods_ir.Attribute:
    return self.operation.attributes["edge"]

  @edge.setter
  def edge(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["edge"] = value

  @builtins.property
  def label(self) -> _Optional[_ods_ir.StringAttr]:
    if "label" not in self.operation.attributes:
      return None
    return self.operation.attributes["label"]

  @label.setter
  def label(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["label"] = value
    elif "label" in self.operation.attributes:
      del self.operation.attributes["label"]

  @label.deleter
  def label(self):
    del self.operation.attributes["label"]

def clocked_assume(property, edge, clock, *, enable=None, label=None, loc=None, ip=None) -> ClockedAssumeOp:
  return ClockedAssumeOp(property=property, edge=edge, clock=clock, enable=enable, label=label, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ClockedCoverOp(_ods_ir.OpView):
  OPERATION_NAME = "verif.clocked_cover"

  _ODS_REGIONS = (0, True)

  def __init__(self, property, edge, clock, *, enable=None, label=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(property)
    operands.append(clock)
    if enable is not None: operands.append(enable)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["edge"] = (edge if (
    isinstance(edge, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ClockEdgeAttr')) else
      _ods_ir.AttrBuilder.get('ClockEdgeAttr')(edge, context=_ods_context))
    if label is not None: attributes["label"] = (label if (
        isinstance(label, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(label, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def property(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def clock(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def enable(self) -> _Optional[_ods_ir.Value[_ods_ir.IntegerType]]:
    return None if len(self.operation.operands) < 3 else self.operation.operands[2]

  @builtins.property
  def edge(self) -> _ods_ir.Attribute:
    return self.operation.attributes["edge"]

  @edge.setter
  def edge(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["edge"] = value

  @builtins.property
  def label(self) -> _Optional[_ods_ir.StringAttr]:
    if "label" not in self.operation.attributes:
      return None
    return self.operation.attributes["label"]

  @label.setter
  def label(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["label"] = value
    elif "label" in self.operation.attributes:
      del self.operation.attributes["label"]

  @label.deleter
  def label(self):
    del self.operation.attributes["label"]

def clocked_cover(property, edge, clock, *, enable=None, label=None, loc=None, ip=None) -> ClockedCoverOp:
  return ClockedCoverOp(property=property, edge=edge, clock=clock, enable=enable, label=label, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ContractOp(_ods_ir.OpView):
  r"""
  This operation creates a new formal contract which can be used to locally
  verify a part of the IR and provide simplifying substitutions. Contracts
  contain `verif.require` ops to establish conditions that must hold for a
  piece of IR to work properly, and `verif.ensure` ops to describe the
  properties that the piece of IR must guarantees when the requirements hold.
  Outside of formal verification, operands are simply passed through to the
  results.
  
  Contracts are checked by extracting them into their own `verif.formal` test
  and replacing `require` with `assume` and `ensure` with `assert`. The
  results of the contract are replaced with the operands of the contract.
  
  Contracts are used as simplifications for other verification tasks by
  inlining them and replacing `require` with `assert` and `ensure` with
  `assume`. The results of the contract are replaced with symbolic values.
  
  See the documentation of the Verif dialect for more details.
  """

  OPERATION_NAME = "verif.contract"

  _ODS_REGIONS = (1, True)

  def __init__(self, outputs, inputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(outputs)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def outputs(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def contract(outputs, inputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, ContractOp]:
  op = ContractOp(outputs=outputs, inputs=inputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class CoverOp(_ods_ir.OpView):
  OPERATION_NAME = "verif.cover"

  _ODS_REGIONS = (0, True)

  def __init__(self, property, *, enable=None, label=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(property)
    if enable is not None: operands.append(enable)
    _ods_context = _ods_get_default_loc_context(loc)
    if label is not None: attributes["label"] = (label if (
        isinstance(label, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(label, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def property(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def enable(self) -> _Optional[_ods_ir.Value[_ods_ir.IntegerType]]:
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def label(self) -> _Optional[_ods_ir.StringAttr]:
    if "label" not in self.operation.attributes:
      return None
    return self.operation.attributes["label"]

  @label.setter
  def label(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["label"] = value
    elif "label" in self.operation.attributes:
      del self.operation.attributes["label"]

  @label.deleter
  def label(self):
    del self.operation.attributes["label"]

def cover(property, *, enable=None, label=None, loc=None, ip=None) -> CoverOp:
  return CoverOp(property=property, enable=enable, label=label, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class EnsureOp(_ods_ir.OpView):
  r"""
  This operation specifies a condition that is asserted when checking a
  contract, and assumed when applying the contract as a simplification.
  
  The `verif.ensure` op is commonly used to specify the conditions that output
  values from a part of the IR are guaranteed to fulfill, under the condition
  that all requirements are fulfilled.
  """

  OPERATION_NAME = "verif.ensure"

  _ODS_REGIONS = (0, True)

  def __init__(self, property, *, enable=None, label=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(property)
    if enable is not None: operands.append(enable)
    _ods_context = _ods_get_default_loc_context(loc)
    if label is not None: attributes["label"] = (label if (
        isinstance(label, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(label, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def property(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def enable(self) -> _Optional[_ods_ir.Value[_ods_ir.IntegerType]]:
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def label(self) -> _Optional[_ods_ir.StringAttr]:
    if "label" not in self.operation.attributes:
      return None
    return self.operation.attributes["label"]

  @label.setter
  def label(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["label"] = value
    elif "label" in self.operation.attributes:
      del self.operation.attributes["label"]

  @label.deleter
  def label(self):
    del self.operation.attributes["label"]

def ensure(property, *, enable=None, label=None, loc=None, ip=None) -> EnsureOp:
  return EnsureOp(property=property, enable=enable, label=label, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class FormalOp(_ods_ir.OpView):
  r"""
  This operation defines a formal unit test that can be automatically run by
  various tools. To describe a test, the body of this op should contain the
  hardware to be tested, alongside any asserts, assumes, and covers to be
  formally verified. The body can contain instances of other modules, in which
  case all asserts, assumes, and covers in those modules are also verified.
  
  The `verif.symbolic_value` op can be used to create symbolic values to feed
  into the hardware to be tested. Testing tools will then try to find concrete
  values for them that violate any asserts or make any covers true.
  
  #### Example
  ```
  verif.formal @AdderTest {myParam = 42, myTag = "hello"} {
    %0 = verif.symbolic_value : i42
    %1 = verif.symbolic_value : i42
    %2 = hw.instance "dut" @Adder(a: %0: i42, b: %1: i42) -> (c: i42)
    %3 = comb.add %0, %1 : i42
    %4 = comb.icmp eq %2, %3 : i42
    verif.assert %4 : i1
  }
  ```
  
  #### Parameters
  The following parameters have a predefined meaning and are interpreted by
  tools such as `circt-test` to guide execution of tests:
  
  - `ignore`: Indicates whether the test should be ignored and skipped. This
    can be useful for temporarily disabling tests without having to remove
    them from the input. Must be a _boolean_ value.
    ```mlir
    verif.formal @Foo {ignore = true}
    ```
  
  - `require_runners`: A list of test runners that may be used to execute this
    test. This option may be used to force a test to run using one of a few
    known-good runners, acting like a whitelist. Must be an _array_ of
    _strings_.
    ```mlir
    verif.formal @Foo {require_runners = ["sby", "circt-bmc"]}
    ```
  
  - `exclude_runners`: A list of test runners that must not be used to execute
    this test. This option may be used to exclude a few known-bad runners from
    executing this test, acting like a blacklist. Must be an _array_ of
    _strings_.
    ```mlir
    verif.formal @Foo {exclude_runners = ["sby", "circt-bmc"]}
    ```
  """

  OPERATION_NAME = "verif.formal"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, parameters, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["parameters"] = (parameters if (
    isinstance(parameters, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DictionaryAttr')) else
      _ods_ir.AttrBuilder.get('DictionaryAttr')(parameters, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def parameters(self) -> _ods_ir.DictAttr:
    return self.operation.attributes["parameters"]

  @parameters.setter
  def parameters(self, value: _ods_ir.DictAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["parameters"] = value

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def formal(sym_name, parameters, *, loc=None, ip=None) -> FormalOp:
  return FormalOp(sym_name=sym_name, parameters=parameters, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class FormatVerilogStringOp(_ods_ir.OpView):
  r"""
  Creates a formatted string suitable for printing via the `verif.print` op.
  The formatting syntax is expected to be identical to verilog string
  formatting to keep things simple for emission.
  If we in the future would like to be less tied to verilog formatting,
  please ask your friendly neighbourhood compiler engineer to e.g. implement
  a `FormatStringOp` which itself may lower to a `FormatVerilogStringOp`.
  """

  OPERATION_NAME = "verif.format_verilog_string"

  _ODS_REGIONS = (0, True)

  def __init__(self, formatString, substitutions, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(substitutions))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["formatString"] = (formatString if (
    isinstance(formatString, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(formatString, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def substitutions(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def formatString(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["formatString"]

  @formatString.setter
  def formatString(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["formatString"] = value

  @builtins.property
  def str(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def format_verilog_string(format_string, substitutions, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FormatVerilogStringOp(formatString=format_string, substitutions=substitutions, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class HasBeenResetOp(_ods_ir.OpView):
  r"""
  The result of `verif.has_been_reset` reads as 0 immediately after simulation
  startup and after each power-cycle in a power-aware simulation. The result
  remains 0 before and during reset and only switches to 1 after the reset is
  deasserted again.
  
  This is a useful utility to disable the evaluation of assertions and other
  verification constructs in the IR before the circuit being tested has been
  properly reset. Verification failures due to uninitialized or randomized
  initial state can thus be prevented.
  
  Using the result of `verif.has_been_reset` to enable verification is more
  powerful and proper than just disabling verification during reset. The
  latter does not properly handle the period of time between simulation
  startup or power-cycling and the start of reset. `verif.has_been_reset` is
  guaranteed to produce a 0 value in that period, as well as during the reset.
  """

  OPERATION_NAME = "verif.has_been_reset"

  _ODS_REGIONS = (0, True)

  def __init__(self, clock, reset, async_, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(clock)
    operands.append(reset)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["async"] = (async_ if (
    isinstance(async_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(async_, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def clock(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def reset(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def async_(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["async"]

  @async_.setter
  def async_(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["async"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def has_been_reset(clock, reset, async_, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return HasBeenResetOp(clock=clock, reset=reset, async_=async_, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LogicEquivalenceCheckingOp(_ods_ir.OpView):
  r"""
  This operation represents a logic equivalence checking problem explicitly in
  the IR. There are several possibilities to perform logical equivalence
  checking. For example, equivalence checking of combinational circuits can be
  done by constructing a miter circuit and testing whether the result is
  satisfiable (can be non-zero for some input), or two canonical BDDs could be
  constructed and compared for identity, etc.
  
  The number and types of the inputs and outputs of the two circuits (and thus
  also the block arguments and yielded values of both regions) have to match.
  Otherwise, the two should be considered trivially non-equivalent.
  
  The operation can return a boolean result that is `true` iff equivalence
  of the two circuits has been proven. The result can be omitted for use-cases
  which do not allow further processing (e.g., SMT-LIB exporting).
  """

  OPERATION_NAME = "verif.lec"

  _ODS_REGIONS = (2, True)

  def __init__(self, isProven, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    if isProven is not None: results.append(isProven)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def isProven(self) -> _Optional[_ods_ir.OpResult[_ods_ir.IntegerType]]:
    return None if len(self.operation.results) < 1 else self.operation.results[0]

  @builtins.property
  def firstCircuit(self) -> _ods_ir.Region:
    return self.regions[0]

  @builtins.property
  def secondCircuit(self) -> _ods_ir.Region:
    return self.regions[1]

def lec(is_proven, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, LogicEquivalenceCheckingOp]:
  op = LogicEquivalenceCheckingOp(isProven=is_proven, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class PrintOp(_ods_ir.OpView):
  OPERATION_NAME = "verif.print"

  _ODS_REGIONS = (0, True)

  def __init__(self, string, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(string)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def string(self) -> _ods_ir.Value:
    return self.operation.operands[0]

def print_(string, *, loc=None, ip=None) -> PrintOp:
  return PrintOp(string=string, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RefinementCheckingOp(_ods_ir.OpView):
  r"""
  This operation represents a refinement checking problem explicitly in the
  IR. Given two (purely combinational) circuits A and B with the same
  signature, B refines A iff for all inputs the set of possible output
  values of B is a subset of the possible output values of A given the
  same input.
  
  For strictly deterministic circuits the 'refines' relation is identical to
  logical equivalence. Informally speaking, refining allows maintaining or
  reducing the non-determinism of a circuit.
  
  If the signatures of the circuits do not match, the second circuit is
  trivially assumed to _not_ be a refinement of the first circuit. Sequential
  elements (i.e., registers and memories) are currently unsupported.
  
  The operation can return a boolean result that is `true` iff the refinement
  relation has been proven. The result can be omitted for use-cases which do
  not allow further processing (e.g., SMT-LIB exporting).
  """

  OPERATION_NAME = "verif.refines"

  _ODS_REGIONS = (2, True)

  def __init__(self, isProven, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    if isProven is not None: results.append(isProven)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def isProven(self) -> _Optional[_ods_ir.OpResult[_ods_ir.IntegerType]]:
    return None if len(self.operation.results) < 1 else self.operation.results[0]

  @builtins.property
  def firstCircuit(self) -> _ods_ir.Region:
    return self.regions[0]

  @builtins.property
  def secondCircuit(self) -> _ods_ir.Region:
    return self.regions[1]

def refines(is_proven, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, RefinementCheckingOp]:
  op = RefinementCheckingOp(isProven=is_proven, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class RequireOp(_ods_ir.OpView):
  r"""
  This operation specifies a condition that is assumed when checking against
  the contract, and asserted when applying the contract as a simplification.
  
  The `verif.require` op is commonly used to specify the conditions that input
  values into a part of the IR must fulfill in order for the IR to work as
  expected, i.e., as outlined in the contract.
  """

  OPERATION_NAME = "verif.require"

  _ODS_REGIONS = (0, True)

  def __init__(self, property, *, enable=None, label=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(property)
    if enable is not None: operands.append(enable)
    _ods_context = _ods_get_default_loc_context(loc)
    if label is not None: attributes["label"] = (label if (
        isinstance(label, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(label, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def property(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def enable(self) -> _Optional[_ods_ir.Value[_ods_ir.IntegerType]]:
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def label(self) -> _Optional[_ods_ir.StringAttr]:
    if "label" not in self.operation.attributes:
      return None
    return self.operation.attributes["label"]

  @label.setter
  def label(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["label"] = value
    elif "label" in self.operation.attributes:
      del self.operation.attributes["label"]

  @label.deleter
  def label(self):
    del self.operation.attributes["label"]

def require(property, *, enable=None, label=None, loc=None, ip=None) -> RequireOp:
  return RequireOp(property=property, enable=enable, label=label, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SimulationOp(_ods_ir.OpView):
  r"""
  This operation defines a simulation unit test that can be automatically run
  by various tools. To describe a test, the body of this op should contain the
  hardware to be tested, alongside any necessary forms of stimulus generation.
  
  #### Inputs
  
  The body has two block arguments as input values: a "clock" signal of type
  `!seq.clock` and an "init" signal of type `i1`. The clock signal starts at 0
  and continuously toggles between 0 and 1 throughout the simulation. The init
  signal starts at 1, remains 1 during a single 0-to-1 transition of the
  clock, and then drops to 0 for the remainder of the simulation.
  
  #### Outputs
  
  The body must have a `verif.yield` terminator op with exactly two operands:
  
  The first operand is a "done" signal of type `i1` which indicates the end of
  the simulation. The simulation stops when the done signal is 1 during a
  0-to-1 transition of the clock after the init signal has dropped to 0. No
  additional clock toggles occur once done has been sampled as 1.
  
  The second operand is a "success" signal of type `i1` which indicates the
  success of a test as 1, or failure as 0. The signal is sampled at the same
  time as the done signal. Simulators must signal failure to the operating
  system through a non-zero exit code.
  
  #### Schedule
  
  The clock and init values adhere to the following schedule during
  simulation:
  
  | Time      | Clock | Init  | Comment
  |-----------|-------|-------| ----
  | t0 (>=0s) | undef | undef | Clock and init may initially be undefined.
  | t1 (>=t0) | 0     | 1     | Initialization code (e.g., `seq.initial`, Verilog `initial` procedures) may run before or after clock and init change to their initial value.
  | t2 (>t1)  | 1     | 1     | Single rising clock edge occurs while init is high.
  | t3 (>t2)  | 0     | 1     | Init may stay during the falling clock edge.
  | t4 (>=t3) | 0     | 0     | Init goes to 0 before second rising clock edge.
  | t5 (>t4)  | 1     | 0     | Clock toggles continue indefinitely.
  | t6 (>t5)  | 0     | 0     |
  
  Simulation termination occurs when the done signal is 1 during a 0-to-1
  transition of the clock.
  
  #### Example
  ```
  verif.simulation @AdderTest {myParam = 42, myTag = "hello"} {
  ^bb0(%clock: !seq.clock, %init: i1):
    // Count the first 9001 simulation cycles.
    %c0_i19 = hw.constant 0 : i19
    %c1_i19 = hw.constant 1 : i19
    %c9001_i19 = hw.constant 9001 : i19
    %count = seq.compreg %0, %clock reset %init, %c0_i19 : i19
    %done = comb.icmp eq %count, %c9001_i19 : i19
    %0 = comb.add %count, %c1_i19 : i19
  
    // Generate inputs to the adder.
    %1, %2 = func.call @generateAdderInputs(%count) : (i19) -> (i42, i42)
    %3 = hw.instance "dut" @Adder(a: %1: i42, b: %2: i42) -> (c: i42)
  
    // Check results and track failures.
    %4 = comb.add %1, %2 : i42
    %5 = comb.icmp eq %3, %4 : i42
    %true = hw.constant true
    %success = seq.compreg %6, %clock reset %init, %true : i1
    %6 = comb.and %success, %5 : i1
  
    verif.yield %done, %success : i1, i1
  }
  ```
  """

  OPERATION_NAME = "verif.simulation"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, parameters, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["parameters"] = (parameters if (
    isinstance(parameters, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DictionaryAttr')) else
      _ods_ir.AttrBuilder.get('DictionaryAttr')(parameters, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def parameters(self) -> _ods_ir.DictAttr:
    return self.operation.attributes["parameters"]

  @parameters.setter
  def parameters(self, value: _ods_ir.DictAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["parameters"] = value

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def simulation(sym_name, parameters, *, loc=None, ip=None) -> SimulationOp:
  return SimulationOp(sym_name=sym_name, parameters=parameters, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SymbolicValueOp(_ods_ir.OpView):
  r"""
  This operation creates a new symbolic value that can be used to formally
  verify designs. Verification tools will try to find concrete assignments for
  symbolic values that violate asserts or make covers true. This value is not
  fixed - the value taken can vary arbitrarily between timesteps.
  """

  OPERATION_NAME = "verif.symbolic_value"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def symbolic_value(result, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return SymbolicValueOp(result=result, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class YieldOp(_ods_ir.OpView):
  OPERATION_NAME = "verif.yield"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def yield_(inputs, *, loc=None, ip=None) -> YieldOp:
  return YieldOp(inputs=inputs, loc=loc, ip=ip)
