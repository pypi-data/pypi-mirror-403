
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "pipeline"

@_ods_cext.register_operation(_Dialect)
class LatencyOp(_ods_ir.OpView):
  r"""
  The `pipeline.latency` operation represents an operation for wrapping
  multi-cycle operations. The operation declares a single block
  wherein any operation may be placed within. The operation is not
  `IsolatedFromAbove` meaning that the operation can reference values
  defined outside of the operation (subject to the materialization
  phase of the parent pipeline).
  """

  OPERATION_NAME = "pipeline.latency"

  _ODS_REGIONS = (1, True)

  def __init__(self, results_, latency, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["latency"] = (latency if (
    isinstance(latency, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(latency, context=_ods_context))
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def latency(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["latency"]

  @latency.setter
  def latency(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["latency"] = value

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def latency(results_, latency, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, LatencyOp]:
  op = LatencyOp(results_=results_, latency=latency, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class LatencyReturnOp(_ods_ir.OpView):
  r"""
  The `pipeline.latency.return` operation represents a terminator of a
  `pipeline.latency` operation.
  """

  OPERATION_NAME = "pipeline.latency.return"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def latency_return(inputs, *, loc=None, ip=None) -> LatencyReturnOp:
  return LatencyReturnOp(inputs=inputs, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ReturnOp(_ods_ir.OpView):
  r"""
  The "return" operation represents a terminator of a `pipeline.pipeline`.
  """

  OPERATION_NAME = "pipeline.return"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def return_(inputs, *, loc=None, ip=None) -> ReturnOp:
  return ReturnOp(inputs=inputs, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ScheduledPipelineOp(_ods_ir.OpView):
  r"""
  The `pipeline.scheduled` operation represents a scheduled pipeline.
  The pipeline contains a single block representing a graph region.
  
  A `pipeline.scheduled` operation can exist in multiple phases, mainly
  pertaining to when registers have been materialized (made explicit).
  For an in-depth explanation, please refer to the Pipeline dialect rationale.
  
  A `pipeline.scheduled` supports a `stall` input. This signal is intended to
  connect to all stages within the pipeline, and is used to stall the entirety
  of the pipeline. It is lowering defined how stages choose to use this signal,
  although in the common case, a `stall` signal would typically connect to
  the clock-enable input of the stage-separating registers.
  
  The `go` input is used to start the pipeline. This value is fed through
  the stages as the current stage valid/next stage enable signal.
  Note: the op is currently only designed for pipelines with II=1. For
  pipelines with II>1, a user must themselves maintain state about when
  the pipeline is ready to accept new inputs. We plan to add support for
  head-of-pipeline backpressure in the future.
  
  Any value defined outside the pipeline is considered an external input. An
  external input will _not_ be registered.
  
  The pipeline may optionally be provided with an array of bits `stallability`
  which is used to determine which stages are stallable.
  - If not provided and the pipeline has a stall signal, all stages are stallable.
  - If provided, and the pipeline has a stall signal, the number of bits must
    match the number of stages in the pipeline. Each bit represents a stage,
    in the order of which the stages appear wrt. the `pipeline.stage` operations.
    A bit set to 1 indicates that the stage is stallable, and 0 indicates that
    the stage is not stallable.
  
  The exit (non-registered) stage of a pipeline cannot be non-stallable, and
  will always follow the stallability of the parent pipeline.
  
  For more information about non-stallable stages, and how these are lowered,
  please refer to the Pipeline dialect rationale.
  """

  OPERATION_NAME = "pipeline.scheduled"

  _ODS_OPERAND_SEGMENTS = [-1,0,1,0,1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, dataOutputs, done, inputs, clock, go, inputNames, outputNames, *, name=None, stall=None, reset=None, stallability=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(stall)
    operands.append(clock)
    operands.append(reset)
    operands.append(go)
    _ods_context = _ods_get_default_loc_context(loc)
    if name is not None: attributes["name"] = (name if (
        isinstance(name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    attributes["inputNames"] = (inputNames if (
    isinstance(inputNames, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
      _ods_ir.AttrBuilder.get('StrArrayAttr')(inputNames, context=_ods_context))
    attributes["outputNames"] = (outputNames if (
    isinstance(outputNames, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
      _ods_ir.AttrBuilder.get('StrArrayAttr')(outputNames, context=_ods_context))
    if stallability is not None: attributes["stallability"] = (stallability if (
        isinstance(stallability, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolArrayAttr')) else
          _ods_ir.AttrBuilder.get('BoolArrayAttr')(stallability, context=_ods_context))
    results = []
    results.extend(dataOutputs)
    results.append(done)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def stall(self) -> _Optional[_ods_ir.Value[_ods_ir.IntegerType]]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def clock(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def reset(self) -> _Optional[_ods_ir.Value[_ods_ir.IntegerType]]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def go(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range[0]

  @builtins.property
  def name(self) -> _Optional[_ods_ir.StringAttr]:
    if "name" not in self.operation.attributes:
      return None
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["name"] = value
    elif "name" in self.operation.attributes:
      del self.operation.attributes["name"]

  @name.deleter
  def name(self):
    del self.operation.attributes["name"]

  @builtins.property
  def inputNames(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["inputNames"]

  @inputNames.setter
  def inputNames(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["inputNames"] = value

  @builtins.property
  def outputNames(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["outputNames"]

  @outputNames.setter
  def outputNames(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputNames"] = value

  @builtins.property
  def stallability(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "stallability" not in self.operation.attributes:
      return None
    return self.operation.attributes["stallability"]

  @stallability.setter
  def stallability(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["stallability"] = value
    elif "stallability" in self.operation.attributes:
      del self.operation.attributes["stallability"]

  @stallability.deleter
  def stallability(self):
    del self.operation.attributes["stallability"]

  @builtins.property
  def dataOutputs(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def done(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[1 + _ods_variadic_group_length - 1]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def scheduled(data_outputs, done, inputs, clock, go, input_names, output_names, *, name=None, stall=None, reset=None, stallability=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, ScheduledPipelineOp]:
  op = ScheduledPipelineOp(dataOutputs=data_outputs, done=done, inputs=inputs, clock=clock, go=go, inputNames=input_names, outputNames=output_names, name=name, stall=stall, reset=reset, stallability=stallability, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class SourceOp(_ods_ir.OpView):
  r"""
  The `pipeline.src` operation represents a source operation in a scheduled,
  non-register materialized pipeline.
  It is used as a canonicalization barrier to prevent cross-block canonicalization
  of operations that are not allowed to be moved or mutated across pipeline
  stages (i.e. MLIR blocks).
  
  To facilitate this, the operation is _not_ marked as `Pure`.
  """

  OPERATION_NAME = "pipeline.src"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def src(input, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return SourceOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class StageOp(_ods_ir.OpView):
  r"""
  The `pipeline.stage` operation represents a stage terminator. It is used
  to communicate:
  1. which stage (block) to transition to next
  2. which registers to build at this stage boundary
  3. which values to pass through to the next stage without registering
  4. An optional hierarchy of boolean values to be used for clock gates for
     each register.
    - The implicit '!stalled' gate will always be the first signal in the
      hierarchy. Further signals are added to the hierarchy from left to
      right.
  
  
  Example:
  ```mlir
  pipeline.stage ^bb1 regs(%a : i32 gated by [%foo, %bar], %b : i1) pass(%c : i32)
  ```
  """

  OPERATION_NAME = "pipeline.stage"

  _ODS_OPERAND_SEGMENTS = [-1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, registers, passthroughs, clockGates, clockGatesPerRegister, nextStage, *, registerNames=None, passthroughNames=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(registers))
    operands.append(_get_op_results_or_values(passthroughs))
    operands.append(_get_op_results_or_values(clockGates))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["clockGatesPerRegister"] = (clockGatesPerRegister if (
    isinstance(clockGatesPerRegister, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(clockGatesPerRegister, context=_ods_context))
    if registerNames is not None: attributes["registerNames"] = (registerNames if (
        isinstance(registerNames, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
          _ods_ir.AttrBuilder.get('StrArrayAttr')(registerNames, context=_ods_context))
    if passthroughNames is not None: attributes["passthroughNames"] = (passthroughNames if (
        isinstance(passthroughNames, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
          _ods_ir.AttrBuilder.get('StrArrayAttr')(passthroughNames, context=_ods_context))
    results = []
    _ods_successors = []
    _ods_successors.append(nextStage)
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def registers(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def passthroughs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def clockGates(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def clockGatesPerRegister(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["clockGatesPerRegister"]

  @clockGatesPerRegister.setter
  def clockGatesPerRegister(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["clockGatesPerRegister"] = value

  @builtins.property
  def registerNames(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "registerNames" not in self.operation.attributes:
      return None
    return self.operation.attributes["registerNames"]

  @registerNames.setter
  def registerNames(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["registerNames"] = value
    elif "registerNames" in self.operation.attributes:
      del self.operation.attributes["registerNames"]

  @registerNames.deleter
  def registerNames(self):
    del self.operation.attributes["registerNames"]

  @builtins.property
  def passthroughNames(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "passthroughNames" not in self.operation.attributes:
      return None
    return self.operation.attributes["passthroughNames"]

  @passthroughNames.setter
  def passthroughNames(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["passthroughNames"] = value
    elif "passthroughNames" in self.operation.attributes:
      del self.operation.attributes["passthroughNames"]

  @passthroughNames.deleter
  def passthroughNames(self):
    del self.operation.attributes["passthroughNames"]

def stage(registers, passthroughs, clock_gates, clock_gates_per_register, next_stage, *, register_names=None, passthrough_names=None, loc=None, ip=None) -> StageOp:
  return StageOp(registers=registers, passthroughs=passthroughs, clockGates=clock_gates, clockGatesPerRegister=clock_gates_per_register, nextStage=next_stage, registerNames=register_names, passthroughNames=passthrough_names, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class UnscheduledPipelineOp(_ods_ir.OpView):
  r"""
  The "pipeline.unscheduled" operation represents a pipeline that has not yet
  been scheduled. It contains a single block representing a graph region of
  operations to-be-scheduled into a pipeline.
  Mainly serves as a container and entrypoint for scheduling.
  
  The interface of a `pipeline.unscheduled` is similar to that of a
  `pipeline.scheduled`. Please refer to this op for further documentation
  about the interface signals.
  """

  OPERATION_NAME = "pipeline.unscheduled"

  _ODS_OPERAND_SEGMENTS = [-1,0,1,0,1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, dataOutputs, done, inputs, clock, go, inputNames, outputNames, *, name=None, stall=None, reset=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(stall)
    operands.append(clock)
    operands.append(reset)
    operands.append(go)
    _ods_context = _ods_get_default_loc_context(loc)
    if name is not None: attributes["name"] = (name if (
        isinstance(name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    attributes["inputNames"] = (inputNames if (
    isinstance(inputNames, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
      _ods_ir.AttrBuilder.get('StrArrayAttr')(inputNames, context=_ods_context))
    attributes["outputNames"] = (outputNames if (
    isinstance(outputNames, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
      _ods_ir.AttrBuilder.get('StrArrayAttr')(outputNames, context=_ods_context))
    results = []
    results.extend(dataOutputs)
    results.append(done)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def stall(self) -> _Optional[_ods_ir.Value[_ods_ir.IntegerType]]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def clock(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def reset(self) -> _Optional[_ods_ir.Value[_ods_ir.IntegerType]]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def go(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range[0]

  @builtins.property
  def name(self) -> _Optional[_ods_ir.StringAttr]:
    if "name" not in self.operation.attributes:
      return None
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["name"] = value
    elif "name" in self.operation.attributes:
      del self.operation.attributes["name"]

  @name.deleter
  def name(self):
    del self.operation.attributes["name"]

  @builtins.property
  def inputNames(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["inputNames"]

  @inputNames.setter
  def inputNames(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["inputNames"] = value

  @builtins.property
  def outputNames(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["outputNames"]

  @outputNames.setter
  def outputNames(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputNames"] = value

  @builtins.property
  def dataOutputs(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def done(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[1 + _ods_variadic_group_length - 1]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def unscheduled(data_outputs, done, inputs, clock, go, input_names, output_names, *, name=None, stall=None, reset=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, UnscheduledPipelineOp]:
  op = UnscheduledPipelineOp(dataOutputs=data_outputs, done=done, inputs=inputs, clock=clock, go=go, inputNames=input_names, outputNames=output_names, name=name, stall=stall, reset=reset, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)
