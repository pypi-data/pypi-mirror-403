
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "sim"

@_ods_cext.register_operation(_Dialect)
class ClockedPauseOp(_ods_ir.OpView):
  r"""
  Implements the semantics of `sim.pause` if the given condition is true on
  the rising edge of the clock operand.
  """

  OPERATION_NAME = "sim.clocked_pause"

  _ODS_REGIONS = (0, True)

  def __init__(self, clock, condition, verbose, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(clock)
    operands.append(condition)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["verbose"] = (verbose if (
    isinstance(verbose, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(verbose, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def clock(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def condition(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def verbose(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["verbose"]

  @verbose.setter
  def verbose(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["verbose"] = value

def clocked_pause(clock, condition, verbose, *, loc=None, ip=None) -> ClockedPauseOp:
  return ClockedPauseOp(clock=clock, condition=condition, verbose=verbose, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ClockedTerminateOp(_ods_ir.OpView):
  r"""
  Implements the semantics of `sim.terminate` if the given condition is true
  on the rising edge of the clock operand.
  """

  OPERATION_NAME = "sim.clocked_terminate"

  _ODS_REGIONS = (0, True)

  def __init__(self, clock, condition, success, verbose, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(clock)
    operands.append(condition)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["success"] = (success if (
    isinstance(success, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(success, context=_ods_context))
    attributes["verbose"] = (verbose if (
    isinstance(verbose, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(verbose, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def clock(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def condition(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def success(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["success"]

  @success.setter
  def success(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["success"] = value

  @builtins.property
  def verbose(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["verbose"]

  @verbose.setter
  def verbose(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["verbose"] = value

def clocked_terminate(clock, condition, success, verbose, *, loc=None, ip=None) -> ClockedTerminateOp:
  return ClockedTerminateOp(clock=clock, condition=condition, success=success, verbose=verbose, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DPICallOp(_ods_ir.OpView):
  r"""
  `sim.func.dpi.call` represents SystemVerilog DPI function call. There are two
  optional operands `clock` and `enable`.
  
  If `clock` is not provided, the callee is invoked when input values are changed.
  If provided, the DPI function is called at clock's posedge. The result values behave
  like registers and the DPI function is used as a state transfer function of them.
  
  `enable` operand is used to conditionally call the DPI since DPI call could be quite
  more expensive than native constructs. When `enable` is low, results of unclocked
  calls are undefined and in SV results they are lowered into `X`. Users are expected
  to gate result values by another `enable` to model a default value of results.
  
  For clocked calls, a low enable means that its register state transfer function is
  not called. Hence their values will not be modify in that clock.
  """

  OPERATION_NAME = "sim.func.dpi.call"

  _ODS_OPERAND_SEGMENTS = [0,0,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, result, callee, inputs, *, clock=None, enable=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(clock)
    operands.append(enable)
    operands.append(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["callee"] = (callee if (
    isinstance(callee, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(callee, context=_ods_context))
    results = []
    results.extend(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def clock(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def enable(self) -> _Optional[_ods_ir.Value[_ods_ir.IntegerType]]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def callee(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["callee"]

  @callee.setter
  def callee(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["callee"] = value

def func_dpi_call(result, callee, inputs, *, clock=None, enable=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, DPICallOp]:
  op = DPICallOp(result=result, callee=callee, inputs=inputs, clock=clock, enable=enable, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class DPIFuncOp(_ods_ir.OpView):
  r"""
  `sim.func.dpi` models an external function in a core dialect.
  """

  OPERATION_NAME = "sim.func.dpi"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, module_type, *, per_argument_attrs=None, argument_locs=None, verilogName=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["module_type"] = (module_type if (
    isinstance(module_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_501')) else
      _ods_ir.AttrBuilder.get('anonymous_501')(module_type, context=_ods_context))
    if per_argument_attrs is not None: attributes["per_argument_attrs"] = (per_argument_attrs if (
        isinstance(per_argument_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(per_argument_attrs, context=_ods_context))
    if argument_locs is not None: attributes["argument_locs"] = (argument_locs if (
        isinstance(argument_locs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LocationArrayAttr')) else
          _ods_ir.AttrBuilder.get('LocationArrayAttr')(argument_locs, context=_ods_context))
    if verilogName is not None: attributes["verilogName"] = (verilogName if (
        isinstance(verilogName, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(verilogName, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def module_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["module_type"]

  @module_type.setter
  def module_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["module_type"] = value

  @builtins.property
  def per_argument_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "per_argument_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["per_argument_attrs"]

  @per_argument_attrs.setter
  def per_argument_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["per_argument_attrs"] = value
    elif "per_argument_attrs" in self.operation.attributes:
      del self.operation.attributes["per_argument_attrs"]

  @per_argument_attrs.deleter
  def per_argument_attrs(self):
    del self.operation.attributes["per_argument_attrs"]

  @builtins.property
  def argument_locs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "argument_locs" not in self.operation.attributes:
      return None
    return self.operation.attributes["argument_locs"]

  @argument_locs.setter
  def argument_locs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["argument_locs"] = value
    elif "argument_locs" in self.operation.attributes:
      del self.operation.attributes["argument_locs"]

  @argument_locs.deleter
  def argument_locs(self):
    del self.operation.attributes["argument_locs"]

  @builtins.property
  def verilogName(self) -> _Optional[_ods_ir.StringAttr]:
    if "verilogName" not in self.operation.attributes:
      return None
    return self.operation.attributes["verilogName"]

  @verilogName.setter
  def verilogName(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["verilogName"] = value
    elif "verilogName" in self.operation.attributes:
      del self.operation.attributes["verilogName"]

  @verilogName.deleter
  def verilogName(self):
    del self.operation.attributes["verilogName"]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def func_dpi(sym_name, module_type, *, per_argument_attrs=None, argument_locs=None, verilog_name=None, loc=None, ip=None) -> DPIFuncOp:
  return DPIFuncOp(sym_name=sym_name, module_type=module_type, per_argument_attrs=per_argument_attrs, argument_locs=argument_locs, verilogName=verilog_name, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class FormatBinOp(_ods_ir.OpView):
  r"""
  Format the given integer value as binary (base two) string.
  
  The printed value will be left-padded with '0' up to the number
  of bits of the argument's type. Zero width values will produce
  the empty string. No further prefix will be added.
  """

  OPERATION_NAME = "sim.fmt.bin"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, *, isLeftAligned=None, paddingChar=None, specifierWidth=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    if isLeftAligned is not None: attributes["isLeftAligned"] = (isLeftAligned if (
        isinstance(isLeftAligned, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(isLeftAligned, context=_ods_context))
    if paddingChar is not None: attributes["paddingChar"] = (paddingChar if (
        isinstance(paddingChar, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I8Attr')) else
          _ods_ir.AttrBuilder.get('I8Attr')(paddingChar, context=_ods_context))
    if specifierWidth is not None: attributes["specifierWidth"] = (specifierWidth if (
        isinstance(specifierWidth, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(specifierWidth, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def isLeftAligned(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["isLeftAligned"]

  @isLeftAligned.setter
  def isLeftAligned(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["isLeftAligned"] = value

  @builtins.property
  def paddingChar(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["paddingChar"]

  @paddingChar.setter
  def paddingChar(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["paddingChar"] = value

  @builtins.property
  def specifierWidth(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "specifierWidth" not in self.operation.attributes:
      return None
    return self.operation.attributes["specifierWidth"]

  @specifierWidth.setter
  def specifierWidth(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["specifierWidth"] = value
    elif "specifierWidth" in self.operation.attributes:
      del self.operation.attributes["specifierWidth"]

  @specifierWidth.deleter
  def specifierWidth(self):
    del self.operation.attributes["specifierWidth"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def fmt_bin(value, *, is_left_aligned=None, padding_char=None, specifier_width=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FormatBinOp(value=value, isLeftAligned=is_left_aligned, paddingChar=padding_char, specifierWidth=specifier_width, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FormatCharOp(_ods_ir.OpView):
  r"""
  Format the given integer value as a single character.
  
  For integer values up to 127, ASCII compatible encoding is assumed.
  For larger values, the encoding is unspecified.
  
  If the argument's type width is less than eight bits, the value is
  zero extended.
  If the width is greater than eight bits, the resulting formatted string
  is undefined.
  """

  OPERATION_NAME = "sim.fmt.char"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def fmt_char(value, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FormatCharOp(value=value, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FormatDecOp(_ods_ir.OpView):
  r"""
  Format the given integer value as signed or unsigned decimal string.
  
  Leading zeros are omitted. Non-negative or unsigned values will
  _not_ be prefixed with a '+'.
  
  For unsigned formatting, the printed value will
  be left-padded with spaces up to _at least_ the length required to print
  the maximum unsigned value of the argument's type.
  For signed formatting, the printed value will be
  left-padded with spaces up to _at least_ the length required
  to print the minimum signed value of the argument's type
  including the '-' character.
  E.g., a zero value of type `i1` requires no padding for unsigned
  formatting and one leading space for signed formatting.
  Format specifiers of same argument type and signedness must be
  padded to the same width. Zero width values will produce
  a single '0'.
  
  Backends are recommended to not exceed the required amount of padding.
  """

  OPERATION_NAME = "sim.fmt.dec"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, *, isLeftAligned=None, paddingChar=None, specifierWidth=None, isSigned=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    if isLeftAligned is not None: attributes["isLeftAligned"] = (isLeftAligned if (
        isinstance(isLeftAligned, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(isLeftAligned, context=_ods_context))
    if paddingChar is not None: attributes["paddingChar"] = (paddingChar if (
        isinstance(paddingChar, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I8Attr')) else
          _ods_ir.AttrBuilder.get('I8Attr')(paddingChar, context=_ods_context))
    if specifierWidth is not None: attributes["specifierWidth"] = (specifierWidth if (
        isinstance(specifierWidth, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(specifierWidth, context=_ods_context))
    if bool(isSigned): attributes["isSigned"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def isLeftAligned(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["isLeftAligned"]

  @isLeftAligned.setter
  def isLeftAligned(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["isLeftAligned"] = value

  @builtins.property
  def paddingChar(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["paddingChar"]

  @paddingChar.setter
  def paddingChar(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["paddingChar"] = value

  @builtins.property
  def specifierWidth(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "specifierWidth" not in self.operation.attributes:
      return None
    return self.operation.attributes["specifierWidth"]

  @specifierWidth.setter
  def specifierWidth(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["specifierWidth"] = value
    elif "specifierWidth" in self.operation.attributes:
      del self.operation.attributes["specifierWidth"]

  @specifierWidth.deleter
  def specifierWidth(self):
    del self.operation.attributes["specifierWidth"]

  @builtins.property
  def isSigned(self) -> bool:
    return "isSigned" in self.operation.attributes

  @isSigned.setter
  def isSigned(self, value):
    if bool(value):
      self.operation.attributes["isSigned"] = _ods_ir.UnitAttr.get()
    elif "isSigned" in self.operation.attributes:
      del self.operation.attributes["isSigned"]

  @isSigned.deleter
  def isSigned(self):
    del self.operation.attributes["isSigned"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def fmt_dec(value, *, is_left_aligned=None, padding_char=None, specifier_width=None, is_signed=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FormatDecOp(value=value, isLeftAligned=is_left_aligned, paddingChar=padding_char, specifierWidth=specifier_width, isSigned=is_signed, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FormatFloatOp(_ods_ir.OpView):
  r"""
  Format the given real value in floating point (decimal) notation
  """

  OPERATION_NAME = "sim.fmt.flt"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, *, isLeftAligned=None, fieldWidth=None, fracDigits=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    if isLeftAligned is not None: attributes["isLeftAligned"] = (isLeftAligned if (
        isinstance(isLeftAligned, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(isLeftAligned, context=_ods_context))
    if fieldWidth is not None: attributes["fieldWidth"] = (fieldWidth if (
        isinstance(fieldWidth, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(fieldWidth, context=_ods_context))
    if fracDigits is not None: attributes["fracDigits"] = (fracDigits if (
        isinstance(fracDigits, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(fracDigits, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def isLeftAligned(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["isLeftAligned"]

  @isLeftAligned.setter
  def isLeftAligned(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["isLeftAligned"] = value

  @builtins.property
  def fieldWidth(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "fieldWidth" not in self.operation.attributes:
      return None
    return self.operation.attributes["fieldWidth"]

  @fieldWidth.setter
  def fieldWidth(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["fieldWidth"] = value
    elif "fieldWidth" in self.operation.attributes:
      del self.operation.attributes["fieldWidth"]

  @fieldWidth.deleter
  def fieldWidth(self):
    del self.operation.attributes["fieldWidth"]

  @builtins.property
  def fracDigits(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["fracDigits"]

  @fracDigits.setter
  def fracDigits(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fracDigits"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def fmt_flt(value, *, is_left_aligned=None, field_width=None, frac_digits=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FormatFloatOp(value=value, isLeftAligned=is_left_aligned, fieldWidth=field_width, fracDigits=frac_digits, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FormatGeneralOp(_ods_ir.OpView):
  r"""
  Format floating-point numbers using either decimal or scientific notation
  based on the exponent and precision parameter fracDigits (default: 6)
  
  For exp ≥ 0:
  Uses decimal notation if exp + 1 ≤ max(1, fracDigits), otherwise switches
  to scientific notation with max(0, fracDigits - 1) fractional digits
  
  For exp < 0:
  If exp ≥ -4: Uses decimal notation with max(b - 1, 0) + |exp| fractional digits
  If exp < -4: Uses scientific notation with max(b - 1, 0) fractional digits
  """

  OPERATION_NAME = "sim.fmt.gen"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, *, isLeftAligned=None, fieldWidth=None, fracDigits=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    if isLeftAligned is not None: attributes["isLeftAligned"] = (isLeftAligned if (
        isinstance(isLeftAligned, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(isLeftAligned, context=_ods_context))
    if fieldWidth is not None: attributes["fieldWidth"] = (fieldWidth if (
        isinstance(fieldWidth, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(fieldWidth, context=_ods_context))
    if fracDigits is not None: attributes["fracDigits"] = (fracDigits if (
        isinstance(fracDigits, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(fracDigits, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def isLeftAligned(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["isLeftAligned"]

  @isLeftAligned.setter
  def isLeftAligned(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["isLeftAligned"] = value

  @builtins.property
  def fieldWidth(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "fieldWidth" not in self.operation.attributes:
      return None
    return self.operation.attributes["fieldWidth"]

  @fieldWidth.setter
  def fieldWidth(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["fieldWidth"] = value
    elif "fieldWidth" in self.operation.attributes:
      del self.operation.attributes["fieldWidth"]

  @fieldWidth.deleter
  def fieldWidth(self):
    del self.operation.attributes["fieldWidth"]

  @builtins.property
  def fracDigits(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["fracDigits"]

  @fracDigits.setter
  def fracDigits(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fracDigits"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def fmt_gen(value, *, is_left_aligned=None, field_width=None, frac_digits=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FormatGeneralOp(value=value, isLeftAligned=is_left_aligned, fieldWidth=field_width, fracDigits=frac_digits, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FormatHexOp(_ods_ir.OpView):
  r"""
  Format the given integer value as lower-case hexadecimal string.
  
  The printed value will be left-padded with '0' up to the
  length required to print the maximum value of the argument's
  type. Zero width values will produce the empty string.
  No further prefix will be added.
  """

  OPERATION_NAME = "sim.fmt.hex"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, isHexUppercase, *, isLeftAligned=None, paddingChar=None, specifierWidth=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["isHexUppercase"] = (isHexUppercase if (
    isinstance(isHexUppercase, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(isHexUppercase, context=_ods_context))
    if isLeftAligned is not None: attributes["isLeftAligned"] = (isLeftAligned if (
        isinstance(isLeftAligned, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(isLeftAligned, context=_ods_context))
    if paddingChar is not None: attributes["paddingChar"] = (paddingChar if (
        isinstance(paddingChar, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I8Attr')) else
          _ods_ir.AttrBuilder.get('I8Attr')(paddingChar, context=_ods_context))
    if specifierWidth is not None: attributes["specifierWidth"] = (specifierWidth if (
        isinstance(specifierWidth, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(specifierWidth, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def isHexUppercase(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["isHexUppercase"]

  @isHexUppercase.setter
  def isHexUppercase(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["isHexUppercase"] = value

  @builtins.property
  def isLeftAligned(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["isLeftAligned"]

  @isLeftAligned.setter
  def isLeftAligned(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["isLeftAligned"] = value

  @builtins.property
  def paddingChar(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["paddingChar"]

  @paddingChar.setter
  def paddingChar(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["paddingChar"] = value

  @builtins.property
  def specifierWidth(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "specifierWidth" not in self.operation.attributes:
      return None
    return self.operation.attributes["specifierWidth"]

  @specifierWidth.setter
  def specifierWidth(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["specifierWidth"] = value
    elif "specifierWidth" in self.operation.attributes:
      del self.operation.attributes["specifierWidth"]

  @specifierWidth.deleter
  def specifierWidth(self):
    del self.operation.attributes["specifierWidth"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def fmt_hex(value, is_hex_uppercase, *, is_left_aligned=None, padding_char=None, specifier_width=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FormatHexOp(value=value, isHexUppercase=is_hex_uppercase, isLeftAligned=is_left_aligned, paddingChar=padding_char, specifierWidth=specifier_width, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FormatLiteralOp(_ods_ir.OpView):
  r"""
  Creates a constant, raw ASCII string literal for formatted printing.
  The given string attribute will be outputted as is,
  including non-printable characters. The literal may be empty or contain
  null characters ('\0') which must not be interpreted as string
  terminators by backends.
  """

  OPERATION_NAME = "sim.fmt.literal"

  _ODS_REGIONS = (0, True)

  def __init__(self, literal, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["literal"] = (literal if (
    isinstance(literal, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(literal, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def literal(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["literal"]

  @literal.setter
  def literal(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["literal"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def fmt_literal(literal, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FormatLiteralOp(literal=literal, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FormatOctOp(_ods_ir.OpView):
  r"""
  Format the given integer value as lower-case octal (base eight) string.
  
  The printed value will be left-padded with '0' up to the
  length required to print the maximum value of the argument's
  type. Zero width values will produce the empty string.
  No further prefix will be added.
  """

  OPERATION_NAME = "sim.fmt.oct"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, *, isLeftAligned=None, paddingChar=None, specifierWidth=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    if isLeftAligned is not None: attributes["isLeftAligned"] = (isLeftAligned if (
        isinstance(isLeftAligned, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(isLeftAligned, context=_ods_context))
    if paddingChar is not None: attributes["paddingChar"] = (paddingChar if (
        isinstance(paddingChar, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I8Attr')) else
          _ods_ir.AttrBuilder.get('I8Attr')(paddingChar, context=_ods_context))
    if specifierWidth is not None: attributes["specifierWidth"] = (specifierWidth if (
        isinstance(specifierWidth, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(specifierWidth, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def isLeftAligned(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["isLeftAligned"]

  @isLeftAligned.setter
  def isLeftAligned(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["isLeftAligned"] = value

  @builtins.property
  def paddingChar(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["paddingChar"]

  @paddingChar.setter
  def paddingChar(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["paddingChar"] = value

  @builtins.property
  def specifierWidth(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "specifierWidth" not in self.operation.attributes:
      return None
    return self.operation.attributes["specifierWidth"]

  @specifierWidth.setter
  def specifierWidth(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["specifierWidth"] = value
    elif "specifierWidth" in self.operation.attributes:
      del self.operation.attributes["specifierWidth"]

  @specifierWidth.deleter
  def specifierWidth(self):
    del self.operation.attributes["specifierWidth"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def fmt_oct(value, *, is_left_aligned=None, padding_char=None, specifier_width=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FormatOctOp(value=value, isLeftAligned=is_left_aligned, paddingChar=padding_char, specifierWidth=specifier_width, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FormatScientificOp(_ods_ir.OpView):
  r"""
  Format the given real value in scientific (exponential) notation
  """

  OPERATION_NAME = "sim.fmt.exp"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, *, isLeftAligned=None, fieldWidth=None, fracDigits=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    if isLeftAligned is not None: attributes["isLeftAligned"] = (isLeftAligned if (
        isinstance(isLeftAligned, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(isLeftAligned, context=_ods_context))
    if fieldWidth is not None: attributes["fieldWidth"] = (fieldWidth if (
        isinstance(fieldWidth, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(fieldWidth, context=_ods_context))
    if fracDigits is not None: attributes["fracDigits"] = (fracDigits if (
        isinstance(fracDigits, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(fracDigits, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value[_ods_ir.FloatType]:
    return self.operation.operands[0]

  @builtins.property
  def isLeftAligned(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["isLeftAligned"]

  @isLeftAligned.setter
  def isLeftAligned(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["isLeftAligned"] = value

  @builtins.property
  def fieldWidth(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "fieldWidth" not in self.operation.attributes:
      return None
    return self.operation.attributes["fieldWidth"]

  @fieldWidth.setter
  def fieldWidth(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["fieldWidth"] = value
    elif "fieldWidth" in self.operation.attributes:
      del self.operation.attributes["fieldWidth"]

  @fieldWidth.deleter
  def fieldWidth(self):
    del self.operation.attributes["fieldWidth"]

  @builtins.property
  def fracDigits(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["fracDigits"]

  @fracDigits.setter
  def fracDigits(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fracDigits"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def fmt_exp(value, *, is_left_aligned=None, field_width=None, frac_digits=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FormatScientificOp(value=value, isLeftAligned=is_left_aligned, fieldWidth=field_width, fracDigits=frac_digits, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FormatStringConcatOp(_ods_ir.OpView):
  r"""
  Concatenates an arbitrary number of format strings from
  left to right. If the argument list is empty, the empty string
  literal is produced.
  
  Concatenations must not be recursive. I.e., a concatenated string should
  not contain itself directly or indirectly.
  """

  OPERATION_NAME = "sim.fmt.concat"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def fmt_concat(inputs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FormatStringConcatOp(inputs=inputs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IntToStringOp(_ods_ir.OpView):
  r"""
  Converts an integer value to a string following Verilog semantics, where
  string literals are represented as right-aligned bitvectors.
  
  The operation reads the integer byte-by-byte, interpreting each non-zero
  byte as an ASCII character. Zero-valued bytes are skipped and
  not included in the output string. See Sec 6.16 of the standard saying
  "A string variable shall not contain the special character "\0". 
  Assigning the value 0 to a string character shall be ignored"
  
  Example:
    Consider the hex value 0x00_00_00_48_00_00_6C_6F
    Reading from MSB to LSB and filtering out null bytes:
      - 0x48 = 'H'
      - 0x6C = 'l'
      - 0x6F = 'o'
    This produces the string "Hlo", not "\0\0\0H\0\0lo".
  """

  OPERATION_NAME = "sim.string.int_to_string"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def string_int_to_string(input, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return IntToStringOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PauseOp(_ods_ir.OpView):
  r"""
  Interrupt the simulation and give control back to the user in case of an
  interactive simulation. Non-interactive simulations may choose to terminate
  instead. Depending on the `verbose` operand, simulators may print additional
  information about the current simulation time and hierarchical location of
  the op.
  
  This op corresponds to the following SystemVerilog constructs:
  
  | Operation           | SystemVerilog          |
  |---------------------|------------------------|
  | `sim.pause quiet`   | `$stop(0)`             |
  | `sim.pause verbose` | `$stop` or `$stop(1)`  |
  """

  OPERATION_NAME = "sim.pause"

  _ODS_REGIONS = (0, True)

  def __init__(self, verbose, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["verbose"] = (verbose if (
    isinstance(verbose, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(verbose, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def verbose(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["verbose"]

  @verbose.setter
  def verbose(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["verbose"] = value

def pause(verbose, *, loc=None, ip=None) -> PauseOp:
  return PauseOp(verbose=verbose, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class PlusArgsTestOp(_ods_ir.OpView):
  OPERATION_NAME = "sim.plusargs.test"

  _ODS_REGIONS = (0, True)

  def __init__(self, formatString, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["formatString"] = (formatString if (
    isinstance(formatString, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(formatString, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def formatString(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["formatString"]

  @formatString.setter
  def formatString(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["formatString"] = value

  @builtins.property
  def found(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def plusargs_test(format_string, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return PlusArgsTestOp(formatString=format_string, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PlusArgsValueOp(_ods_ir.OpView):
  OPERATION_NAME = "sim.plusargs.value"

  _ODS_REGIONS = (0, True)

  def __init__(self, found, result, formatString, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["formatString"] = (formatString if (
    isinstance(formatString, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(formatString, context=_ods_context))
    results = []
    results.append(found)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def formatString(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["formatString"]

  @formatString.setter
  def formatString(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["formatString"] = value

  @builtins.property
  def found(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[1]

def plusargs_value(found, result, format_string, *, loc=None, ip=None) -> _ods_ir.OpResultList:
  return PlusArgsValueOp(found=found, result=result, formatString=format_string, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class PrintFormattedOp(_ods_ir.OpView):
  r"""
  Evaluate a format string and print it to the simulation console on the
  rising edge of the given clock, if, and only if, the condition argument
  is 'true'.
  
  Multiple print operations in the same module and on the same clock edge
  are performed according to their order of occurence in the IR. The order
  of printing for operations in different modules, instances or on different
  clocks is undefined.
  """

  OPERATION_NAME = "sim.print"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, clock, condition, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(clock)
    operands.append(condition)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def clock(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def condition(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[2]

def print_(input, clock, condition, *, loc=None, ip=None) -> PrintFormattedOp:
  return PrintFormattedOp(input=input, clock=clock, condition=condition, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class PrintFormattedProcOp(_ods_ir.OpView):
  r"""
  Evaluate a format string and print it to the simulation console.
  
  This operation must be within a procedural region.
  """

  OPERATION_NAME = "sim.proc.print"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

def proc_print(input, *, loc=None, ip=None) -> PrintFormattedProcOp:
  return PrintFormattedProcOp(input=input, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class StringConcatOp(_ods_ir.OpView):
  r"""
  Concatenates multiple strings into a single, longer string. The first
  operand appears first in the output string. The last character of the first
  operand is immediately followed by the first character of the second
  operand. If the operation has a single operand, its result is equal to that
  operand. If the operation has zero operands, it returns an empty string.
  The length of the result is the sum of each operand's length.
  
  Example:
  
  ```mlir
  %0 = sim.string.literal "abc"
  %1 = sim.string.literal "def"
  %2 = sim.string.literal "ghj"
  %3 = sim.string.concat (%0, %1, %2)  // %3 is "abcdefghj"
  %4 = sim.string.concat (%0)          // %4 is "abc"
  %5 = sim.string.concat ()            // %5 is ""
  ```
  """

  OPERATION_NAME = "sim.string.concat"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def string_concat(inputs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return StringConcatOp(inputs=inputs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class StringConstantOp(_ods_ir.OpView):
  r"""
  Creates a dynamic string from a constant string literal.
  """

  OPERATION_NAME = "sim.string.literal"

  _ODS_REGIONS = (0, True)

  def __init__(self, literal, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["literal"] = (literal if (
    isinstance(literal, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(literal, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def literal(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["literal"]

  @literal.setter
  def literal(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["literal"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def string_literal(literal, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return StringConstantOp(literal=literal, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class StringLengthOp(_ods_ir.OpView):
  r"""
  Returns the length of a dynamic string as an `i64` value.
  """

  OPERATION_NAME = "sim.string.length"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IntegerType]:
    return self.operation.results[0]

def string_length(input, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return StringLengthOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TerminateOp(_ods_ir.OpView):
  r"""
  Terminate the simulation with a success or failure exit code. Depending on
  the `verbose` operand, simulators may print additional information about the
  current simulation time and hierarchical location of the op.
  
  This op correpsonds to the following SystemVerilog constructs:
  
  | Operation                        | SystemVerilog             |
  |----------------------------------|---------------------------|
  | `sim.terminate success, quiet`   | `$finish(0)`              |
  | `sim.terminate success, verbose` | `$finish` or `$finish(1)` |
  | `sim.terminate failure, quiet`   | `$fatal(0)`               |
  | `sim.terminate failure, verbose` | `$fatal` or `$fatal(1)`   |
  
  Note that this op does not match the behavior of the `$exit` system task in
  SystemVerilog, which blocks execution of the calling process until all
  `program` instances have terminated, and then calls `$finish`.
  """

  OPERATION_NAME = "sim.terminate"

  _ODS_REGIONS = (0, True)

  def __init__(self, success, verbose, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["success"] = (success if (
    isinstance(success, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(success, context=_ods_context))
    attributes["verbose"] = (verbose if (
    isinstance(verbose, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(verbose, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def success(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["success"]

  @success.setter
  def success(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["success"] = value

  @builtins.property
  def verbose(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["verbose"]

  @verbose.setter
  def verbose(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["verbose"] = value

def terminate(success, verbose, *, loc=None, ip=None) -> TerminateOp:
  return TerminateOp(success=success, verbose=verbose, loc=loc, ip=ip)
