
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "rtg"

@_ods_cext.register_operation(_Dialect)
class ArrayCreateOp(_ods_ir.OpView):
  r"""
  This operation creates an array from a list of values. The element on the
  left-most position in the MLIR assembly format ends up at index 0.
  """

  OPERATION_NAME = "rtg.array_create"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, elements, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(elements))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def elements(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def array_create(result, elements, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ArrayCreateOp(result=result, elements=elements, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ArrayExtractOp(_ods_ir.OpView):
  r"""
  This operation returns the element at the given index of the array.
  Accessing out-of-bounds indices is (immediate) UB.
  """

  OPERATION_NAME = "rtg.array_extract"

  _ODS_REGIONS = (0, True)

  def __init__(self, array, index, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(array)
    operands.append(index)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def array(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def index(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def array_extract(array, index, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ArrayExtractOp(array=array, index=index, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ArrayInjectOp(_ods_ir.OpView):
  r"""
  This operation produces a new array of the same type as the input array and
  sets the element at the given index to the given value. All other values
  remain the same. An OOB access is (immediate) undefined behavior.
  """

  OPERATION_NAME = "rtg.array_inject"

  _ODS_REGIONS = (0, True)

  def __init__(self, array, index, value, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(array)
    operands.append(index)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def array(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def index(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def array_inject(array, index, value, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ArrayInjectOp(array=array, index=index, value=value, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ArraySizeOp(_ods_ir.OpView):
  OPERATION_NAME = "rtg.array_size"

  _ODS_REGIONS = (0, True)

  def __init__(self, array, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(array)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def array(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def array_size(array, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ArraySizeOp(array=array, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BagConvertToSetOp(_ods_ir.OpView):
  r"""
  This operation converts a bag to a set by dropping all duplicate elements.
  For example, the bag `{a, a, b}` is converted to `{a, b}`.
  """

  OPERATION_NAME = "rtg.bag_convert_to_set"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def bag_convert_to_set(input, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BagConvertToSetOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BagCreateOp(_ods_ir.OpView):
  r"""
  This operation constructs a bag with the provided values and associated
  multiples. This means the bag constructed in the following example contains
  two of each `%arg0` and `%arg0` (`{%arg0, %arg0, %arg1, %arg1}`).
  
  ```mlir
  %0 = arith.constant 2 : index
  %1 = rtg.bag_create (%0 x %arg0, %0 x %arg1) : i32
  ```
  """

  OPERATION_NAME = "rtg.bag_create"

  _ODS_REGIONS = (0, True)

  def __init__(self, bag, elements, multiples, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(elements))
    operands.extend(_get_op_results_or_values(multiples))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(bag)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def elements(self) -> _ods_ir.OpOperandList:
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 0, 2, 0, 0)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def multiples(self) -> _ods_ir.OpOperandList:
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 0, 2, 0, 1)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def bag(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def bag_create(bag, elements, multiples, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return BagCreateOp(bag=bag, elements=elements, multiples=multiples, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BagDifferenceOp(_ods_ir.OpView):
  r"""
  For each element the resulting bag will have as many fewer than the
  'original' bag as there are in the 'diff' bag. However, if the 'inf'
  attribute is attached, all elements of that kind will be removed (i.e., it
  is assumed the 'diff' bag has infinitely many copies of each element).
  """

  OPERATION_NAME = "rtg.bag_difference"

  _ODS_REGIONS = (0, True)

  def __init__(self, original, diff, *, inf=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(original)
    operands.append(diff)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(inf): attributes["inf"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def original(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def diff(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def inf(self) -> bool:
    return "inf" in self.operation.attributes

  @inf.setter
  def inf(self, value):
    if bool(value):
      self.operation.attributes["inf"] = _ods_ir.UnitAttr.get()
    elif "inf" in self.operation.attributes:
      del self.operation.attributes["inf"]

  @inf.deleter
  def inf(self):
    del self.operation.attributes["inf"]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def bag_difference(original, diff, *, inf=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BagDifferenceOp(original=original, diff=diff, inf=inf, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BagSelectRandomOp(_ods_ir.OpView):
  r"""
  This operation returns an element from the bag selected uniformely at
  random. Therefore, the number of duplicates of each element can be used to
  bias the distribution.
  If the bag does not contain any elements, the behavior of this operation is
  undefined.
  """

  OPERATION_NAME = "rtg.bag_select_random"

  _ODS_REGIONS = (0, True)

  def __init__(self, bag, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(bag)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def bag(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def bag_select_random(bag, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BagSelectRandomOp(bag=bag, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BagUnionOp(_ods_ir.OpView):
  r"""
  Computes the union of the given bags. The list of sets must contain at
  least one element.
  """

  OPERATION_NAME = "rtg.bag_union"

  _ODS_REGIONS = (0, True)

  def __init__(self, bags, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(bags))
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def bags(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def bag_union(bags, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BagUnionOp(bags=bags, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BagUniqueSizeOp(_ods_ir.OpView):
  r"""
  This operation returns the number of unique elements in the bag, i.e., for
  the bag `{a, a, b, c, c}` it returns 3.
  """

  OPERATION_NAME = "rtg.bag_unique_size"

  _ODS_REGIONS = (0, True)

  def __init__(self, bag, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(bag)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def bag(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def bag_unique_size(bag, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BagUniqueSizeOp(bag=bag, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CommentOp(_ods_ir.OpView):
  OPERATION_NAME = "rtg.comment"

  _ODS_REGIONS = (0, True)

  def __init__(self, comment, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["comment"] = (comment if (
    isinstance(comment, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(comment, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def comment(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["comment"]

  @comment.setter
  def comment(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["comment"] = value

def comment(comment, *, loc=None, ip=None) -> CommentOp:
  return CommentOp(comment=comment, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ConcatImmediateOp(_ods_ir.OpView):
  r"""
  This operation concatenates a variadic number of immediates into a single
  immediate. The operands are concatenated in order, with the first operand
  becoming the most significant bits of the result.
  """

  OPERATION_NAME = "rtg.isa.concat_immediate"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def isa_concat_immediate(operands_, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConcatImmediateOp(operands_=operands_, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConstantOp(_ods_ir.OpView):
  OPERATION_NAME = "rtg.constant"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypedAttrInterface')) else
      _ods_ir.AttrBuilder.get('TypedAttrInterface')(value, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Attribute:
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def constant(value, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConstantOp(value=value, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConstraintOp(_ods_ir.OpView):
  r"""
  This operation enforces a constraint. This allows to specify additional
  constraints on values after their construction. It should be avoided when
  possible as these backward constraints are computationally more expensive.
  
  Constraints should be tried to be solved such that all of them evaluate to
  'true'. If the constraint system turns out to be unsolvable, the compiler
  should error out gracefully as early as possible (it might also error out
  when the system is too expensive to solve).
  """

  OPERATION_NAME = "rtg.constraint"

  _ODS_REGIONS = (0, True)

  def __init__(self, condition, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(condition)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def condition(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

def constraint(condition, *, loc=None, ip=None) -> ConstraintOp:
  return ConstraintOp(condition=condition, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ContextSwitchOp(_ods_ir.OpView):
  r"""
  This operation allows the user to specify a sequence of instructions to
  switch from context 'from' to context 'to', randomize and embed a provided
  sequence, and switch back from context 'to' to context 'from'.  This
  sequence of instructions should be provided as the 'sequence' operand which
  is a sequence of the type '!rtg.sequence<context-type-interface,
  context-type-interface, !rtg.sequence>'.  The first parameter is the 'from'
  context, the second one the 'to' context, and the third is the sequence to
  randomize and embed under the 'to' context.
  """

  OPERATION_NAME = "rtg.context_switch"

  _ODS_REGIONS = (0, True)

  def __init__(self, from_, to, sequence, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(sequence)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["from"] = (from_ if (
    isinstance(from_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ContextResourceAttrInterface')) else
      _ods_ir.AttrBuilder.get('ContextResourceAttrInterface')(from_, context=_ods_context))
    attributes["to"] = (to if (
    isinstance(to, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ContextResourceAttrInterface')) else
      _ods_ir.AttrBuilder.get('ContextResourceAttrInterface')(to, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sequence(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def from_(self) -> _ods_ir.Attribute:
    return self.operation.attributes["from"]

  @from_.setter
  def from_(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["from"] = value

  @builtins.property
  def to(self) -> _ods_ir.Attribute:
    return self.operation.attributes["to"]

  @to.setter
  def to(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["to"] = value

def context_switch(from_, to, sequence, *, loc=None, ip=None) -> ContextSwitchOp:
  return ContextSwitchOp(from_=from_, to=to, sequence=sequence, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class EmbedSequenceOp(_ods_ir.OpView):
  r"""
  This operation takes a fully randomized sequence and embeds it into another
  sequence or test at the position of this operation.
  In particular, this is not any kind of function call, it doesn't set up a
  stack frame, etc. It behaves as if the sequence of instructions it refers to
  were directly inlined relacing this operation.
  """

  OPERATION_NAME = "rtg.embed_sequence"

  _ODS_REGIONS = (0, True)

  def __init__(self, sequence, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(sequence)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sequence(self) -> _ods_ir.Value:
    return self.operation.operands[0]

def embed_sequence(sequence, *, loc=None, ip=None) -> EmbedSequenceOp:
  return EmbedSequenceOp(sequence=sequence, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GetSequenceOp(_ods_ir.OpView):
  r"""
  This operation creates a sequence value referring to the provided sequence
  by symbol. It allows sequences to be passed around as an SSA value. For
  example, it can be inserted into a set and selected at random which is one
  of the main ways to do randomization.
  """

  OPERATION_NAME = "rtg.get_sequence"

  _ODS_REGIONS = (0, True)

  def __init__(self, ref, sequence, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sequence"] = (sequence if (
    isinstance(sequence, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(sequence, context=_ods_context))
    results = []
    results.append(ref)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sequence(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["sequence"]

  @sequence.setter
  def sequence(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sequence"] = value

  @builtins.property
  def ref(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def get_sequence(ref, sequence, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return GetSequenceOp(ref=ref, sequence=sequence, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IntToImmediateOp(_ods_ir.OpView):
  r"""
  Create an immediate of static bit-width from the provided integer. If the
  integer does not fit in the specified bit-width, an error shall be emitted
  when executing this operation.
  """

  OPERATION_NAME = "rtg.isa.int_to_immediate"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def isa_int_to_immediate(result, input, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return IntToImmediateOp(result=result, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class InterleaveSequencesOp(_ods_ir.OpView):
  r"""
  This operation takes a list of (at least one) fully randomized sequences and
  interleaves them by taking the next `batchSize` number of operations
  implementing the `InstructionOpInterface` of each sequence round-robin.
  
  Therefore, if only one sequence is in the list, this operation returns that
  sequence unchanged.
  """

  OPERATION_NAME = "rtg.interleave_sequences"

  _ODS_REGIONS = (0, True)

  def __init__(self, sequences, *, batchSize=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(sequences))
    _ods_context = _ods_get_default_loc_context(loc)
    if batchSize is not None: attributes["batchSize"] = (batchSize if (
        isinstance(batchSize, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(batchSize, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sequences(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def batchSize(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["batchSize"]

  @batchSize.setter
  def batchSize(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["batchSize"] = value

  @builtins.property
  def interleavedSequence(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def interleave_sequences(sequences, *, batch_size=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return InterleaveSequencesOp(sequences=sequences, batchSize=batch_size, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LabelDeclOp(_ods_ir.OpView):
  r"""
  Declares a label that can then be placed by an `rtg.label` operation in an
  instruction sequence, passed on to sequences via their arguments, and used
  by instructions (e.g., as jump targets) by allowing ISA dialects to use them
  directly as an operand of an instruction or by casting it to a value
  representing an immediate.
  
  The format string may contain placeholders of the form `{i}` where `i`
  refers to the i-th element in `args`.
  The declared label is uniqued by the compiler to no collide with any other
  label declarations.
  """

  OPERATION_NAME = "rtg.label_decl"

  _ODS_REGIONS = (0, True)

  def __init__(self, formatString, args, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["formatString"] = (formatString if (
    isinstance(formatString, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(formatString, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def formatString(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["formatString"]

  @formatString.setter
  def formatString(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["formatString"] = value

  @builtins.property
  def label(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def label_decl(format_string, args, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return LabelDeclOp(formatString=format_string, args=args, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LabelOp(_ods_ir.OpView):
  r"""
  Any declared label must only be placed at most once in any fully elaborated
  instruction sequence.
  """

  OPERATION_NAME = "rtg.label"

  _ODS_REGIONS = (0, True)

  def __init__(self, visibility, label, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(label)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["visibility"] = (visibility if (
    isinstance(visibility, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('LabelVisibilityAttr')) else
      _ods_ir.AttrBuilder.get('LabelVisibilityAttr')(visibility, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def label(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def visibility(self) -> _ods_ir.Attribute:
    return self.operation.attributes["visibility"]

  @visibility.setter
  def visibility(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["visibility"] = value

def label(visibility, label, *, loc=None, ip=None) -> LabelOp:
  return LabelOp(visibility=visibility, label=label, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class LabelUniqueDeclOp(_ods_ir.OpView):
  r"""
  Declares a label that can then be placed by an `rtg.label` operation in an
  instruction sequence, passed on to sequences via their arguments, and used
  by instructions (e.g., as jump targets) by allowing ISA dialects to use them
  directly as an operand of an instruction or by casting it to a value
  representing an immediate.
  
  The format string may contain placeholders of the form `{i}` where `i`
  refers to the i-th element in `args`.
  The declared label is uniqued by the compiler to no collide with any other
  label declarations.
  """

  OPERATION_NAME = "rtg.label_unique_decl"

  _ODS_REGIONS = (0, True)

  def __init__(self, formatString, args, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["formatString"] = (formatString if (
    isinstance(formatString, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(formatString, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def formatString(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["formatString"]

  @formatString.setter
  def formatString(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["formatString"] = value

  @builtins.property
  def label(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def label_unique_decl(format_string, args, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return LabelUniqueDeclOp(formatString=format_string, args=args, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MemoryAllocOp(_ods_ir.OpView):
  r"""
  This operation declares a memory to be allocated with the provided
  properties. It is only allowed to declare new memories in the `rtg.target`
  operations and must be passed as argument to the `rtg.test`.
  """

  OPERATION_NAME = "rtg.isa.memory_alloc"

  _ODS_REGIONS = (0, True)

  def __init__(self, memoryBlock, size, alignment, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(memoryBlock)
    operands.append(size)
    operands.append(alignment)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def memoryBlock(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def alignment(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[2]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def isa_memory_alloc(memory_block, size, alignment, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MemoryAllocOp(memoryBlock=memory_block, size=size, alignment=alignment, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MemoryBaseAddressOp(_ods_ir.OpView):
  r"""
  This operation returns the base address of the given memory. The bit-width
  of the returned immediate must match the address width of the given memory.
  """

  OPERATION_NAME = "rtg.isa.memory_base_address"

  _ODS_REGIONS = (0, True)

  def __init__(self, memory, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(memory)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def memory(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def isa_memory_base_address(memory, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MemoryBaseAddressOp(memory=memory, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MemoryBlockDeclareOp(_ods_ir.OpView):
  r"""
  This operation declares a memory block to be allocated with the provided
  properties. It is only allowed to declare new memory blocks in the
  `rtg.target` operations and must be passed as argument to the `rtg.test`.
  This is because the available memory blocks are specified by the hardware
  design. This specification is fixed from the start and thus a test should
  not be able to declare new memory blocks on-the-fly. However, tests are
  allowed to allocate memory regions from these memory blocks.
  
  The 'baseAddress' attribute specifies the first memory address (lowest
  address representing a valid access to the memory) and the 'endAddress'
  represents the last address (highest address that is valid to access the
  memory).
  """

  OPERATION_NAME = "rtg.isa.memory_block_declare"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, baseAddress, endAddress, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["baseAddress"] = (baseAddress if (
    isinstance(baseAddress, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('APIntAttr')) else
      _ods_ir.AttrBuilder.get('APIntAttr')(baseAddress, context=_ods_context))
    attributes["endAddress"] = (endAddress if (
    isinstance(endAddress, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('APIntAttr')) else
      _ods_ir.AttrBuilder.get('APIntAttr')(endAddress, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def baseAddress(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["baseAddress"]

  @baseAddress.setter
  def baseAddress(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["baseAddress"] = value

  @builtins.property
  def endAddress(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["endAddress"]

  @endAddress.setter
  def endAddress(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["endAddress"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def isa_memory_block_declare(result, base_address, end_address, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return MemoryBlockDeclareOp(result=result, baseAddress=base_address, endAddress=end_address, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MemorySizeOp(_ods_ir.OpView):
  OPERATION_NAME = "rtg.isa.memory_size"

  _ODS_REGIONS = (0, True)

  def __init__(self, memory, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(memory)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def memory(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def isa_memory_size(memory, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MemorySizeOp(memory=memory, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class OnContextOp(_ods_ir.OpView):
  r"""
  This operation takes a context and a fully substituted, but not yet
  randomized sequence and inserts the necessary instructions to switch from
  the current context to the provided context, randomizes and embeds the given
  sequence under the given context, and inserts instructions to switch back to
  the original context.
  
  These instructions are provided by the 'rtg.context_switch' operation. If no
  'rtg.context_switch' for this transition is provided, the compiler will
  error out. If multiple such context switches apply, the most recently
  registered one takes precedence.
  """

  OPERATION_NAME = "rtg.on_context"

  _ODS_REGIONS = (0, True)

  def __init__(self, context_, sequence, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(context_)
    operands.append(sequence)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def context_(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def sequence(self) -> _ods_ir.Value:
    return self.operation.operands[1]

def on_context(context_, sequence, *, loc=None, ip=None) -> OnContextOp:
  return OnContextOp(context_=context_, sequence=sequence, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RandomNumberInRangeOp(_ods_ir.OpView):
  r"""
  This operation computes a random number based on a uniform distribution
  within the given range. Both the lower and upper bounds are inclusive. If
  the range is empty, compilation will fail. This is (obviously) more
  performant than inserting all legal numbers into a set and using
  'set_select_random', but yields the same behavior.
  """

  OPERATION_NAME = "rtg.random_number_in_range"

  _ODS_REGIONS = (0, True)

  def __init__(self, lowerBound, upperBound, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lowerBound)
    operands.append(upperBound)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lowerBound(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[0]

  @builtins.property
  def upperBound(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def random_number_in_range(lower_bound, upper_bound, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return RandomNumberInRangeOp(lowerBound=lower_bound, upperBound=upper_bound, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RandomizeSequenceOp(_ods_ir.OpView):
  r"""
  This operation takes a fully substituted sequence and randomizes its
  content. This means, no operations the returned sequence does not contain
  any randomization constructs anymore (such as random selection from sets and
  bags, or other 'randomize_sequence' operations).
  
  It is useful to have this operation separate from 'embed_sequence' such that
  the exact same sequence (i.e., with the same random choices taken) can be
  embedded at multiple places.
  It is also useful to have this separate from sequence substitution because
  this operation is sensitive to the context, but the substitution values for
  a sequence family might already be available in a parent sequence that is
  placed on a different context. Thus, not having it separated would mean that
  the substitution values must all be passed down as arguments to the child
  sequence instead of a a single fully substituted sequence value.
  """

  OPERATION_NAME = "rtg.randomize_sequence"

  _ODS_REGIONS = (0, True)

  def __init__(self, sequence, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(sequence)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sequence(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def randomizedSequence(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def randomize_sequence(sequence, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return RandomizeSequenceOp(sequence=sequence, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SequenceOp(_ods_ir.OpView):
  r"""
  This operation collects a sequence of instructions such that they can be
  placed as one unit. This is effectively the way to impose a constraint on
  the order and presence of some instructions.
  
  It is allowed to contain randomization constructs and invokations on any
  contexts. It is not allowed to create new context resources inside a
  sequence, however.
  
  This operation can be invoked by the `invoke` and `on_context` operations.
  It is referred to by symbol and isolated from above to ease multi-threading
  and it allows the `rtg.test` operation to be isolated-from-above to provide
  stronger top-level isolation guarantees.
  """

  OPERATION_NAME = "rtg.sequence"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, sequenceType, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["sequenceType"] = (sequenceType if (
    isinstance(sequenceType, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_500')) else
      _ods_ir.AttrBuilder.get('anonymous_500')(sequenceType, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def sequenceType(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["sequenceType"]

  @sequenceType.setter
  def sequenceType(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sequenceType"] = value

  @builtins.property
  def bodyRegion(self) -> _ods_ir.Region:
    return self.regions[0]

def sequence(sym_name, sequence_type, *, loc=None, ip=None) -> SequenceOp:
  return SequenceOp(sym_name=sym_name, sequenceType=sequence_type, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SetCartesianProductOp(_ods_ir.OpView):
  r"""
  This operation computes a set of tuples from a list of input sets such that
  each combination of elements from the input sets is present in the result
  set. More formally, for n input sets it computes
  `X_1 x ... x X_n = {(x_1, ..., x_n) | x_i \in X_i for i  \in {1, ..., n}}`.
  At least one input set has to be provided (i.e., `n > 0`).
  
  For example, given two sets A and B with elements
  `A = {a0, a1}, B = {b0, b1}` the result set R will be
  `R = {(a0, b0), (a0, b1), (a1, b0), (a1, b1)}`.
  
  Note that an RTG set does not provide any guarantees about the order of
  elements an can thus not be iterated over or indexed into, however, a
  random element can be selected and subtracted from the set until it is
  empty. This procedure is determinstic and will yield the same sequence of
  elements for a fixed seed and RTG version. If more guarantees about the
  order of elements is necessary, use arrays instead (and compute the
  cartesian product manually using nested loops).
  """

  OPERATION_NAME = "rtg.set_cartesian_product"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def set_cartesian_product(inputs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return SetCartesianProductOp(inputs=inputs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SetConvertToBagOp(_ods_ir.OpView):
  r"""
  This operation converts a set to a bag. Each element in the set occurs
  exactly once in the resulting bag.
  """

  OPERATION_NAME = "rtg.set_convert_to_bag"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def set_convert_to_bag(input, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return SetConvertToBagOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SetCreateOp(_ods_ir.OpView):
  OPERATION_NAME = "rtg.set_create"

  _ODS_REGIONS = (0, True)

  def __init__(self, set, elements, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(elements))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(set)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def elements(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def set(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def set_create(set, elements, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return SetCreateOp(set=set, elements=elements, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SetDifferenceOp(_ods_ir.OpView):
  OPERATION_NAME = "rtg.set_difference"

  _ODS_REGIONS = (0, True)

  def __init__(self, original, diff, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(original)
    operands.append(diff)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def original(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def diff(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def set_difference(original, diff, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return SetDifferenceOp(original=original, diff=diff, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SetSelectRandomOp(_ods_ir.OpView):
  r"""
  This operation returns an element from the given set uniformly at random.
  Applying this operation to an empty set is undefined behavior.
  """

  OPERATION_NAME = "rtg.set_select_random"

  _ODS_REGIONS = (0, True)

  def __init__(self, set, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(set)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def set(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def set_select_random(set, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return SetSelectRandomOp(set=set, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SetSizeOp(_ods_ir.OpView):
  OPERATION_NAME = "rtg.set_size"

  _ODS_REGIONS = (0, True)

  def __init__(self, set, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(set)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def set(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.IndexType]:
    return self.operation.results[0]

def set_size(set, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return SetSizeOp(set=set, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SetUnionOp(_ods_ir.OpView):
  r"""
  Computes the union of the given sets. The list of sets must contain at
  least one element.
  """

  OPERATION_NAME = "rtg.set_union"

  _ODS_REGIONS = (0, True)

  def __init__(self, sets, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(sets))
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sets(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def set_union(sets, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return SetUnionOp(sets=sets, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SliceImmediateOp(_ods_ir.OpView):
  r"""
  This operation extracts a contiguous slice of bits from an immediate value.
  The slice is specified by a low bit index (inclusive) and the width of the
  slice is determined by the result type. The slice must fit within the input
  immediate's width.
  """

  OPERATION_NAME = "rtg.isa.slice_immediate"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, lowBit, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["lowBit"] = (lowBit if (
    isinstance(lowBit, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(lowBit, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def lowBit(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["lowBit"]

  @lowBit.setter
  def lowBit(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["lowBit"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def isa_slice_immediate(result, input, low_bit, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return SliceImmediateOp(result=result, input=input, lowBit=low_bit, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SpaceOp(_ods_ir.OpView):
  OPERATION_NAME = "rtg.isa.space"

  _ODS_REGIONS = (0, True)

  def __init__(self, size, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(size)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def size(self) -> _ods_ir.Value[_ods_ir.IndexType]:
    return self.operation.operands[0]

def isa_space(size, *, loc=None, ip=None) -> SpaceOp:
  return SpaceOp(size=size, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SubstituteSequenceOp(_ods_ir.OpView):
  r"""
  This operation substitutes the first N of the M >= N arguments of the given
  sequence family, where N is the size of provided argument substitution list.
  A new sequence (if N == M) or sequence family with M-N will be returned.
  
  Not having to deal with sequence arguments after randomly selecting a
  sequence simplifies the problem of coming up with values to pass as
  arguments, but also provides a way for the user to constrain the arguments
  at the location where they are added to a set or bag.
  """

  OPERATION_NAME = "rtg.substitute_sequence"

  _ODS_REGIONS = (0, True)

  def __init__(self, sequence, replacements, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(sequence)
    operands.extend(_get_op_results_or_values(replacements))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sequence(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def replacements(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def substitute_sequence(sequence, replacements, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return SubstituteSequenceOp(sequence=sequence, replacements=replacements, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TargetOp(_ods_ir.OpView):
  r"""
  This operation specifies capabilities of a specific test target and can
  provide additional information about it. These are added as operands to the
  `yield` terminator and implicitly packed up into an `!rtg.dict` type which
  is passed to tests that are matched with this target.
  
  These capabilities can, for example, consist of the number of CPUs, supported
  priviledge modes, available memories, etc.
  """

  OPERATION_NAME = "rtg.target"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, target, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["target"] = (target if (
    isinstance(target, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_544')) else
      _ods_ir.AttrBuilder.get('anonymous_544')(target, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def target(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["target"]

  @target.setter
  def target(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["target"] = value

  @builtins.property
  def bodyRegion(self) -> _ods_ir.Region:
    return self.regions[0]

def target(sym_name, target, *, loc=None, ip=None) -> TargetOp:
  return TargetOp(sym_name=sym_name, target=target, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class TestFailureOp(_ods_ir.OpView):
  OPERATION_NAME = "rtg.test.failure"

  _ODS_REGIONS = (0, True)

  def __init__(self, errorMessage, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["errorMessage"] = (errorMessage if (
    isinstance(errorMessage, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(errorMessage, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def errorMessage(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["errorMessage"]

  @errorMessage.setter
  def errorMessage(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["errorMessage"] = value

def test_failure(error_message, *, loc=None, ip=None) -> TestFailureOp:
  return TestFailureOp(errorMessage=error_message, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class TestOp(_ods_ir.OpView):
  r"""
  This operation declares the root of a randomized or directed test.
  The target attribute specifies requirements of this test. These can be
  refined by `rtg.require` operations inside this operation's body. A test
  can only be matched with a target if the target fulfills all the test's
  requirements. However, the target may provide more than the test requires.
  For example, if the target allows execution in a user and privileged mode,
  but the test only requires and runs in user mode, it can still be matched
  with that target.
  
  By default each test can be matched with all targets that fulfill its
  requirements, but the user can also directly provide a target via the
  'target' attribute. In that case, the test will only be randomized against
  that target.
  
  The 'templateName' attribute specifies the name of the original test
  template (mostly for result reporting purposes). This is because a test
  (template) can be matched against many targets and during this process one
  test per match is created, but all of them preserve the same test template
  name.
  
  The body of this operation shall be processed the same way as an
  `rtg.sequence`'s body with the exception of the block arguments.
  The arguments must match the fields of the dict type in the target attribute
  exactly. The test must not have any additional arguments and cannot be
  referenced by an `rtg.get_sequence` operation.
  
  If the end of the test is reached without executing an `rtg.test.success`
  or `rtg.test.failure` it is as if an `rtg.test.success` is executed at the
  very end.
  """

  OPERATION_NAME = "rtg.test"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, templateName, targetType, *, target=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["templateName"] = (templateName if (
    isinstance(templateName, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(templateName, context=_ods_context))
    attributes["targetType"] = (targetType if (
    isinstance(targetType, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_544')) else
      _ods_ir.AttrBuilder.get('anonymous_544')(targetType, context=_ods_context))
    if target is not None: attributes["target"] = (target if (
        isinstance(target, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
          _ods_ir.AttrBuilder.get('SymbolNameAttr')(target, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def templateName(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["templateName"]

  @templateName.setter
  def templateName(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["templateName"] = value

  @builtins.property
  def targetType(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["targetType"]

  @targetType.setter
  def targetType(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["targetType"] = value

  @builtins.property
  def target(self) -> _Optional[_ods_ir.StringAttr]:
    if "target" not in self.operation.attributes:
      return None
    return self.operation.attributes["target"]

  @target.setter
  def target(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["target"] = value
    elif "target" in self.operation.attributes:
      del self.operation.attributes["target"]

  @target.deleter
  def target(self):
    del self.operation.attributes["target"]

  @builtins.property
  def bodyRegion(self) -> _ods_ir.Region:
    return self.regions[0]

def test(sym_name, template_name, target_type, *, target=None, loc=None, ip=None) -> TestOp:
  return TestOp(sym_name=sym_name, templateName=template_name, targetType=target_type, target=target, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class TestSuccessOp(_ods_ir.OpView):
  OPERATION_NAME = "rtg.test.success"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def test_success(*, loc=None, ip=None) -> TestSuccessOp:
  return TestSuccessOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class TupleCreateOp(_ods_ir.OpView):
  OPERATION_NAME = "rtg.tuple_create"

  _ODS_REGIONS = (0, True)

  def __init__(self, elements, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(elements))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def elements(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tuple_create(elements, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return TupleCreateOp(elements=elements, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TupleExtractOp(_ods_ir.OpView):
  OPERATION_NAME = "rtg.tuple_extract"

  _ODS_REGIONS = (0, True)

  def __init__(self, tuple, index, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(tuple)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["index"] = (index if (
    isinstance(index, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(index, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def tuple(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def index(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["index"]

  @index.setter
  def index(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["index"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tuple_extract(tuple, index, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return TupleExtractOp(tuple=tuple, index=index, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ValidateOp(_ods_ir.OpView):
  r"""
  Validates the content of a reference-style value from the payload dialect
  at the position of this operation. This validation may happen in a single
  lowering step, e.g., a compiler pass that interprets the IR and inlines the
  interpreted value directly, or a program that can be run to generate the
  desired values may be generated first and in a second compilation run those
  values (possibly stored in a file by the first run) may be inlined at the
  position of these operations. For the latter, the ID attribute may be used
  to match the values to the right operations and the 'defaultValue' is used
  by the first run instead of the simulated value.
  
  If the control-flow of the payload program visits this operation multiple
  times, a possibly different value may be logged each time. In such
  situations, the lowering should fail as no single value can be determined
  that can be hardcoded/inlined in its place.
  
  The value returned by this operation is not known during elaboration and
  is thus treated like a value with identity (even though it might just be
  a simple integer). Therefore, it is strongly recommended to not use the
  result value of this operation in situations that expect structural
  equivalence checks such as adding it to sets or bags.
  
  The 'defaultUsedValues' are forwarded to the 'values' results without any
  modification whenever the 'defaultValue' is used as replacement for 'value'.
  Otherwise, the 'elseValues' are forwarded. This can be used to conditionally
  execute code based on whether the default value was used or a proper value
  was used as replacement. Note that this is not the most light-weight
  implementation as, in principle, a single 'i1' result could achieve the same
  in combination with an 'scf.if' or 'select' operation. However, these
  operations are fully resolved during elaboration while the 'validate'
  operation remains until later in the pipeline because the repeated
  compilation runs to resolve the validate operations should use the same
  elaboration result which is difficult to achieve with multiple elaboration
  runs even with the same seed as a different elaboration of the validate op
  for the different compilation runs can lead to subtle differences in the
  RNG querrying behavior.
  
  Another alternative could be a region that is conditionally inlined or
  deleted. However, this is even more heavy-weight and implies a strategy that
  involves some instructions to be present in one run but not the other which
  can lead to different label addresses, etc. and thus more likely to problems
  with AOT co-simulation.
  """

  OPERATION_NAME = "rtg.validate"

  _ODS_OPERAND_SEGMENTS = [1,1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, value, values, ref, defaultValue, defaultUsedValues, elseValues, *, id=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(ref)
    operands.append(defaultValue)
    operands.append(_get_op_results_or_values(defaultUsedValues))
    operands.append(_get_op_results_or_values(elseValues))
    _ods_context = _ods_get_default_loc_context(loc)
    if id is not None: attributes["id"] = (id if (
        isinstance(id, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(id, context=_ods_context))
    results = []
    results.append(value)
    results.extend(values)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def ref(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def defaultValue(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def defaultUsedValues(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def elseValues(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def id(self) -> _Optional[_ods_ir.StringAttr]:
    if "id" not in self.operation.attributes:
      return None
    return self.operation.attributes["id"]

  @id.setter
  def id(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["id"] = value
    elif "id" in self.operation.attributes:
      del self.operation.attributes["id"]

  @id.deleter
  def id(self):
    del self.operation.attributes["id"]

  @builtins.property
  def value(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def values(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[1:1 + _ods_variadic_group_length]

def validate(value, values, ref, default_value, default_used_values, else_values, *, id=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, ValidateOp]:
  op = ValidateOp(value=value, values=values, ref=ref, defaultValue=default_value, defaultUsedValues=default_used_values, elseValues=else_values, id=id, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class VirtualRegisterOp(_ods_ir.OpView):
  r"""
  This operation creates a value representing a virtual register. The
  'allowedRegisters' attribute specifies the concrete registers that may be
  chosen during register allocation.
  """

  OPERATION_NAME = "rtg.virtual_reg"

  _ODS_REGIONS = (0, True)

  def __init__(self, allowedRegs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["allowedRegs"] = (allowedRegs if (
    isinstance(allowedRegs, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('VirtualRegisterConfigAttr')) else
      _ods_ir.AttrBuilder.get('VirtualRegisterConfigAttr')(allowedRegs, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def allowedRegs(self) -> _ods_ir.Attribute:
    return self.operation.attributes["allowedRegs"]

  @allowedRegs.setter
  def allowedRegs(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["allowedRegs"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def virtual_reg(allowed_regs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return VirtualRegisterOp(allowedRegs=allowed_regs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class YieldOp(_ods_ir.OpView):
  OPERATION_NAME = "rtg.yield"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def yield_(operands_, *, loc=None, ip=None) -> YieldOp:
  return YieldOp(operands_=operands_, loc=loc, ip=ip)
