
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "handshake"

@_ods_cext.register_operation(_Dialect)
class BranchOp(_ods_ir.OpView):
  r"""
  The branch operation represents an unconditional
  branch.  The single data input is propagated to the single
  successor.  The input must be triggered by some predecessor to
  avoid continous triggering of a successor block.
  
  Example:
  ```mlir
  %1 = br %0 : i32
  ```
  """

  OPERATION_NAME = "handshake.br"

  _ODS_REGIONS = (0, True)

  def __init__(self, dataOperand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(dataOperand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def dataOperand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def dataResult(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def br(data_operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BranchOp(dataOperand=data_operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferOp(_ods_ir.OpView):
  r"""
  The buffer operation represents a buffer operation. $slots
  must be an unsigned integer larger than 0. $bufferType=BufferTypeEnum::seq indicates a
  nontransparent buffer, while $bufferType=BufferTypeEnum::fifo indicates a transparent
  buffer.
  
  An 'initValues' attribute containing a list of integer values may be provided.
  The list must be of the same length as the number of slots. This will
  initialize the buffer with the given values upon reset.
  For now, only sequential buffers are allowed to have initial values.
  @todo: How to support different init types? these have to be stored (and
  retrieved) as attributes, hence they must be of a known type.
  """

  OPERATION_NAME = "handshake.buffer"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, slots, bufferType, *, initValues=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["slots"] = (slots if (
    isinstance(slots, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(slots, context=_ods_context))
    attributes["bufferType"] = (bufferType if (
    isinstance(bufferType, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BufferTypeEnumAttr')) else
      _ods_ir.AttrBuilder.get('BufferTypeEnumAttr')(bufferType, context=_ods_context))
    if initValues is not None: attributes["initValues"] = (initValues if (
        isinstance(initValues, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(initValues, context=_ods_context))
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def slots(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["slots"]

  @slots.setter
  def slots(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["slots"] = value

  @builtins.property
  def bufferType(self) -> _ods_ir.Attribute:
    return self.operation.attributes["bufferType"]

  @bufferType.setter
  def bufferType(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["bufferType"] = value

  @builtins.property
  def initValues(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "initValues" not in self.operation.attributes:
      return None
    return self.operation.attributes["initValues"]

  @initValues.setter
  def initValues(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["initValues"] = value
    elif "initValues" in self.operation.attributes:
      del self.operation.attributes["initValues"]

  @initValues.deleter
  def initValues(self):
    del self.operation.attributes["initValues"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def buffer(operand, slots, buffer_type, *, init_values=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BufferOp(operand=operand, slots=slots, bufferType=buffer_type, initValues=init_values, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConditionalBranchOp(_ods_ir.OpView):
  r"""
  The cbranch operation represents a conditional
  branch.  The data input is propagated to one of the two outputs
  based on the condition input.
  
  Example:
  ```mlir
  %true, %false = conditional_branch %cond, %data : i32
  ```
  """

  OPERATION_NAME = "handshake.cond_br"

  _ODS_REGIONS = (0, True)

  def __init__(self, conditionOperand, dataOperand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(conditionOperand)
    operands.append(dataOperand)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def conditionOperand(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def dataOperand(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def trueResult(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def falseResult(self) -> _ods_ir.OpResult:
    return self.operation.results[1]

def cond_br(condition_operand, data_operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResultList:
  return ConditionalBranchOp(conditionOperand=condition_operand, dataOperand=data_operand, results=results, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class ConstantOp(_ods_ir.OpView):
  r"""
  The const has a constant value. When triggered by its
  single `ctrl` input, it sends the constant value to its single
  successor.
  
  Example:
  ```mlir
  %0 = constant %ctrl {value = 42 : i32} : i32
  ```
  """

  OPERATION_NAME = "handshake.constant"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, value, ctrl, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(ctrl)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypedAttrInterface')) else
      _ods_ir.AttrBuilder.get('TypedAttrInterface')(value, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def ctrl(self) -> _ods_ir.Value[_ods_ir.NoneType]:
    return self.operation.operands[0]

  @builtins.property
  def value(self) -> _ods_ir.Attribute:
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def constant(result, value, ctrl, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConstantOp(result=result, value=value, ctrl=ctrl, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ControlMergeOp(_ods_ir.OpView):
  r"""
  The control_merge operation represents a
  (nondeterministic) control merge.  Any input is propagated to the
  first output and the index of the propagated input is sent to the
  second output.  The number of inputs corresponds to the number of
  predecessor blocks.
  
  Example:
  ```
  %0, %idx = control_merge %a, %b, %c {attributes} : i32, index
  ```
  """

  OPERATION_NAME = "handshake.control_merge"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, index, dataOperands, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(dataOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    results.append(index)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def dataOperands(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def index(self) -> _ods_ir.OpResult:
    return self.operation.results[1]

def control_merge(result, index, data_operands, *, loc=None, ip=None) -> _ods_ir.OpResultList:
  return ControlMergeOp(result=result, index=index, dataOperands=data_operands, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class ESIInstanceOp(_ods_ir.OpView):
  r"""
  Instantiate (call) a Handshake function in a non-Handshake design using ESI
  channels as the outside connections.
  """

  OPERATION_NAME = "handshake.esi_instance"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, module, instName, clk, rst, opOperands, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(clk)
    operands.append(rst)
    operands.extend(_get_op_results_or_values(opOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["module"] = (module if (
    isinstance(module, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(module, context=_ods_context))
    attributes["instName"] = (instName if (
    isinstance(instName, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(instName, context=_ods_context))
    results = []
    results.extend(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def clk(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rst(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[1]

  @builtins.property
  def opOperands(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2:2 + _ods_variadic_group_length]

  @builtins.property
  def module(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["module"]

  @module.setter
  def module(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["module"] = value

  @builtins.property
  def instName(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["instName"]

  @instName.setter
  def instName(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["instName"] = value

def esi_instance(result, module, inst_name, clk, rst, op_operands, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, ESIInstanceOp]:
  op = ESIInstanceOp(result=result, module=module, instName=inst_name, clk=clk, rst=rst, opOperands=op_operands, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class ExternalMemoryOp(_ods_ir.OpView):
  r"""
  An ExternalMemoryOp represents a wrapper around a memref input to a
  handshake function. The semantics of the load/store operands are identical
  to what is decribed for MemoryOp. The only difference is that the first
  operand to this operand is a `memref` value.
  Upon lowering to FIRRTL, a handshake interface will be created in the
  top-level component for each load- and store which connected to this memory.
  
  Example:
  
  ```mlir
  handshake.func @main(%i: index, %v: i32, %mem : memref<10xi32>, %ctrl: none) -> none {
    %stCtrl = extmemory[ld = 0, st = 1](%mem : memref<10xi32>)(%vout, %addr) {id = 0 : i32} : (i32, index) -> (none)
    %vout, %addr = store(%v, %i, %ctrl) : (i32, index, none) -> (i32, index)
    ...
  }
  ```
  """

  OPERATION_NAME = "handshake.extmemory"

  _ODS_REGIONS = (0, True)

  def __init__(self, outputs, memref, inputs, ldCount, stCount, id, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(memref)
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["ldCount"] = (ldCount if (
    isinstance(ldCount, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(ldCount, context=_ods_context))
    attributes["stCount"] = (stCount if (
    isinstance(stCount, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(stCount, context=_ods_context))
    attributes["id"] = (id if (
    isinstance(id, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(id, context=_ods_context))
    results = []
    results.extend(outputs)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def memref(self) -> _ods_ir.Value[_ods_ir.MemRefType]:
    return self.operation.operands[0]

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def ldCount(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["ldCount"]

  @ldCount.setter
  def ldCount(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ldCount"] = value

  @builtins.property
  def stCount(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["stCount"]

  @stCount.setter
  def stCount(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["stCount"] = value

  @builtins.property
  def id(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["id"]

  @id.setter
  def id(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["id"] = value

  @builtins.property
  def outputs(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def extmemory(outputs, memref, inputs, ld_count, st_count, id, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, ExternalMemoryOp]:
  op = ExternalMemoryOp(outputs=outputs, memref=memref, inputs=inputs, ldCount=ld_count, stCount=st_count, id=id, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class ForkOp(_ods_ir.OpView):
  r"""
  The fork operation represents a fork operation.  A
  single input is replicated to N outputs and distributed to each
  output as soon as the corresponding successor is available.
  
  Example:
  ```mlir
  %1:2 = fork [2] %0 : i32
  ```
  """

  OPERATION_NAME = "handshake.fork"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def fork(result, operand, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, ForkOp]:
  op = ForkOp(result=result, operand=operand, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class FuncOp(_ods_ir.OpView):
  r"""
  The func operation represents a handshaked function.
  This is almost exactly like a standard FuncOp, except that it has
  some extra verification conditions. In particular, each Value must
  only have a single use.
  """

  OPERATION_NAME = "handshake.func"

  _ODS_REGIONS = (1, True)

  def __init__(self, function_type, *, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["function_type"] = (function_type if (
    isinstance(function_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_494')) else
      _ods_ir.AttrBuilder.get('anonymous_494')(function_type, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def function_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["function_type"]

  @function_type.setter
  def function_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["function_type"] = value

  @builtins.property
  def arg_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def func(function_type, *, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> FuncOp:
  return FuncOp(function_type=function_type, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class InstanceOp(_ods_ir.OpView):
  r"""
  The `instance` operation represents the instantiation of a module.  This
  is similar to a function call, except that different instances of the
  same module are guaranteed to have their own distinct state.
  The instantiated module is encoded as a symbol reference attribute named
  "module". An instance operation takes a control input as its last argument
  and returns a control output as its last result.
  
  Example:
  ```mlir
  %2:2 = handshake.instance @my_add(%0, %1, %ctrl) : (f32, f32, none) -> (f32, none)
  ```
  """

  OPERATION_NAME = "handshake.instance"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, module, opOperands, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(opOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["module"] = (module if (
    isinstance(module, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(module, context=_ods_context))
    results = []
    results.extend(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def opOperands(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def module(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["module"]

  @module.setter
  def module(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["module"] = value

def instance(result, module, op_operands, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, InstanceOp]:
  op = InstanceOp(result=result, module=module, opOperands=op_operands, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class JoinOp(_ods_ir.OpView):
  r"""
  A control-only synchronizer.  Produces a valid output when all
  inputs become available.
  
  Example:
  ```mlir
  %0 = join %a, %b, %c : i32, i1, none
  ```
  """

  OPERATION_NAME = "handshake.join"

  _ODS_REGIONS = (0, True)

  def __init__(self, data, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(data))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def data(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.NoneType]:
    return self.operation.results[0]

def join(data, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return JoinOp(data=data, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LazyForkOp(_ods_ir.OpView):
  r"""
  The lazy_fork operation represents a lazy fork operation.
  A single input is replicated to N outputs and distributed to each
  output when all successors are available.
  
  Example:
  ```mlir
  %1:2 = lazy_fork [2] %0 : i32
  ```
  """

  OPERATION_NAME = "handshake.lazy_fork"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def lazy_fork(result, operand, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, LazyForkOp]:
  op = LazyForkOp(result=result, operand=operand, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class LoadOp(_ods_ir.OpView):
  r"""
   Load memory port, sends load requests to MemoryOp. From dataflow
   predecessor, receives address indices and a control-only value
   which signals completion of all previous memory accesses which
   target the same memory.  When all inputs are received, the load
   sends the address indices to MemoryOp. When the MemoryOp returns
   a piece of data, the load sends it to its dataflow successor.
  
   Operands: address indices (from predecessor), data (from MemoryOp), control-only input.
   Results: data (to successor), address indices (to MemoryOp).
  
  Example:
  ```mlir
  %dataToSucc, %addr1ToMem, %addr2ToMem = load [%addr1, %addr2] %dataFromMem, %ctrl : i8, i16, index
  ```
  """

  OPERATION_NAME = "handshake.load"

  _ODS_REGIONS = (0, True)

  def __init__(self, dataResult, addressResults, addresses, data, ctrl, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(addresses))
    operands.append(data)
    operands.append(ctrl)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(dataResult)
    results.extend(addressResults)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def addresses(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def data(self) -> _ods_ir.Value:
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[1 + _ods_variadic_group_length - 1]

  @builtins.property
  def ctrl(self) -> _ods_ir.Value[_ods_ir.NoneType]:
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2 + _ods_variadic_group_length - 1]

  @builtins.property
  def dataResult(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def addressResults(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[1:1 + _ods_variadic_group_length]

def load(data_result, address_results, addresses, data, ctrl, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, LoadOp]:
  op = LoadOp(dataResult=data_result, addressResults=address_results, addresses=addresses, data=data, ctrl=ctrl, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class MemoryOp(_ods_ir.OpView):
  r"""
  Each MemoryOp represents an independent memory or memory region (BRAM or external memory).
  It receives memory access requests from load and store operations. For every request,
  it returns data (for load) and a data-less token indicating completion.
  The memory op represents a flat, unidimensional memory.
  Operands: all stores (stdata1, staddr1, stdata2, staddr2, ...), then all loads (ldaddr1, ldaddr2,...)
  Outputs: all load outputs, ordered the same as
  load data (lddata1, lddata2, ...), followed by all none outputs,
  ordered as operands (stnone1, stnone2,...ldnone1, ldnone2,...)
  """

  OPERATION_NAME = "handshake.memory"

  _ODS_REGIONS = (0, True)

  def __init__(self, outputs, inputs, ldCount, stCount, id, memRefType, lsq, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["ldCount"] = (ldCount if (
    isinstance(ldCount, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(ldCount, context=_ods_context))
    attributes["stCount"] = (stCount if (
    isinstance(stCount, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(stCount, context=_ods_context))
    attributes["id"] = (id if (
    isinstance(id, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(id, context=_ods_context))
    attributes["memRefType"] = (memRefType if (
    isinstance(memRefType, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('MemRefTypeAttr')) else
      _ods_ir.AttrBuilder.get('MemRefTypeAttr')(memRefType, context=_ods_context))
    attributes["lsq"] = (lsq if (
    isinstance(lsq, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(lsq, context=_ods_context))
    results = []
    results.extend(outputs)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def ldCount(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["ldCount"]

  @ldCount.setter
  def ldCount(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ldCount"] = value

  @builtins.property
  def stCount(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["stCount"]

  @stCount.setter
  def stCount(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["stCount"] = value

  @builtins.property
  def id(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["id"]

  @id.setter
  def id(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["id"] = value

  @builtins.property
  def memRefType(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["memRefType"]

  @memRefType.setter
  def memRefType(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memRefType"] = value

  @builtins.property
  def lsq(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["lsq"]

  @lsq.setter
  def lsq(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["lsq"] = value

  @builtins.property
  def outputs(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def memory(outputs, inputs, ld_count, st_count, id, mem_ref_type, lsq, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, MemoryOp]:
  op = MemoryOp(outputs=outputs, inputs=inputs, ldCount=ld_count, stCount=st_count, id=id, memRefType=mem_ref_type, lsq=lsq, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class MergeOp(_ods_ir.OpView):
  r"""
  The merge operation represents a (nondeterministic)
  merge operation. Any input is propagated to the single output. The
  number of inputs corresponds to the number of predecessor
  blocks.
  
  Example:
  ```
  %0 = merge %a, %b, %c : i32
  ```
  """

  OPERATION_NAME = "handshake.merge"

  _ODS_REGIONS = (0, True)

  def __init__(self, dataOperands, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(dataOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def dataOperands(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def merge(data_operands, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MergeOp(dataOperands=data_operands, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MuxOp(_ods_ir.OpView):
  r"""
  The mux operation represents a(deterministic) merge operation.
  Operands: select, data0, data1, data2, ...
  
  The 'select' operand is received from ControlMerge of the same
  block and it represents the index of the data operand that the mux
  should propagate to its single output.  The number of data inputs
  corresponds to the number of predecessor blocks.
  
  The mux operation is intended solely for control+dataflow selection.
  For purely dataflow selection, use the 'select' operation instead.
  
  Example:
  ```mlir
  %0 = mux %select [%data0, %data1, %data2] {attributes}: index, i32
  ```
  """

  OPERATION_NAME = "handshake.mux"

  _ODS_REGIONS = (0, True)

  def __init__(self, selectOperand, dataOperands, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(selectOperand)
    operands.extend(_get_op_results_or_values(dataOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def selectOperand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def dataOperands(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mux(select_operand, data_operands, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MuxOp(selectOperand=select_operand, dataOperands=data_operands, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class NeverOp(_ods_ir.OpView):
  r"""
  The never operation represents disconnected data
  source. The source never sets any 'valid' signal which will
  never trigger the successor at any point in time.
  """

  OPERATION_NAME = "handshake.never"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def never(result, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return NeverOp(result=result, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PackOp(_ods_ir.OpView):
  r"""
  The `pack` operation constructs a tuple from separate values.
  The number of operands corresponds to the number of tuple elements.
  Similar to `join`, the output is ready when all inputs are ready.
  
  Example:
  ```mlir
  %tuple = handshake.pack %a, %b {attributes} : tuple<i32, i64>
  ```
  """

  OPERATION_NAME = "handshake.pack"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, inputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult[_ods_ir.TupleType]:
    return self.operation.results[0]

def pack(result, inputs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return PackOp(result=result, inputs=inputs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReturnOp(_ods_ir.OpView):
  r"""
  The return operation represents a handshaked
  function.  This is almost exactly like a standard ReturnOp, except
  that it exists in a handshake.func.  It has the same operands as
  standard ReturnOp which it replaces and an additional control -
  only operand(exit point of control - only network).
  """

  OPERATION_NAME = "handshake.return"

  _ODS_REGIONS = (0, True)

  def __init__(self, opOperands, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(opOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def opOperands(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def return_(op_operands, *, loc=None, ip=None) -> ReturnOp:
  return ReturnOp(opOperands=op_operands, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SinkOp(_ods_ir.OpView):
  r"""
  The sink operation discards any data that arrives at its
       input.The sink has no successors and it can continuously consume data.
  
  Example:
  ```mlir
  sink %data : i32
  ```
  """

  OPERATION_NAME = "handshake.sink"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

def sink(operand, *, loc=None, ip=None) -> SinkOp:
  return SinkOp(operand=operand, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SourceOp(_ods_ir.OpView):
  r"""
  The source operation represents continuous token
  source.  The source continously sets a 'valid' signal which the
  successor can consume at any point in time.
  """

  OPERATION_NAME = "handshake.source"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def source(result, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return SourceOp(result=result, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class StoreOp(_ods_ir.OpView):
  r"""
  Store memory port, sends store requests to MemoryOp. From dataflow
  predecessors, receives address indices, data, and a control-only
  value which signals completion of all previous memory accesses
  which target the same memory.  When all inputs are received, the
  store sends the address and data to MemoryOp.
  
  Operands: address indices, data, control-only input.
  Results: data and address indices (sent to MemoryOp).
  Types: data type followed by address type.
  
  Example:
  ```mlir
  %dataToMem, %addrToMem = store [%addr1, %addr2] %dataFromPred , %ctrl : i8, i16, index
  ```
  """

  OPERATION_NAME = "handshake.store"

  _ODS_REGIONS = (0, True)

  def __init__(self, dataResult, addressResult, addresses, data, ctrl, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(addresses))
    operands.append(data)
    operands.append(ctrl)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(dataResult)
    results.extend(addressResult)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def addresses(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def data(self) -> _ods_ir.Value:
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[1 + _ods_variadic_group_length - 1]

  @builtins.property
  def ctrl(self) -> _ods_ir.Value[_ods_ir.NoneType]:
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2 + _ods_variadic_group_length - 1]

  @builtins.property
  def dataResult(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def addressResult(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[1:1 + _ods_variadic_group_length]

def store(data_result, address_result, addresses, data, ctrl, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, StoreOp]:
  op = StoreOp(dataResult=data_result, addressResult=address_result, addresses=addresses, data=data, ctrl=ctrl, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class SyncOp(_ods_ir.OpView):
  r"""
  Synchronizes an arbitrary set of inputs. Synchronization implies applying
  join semantics in between all in- and output ports.
  
  Example:
  ```mlir
  %aSynced, %bSynced, %cSynced = sync %a, %b, %c : i32, i1, none
  ```
  """

  OPERATION_NAME = "handshake.sync"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, operands_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def sync(results_, operands_, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, SyncOp]:
  op = SyncOp(results_=results_, operands_=operands_, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class UnpackOp(_ods_ir.OpView):
  r"""
  The `unpack` operation assigns each value of a tuple to a separate
  value for further processing. The number of results corresponds
  to the number of tuple elements.
  Similar to `fork`, each output is distributed as soon as the corresponding
  successor is ready.
  
  Example:
  ```mlir
  %a, %b = handshake.unpack %tuple {attributes} : tuple<i32, i64>
  ```
  """

  OPERATION_NAME = "handshake.unpack"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value[_ods_ir.TupleType]:
    return self.operation.operands[0]

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def unpack(results_, input, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, UnpackOp]:
  op = UnpackOp(results_=results_, input=input, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)
