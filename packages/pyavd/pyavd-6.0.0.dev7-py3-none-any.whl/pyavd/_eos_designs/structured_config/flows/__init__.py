# Copyright (c) 2023-2026 Arista Networks, Inc.
# Use of this source code is governed by the Apache License 2.0
# that can be found in the LICENSE file.
from __future__ import annotations

from functools import cached_property
from itertools import chain

from pyavd._eos_cli_config_gen.schema import EosCliConfigGen
from pyavd._eos_designs.schema import EosDesigns
from pyavd._eos_designs.structured_config.structured_config_generator import StructuredConfigGenerator, structured_config_contributor
from pyavd._errors import AristaAvdDuplicateDataError, AristaAvdInvalidInputsError
from pyavd.j2filters import natural_sort


class AvdStructuredConfigFlows(StructuredConfigGenerator):
    """
    Structured config for sflow and flow_tracker.

    This class must be rendered after all other eos_designs modules since it relies on
    detecting sflow from the interface structured config generated by the other modules.

    The only exception is of course custom_structured_configuration which always comes last.
    """

    @structured_config_contributor
    def sflow(self) -> None:
        """
        Structured config for sFlow.

        Only configure if any interface is enabled for sFlow.

        Covers:
        - sflow_settings
        - source-interfaces based on source_interfaces.sflow
        """
        if not self._enable_sflow:
            return

        sflow_settings = self.inputs.sflow_settings
        destinations = sflow_settings.destinations
        if not destinations and not sflow_settings.export_to_cloudvision.enabled:
            msg = "Either `sflow_settings.destinations` or `sflow_settings.export_to_cloudvision.enabled: true` is required to configure `sflow`."
            raise AristaAvdInvalidInputsError(msg)

        # At this point we have at least one interface with sFlow enabled
        # and at least one destination.
        self.structured_config.sflow._update(run=True, polling_interval=sflow_settings.polling_interval, sample=sflow_settings.sample.rate)

        for destination in natural_sort(destinations, "destination"):
            destination: EosDesigns.SflowSettings.DestinationsItem
            sflow_vrf, source_interface = self.shared_utils.get_vrf_and_source_interface(
                vrf_input=destination.vrf,
                vrfs=sflow_settings.vrfs,
                set_source_interfaces=True,
                context=f"sflow_settings.destinations[destination={destination.destination}].vrf",
            )
            if sflow_vrf == "default":
                # Add destination without VRF field
                self.structured_config.sflow.destinations.append_new(destination=destination.destination, port=destination.port)
                self.structured_config.sflow.source_interface = source_interface
            else:
                # Add destination with VRF field.
                vrf_item = self.structured_config.sflow.vrfs.obtain(sflow_vrf)
                vrf_item.destinations.append_new(destination=destination.destination, port=destination.port)
                vrf_item.source_interface = source_interface
                self.structured_config.sflow.vrfs.append(vrf_item)

        if sflow_settings.export_to_cloudvision.enabled:
            sflow_vrf = self.shared_utils.get_vrf(sflow_settings.export_to_cloudvision.vrf, context="sflow_settings.export_to_cloudvision.vrf")
            vrf_item = self.structured_config.sflow.vrfs.obtain(sflow_vrf)
            vrf_item.destinations.append_new(destination="127.0.0.1", port=6343)

    @cached_property
    def _enable_sflow(self) -> bool:
        """
        Enable sFlow if any interface is enabled for sFlow.

        This relies on sFlow being rendered after all other eos_designs modules (except structured config).
        """
        if not self.shared_utils.platform_settings.feature_support.sflow:
            return False
        return any(interface.sflow.enable for interface in chain(self.structured_config.ethernet_interfaces, self.structured_config.port_channel_interfaces))

    @structured_config_contributor
    def flow_tracking(self) -> None:
        """
        Set the structured config for flow_tracking if any interface is enabled for flow-tracking.

        This relies on flow-tracking being rendered after all other eos_designs modules (except structured config).
        """
        if self.shared_utils.flow_tracking_type == "hardware":
            self._set_hardware_flow_tracking()
        elif self.shared_utils.flow_tracking_type == "sampled":
            self._set_sampled_flow_tracking()

    def _set_hardware_flow_tracking(self) -> None:
        """Set the structured configuration for hardware flow tracking if any interface is configured."""
        all_interfaces = chain(
            self.structured_config.ethernet_interfaces, self.structured_config.port_channel_interfaces, self.structured_config.dps_interfaces
        )

        trackers: set[str] = {interface.flow_tracker.hardware for interface in all_interfaces if interface.flow_tracker.hardware}
        if not trackers:
            return

        self.structured_config.flow_tracking.hardware.record.format_ipfix_standard_timestamps_counters = (
            self.inputs.flow_tracking_settings.hardware.record.format_ipfix_standard_timestamps_counters
        )
        self.structured_config.flow_tracking.hardware.shutdown = False

        # Validate and configure trackers
        for tracker_name in natural_sort(trackers):
            config = self._get_tracker_input_config(tracker_name)
            tracker = self.structured_config.flow_tracking.hardware.trackers.append_new(
                name=config.name,
                record_export=config.record_export._cast_as(EosCliConfigGen.FlowTracking.Hardware.TrackersItem.RecordExport),
            )
            for exporter in config.exporters:
                local_interface = self.shared_utils.get_local_interface(exporter.local_interface)
                tracker.exporters.append_new(
                    name=exporter.name,
                    collectors=exporter.collectors._cast_as(EosCliConfigGen.FlowTracking.Hardware.TrackersItem.ExportersItem.Collectors),
                    format=exporter.format._cast_as(EosCliConfigGen.FlowTracking.Hardware.TrackersItem.ExportersItem.Format),
                    local_interface=local_interface,
                    template_interval=exporter.template_interval,
                )
            if config.export_to_cloudvision:
                export_to_cv = self.inputs.flow_tracking_settings.cloudvision_exporter
                local_interface = self.shared_utils.get_source_interface(export_to_cv.vrf, export_to_cv.source_interface)
                collectors = EosCliConfigGen.FlowTracking.Hardware.TrackersItem.ExportersItem.Collectors()
                collectors.append_new(host="127.0.0.1")
                try:
                    tracker.exporters.append_new(name=export_to_cv.name, collectors=collectors, local_interface=local_interface)
                except AristaAvdDuplicateDataError:
                    msg = (
                        f"Found conflicting configuration for exporter '{export_to_cv.name}' while generating configuration for flow tracking "
                        f"'export_to_cloudvision'. One exporter defined for tracker '{tracker.name}' is conflicting with the 'cloudvision_exporter.name' "
                        "configuration."
                    )
                    raise AristaAvdInvalidInputsError(msg) from None

    def _set_sampled_flow_tracking(self) -> None:
        """Set the structured configuration for sampled flow tracking if any interface is configured."""
        all_interfaces = chain(
            self.structured_config.ethernet_interfaces, self.structured_config.port_channel_interfaces, self.structured_config.dps_interfaces
        )

        trackers: set[str] = {interface.flow_tracker.sampled for interface in all_interfaces if interface.flow_tracker.sampled}
        if not trackers:
            return

        self.structured_config.flow_tracking.sampled._update(
            sample=self.inputs.flow_tracking_settings.sampled.sample,
            shutdown=False,
            encapsulation=EosCliConfigGen.FlowTracking.Sampled.Encapsulation(
                ipv4_ipv6=self.inputs.flow_tracking_settings.sampled.encapsulation.ipv4_ipv6,
                mpls=self.inputs.flow_tracking_settings.sampled.encapsulation.mpls,
            ),
            hardware_offload=EosCliConfigGen.FlowTracking.Sampled.HardwareOffload(
                ipv4=self.inputs.flow_tracking_settings.sampled.hardware_offload.ipv4,
                ipv6=self.inputs.flow_tracking_settings.sampled.hardware_offload.ipv6,
                threshold_minimum=self.inputs.flow_tracking_settings.sampled.hardware_offload.threshold_minimum,
            ),
        )

        # Validate and configure trackers
        for tracker_name in natural_sort(trackers):
            config = self._get_tracker_input_config(tracker_name)

            # Need to handle mpls specifically
            record_export = config.record_export._cast_as(EosCliConfigGen.FlowTracking.Sampled.TrackersItem.RecordExport)
            record_export.mpls = config.sampled.record_export.mpls

            tracker = self.structured_config.flow_tracking.sampled.trackers.append_new(
                name=config.name,
                record_export=record_export,
                table_size=config.sampled.table_size,
            )
            for exporter in config.exporters:
                local_interface = self.shared_utils.get_local_interface(exporter.local_interface)
                tracker.exporters.append_new(
                    name=exporter.name,
                    collectors=exporter.collectors._cast_as(EosCliConfigGen.FlowTracking.Sampled.TrackersItem.ExportersItem.Collectors),
                    format=exporter.format._cast_as(EosCliConfigGen.FlowTracking.Sampled.TrackersItem.ExportersItem.Format),
                    local_interface=local_interface,
                    template_interval=exporter.template_interval,
                )
            if config.export_to_cloudvision:
                export_to_cv = self.inputs.flow_tracking_settings.cloudvision_exporter
                local_interface = self.shared_utils.get_source_interface(export_to_cv.vrf, export_to_cv.source_interface)
                collectors = EosCliConfigGen.FlowTracking.Sampled.TrackersItem.ExportersItem.Collectors()
                collectors.append_new(host="127.0.0.1")
                try:
                    tracker.exporters.append_new(name=export_to_cv.name, collectors=collectors, local_interface=local_interface)
                except AristaAvdDuplicateDataError:
                    msg = (
                        f"Found conflicting configuration for exporter '{export_to_cv.name}' while generating configuration for flow tracking "
                        f"'export_to_cloudvision'. One exporter defined for tracker '{tracker.name}' is conflicting with the 'cloudvision_exporter.name' "
                        "configuration."
                    )
                    raise AristaAvdInvalidInputsError(msg) from None

    def _get_tracker_input_config(self, tracker_name: str) -> EosDesigns.FlowTrackingSettings.TrackersItem:
        """
        Retrieves inputs for the given tracker_name.

        If the name matches the default tracker_name, return the default tracker.

        We allow overriding the default flow tracker name, so if user has configured a tracker
        with the default tracker name, then we just use that, if not, we create a default config
        """
        if tracker_name in self.inputs.flow_tracking_settings.trackers:
            return self.inputs.flow_tracking_settings.trackers[tracker_name]

        default_tracker = next(iter(EosDesigns.FlowTrackingSettings().trackers))
        if tracker_name == default_tracker.name:
            return default_tracker

        msg = f"The flow tracker '{tracker_name}' is being used for at least one interface, but is not configured in 'self.inputs.flow_tracking_settings'."
        raise AristaAvdInvalidInputsError(msg)
