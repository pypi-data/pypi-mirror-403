from __future__ import annotations

from pathlib import Path
from typing import (
    Callable,
    Dict,
    Generator,
    Iterable,
    List,
    Literal,
    Optional,
    Protocol,
    Set,
    Tuple,
    Type,
    Union,
    overload,
    runtime_checkable,
)

from pydantic import NonNegativeInt, PositiveInt
from typing_extensions import Self

from netlist_carpentry import Direction, Signal
from netlist_carpentry.core.enums.element_type import EType
from netlist_carpentry.core.graph.module_graph import ModuleGraph
from netlist_carpentry.core.netlist_elements.element_path import (
    ElementPath,
    InstancePath,
    ModulePath,
    PortPath,
    PortSegmentPath,
    WirePath,
    WireSegmentPath,
)
from netlist_carpentry.core.netlist_elements.mixins.metadata import METADATA_DICT
from netlist_carpentry.core.protocols.base_types import Connectable, ConnectableMultibit, DirectedPortElement
from netlist_carpentry.core.protocols.signals import CarriesMultibitSignal, CarriesSignal, LogicLevel
from netlist_carpentry.utils.custom_dict import CustomDict


class NetlistElementLike(Protocol):
    raw_path: str
    parameters: Dict[str, Union[str, int]]

    @property
    def path(self) -> ElementPath: ...
    @property
    def name(self) -> str: ...
    @property
    def type(self) -> EType: ...
    @property
    def hierarchy_level(self) -> int: ...
    @property
    def parent(self) -> NetlistElementLike: ...
    @property
    def locked(self) -> bool: ...
    @property
    def is_placeholder_instance(self) -> bool: ...
    @property
    def can_carry_signal(self) -> bool: ...

    def set_name(self, new_name: str) -> None: ...
    def change_mutability(self, is_now_locked: bool) -> Self: ...
    def add_listener(self, element: NetlistElementLike) -> None: ...
    def remove_listener(self, element: NetlistElementLike) -> None: ...
    def notify_listeners(self) -> bool: ...
    def on_notification(self, element: NetlistElementLike) -> bool: ...
    def evaluate(self) -> None: ...
    def normalize_metadata(self, include_empty: bool = False, sort_by: Literal['path', 'category'] = 'path') -> METADATA_DICT: ...


class PortSegmentLike(CarriesSignal, DirectedPortElement, Connectable, NetlistElementLike, Protocol):
    @property
    def path(self) -> PortSegmentPath: ...
    @property
    def raw_ws_path(self) -> str: ...
    @property
    def ws_path(self) -> WireSegmentPath: ...
    @property
    def wire_name(self) -> str: ...
    @property
    def parent_name(self) -> str: ...
    @property
    def parent_parent_name(self) -> str: ...

    def set_ws_path(self, ws_path: str) -> Self: ...
    def change_connection(self, new_wire_segment_path: WireSegmentPath = WireSegmentPath(raw='')) -> None: ...


class WireSegmentLike(CarriesSignal, NetlistElementLike, Protocol):
    @property
    def path(self) -> WireSegmentPath: ...
    @property
    def signal(self) -> Signal: ...
    @property
    def port_segments(self) -> List[PortSegmentLike]: ...
    @property
    def nr_connected_ports(self) -> int: ...
    @property
    def is_constant(self) -> bool: ...
    @property
    def is_defined_constant(self) -> bool: ...
    @property
    def super_wire_name(self) -> str: ...
    @property
    def super_module_name(self) -> str: ...

    def add_port_segment(self, port_segment: PortSegmentLike) -> PortSegmentLike: ...
    def add_port_segments(self, port_segments: Iterable[PortSegmentLike]) -> List[PortSegmentLike]: ...
    def remove_port_segment(self, port_segment: PortSegmentLike) -> None: ...
    def get_port_segment(self, port_segment: PortSegmentLike) -> PortSegmentLike: ...
    def has_defined_signal(self) -> bool: ...
    def driver(self, warn_if_issue: bool = False) -> List[PortSegmentLike]: ...
    def loads(self, warn_if_issue: bool = False) -> List[PortSegmentLike]: ...
    def has_no_driver(self) -> bool: ...
    def has_multiple_drivers(self) -> bool: ...
    def has_no_loads(self) -> bool: ...
    def is_dangling(self) -> bool: ...
    def has_problems(self) -> bool: ...


class SegmentContainer(NetlistElementLike, Protocol):
    @property
    def segments(self) -> CustomDict[int, PortSegmentLike]: ...

    def __getitem__(self, index: int) -> PortSegmentLike: ...
    def __len__(self) -> int: ...


class PortLike(CarriesMultibitSignal, DirectedPortElement, ConnectableMultibit, SegmentContainer, Protocol):
    @property
    def path(self) -> PortPath: ...
    @property
    def connected_wire_segments(self) -> Set[WireSegmentPath]: ...
    @property
    def connected_wires(self) -> Set[WirePath]: ...

    def __iter__(self) -> Generator[Tuple[int, PortSegmentLike], None, None]: ...
    def create_port_segment(self, index: NonNegativeInt) -> PortSegmentLike: ...
    def create_port_segments(self, count: PositiveInt, offset: NonNegativeInt = 0) -> PortSegmentLike: ...
    def remove_port_segment(self, index: NonNegativeInt) -> None: ...
    def get_port_segment(self, index: NonNegativeInt) -> Optional[PortSegmentLike]: ...
    def change_connection(self, new_wire_segment_path: WireSegmentPath, index: NonNegativeInt = 0) -> None: ...
    def change_mutability(self, is_now_locked: bool, recursive: bool = False) -> Self: ...


@runtime_checkable
class WireLike(CarriesMultibitSignal, SegmentContainer, Protocol):
    @property
    def path(self) -> WirePath: ...
    @property
    def ports(self) -> Dict[int, List[PortSegmentLike]]: ...
    @property
    def connected_port_segments(self) -> Set[PortSegmentLike]: ...
    @property
    def nr_connected_port_segments(self) -> int: ...

    def __iter__(self) -> Generator[Tuple[int, WireSegmentLike], None, None]: ...
    def create_wire_segment(self, index: NonNegativeInt) -> WireSegmentLike: ...
    def create_wire_segments(self, count: PositiveInt, offset: NonNegativeInt = 0) -> Dict[int, WireSegmentLike]: ...
    def remove_wire_segment(self, index: NonNegativeInt) -> None: ...
    def get_wire_segment(self, index: NonNegativeInt) -> WireSegmentLike: ...
    def get_wire_segments(self, name: str = '', fuzzy: bool = False) -> Dict[int, WireSegmentLike]: ...
    def driver(self) -> Dict[int, List[PortSegmentLike]]: ...
    def loads(self) -> Dict[int, List[PortSegmentLike]]: ...
    def has_no_driver(self, get_mapping: bool = False) -> Union[bool, Dict[int, bool]]: ...
    def has_multiple_drivers(self, get_mapping: bool = False) -> Union[bool, Dict[int, bool]]: ...
    def has_no_loads(self, get_mapping: bool = False) -> Union[bool, Dict[int, bool]]: ...
    def is_dangling(self, get_mapping: bool = False) -> Union[bool, Dict[int, bool]]: ...
    def has_problems(self, get_mapping: bool = False) -> Union[bool, Dict[int, bool]]: ...


class HasPorts(Protocol):
    @property
    def ports(self) -> Dict[str, PortLike]: ...
    @property
    def input_ports(self) -> Set[PortLike]: ...
    @property
    def output_ports(self) -> Set[PortLike]: ...


class InstanceLike(NetlistElementLike, HasPorts, Protocol):
    instance_type: str

    @property
    def path(self) -> InstancePath: ...
    @property
    def connections(self) -> Dict[str, Dict[int, WireSegmentPath]]: ...
    def all_connections(self, include_unconnected: bool) -> Dict[str, Dict[int, WireSegmentPath]]: ...
    @property
    def connection_str_paths(self) -> Dict[str, Dict[int, str]]: ...
    @property
    def is_primitive(self) -> bool: ...
    @property
    def is_module_instance(self) -> bool: ...
    @property
    def is_primitive_from_gatelib(self) -> bool: ...
    @property
    def verilog_template(self) -> str: ...
    @property
    def verilog(self) -> str: ...
    def port_is_known(self, port_name: str) -> bool: ...
    def connect(
        self, port_name: str, ws_path: Optional[WireSegmentPath], direction: Direction = Direction.UNKNOWN, index: int = 0, width: int = 1
    ) -> None: ...
    def disconnect(self, port_name: str, index: Optional[int]) -> None: ...
    def get_connection(self, port_name: str, index: Optional[NonNegativeInt] = None) -> Union[WireSegmentPath, Dict[int, WireSegmentPath]]: ...
    def modify_connection(self, port_name: str, ws_path: WireSegmentPath, index: NonNegativeInt = 0) -> None: ...
    def connect_modify(
        self, port_name: str, ws_path: WireSegmentPath, direction: Direction = Direction.UNKNOWN, index: int = 0, width: int = 1
    ) -> None: ...
    def tie_port(self, name: str, index: NonNegativeInt, sig_value: LogicLevel) -> None: ...
    def has_tied_ports(self) -> bool: ...
    def has_tied_inputs(self) -> bool: ...
    def has_tied_outputs(self) -> bool: ...


class ModuleLike(NetlistElementLike, HasPorts, Protocol):
    @property
    def path(self) -> ModulePath: ...
    @property
    def instances(self) -> Dict[str, InstanceLike]: ...
    @property
    def instance_types(self) -> Dict[str, List[InstanceLike]]: ...
    @property
    def wires(self) -> Dict[str, WireLike]: ...
    @property
    def instances_with_constant_inputs(self) -> Set[InstanceLike]: ...
    @property
    def submodules(self) -> Set[InstanceLike]: ...
    @property
    def primitives(self) -> Set[InstanceLike]: ...
    @property
    def gatelib_primitives(self) -> Set[InstanceLike]: ...

    def valid_module_path(self, element_path: ElementPath) -> bool: ...
    def is_in_module(self, element_path: ElementPath) -> bool: ...
    def get_from_path(self, element_path: ElementPath) -> NetlistElementLike: ...
    def add_instance(self, instance: InstanceLike) -> InstanceLike: ...
    def create_instance(
        self, interface_definition: Union[ModuleLike, Type[InstanceLike]], instance_name: Optional[str] = None, params: Dict[str, object] = {}
    ) -> InstanceLike: ...
    def remove_instance(self, instance: Union[str, InstanceLike]) -> None: ...
    def get_instance(self, instance_name: str) -> InstanceLike: ...
    def get_instances(self, name: str = '', type: str = '', fuzzy: bool = False) -> List[InstanceLike]: ...
    def add_port(self, port: PortLike) -> PortLike: ...
    def create_port(
        self,
        port_name: str,
        direction: Direction = Direction.UNKNOWN,
        width: PositiveInt = 1,
        offset: NonNegativeInt = 0,
        is_locked: bool = False,
    ) -> PortLike: ...
    def remove_port(self, port: Union[str, PortLike]) -> None: ...
    def get_port(self, port_name: str) -> PortLike: ...
    def get_ports(self, name: str = '', direction: Optional[Direction] = None, fuzzy: bool = False) -> List[PortLike]: ...
    def add_wire(self, wire: WireLike) -> WireLike: ...
    def create_wire(
        self, wire_name: Optional[str] = None, width: PositiveInt = 1, is_locked: bool = False, offset: NonNegativeInt = 0
    ) -> WireLike: ...
    def remove_wire(self, wire: Union[str, WireLike]) -> None: ...
    def get_wire(self, wire_name: str) -> WireLike: ...
    def get_wires(self, name: str = '', fuzzy: bool = False) -> List[WireLike]: ...
    @overload
    def connect(
        self, source: Union[PortSegmentPath, PortSegmentLike], target: Union[PortSegmentPath, PortSegmentLike], new_wire_name: Optional[str] = None
    ) -> None: ...
    @overload
    def connect(self, source: PortLike, target: PortLike, new_wire_name: Optional[str] = None) -> None: ...
    @overload
    def connect(
        self, source: Union[WireSegmentPath, WireSegmentLike], target: Union[PortSegmentPath, PortSegmentLike], new_wire_name: Optional[str] = None
    ) -> None: ...
    @overload
    def connect(self, source: WireLike, target: PortLike, new_wire_name: Optional[str] = None) -> None: ...
    def connect(
        self,
        source: Union[PortSegmentPath, PortSegmentLike, PortLike, WireSegmentPath, WireSegmentLike, WireLike],
        target: Union[PortSegmentPath, PortSegmentLike, PortLike],
        new_wire_name: Optional[str] = None,
    ) -> None: ...
    @overload
    def disconnect(self, ps: PortSegmentPath) -> None: ...
    @overload
    def disconnect(self, ps: PortSegmentLike) -> None: ...
    @overload
    def disconnect(self, ps: PortLike) -> None: ...
    def disconnect(self, ps: Union[PortSegmentPath, PortSegmentLike, PortLike]) -> None: ...
    def get_edges(self, instance: Union[str, InstanceLike]) -> Dict[str, Dict[int, WireSegmentLike]]: ...
    def get_outgoing_edges(self, instance_name: str) -> Dict[str, Dict[int, WireSegmentLike]]: ...
    def get_incoming_edges(self, instance_name: str) -> Dict[str, Dict[int, WireSegmentLike]]: ...
    def get_wire_ports(self, ws_path: WireSegmentPath) -> Set[PortSegmentLike]: ...
    def get_driving_ports(self, ws_path: WireSegmentPath) -> Set[PortSegmentLike]: ...
    def get_load_ports(self, ws_path: WireSegmentPath) -> Set[PortSegmentLike]: ...
    def get_neighbors(self, instance_name: str) -> Dict[str, Dict[int, List[PortSegmentLike]]]: ...
    def get_succeeding_instances(self, instance_name: str) -> Dict[str, Dict[int, List[Union[InstanceLike, PortLike]]]]: ...
    def get_preceeding_instances(self, instance_name: str) -> Dict[str, Dict[int, List[Union[InstanceLike, PortLike]]]]: ...
    def bfs_paths_between(self, start: ElementPath, end: ElementPath, return_first_only: bool = True) -> Set[Tuple[ElementPath, ...]]: ...
    def dfs_paths_between(self, start: ElementPath, end: ElementPath, max_paths: int = 1) -> Set[Tuple[ElementPath, ...]]: ...
    def optimize(self) -> bool: ...
    def visualize(self, graph_file_path: str) -> None: ...
    def evaluate(self, modules: Dict[str, ModuleLike] = {}) -> None: ...
    def graph(self) -> ModuleGraph: ...
    def export_metadata(
        self,
        path: Union[str, Path],
        include_empty: bool = False,
        sort_by: Literal['path', 'category'] = 'path',
        filter: Callable[[str, Dict[object, object]], bool] = lambda cat, md: True,
    ) -> None: ...
