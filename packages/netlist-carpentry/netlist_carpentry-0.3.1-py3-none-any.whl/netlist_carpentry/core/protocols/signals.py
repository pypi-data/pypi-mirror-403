from __future__ import annotations

from typing import Dict, Literal, Optional, Protocol, Union, overload

from pydantic import NonNegativeInt

from netlist_carpentry import Signal

LogicLevelInt = Literal[0, 1]
LogicLevel = Union[Literal['0', '1', 'Z', 'X'], LogicLevelInt]
SignalOrLogicLevel = Union[Signal, LogicLevel]
SignalDict = Dict[int, Signal]


class CarriesSignal(Protocol):
    @property
    def signal(self) -> Signal: ...
    @property
    def signal_int(self) -> Optional[int]: ...
    @property
    def is_floating(self) -> bool: ...
    @property
    def is_tied(self) -> bool: ...
    @property
    def is_tied_defined(self) -> bool: ...
    @property
    def is_tied_undefined(self) -> bool: ...

    @overload
    def tie_signal(self, signal: LogicLevel) -> None: ...
    @overload
    def tie_signal(self, signal: Signal) -> None: ...
    def tie_signal(self, signal: SignalOrLogicLevel) -> None: ...

    @overload
    def set_signal(self, signal: LogicLevel) -> None: ...
    @overload
    def set_signal(self, signal: Signal) -> None: ...
    def set_signal(self, signal: SignalOrLogicLevel) -> None: ...


class CarriesMultibitSignal(CarriesSignal, Protocol):
    msb_first: bool

    @property
    def signal_array(self) -> Dict[int, Signal]: ...
    @property
    def signal_str(self) -> str: ...
    @property
    def has_undefined_signals(self) -> bool: ...
    @property
    def is_floating_partly(self) -> bool: ...
    @property
    def is_tied_partly(self) -> bool: ...
    @property
    def is_tied_defined_partly(self) -> bool: ...
    @property
    def is_tied_undefined_partly(self) -> bool: ...
    @property
    def width(self) -> int: ...
    @property
    def offset(self) -> int: ...
    @property
    def lsb_first(self) -> bool: ...
    @property
    def signed(self) -> bool: ...
    @property
    def unsigned(self) -> bool: ...

    @overload
    def tie_signal(self, signal: LogicLevel, index: NonNegativeInt = 0) -> None: ...
    @overload
    def tie_signal(self, signal: Signal, index: NonNegativeInt = 0) -> None: ...
    def tie_signal(self, signal: SignalOrLogicLevel, index: NonNegativeInt = 0) -> None: ...

    @overload
    def set_signal(self, signal: LogicLevel, index: NonNegativeInt = 0) -> None: ...
    @overload
    def set_signal(self, signal: Signal, index: NonNegativeInt = 0) -> None: ...
    def set_signal(self, signal: SignalOrLogicLevel, index: NonNegativeInt = 0) -> None: ...

    @overload
    def set_signals(self, signal: int) -> None: ...
    @overload
    def set_signals(self, signal: str) -> None: ...
    @overload
    def set_signals(self, signal: SignalDict) -> None: ...
    def set_signals(self, signal: Union[int, str, SignalDict]) -> None: ...
    def count_signals(self, target_signal: Signal) -> int: ...
    def set_signed(self, signed: bool) -> None: ...
