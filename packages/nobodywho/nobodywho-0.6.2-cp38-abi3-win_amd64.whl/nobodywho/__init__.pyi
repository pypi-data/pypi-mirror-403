import _typeshed
import os
import typing

T = typing.TypeVar('T', str, typing.Awaitable[str])  # Type variable for tool return types (sync str or async Awaitable[str])

class Chat:
    def __new__(cls, /, model: Model | os.PathLike | str, n_ctx: int = 4096, system_prompt: str = "", allow_thinking: bool = True, tools: list[Tool] = ..., sampler: SamplerConfig = ...) -> Chat: ...
    def ask(self, /, text: str) -> TokenStream: ...
    def get_chat_history(self, /) -> list[dict]: ...
    def reset(self, /, system_prompt: str, tools: list[Tool]) -> None: ...
    def reset_history(self, /) -> None: ...
    def set_allow_thinking(self, /, allow_thinking: bool) -> None: ...
    def set_chat_history(self, /, msgs: list[dict]) -> None: ...
    def set_sampler_config(self, /, sampler: SamplerConfig) -> None: ...
    def set_system_prompt(self, /, system_prompt: str) -> None: ...
    def set_tools(self, /, tools: list[Tool]) -> None: ...
    def stop_generation(self, /) -> None: ...

class ChatAsync:
    def __new__(cls, /, model: Model | os.PathLike | str, n_ctx: int = 4096, system_prompt: str = "", allow_thinking: bool = True, tools: list[Tool] = ..., sampler: SamplerConfig = ...) -> ChatAsync: ...
    def ask(self, /, text: str) -> TokenStreamAsync: ...
    def get_chat_history(self, /) -> list[dict]: ...
    def reset(self, /, system_prompt: str, tools: list[Tool]) -> None: ...
    def reset_history(self, /) -> None: ...
    def set_allow_thinking(self, /, allow_thinking: bool) -> None: ...
    def set_chat_history(self, /, msgs: list[dict]) -> None: ...
    def set_sampler_config(self, /, sampler: SamplerConfig) -> None: ...
    def set_system_prompt(self, /, system_prompt: str) -> None: ...
    def set_tools(self, /, tools: list[Tool]) -> None: ...
    def stop_generation(self, /) -> None: ...

class CrossEncoder:
    def __new__(cls, /, model: Model | os.PathLike | str, n_ctx: int = 4096) -> CrossEncoder: ...
    def rank(self, /, query: str, documents: list[str]) -> list[float]: ...
    def rank_and_sort(self, /, query: str, documents: list[str]) -> list[tuple[str, float]]: ...

class CrossEncoderAsync:
    def __new__(cls, /, model: Model | os.PathLike | str, n_ctx: int = 4096) -> CrossEncoderAsync: ...
    def rank(self, /, query: str, documents: list[str]) -> typing.Awaitable[list[float]]: ...
    def rank_and_sort(self, /, query: str, documents: list[str]) -> typing.Awaitable[list[tuple[str, float]]]: ...

class Encoder:
    def __new__(cls, /, model: Model | os.PathLike | str, n_ctx: int = 4096) -> Encoder: ...
    def encode(self, /, text: str) -> list[float]: ...

class EncoderAsync:
    def __new__(cls, /, model: Model | os.PathLike | str, n_ctx: int = 4096) -> EncoderAsync: ...
    def encode(self, /, text: str) -> typing.Awaitable[list[float]]: ...

class Model:
    def __new__(cls, /, model_path: os.PathLike | str, use_gpu_if_available: bool = True) -> Model: ...

class SamplerBuilder:
    def __new__(cls, /) -> SamplerBuilder: ...
    def dist(self, /) -> SamplerConfig: ...
    def dry(self, /, multiplier: float, base: float, allowed_length: int, penalty_last_n: int, seq_breakers: list[str]) -> SamplerBuilder: ...
    def grammar(self, /, grammar: str, trigger_on: str | None, root: str) -> SamplerBuilder: ...
    def greedy(self, /) -> SamplerConfig: ...
    def min_p(self, /, min_p: float, min_keep: int) -> SamplerBuilder: ...
    def mirostat_v1(self, /, tau: float, eta: float, m: int) -> SamplerConfig: ...
    def mirostat_v2(self, /, tau: float, eta: float) -> SamplerConfig: ...
    def penalties(self, /, penalty_last_n: int, penalty_repeat: float, penalty_freq: float, penalty_present: float) -> SamplerBuilder: ...
    def temperature(self, /, temperature: float) -> SamplerBuilder: ...
    def top_k(self, /, top_k: int) -> SamplerBuilder: ...
    def top_p(self, /, top_p: float, min_keep: int) -> SamplerBuilder: ...
    def typical_p(self, /, typ_p: float, min_keep: int) -> SamplerBuilder: ...
    def xtc(self, /, xtc_probability: float, xtc_threshold: float, min_keep: int) -> SamplerBuilder: ...

class SamplerConfig: ...

class SamplerPresets:
    @staticmethod
    def default() -> SamplerConfig: ...
    @staticmethod
    def dry() -> SamplerConfig: ...
    @staticmethod
    def grammar(grammar: str) -> SamplerConfig: ...
    @staticmethod
    def greedy() -> SamplerConfig: ...
    @staticmethod
    def json() -> SamplerConfig: ...
    @staticmethod
    def temperature(temperature: float) -> SamplerConfig: ...
    @staticmethod
    def top_k(top_k: int) -> SamplerConfig: ...
    @staticmethod
    def top_p(top_p: float) -> SamplerConfig: ...

class TokenStream:
    def __iter__(self, /) -> TokenStream: ...
    def __next__(self, /) -> str: ... # Replaced with str to avoid type errors
    def completed(self, /) -> str: ...
    def next_token(self, /) -> str | None: ...

class TokenStreamAsync:
    def __aiter__(self, /) -> TokenStreamAsync: ...
    def __anext__(self, /) -> typing.Awaitable[str]: ... # Replaced with str to avoid type errors
    def completed(self, /) -> typing.Awaitable[str]: ...
    def next_token(self, /) -> typing.Awaitable[str | None]: ...

class Tool(typing.Generic[T]):
    def __call__(self, /, *args, **kwargs) -> T: ...

def cosine_similarity(a: list[float], b: list[float]) -> float: ...
def tool(description: str, params: dict[str, str] | None = None) -> typing.Callable[[typing.Callable[..., T]], Tool[T]]: ...
def __getattr__(name: str) -> _typeshed.Incomplete: ...