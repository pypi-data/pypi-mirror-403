"""Switch API endpoints.

This file is automatically @generated from the Meraki API specification.
Do not edit this file manually.

"""

from __future__ import annotations

import urllib.parse
from typing import TYPE_CHECKING, Any, Literal

from meraki_client.schemas import (
    AddNetworkSwitchStackResponse,
    CloneOrganizationSwitchDevicesResponse,
    CreateDeviceSwitchRoutingInterfaceIpv6,
    CreateDeviceSwitchRoutingInterfaceOspfSettings,
    CreateDeviceSwitchRoutingInterfaceResponse,
    CreateDeviceSwitchRoutingInterfaceVrf,
    CreateDeviceSwitchRoutingStaticRouteResponse,
    CreateDeviceSwitchRoutingStaticRouteVrf,
    CreateNetworkSwitchAccessPolicyDot1x,
    CreateNetworkSwitchAccessPolicyRadius,
    CreateNetworkSwitchAccessPolicyRadiusAccountingServersItem,
    CreateNetworkSwitchAccessPolicyRadiusServersItem,
    CreateNetworkSwitchAccessPolicyResponse,
    CreateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerIpv4,
    CreateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerResponse,
    CreateNetworkSwitchLinkAggregationResponse,
    CreateNetworkSwitchLinkAggregationSwitchPortsItem,
    CreateNetworkSwitchLinkAggregationSwitchProfilePortsItem,
    CreateNetworkSwitchPortSchedulePortSchedule,
    CreateNetworkSwitchPortScheduleResponse,
    CreateNetworkSwitchQosRuleResponse,
    CreateNetworkSwitchRoutingMulticastRendezvousPointResponse,
    CreateNetworkSwitchRoutingMulticastRendezvousPointVrf,
    CreateNetworkSwitchStackResponse,
    CreateNetworkSwitchStackRoutingInterfaceIpv6,
    CreateNetworkSwitchStackRoutingInterfaceOspfSettings,
    CreateNetworkSwitchStackRoutingInterfaceResponse,
    CreateNetworkSwitchStackRoutingInterfaceVrf,
    CreateNetworkSwitchStackRoutingStaticRouteResponse,
    CreateNetworkSwitchStackRoutingStaticRouteVrf,
    CycleDeviceSwitchPortsResponse,
    GetDeviceSwitchPortResponse,
    GetDeviceSwitchPortsResponseItem,
    GetDeviceSwitchPortsStatusesPacketsResponseItem,
    GetDeviceSwitchPortsStatusesResponseItem,
    GetDeviceSwitchRoutingInterfaceDhcpResponse,
    GetDeviceSwitchRoutingInterfaceResponse,
    GetDeviceSwitchRoutingInterfacesResponseItem,
    GetDeviceSwitchRoutingStaticRouteResponse,
    GetDeviceSwitchRoutingStaticRoutesResponseItem,
    GetDeviceSwitchWarmSpareResponse,
    GetNetworkSwitchAccessControlListsResponse,
    GetNetworkSwitchAccessPoliciesResponseItem,
    GetNetworkSwitchAccessPolicyResponse,
    GetNetworkSwitchAlternateManagementInterfaceResponse,
    GetNetworkSwitchDhcpServerPolicyArpInspectionTrustedServersResponseItem,
    GetNetworkSwitchDhcpServerPolicyArpInspectionWarningsByDeviceResponseItem,
    GetNetworkSwitchDhcpServerPolicyResponse,
    GetNetworkSwitchDhcpV4ServersSeenResponseItem,
    GetNetworkSwitchDscpToCosMappingsResponse,
    GetNetworkSwitchLinkAggregationsResponseItem,
    GetNetworkSwitchMtuResponse,
    GetNetworkSwitchPortSchedulesResponseItem,
    GetNetworkSwitchQosRuleResponse,
    GetNetworkSwitchQosRulesOrderResponse,
    GetNetworkSwitchQosRulesResponseItem,
    GetNetworkSwitchRoutingMulticastRendezvousPointResponse,
    GetNetworkSwitchRoutingMulticastRendezvousPointsResponseItem,
    GetNetworkSwitchRoutingMulticastResponse,
    GetNetworkSwitchRoutingOspfResponse,
    GetNetworkSwitchSettingsResponse,
    GetNetworkSwitchStackResponse,
    GetNetworkSwitchStackRoutingInterfaceDhcpResponse,
    GetNetworkSwitchStackRoutingInterfaceResponse,
    GetNetworkSwitchStackRoutingInterfacesResponseItem,
    GetNetworkSwitchStackRoutingStaticRouteResponse,
    GetNetworkSwitchStackRoutingStaticRoutesResponseItem,
    GetNetworkSwitchStacksResponseItem,
    GetNetworkSwitchStormControlResponse,
    GetNetworkSwitchStpResponse,
    GetOrganizationConfigTemplateSwitchProfilePortResponse,
    GetOrganizationConfigTemplateSwitchProfilePortsResponseItem,
    GetOrganizationConfigTemplateSwitchProfilesResponseItem,
    GetOrganizationSummarySwitchPowerHistoryResponseItem,
    GetOrganizationSwitchPortsBySwitchResponsePortsItem,
    GetOrganizationSwitchPortsClientsOverviewByDeviceResponseItemsItem,
    GetOrganizationSwitchPortsOverviewResponse,
    GetOrganizationSwitchPortsStatusesBySwitchResponseItemsItem,
    GetOrganizationSwitchPortsTopologyDiscoveryByDeviceResponseItemsItem,
    GetOrganizationSwitchPortsUsageHistoryByDeviceByIntervalResponseItemsItem,
    RemoveNetworkSwitchStackResponse,
    UpdateDeviceSwitchPortDot3az,
    UpdateDeviceSwitchPortHighSpeed,
    UpdateDeviceSwitchPortProfile,
    UpdateDeviceSwitchPortResponse,
    UpdateDeviceSwitchRoutingInterfaceDhcpDhcpOptionsItem,
    UpdateDeviceSwitchRoutingInterfaceDhcpFixedIpAssignmentsItem,
    UpdateDeviceSwitchRoutingInterfaceDhcpReservedIpRangesItem,
    UpdateDeviceSwitchRoutingInterfaceDhcpResponse,
    UpdateDeviceSwitchRoutingInterfaceIpv6,
    UpdateDeviceSwitchRoutingInterfaceOspfSettings,
    UpdateDeviceSwitchRoutingInterfaceResponse,
    UpdateDeviceSwitchRoutingInterfaceVrf,
    UpdateDeviceSwitchRoutingStaticRouteResponse,
    UpdateDeviceSwitchRoutingStaticRouteVrf,
    UpdateDeviceSwitchWarmSpareResponse,
    UpdateNetworkSwitchAccessControlListsResponse,
    UpdateNetworkSwitchAccessControlListsRulesItem,
    UpdateNetworkSwitchAccessPolicyDot1x,
    UpdateNetworkSwitchAccessPolicyRadius,
    UpdateNetworkSwitchAccessPolicyRadiusAccountingServersItem,
    UpdateNetworkSwitchAccessPolicyRadiusServersItem,
    UpdateNetworkSwitchAccessPolicyResponse,
    UpdateNetworkSwitchAlternateManagementInterfaceResponse,
    UpdateNetworkSwitchAlternateManagementInterfaceSwitchesItem,
    UpdateNetworkSwitchDhcpServerPolicyAlerts,
    UpdateNetworkSwitchDhcpServerPolicyArpInspection,
    UpdateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerIpv4,
    UpdateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerResponse,
    UpdateNetworkSwitchDhcpServerPolicyResponse,
    UpdateNetworkSwitchDscpToCosMappingsMappingsItem,
    UpdateNetworkSwitchDscpToCosMappingsResponse,
    UpdateNetworkSwitchLinkAggregationResponse,
    UpdateNetworkSwitchLinkAggregationSwitchPortsItem,
    UpdateNetworkSwitchLinkAggregationSwitchProfilePortsItem,
    UpdateNetworkSwitchMtuOverridesItem,
    UpdateNetworkSwitchMtuResponse,
    UpdateNetworkSwitchPortSchedulePortSchedule,
    UpdateNetworkSwitchPortScheduleResponse,
    UpdateNetworkSwitchQosRuleResponse,
    UpdateNetworkSwitchQosRulesOrderResponse,
    UpdateNetworkSwitchRoutingMulticastDefaultSettings,
    UpdateNetworkSwitchRoutingMulticastOverridesItem,
    UpdateNetworkSwitchRoutingMulticastRendezvousPointResponse,
    UpdateNetworkSwitchRoutingMulticastRendezvousPointVrf,
    UpdateNetworkSwitchRoutingMulticastResponse,
    UpdateNetworkSwitchRoutingOspfAreasItem,
    UpdateNetworkSwitchRoutingOspfMd5AuthenticationKey,
    UpdateNetworkSwitchRoutingOspfResponse,
    UpdateNetworkSwitchRoutingOspfV3,
    UpdateNetworkSwitchSettingsMacBlocklist,
    UpdateNetworkSwitchSettingsPowerExceptionsItem,
    UpdateNetworkSwitchSettingsResponse,
    UpdateNetworkSwitchSettingsUplinkClientSampling,
    UpdateNetworkSwitchSettingsUplinkSelection,
    UpdateNetworkSwitchStackRoutingInterfaceDhcpDhcpOptionsItem,
    UpdateNetworkSwitchStackRoutingInterfaceDhcpFixedIpAssignmentsItem,
    UpdateNetworkSwitchStackRoutingInterfaceDhcpReservedIpRangesItem,
    UpdateNetworkSwitchStackRoutingInterfaceDhcpResponse,
    UpdateNetworkSwitchStackRoutingInterfaceIpv6,
    UpdateNetworkSwitchStackRoutingInterfaceOspfSettings,
    UpdateNetworkSwitchStackRoutingInterfaceResponse,
    UpdateNetworkSwitchStackRoutingInterfaceVrf,
    UpdateNetworkSwitchStackRoutingStaticRouteResponse,
    UpdateNetworkSwitchStackRoutingStaticRouteVrf,
    UpdateNetworkSwitchStormControlResponse,
    UpdateNetworkSwitchStpResponse,
    UpdateNetworkSwitchStpStpBridgePriorityItem,
    UpdateOrganizationConfigTemplateSwitchProfilePortDot3az,
    UpdateOrganizationConfigTemplateSwitchProfilePortHighSpeed,
    UpdateOrganizationConfigTemplateSwitchProfilePortProfile,
    UpdateOrganizationConfigTemplateSwitchProfilePortResponse,
)

if TYPE_CHECKING:
    from meraki_client._session import PaginatedResponse, Session


class Switch:
    """Switch class."""

    def __init__(self, session: Session) -> None:
        self._session = session

    def get_device_switch_ports(
        self, serial: str
    ) -> PaginatedResponse[GetDeviceSwitchPortsResponseItem]:
        """List the switch ports for a switch.

        [API documentation: getDeviceSwitchPorts](https://developer.cisco.com/meraki/api-v1/#!get-device-switch-ports)

        Args:
            serial: Serial.

        Returns:
            Successful operation.

        Example API response:
            ```json
            [
              {
                "portId": "1",
                "name": "My switch port",
                "tags": [
                  "tag1",
                  "tag2"
                ],
                "enabled": true,
                "poeEnabled": true,
                "type": "access",
                "vlan": 10,
                "voiceVlan": 20,
                "allowedVlans": "1,3,5-10",
                "isolationEnabled": false,
                "rstpEnabled": true,
                "stpGuard": "disabled",
                "stpPortFastTrunk": false,
                "linkNegotiation": "Auto negotiate",
                "linkNegotiationCapabilities": [
                  "Auto negotiate",
                  "1 Gigabit full duplex (auto)"
                ],
                "portScheduleId": "1234",
                "schedule": {
                  "id": "1234",
                  "name": "Port Schedule"
                },
                "udld": "Alert only",
                "accessPolicyType": "Sticky MAC allow list",
                "accessPolicyNumber": 2,
                "macAllowList": [
                  "34:56:fe:ce:8e:a0",
                  "34:56:fe:ce:8e:a1"
                ],
                "macWhitelistLimit": 10,
                "stickyMacAllowList": [
                  "34:56:fe:ce:8e:b0",
                  "34:56:fe:ce:8e:b1"
                ],
                "stickyMacAllowListLimit": 5,
                "stormControlEnabled": true,
                "adaptivePolicyGroupId": "123",
                "adaptivePolicyGroup": {
                  "id": "123",
                  "name": "Adaptive Policy Group"
                },
                "peerSgtCapable": false,
                "flexibleStackingEnabled": true,
                "daiTrusted": false,
                "profile": {
                  "enabled": false,
                  "id": "1284392014819",
                  "iname": "iname"
                },
                "module": {
                  "model": "MA-MOD-4X10G",
                  "serial": "3_MA-MOD-4X10G",
                  "slot": 1
                },
                "mirror": {
                  "mode": "Not mirroring traffic"
                },
                "dot3az": {
                  "enabled": false
                },
                "highSpeed": {
                  "enabled": false
                }
              }
            ]
            ```

        """
        serial = urllib.parse.quote(str(serial), safe="")
        path = f"/devices/{serial}/switch/ports"

        return self._session.get_pages(
            scope="switch",
            operation_id="getDeviceSwitchPorts",
            path=path,
            item_schema=GetDeviceSwitchPortsResponseItem,
        )

    def cycle_device_switch_ports(
        self, *, serial: str, ports: list[str]
    ) -> CycleDeviceSwitchPortsResponse | None:
        """Cycle a set of switch ports.

        [API documentation: cycleDeviceSwitchPorts](https://developer.cisco.com/meraki/api-v1/#!cycle-device-switch-ports)

        Args:
            serial: Serial.
            ports: List of switch ports.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "ports": [
                "1",
                "2-5",
                "1_MA-MOD-8X10G_1",
                "1_MA-MOD-8X10G_2-1_MA-MOD-8X10G_8"
              ]
            }
            ```

        """
        serial = urllib.parse.quote(str(serial), safe="")
        path = f"/devices/{serial}/switch/ports/cycle"

        payload = {}
        if ports is not None:
            payload["ports"] = ports

        return self._session.post(
            scope="switch",
            operation_id="cycleDeviceSwitchPorts",
            path=path,
            json=payload,
            response_schema=CycleDeviceSwitchPortsResponse,
        )

    def get_device_switch_ports_statuses(
        self, serial: str, *, t0: str | None = None, timespan: float | None = None
    ) -> PaginatedResponse[GetDeviceSwitchPortsStatusesResponseItem]:
        """Return the status for all the ports of a switch.

        [API documentation: getDeviceSwitchPortsStatuses](https://developer.cisco.com/meraki/api-v1/#!get-device-switch-ports-statuses)

        Args:
            serial: Serial.
            t0: The beginning of the timespan for the data. The maximum lookback period is 31 days
                from today.
            timespan: The timespan for which the information will be fetched. If specifying
                timespan, do not specify parameter t0. The value must be in seconds and
                be less than or equal to 31 days. The default is 1 day.

        Returns:
            Successful operation.

        Example API response:
            ```json
            [
              {
                "portId": "1",
                "enabled": true,
                "status": "Connected",
                "isUplink": false,
                "errors": [
                  "PoE overload",
                  "Very high proportion of CRC errors"
                ],
                "warnings": [
                  "SecurePort authentication in progress",
                  "PoE port was denied power",
                  "High proportion of CRC errors"
                ],
                "speed": "10 Gbps",
                "duplex": "full",
                "spanningTree": {
                  "statuses": [
                    "Learning"
                  ]
                },
                "poe": {
                  "isAllocated": false
                },
                "usageInKb": {
                  "total": 40867,
                  "sent": 23008,
                  "recv": 17859
                },
                "cdp": {
                  "systemName": "",
                  "platform": "MS350-24X",
                  "deviceId": "0c8ddbddee:ff",
                  "portId": "Port 20",
                  "nativeVlan": 1,
                  "address": "10.0,0.1",
                  "managementAddress": "10.0.0.100",
                  "version": "1",
                  "vtpManagementDomain": "",
                  "capabilities": "Switch"
                },
                "lldp": {
                  "systemName": "MS350-24X - Test",
                  "systemDescription": "MS350-24X Cloud Managed PoE Switch",
                  "chassisId": "0c:8d:db:dd:ee:ff",
                  "portId": "20",
                  "managementVlan": 1,
                  "portVlan": 1,
                  "managementAddress": "10.0.0.100",
                  "portDescription": "Port 20",
                  "systemCapabilities": "switch"
                },
                "clientCount": 10,
                "powerUsageInWh": 55.9,
                "trafficInKbps": {
                  "total": 2.2,
                  "sent": 1.2,
                  "recv": 1.0
                },
                "securePort": {
                  "enabled": true,
                  "active": true,
                  "authenticationStatus": "Authentication in progress",
                  "configOverrides": {
                    "type": "trunk",
                    "vlan": 12,
                    "voiceVlan": 34,
                    "allowedVlans": "all"
                  }
                }
              }
            ]
            ```

        """
        serial = urllib.parse.quote(str(serial), safe="")
        path = f"/devices/{serial}/switch/ports/statuses"

        params = {}
        if t0 is not None:
            params["t0"] = t0
        if timespan is not None:
            params["timespan"] = timespan

        return self._session.get_pages(
            scope="switch",
            operation_id="getDeviceSwitchPortsStatuses",
            path=path,
            params=params,
            item_schema=GetDeviceSwitchPortsStatusesResponseItem,
        )

    def get_device_switch_ports_statuses_packets(
        self, serial: str, *, t0: str | None = None, timespan: float | None = None
    ) -> PaginatedResponse[GetDeviceSwitchPortsStatusesPacketsResponseItem]:
        """Return the packet counters for all the ports of a switch.

        [API documentation: getDeviceSwitchPortsStatusesPackets](https://developer.cisco.com/meraki/api-v1/#!get-device-switch-ports-statuses-packets)

        Args:
            serial: Serial.
            t0: The beginning of the timespan for the data. The value is used only to determine the
                elapsed duration between t0 and the time of the request; the API snaps
                that duration to the nearest preset window (5 minutes, 15 minutes, 1
                hour, or 1 day).
            timespan: The timespan for which the information will be fetched. If specifying
                timespan, do not specify t0. The value must be in seconds and be less
                than or equal to 86400 seconds (1 day). The default is 1 day.

        Returns:
            Successful operation.

        Example API response:
            ```json
            [
              {
                "portId": "1",
                "packets": [
                  {
                    "desc": "Total",
                    "total": 112081,
                    "sent": 104135,
                    "recv": 7946,
                    "ratePerSec": {
                      "total": 1,
                      "sent": 1,
                      "recv": 0
                    }
                  }
                ]
              }
            ]
            ```

        """
        serial = urllib.parse.quote(str(serial), safe="")
        path = f"/devices/{serial}/switch/ports/statuses/packets"

        params = {}
        if t0 is not None:
            params["t0"] = t0
        if timespan is not None:
            params["timespan"] = timespan

        return self._session.get_pages(
            scope="switch",
            operation_id="getDeviceSwitchPortsStatusesPackets",
            path=path,
            params=params,
            item_schema=GetDeviceSwitchPortsStatusesPacketsResponseItem,
        )

    def get_device_switch_port(
        self, *, serial: str, port_id: str
    ) -> GetDeviceSwitchPortResponse | None:
        """Return a switch port.

        [API documentation: getDeviceSwitchPort](https://developer.cisco.com/meraki/api-v1/#!get-device-switch-port)

        Args:
            serial: Serial.
            port_id: Port ID.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "portId": "1",
              "name": "My switch port",
              "tags": [
                "tag1",
                "tag2"
              ],
              "enabled": true,
              "poeEnabled": true,
              "type": "access",
              "vlan": 10,
              "voiceVlan": 20,
              "allowedVlans": "1,3,5-10",
              "isolationEnabled": false,
              "rstpEnabled": true,
              "stpGuard": "disabled",
              "stpPortFastTrunk": false,
              "linkNegotiation": "Auto negotiate",
              "linkNegotiationCapabilities": [
                "Auto negotiate",
                "1 Gigabit full duplex (auto)"
              ],
              "portScheduleId": "1234",
              "schedule": {
                "id": "1234",
                "name": "Port Schedule"
              },
              "udld": "Alert only",
              "accessPolicyType": "Sticky MAC allow list",
              "accessPolicyNumber": 2,
              "macAllowList": [
                "34:56:fe:ce:8e:a0",
                "34:56:fe:ce:8e:a1"
              ],
              "macWhitelistLimit": 10,
              "stickyMacAllowList": [
                "34:56:fe:ce:8e:b0",
                "34:56:fe:ce:8e:b1"
              ],
              "stickyMacAllowListLimit": 5,
              "stormControlEnabled": true,
              "adaptivePolicyGroupId": "123",
              "adaptivePolicyGroup": {
                "id": "123",
                "name": "Adaptive Policy Group"
              },
              "peerSgtCapable": false,
              "flexibleStackingEnabled": true,
              "daiTrusted": false,
              "profile": {
                "enabled": false,
                "id": "1284392014819",
                "iname": "iname"
              },
              "module": {
                "model": "MA-MOD-4X10G",
                "serial": "3_MA-MOD-4X10G",
                "slot": 1
              },
              "mirror": {
                "mode": "Not mirroring traffic"
              },
              "dot3az": {
                "enabled": false
              },
              "highSpeed": {
                "enabled": false
              }
            }
            ```

        """
        serial = urllib.parse.quote(str(serial), safe="")
        port_id = urllib.parse.quote(str(port_id), safe="")
        path = f"/devices/{serial}/switch/ports/{port_id}"

        return self._session.get(
            scope="switch",
            operation_id="getDeviceSwitchPort",
            path=path,
            response_schema=GetDeviceSwitchPortResponse,
        )

    def update_device_switch_port(
        self,
        *,
        serial: str,
        port_id: str,
        name: str | None = None,
        tags: list[str] | None = None,
        enabled: bool | None = None,
        poe_enabled: bool | None = None,
        type_: str | None = None,
        vlan: int | None = None,
        voice_vlan: int | None = None,
        allowed_vlans: str | None = None,
        isolation_enabled: bool | None = None,
        rstp_enabled: bool | None = None,
        stp_guard: str | None = None,
        stp_port_fast_trunk: bool | None = None,
        link_negotiation: str | None = None,
        port_schedule_id: str | None = None,
        udld: str | None = None,
        access_policy_type: str | None = None,
        access_policy_number: int | None = None,
        mac_allow_list: list[str] | None = None,
        mac_whitelist_limit: int | None = None,
        sticky_mac_allow_list: list[str] | None = None,
        sticky_mac_allow_list_limit: int | None = None,
        storm_control_enabled: bool | None = None,
        adaptive_policy_group_id: str | None = None,
        peer_sgt_capable: bool | None = None,
        flexible_stacking_enabled: bool | None = None,
        dai_trusted: bool | None = None,
        profile: UpdateDeviceSwitchPortProfile | None = None,
        dot3az: UpdateDeviceSwitchPortDot3az | None = None,
        high_speed: UpdateDeviceSwitchPortHighSpeed | None = None,
    ) -> UpdateDeviceSwitchPortResponse | None:
        """Update a switch port.

        [API documentation: updateDeviceSwitchPort](https://developer.cisco.com/meraki/api-v1/#!update-device-switch-port)

        Args:
            serial: Serial.
            port_id: Port ID.
            name: The name of the switch port.
            tags: The list of tags of the switch port.
            enabled: The status of the switch port.
            poe_enabled: The PoE status of the switch port.
            type_: The type of the switch port ('access', 'trunk', 'stack', 'routed', 'svl' or
                'dad').
            vlan: The VLAN of the switch port. For a trunk port, this is the native VLAN. A null
                value will clear the value set for trunk ports.
            voice_vlan: The voice VLAN of the switch port. Only applicable to access ports.
            allowed_vlans: The VLANs allowed on the switch port. Only applicable to trunk ports.
            isolation_enabled: The isolation status of the switch port.
            rstp_enabled: The rapid spanning tree protocol status.
            stp_guard: The state of the STP guard ('disabled', 'root guard', 'bpdu guard' or 'loop
                guard').
            stp_port_fast_trunk: The state of STP PortFast Trunk on the switch port.
            link_negotiation: The link speed for the switch port.
            port_schedule_id: The ID of the port schedule. A value of null will clear the port
                schedule.
            udld: The action to take when Unidirectional Link is detected (Alert only, Enforce).
                Default configuration is Alert only.
            access_policy_type: The type of the access policy of the switch port. Only applicable to
                access ports. Can be one of 'Open', 'Custom access policy', 'MAC allow
                list' or 'Sticky MAC allow list'.
            access_policy_number: The number of a custom access policy to configure on the switch
                port. Only applicable when 'accessPolicyType' is 'Custom access policy'.
            mac_allow_list: Only devices with MAC addresses specified in this list will have access
                to this port. Up to 20 MAC addresses can be defined. Only applicable
                when 'accessPolicyType' is 'MAC allow list'.
            mac_whitelist_limit: The maximum number of MAC addresses for regular MAC allow list.
                Only applicable when 'accessPolicyType' is 'MAC allow list'. Note:
                Config only supported on verions greater than ms18 only for classic
                switches.
            sticky_mac_allow_list: The initial list of MAC addresses for sticky Mac allow list. Only
                applicable when 'accessPolicyType' is 'Sticky MAC allow list'.
            sticky_mac_allow_list_limit: The maximum number of MAC addresses for sticky MAC allow
                list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow
                list'.
            storm_control_enabled: The storm control status of the switch port.
            adaptive_policy_group_id: The adaptive policy group ID that will be used to tag traffic
                through this switch port. This ID must pre-exist during the
                configuration, else needs to be created using adaptivePolicy/groups API.
                Cannot be applied to a port on a switch bound to profile.
            peer_sgt_capable: If true, Peer SGT is enabled for traffic through this switch port.
                Applicable to trunk port only, not access port. Cannot be applied to a
                port on a switch bound to profile.
            flexible_stacking_enabled: For supported switches (e.g. MS420/MS425), whether or not the
                port has flexible stacking enabled.
            dai_trusted: If true, ARP packets for this port will be considered trusted, and Dynamic
                ARP Inspection will allow the traffic.
            profile: Profile attributes.
            dot3az: dot3az settings for the port.
            high_speed: High speed port enablement settings for C9500-32QC.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "portId": "1",
              "name": "My switch port",
              "tags": [
                "tag1",
                "tag2"
              ],
              "enabled": true,
              "poeEnabled": true,
              "type": "access",
              "vlan": 10,
              "voiceVlan": 20,
              "allowedVlans": "1,3,5-10",
              "isolationEnabled": false,
              "rstpEnabled": true,
              "stpGuard": "disabled",
              "stpPortFastTrunk": false,
              "linkNegotiation": "Auto negotiate",
              "linkNegotiationCapabilities": [
                "Auto negotiate",
                "1 Gigabit full duplex (auto)"
              ],
              "portScheduleId": "1234",
              "schedule": {
                "id": "1234",
                "name": "Port Schedule"
              },
              "udld": "Alert only",
              "accessPolicyType": "Sticky MAC allow list",
              "accessPolicyNumber": 2,
              "macAllowList": [
                "34:56:fe:ce:8e:a0",
                "34:56:fe:ce:8e:a1"
              ],
              "macWhitelistLimit": 10,
              "stickyMacAllowList": [
                "34:56:fe:ce:8e:b0",
                "34:56:fe:ce:8e:b1"
              ],
              "stickyMacAllowListLimit": 5,
              "stormControlEnabled": true,
              "adaptivePolicyGroupId": "123",
              "adaptivePolicyGroup": {
                "id": "123",
                "name": "Adaptive Policy Group"
              },
              "peerSgtCapable": false,
              "flexibleStackingEnabled": true,
              "daiTrusted": false,
              "profile": {
                "enabled": false,
                "id": "1284392014819",
                "iname": "iname"
              },
              "module": {
                "model": "MA-MOD-4X10G",
                "serial": "3_MA-MOD-4X10G",
                "slot": 1
              },
              "mirror": {
                "mode": "Not mirroring traffic"
              },
              "dot3az": {
                "enabled": false
              },
              "highSpeed": {
                "enabled": false
              }
            }
            ```

        """
        if type_ is not None:
            options = ["access", "dad", "routed", "stack", "svl", "trunk"]
            assert type_ in options, (
                f'"type_" cannot be "{type_}", & must be set to one of: {options}'
            )
        if stp_guard is not None:
            options = ["bpdu guard", "disabled", "loop guard", "root guard"]
            assert stp_guard in options, (
                f'"stp_guard" cannot be "{stp_guard}", & must be set to one of: {options}'
            )
        if udld is not None:
            options = ["Alert only", "Enforce"]
            assert udld in options, f'"udld" cannot be "{udld}", & must be set to one of: {options}'
        if access_policy_type is not None:
            options = ["Custom access policy", "MAC allow list", "Open", "Sticky MAC allow list"]
            assert access_policy_type in options, (
                f'"access_policy_type" cannot be "{access_policy_type}", & must be set to one of: {options}'
            )

        serial = urllib.parse.quote(str(serial), safe="")
        port_id = urllib.parse.quote(str(port_id), safe="")
        path = f"/devices/{serial}/switch/ports/{port_id}"

        payload = {}
        if name is not None:
            payload["name"] = name
        if tags is not None:
            payload["tags"] = tags
        if enabled is not None:
            payload["enabled"] = enabled
        if poe_enabled is not None:
            payload["poeEnabled"] = poe_enabled
        if type_ is not None:
            payload["type"] = type_
        if vlan is not None:
            payload["vlan"] = vlan
        if voice_vlan is not None:
            payload["voiceVlan"] = voice_vlan
        if allowed_vlans is not None:
            payload["allowedVlans"] = allowed_vlans
        if isolation_enabled is not None:
            payload["isolationEnabled"] = isolation_enabled
        if rstp_enabled is not None:
            payload["rstpEnabled"] = rstp_enabled
        if stp_guard is not None:
            payload["stpGuard"] = stp_guard
        if stp_port_fast_trunk is not None:
            payload["stpPortFastTrunk"] = stp_port_fast_trunk
        if link_negotiation is not None:
            payload["linkNegotiation"] = link_negotiation
        if port_schedule_id is not None:
            payload["portScheduleId"] = port_schedule_id
        if udld is not None:
            payload["udld"] = udld
        if access_policy_type is not None:
            payload["accessPolicyType"] = access_policy_type
        if access_policy_number is not None:
            payload["accessPolicyNumber"] = access_policy_number
        if mac_allow_list is not None:
            payload["macAllowList"] = mac_allow_list
        if mac_whitelist_limit is not None:
            payload["macWhitelistLimit"] = mac_whitelist_limit
        if sticky_mac_allow_list is not None:
            payload["stickyMacAllowList"] = sticky_mac_allow_list
        if sticky_mac_allow_list_limit is not None:
            payload["stickyMacAllowListLimit"] = sticky_mac_allow_list_limit
        if storm_control_enabled is not None:
            payload["stormControlEnabled"] = storm_control_enabled
        if adaptive_policy_group_id is not None:
            payload["adaptivePolicyGroupId"] = adaptive_policy_group_id
        if peer_sgt_capable is not None:
            payload["peerSgtCapable"] = peer_sgt_capable
        if flexible_stacking_enabled is not None:
            payload["flexibleStackingEnabled"] = flexible_stacking_enabled
        if dai_trusted is not None:
            payload["daiTrusted"] = dai_trusted
        if profile is not None:
            payload["profile"] = profile.model_dump(by_alias=True, exclude_none=True)
        if dot3az is not None:
            payload["dot3az"] = dot3az.model_dump(by_alias=True, exclude_none=True)
        if high_speed is not None:
            payload["highSpeed"] = high_speed.model_dump(by_alias=True, exclude_none=True)

        return self._session.put(
            scope="switch",
            operation_id="updateDeviceSwitchPort",
            path=path,
            json=payload,
            response_schema=UpdateDeviceSwitchPortResponse,
        )

    def get_device_switch_routing_interfaces(
        self, serial: str, *, mode: str | None = None, protocol: str | None = None
    ) -> PaginatedResponse[GetDeviceSwitchRoutingInterfacesResponseItem]:
        """List layer 3 interfaces for a switch.

        [API documentation: getDeviceSwitchRoutingInterfaces](https://developer.cisco.com/meraki/api-v1/#!get-device-switch-routing-interfaces)

        Args:
            serial: Serial.
            mode: Optional parameter to filter L3 interfaces by mode.
            protocol: Optional parameter to filter L3 interfaces by protocol.

        Returns:
            Successful operation.

        Example API response:
            ```json
            [
              {
                "interfaceId": "1234",
                "name": "L3 interface",
                "mode": "vlan",
                "subnet": "192.168.1.0/24",
                "interfaceIp": "192.168.1.2",
                "serial": "Q234-ABCD-5678",
                "switchPortId": "1",
                "multicastRouting": "disabled",
                "vlanId": 100,
                "uplinkV4": false,
                "uplinkV6": false,
                "ospfSettings": {
                  "area": "0",
                  "cost": 1,
                  "isPassiveEnabled": true,
                  "networkType": "broadcast"
                },
                "ospfV3": {
                  "area": "1",
                  "cost": 2,
                  "isPassiveEnabled": true,
                  "networkType": "broadcast"
                },
                "ipv6": {
                  "assignmentMode": "static",
                  "address": "2001:db8::1",
                  "prefix": "2001:db8::/32",
                  "gateway": "2001:db8::2"
                },
                "vrf": {
                  "name": "Blue"
                },
                "defaultGateway": "192.168.1.1"
              }
            ]
            ```

        """
        if mode is not None:
            options = ["loopback", "oob_management", "routed", "vlan"]
            assert mode in options, f'"mode" cannot be "{mode}", & must be set to one of: {options}'
        if protocol is not None:
            options = ["ipv4", "ipv6"]
            assert protocol in options, (
                f'"protocol" cannot be "{protocol}", & must be set to one of: {options}'
            )

        serial = urllib.parse.quote(str(serial), safe="")
        path = f"/devices/{serial}/switch/routing/interfaces"

        params = {}
        if mode is not None:
            params["mode"] = mode
        if protocol is not None:
            params["protocol"] = protocol

        return self._session.get_pages(
            scope="switch",
            operation_id="getDeviceSwitchRoutingInterfaces",
            path=path,
            params=params,
            item_schema=GetDeviceSwitchRoutingInterfacesResponseItem,
        )

    def create_device_switch_routing_interface(
        self,
        *,
        serial: str,
        name: str,
        mode: str | None = None,
        subnet: str | None = None,
        switch_port_id: str | None = None,
        interface_ip: str | None = None,
        multicast_routing: str | None = None,
        vlan_id: int | None = None,
        default_gateway: str | None = None,
        ospf_settings: CreateDeviceSwitchRoutingInterfaceOspfSettings | None = None,
        ipv6: CreateDeviceSwitchRoutingInterfaceIpv6 | None = None,
        vrf: CreateDeviceSwitchRoutingInterfaceVrf | None = None,
        loopback: dict[str, Any] | None = None,
    ) -> CreateDeviceSwitchRoutingInterfaceResponse | None:
        """Create a layer 3 interface for a switch.

        [API documentation: createDeviceSwitchRoutingInterface](https://developer.cisco.com/meraki/api-v1/#!create-device-switch-routing-interface)

        Args:
            serial: Serial.
            name: A friendly name or description for the interface or VLAN (max length 128
                characters).
            mode: L3 Interface mode, can be one of 'vlan', 'routed', 'loopback'. Default is 'vlan'.
                CS 17.18 or higher is required for 'routed' mode.
            subnet: The network that this L3 interface is on, in CIDR notation (ex. 10.1.1.0/24).
            switch_port_id: Switch Port ID when in Routed mode (CS 17.18 or higher required).
            interface_ip: The IP address that will be used for Layer 3 routing on this VLAN or
                subnet. This cannot be the same as the device management IP.
            multicast_routing: Enable multicast support if, multicast routing between VLANs is
                required. Options are: 'disabled', 'enabled' or 'IGMP snooping querier'.
                Default is 'disabled'.
            vlan_id: The VLAN this L3 interface is on. VLAN must be between 1 and 4094.
            default_gateway: The next hop for any traffic that isn't going to a directly connected
                subnet or over a static route. This IP address must exist in a subnet
                with a L3 interface. Required if this is the first IPv4 interface.
            ospf_settings: The OSPF routing settings of the interface.
            ipv6: The IPv6 settings of the interface.
            vrf: The VRF settings of the interface. Requires IOS XE 17.18 or higher.
            loopback: The loopback settings of the interface.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "interfaceId": "1234",
              "name": "L3 interface",
              "mode": "vlan",
              "subnet": "192.168.1.0/24",
              "interfaceIp": "192.168.1.2",
              "serial": "Q234-ABCD-5678",
              "switchPortId": "1",
              "multicastRouting": "disabled",
              "vlanId": 100,
              "uplinkV4": false,
              "uplinkV6": false,
              "ospfSettings": {
                "area": "0",
                "cost": 1,
                "isPassiveEnabled": true,
                "networkType": "broadcast"
              },
              "ospfV3": {
                "area": "1",
                "cost": 2,
                "isPassiveEnabled": true,
                "networkType": "broadcast"
              },
              "ipv6": {
                "assignmentMode": "static",
                "address": "2001:db8::1",
                "prefix": "2001:db8::/32",
                "gateway": "2001:db8::2"
              },
              "vrf": {
                "name": "Blue"
              },
              "defaultGateway": "192.168.1.1"
            }
            ```

        """
        if mode is not None:
            options = ["loopback", "oob_management", "routed", "vlan"]
            assert mode in options, f'"mode" cannot be "{mode}", & must be set to one of: {options}'
        if multicast_routing is not None:
            options = ["IGMP snooping querier", "disabled", "enabled"]
            assert multicast_routing in options, (
                f'"multicast_routing" cannot be "{multicast_routing}", & must be set to one of: {options}'
            )

        serial = urllib.parse.quote(str(serial), safe="")
        path = f"/devices/{serial}/switch/routing/interfaces"

        payload = {}
        if name is not None:
            payload["name"] = name
        if mode is not None:
            payload["mode"] = mode
        if subnet is not None:
            payload["subnet"] = subnet
        if switch_port_id is not None:
            payload["switchPortId"] = switch_port_id
        if interface_ip is not None:
            payload["interfaceIp"] = interface_ip
        if multicast_routing is not None:
            payload["multicastRouting"] = multicast_routing
        if vlan_id is not None:
            payload["vlanId"] = vlan_id
        if default_gateway is not None:
            payload["defaultGateway"] = default_gateway
        if ospf_settings is not None:
            payload["ospfSettings"] = ospf_settings.model_dump(by_alias=True, exclude_none=True)
        if ipv6 is not None:
            payload["ipv6"] = ipv6.model_dump(by_alias=True, exclude_none=True)
        if vrf is not None:
            payload["vrf"] = vrf.model_dump(by_alias=True, exclude_none=True)
        if loopback is not None:
            payload["loopback"] = loopback

        return self._session.post(
            scope="switch",
            operation_id="createDeviceSwitchRoutingInterface",
            path=path,
            json=payload,
            response_schema=CreateDeviceSwitchRoutingInterfaceResponse,
        )

    def get_device_switch_routing_interface(
        self, *, serial: str, interface_id: str
    ) -> GetDeviceSwitchRoutingInterfaceResponse | None:
        """Return a layer 3 interface for a switch.

        [API documentation: getDeviceSwitchRoutingInterface](https://developer.cisco.com/meraki/api-v1/#!get-device-switch-routing-interface)

        Args:
            serial: Serial.
            interface_id: Interface ID.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "interfaceId": "1234",
              "name": "L3 interface",
              "mode": "vlan",
              "subnet": "192.168.1.0/24",
              "interfaceIp": "192.168.1.2",
              "serial": "Q234-ABCD-5678",
              "switchPortId": "1",
              "multicastRouting": "disabled",
              "vlanId": 100,
              "uplinkV4": false,
              "uplinkV6": false,
              "ospfSettings": {
                "area": "0",
                "cost": 1,
                "isPassiveEnabled": true,
                "networkType": "broadcast"
              },
              "ospfV3": {
                "area": "1",
                "cost": 2,
                "isPassiveEnabled": true,
                "networkType": "broadcast"
              },
              "ipv6": {
                "assignmentMode": "static",
                "address": "2001:db8::1",
                "prefix": "2001:db8::/32",
                "gateway": "2001:db8::2"
              },
              "vrf": {
                "name": "Blue"
              },
              "defaultGateway": "192.168.1.1"
            }
            ```

        """
        serial = urllib.parse.quote(str(serial), safe="")
        interface_id = urllib.parse.quote(str(interface_id), safe="")
        path = f"/devices/{serial}/switch/routing/interfaces/{interface_id}"

        return self._session.get(
            scope="switch",
            operation_id="getDeviceSwitchRoutingInterface",
            path=path,
            response_schema=GetDeviceSwitchRoutingInterfaceResponse,
        )

    def update_device_switch_routing_interface(
        self,
        *,
        serial: str,
        interface_id: str,
        name: str | None = None,
        subnet: str | None = None,
        switch_port_id: str | None = None,
        interface_ip: str | None = None,
        multicast_routing: str | None = None,
        vlan_id: int | None = None,
        default_gateway: str | None = None,
        ospf_settings: UpdateDeviceSwitchRoutingInterfaceOspfSettings | None = None,
        ipv6: UpdateDeviceSwitchRoutingInterfaceIpv6 | None = None,
        vrf: UpdateDeviceSwitchRoutingInterfaceVrf | None = None,
        loopback: dict[str, Any] | None = None,
    ) -> UpdateDeviceSwitchRoutingInterfaceResponse | None:
        """Update a layer 3 interface for a switch.

        [API documentation: updateDeviceSwitchRoutingInterface](https://developer.cisco.com/meraki/api-v1/#!update-device-switch-routing-interface)

        Args:
            serial: Serial.
            interface_id: Interface ID.
            name: A friendly name or description for the interface or VLAN (max length 128
                characters).
            subnet: The network that this L3 interface is on, in CIDR notation (ex. 10.1.1.0/24).
            switch_port_id: Switch Port ID when in Routed mode (CS 17.18 or higher required).
            interface_ip: The IP address that will be used for Layer 3 routing on this VLAN or
                subnet. This cannot be the same as the device management IP.
            multicast_routing: Enable multicast support if, multicast routing between VLANs is
                required. Options are: 'disabled', 'enabled' or 'IGMP snooping querier'.
                Default is 'disabled'.
            vlan_id: The VLAN this L3 interface is on. VLAN must be between 1 and 4094.
            default_gateway: The next hop for any traffic that isn't going to a directly connected
                subnet or over a static route. This IP address must exist in a subnet
                with a L3 interface. Required if this is the first IPv4 interface.
            ospf_settings: The OSPF routing settings of the interface.
            ipv6: The IPv6 settings of the interface.
            vrf: The VRF settings of the interface. Requires IOS XE 17.18 or higher.
            loopback: The loopback settings of the interface.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "interfaceId": "1234",
              "name": "L3 interface",
              "mode": "vlan",
              "subnet": "192.168.1.0/24",
              "interfaceIp": "192.168.1.2",
              "serial": "Q234-ABCD-5678",
              "switchPortId": "1",
              "multicastRouting": "disabled",
              "vlanId": 100,
              "uplinkV4": false,
              "uplinkV6": false,
              "ospfSettings": {
                "area": "0",
                "cost": 1,
                "isPassiveEnabled": true,
                "networkType": "broadcast"
              },
              "ospfV3": {
                "area": "1",
                "cost": 2,
                "isPassiveEnabled": true,
                "networkType": "broadcast"
              },
              "ipv6": {
                "assignmentMode": "static",
                "address": "2001:db8::1",
                "prefix": "2001:db8::/32",
                "gateway": "2001:db8::2"
              },
              "vrf": {
                "name": "Blue"
              },
              "defaultGateway": "192.168.1.1"
            }
            ```

        """
        if multicast_routing is not None:
            options = ["IGMP snooping querier", "disabled", "enabled"]
            assert multicast_routing in options, (
                f'"multicast_routing" cannot be "{multicast_routing}", & must be set to one of: {options}'
            )

        serial = urllib.parse.quote(str(serial), safe="")
        interface_id = urllib.parse.quote(str(interface_id), safe="")
        path = f"/devices/{serial}/switch/routing/interfaces/{interface_id}"

        payload = {}
        if name is not None:
            payload["name"] = name
        if subnet is not None:
            payload["subnet"] = subnet
        if switch_port_id is not None:
            payload["switchPortId"] = switch_port_id
        if interface_ip is not None:
            payload["interfaceIp"] = interface_ip
        if multicast_routing is not None:
            payload["multicastRouting"] = multicast_routing
        if vlan_id is not None:
            payload["vlanId"] = vlan_id
        if default_gateway is not None:
            payload["defaultGateway"] = default_gateway
        if ospf_settings is not None:
            payload["ospfSettings"] = ospf_settings.model_dump(by_alias=True, exclude_none=True)
        if ipv6 is not None:
            payload["ipv6"] = ipv6.model_dump(by_alias=True, exclude_none=True)
        if vrf is not None:
            payload["vrf"] = vrf.model_dump(by_alias=True, exclude_none=True)
        if loopback is not None:
            payload["loopback"] = loopback

        return self._session.put(
            scope="switch",
            operation_id="updateDeviceSwitchRoutingInterface",
            path=path,
            json=payload,
            response_schema=UpdateDeviceSwitchRoutingInterfaceResponse,
        )

    def delete_device_switch_routing_interface(self, *, serial: str, interface_id: str) -> None:
        """Delete a layer 3 interface from the switch.

        [API documentation: deleteDeviceSwitchRoutingInterface](https://developer.cisco.com/meraki/api-v1/#!delete-device-switch-routing-interface)

        Args:
            serial: Serial.
            interface_id: Interface ID.

        Returns:
            Successful operation.

        """
        serial = urllib.parse.quote(str(serial), safe="")
        interface_id = urllib.parse.quote(str(interface_id), safe="")
        path = f"/devices/{serial}/switch/routing/interfaces/{interface_id}"

        return self._session.delete(
            scope="switch", operation_id="deleteDeviceSwitchRoutingInterface", path=path
        )

    def get_device_switch_routing_interface_dhcp(
        self, *, serial: str, interface_id: str
    ) -> GetDeviceSwitchRoutingInterfaceDhcpResponse | None:
        """Return a layer 3 interface DHCP configuration for a switch.

        [API documentation: getDeviceSwitchRoutingInterfaceDhcp](https://developer.cisco.com/meraki/api-v1/#!get-device-switch-routing-interface-dhcp)

        Args:
            serial: Serial.
            interface_id: Interface ID.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "dhcpMode": "dhcpServer",
              "dhcpRelayServerIps": [
                "1.2.3.4"
              ],
              "dhcpLeaseTime": "1 day",
              "dnsNameserversOption": "custom",
              "dnsCustomNameservers": [
                "8.8.8.8, 8.8.4.4"
              ],
              "bootOptionsEnabled": true,
              "bootNextServer": "1.2.3.4",
              "bootFileName": "home_boot_file",
              "dhcpOptions": [
                {
                  "code": "5",
                  "type": "text",
                  "value": "five"
                }
              ],
              "reservedIpRanges": [
                {
                  "start": "192.168.1.1",
                  "end": "192.168.1.10",
                  "comment": "A reserved IP range"
                }
              ],
              "fixedIpAssignments": [
                {
                  "name": "Cisco Meraki valued client",
                  "mac": "22:33:44:55:66:77",
                  "ip": "192.168.1.12"
                }
              ]
            }
            ```

        """
        serial = urllib.parse.quote(str(serial), safe="")
        interface_id = urllib.parse.quote(str(interface_id), safe="")
        path = f"/devices/{serial}/switch/routing/interfaces/{interface_id}/dhcp"

        return self._session.get(
            scope="switch",
            operation_id="getDeviceSwitchRoutingInterfaceDhcp",
            path=path,
            response_schema=GetDeviceSwitchRoutingInterfaceDhcpResponse,
        )

    def update_device_switch_routing_interface_dhcp(
        self,
        *,
        serial: str,
        interface_id: str,
        dhcp_mode: str | None = None,
        dhcp_relay_server_ips: list[str] | None = None,
        dhcp_lease_time: str | None = None,
        dns_nameservers_option: str | None = None,
        dns_custom_nameservers: list[str] | None = None,
        boot_options_enabled: bool | None = None,
        boot_next_server: str | None = None,
        boot_file_name: str | None = None,
        dhcp_options: list[UpdateDeviceSwitchRoutingInterfaceDhcpDhcpOptionsItem] | None = None,
        reserved_ip_ranges: list[UpdateDeviceSwitchRoutingInterfaceDhcpReservedIpRangesItem]
        | None = None,
        fixed_ip_assignments: list[UpdateDeviceSwitchRoutingInterfaceDhcpFixedIpAssignmentsItem]
        | None = None,
    ) -> UpdateDeviceSwitchRoutingInterfaceDhcpResponse | None:
        """Update a layer 3 interface DHCP configuration for a switch.

        [API documentation: updateDeviceSwitchRoutingInterfaceDhcp](https://developer.cisco.com/meraki/api-v1/#!update-device-switch-routing-interface-dhcp)

        Args:
            serial: Serial.
            interface_id: Interface ID.
            dhcp_mode: The DHCP mode options for the switch interface ('dhcpDisabled', 'dhcpRelay'
                or 'dhcpServer').
            dhcp_relay_server_ips: The DHCP relay server IPs to which DHCP packets would get relayed
                for the switch interface.
            dhcp_lease_time: The DHCP lease time config for the dhcp server running on switch
                interface ('30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1
                week').
            dns_nameservers_option: The DHCP name server option for the dhcp server running on the
                switch interface ('googlePublicDns', 'openDns' or 'custom').
            dns_custom_nameservers: The DHCP name server IPs when DHCP name server option is
                'custom'.
            boot_options_enabled: Enable DHCP boot options to provide PXE boot options configs for
                the dhcp server running on the switch interface.
            boot_next_server: The PXE boot server IP for the DHCP server running on the switch
                interface.
            boot_file_name: The PXE boot server filename for the DHCP server running on the switch
                interface.
            dhcp_options: Array of DHCP options consisting of code, type and value for the DHCP
                server running on the switch interface.
            reserved_ip_ranges: Array of DHCP reserved IP assignments for the DHCP server running on
                the switch interface.
            fixed_ip_assignments: Array of DHCP fixed IP assignments for the DHCP server running on
                the switch interface.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "dhcpMode": "dhcpServer",
              "dhcpRelayServerIps": [
                "1.2.3.4"
              ],
              "dhcpLeaseTime": "1 day",
              "dnsNameserversOption": "custom",
              "dnsCustomNameservers": [
                "8.8.8.8, 8.8.4.4"
              ],
              "bootOptionsEnabled": true,
              "bootNextServer": "1.2.3.4",
              "bootFileName": "home_boot_file",
              "dhcpOptions": [
                {
                  "code": "5",
                  "type": "text",
                  "value": "five"
                }
              ],
              "reservedIpRanges": [
                {
                  "start": "192.168.1.1",
                  "end": "192.168.1.10",
                  "comment": "A reserved IP range"
                }
              ],
              "fixedIpAssignments": [
                {
                  "name": "Cisco Meraki valued client",
                  "mac": "22:33:44:55:66:77",
                  "ip": "192.168.1.12"
                }
              ]
            }
            ```

        """
        if dhcp_mode is not None:
            options = ["dhcpDisabled", "dhcpRelay", "dhcpServer"]
            assert dhcp_mode in options, (
                f'"dhcp_mode" cannot be "{dhcp_mode}", & must be set to one of: {options}'
            )
        if dhcp_lease_time is not None:
            options = ["1 day", "1 hour", "1 week", "12 hours", "30 minutes", "4 hours"]
            assert dhcp_lease_time in options, (
                f'"dhcp_lease_time" cannot be "{dhcp_lease_time}", & must be set to one of: {options}'
            )
        if dns_nameservers_option is not None:
            options = ["custom", "googlePublicDns", "openDns"]
            assert dns_nameservers_option in options, (
                f'"dns_nameservers_option" cannot be "{dns_nameservers_option}", & must be set to one of: {options}'
            )

        serial = urllib.parse.quote(str(serial), safe="")
        interface_id = urllib.parse.quote(str(interface_id), safe="")
        path = f"/devices/{serial}/switch/routing/interfaces/{interface_id}/dhcp"

        payload = {}
        if dhcp_mode is not None:
            payload["dhcpMode"] = dhcp_mode
        if dhcp_relay_server_ips is not None:
            payload["dhcpRelayServerIps"] = dhcp_relay_server_ips
        if dhcp_lease_time is not None:
            payload["dhcpLeaseTime"] = dhcp_lease_time
        if dns_nameservers_option is not None:
            payload["dnsNameserversOption"] = dns_nameservers_option
        if dns_custom_nameservers is not None:
            payload["dnsCustomNameservers"] = dns_custom_nameservers
        if boot_options_enabled is not None:
            payload["bootOptionsEnabled"] = boot_options_enabled
        if boot_next_server is not None:
            payload["bootNextServer"] = boot_next_server
        if boot_file_name is not None:
            payload["bootFileName"] = boot_file_name
        if dhcp_options is not None:
            payload["dhcpOptions"] = [
                item.model_dump(by_alias=True, exclude_none=True) for item in dhcp_options
            ]
        if reserved_ip_ranges is not None:
            payload["reservedIpRanges"] = [
                item.model_dump(by_alias=True, exclude_none=True) for item in reserved_ip_ranges
            ]
        if fixed_ip_assignments is not None:
            payload["fixedIpAssignments"] = [
                item.model_dump(by_alias=True, exclude_none=True) for item in fixed_ip_assignments
            ]

        return self._session.put(
            scope="switch",
            operation_id="updateDeviceSwitchRoutingInterfaceDhcp",
            path=path,
            json=payload,
            response_schema=UpdateDeviceSwitchRoutingInterfaceDhcpResponse,
        )

    def get_device_switch_routing_static_routes(
        self, serial: str
    ) -> PaginatedResponse[GetDeviceSwitchRoutingStaticRoutesResponseItem]:
        """List layer 3 static routes for a switch.

        [API documentation: getDeviceSwitchRoutingStaticRoutes](https://developer.cisco.com/meraki/api-v1/#!get-device-switch-routing-static-routes)

        Args:
            serial: Serial.

        Returns:
            Successful operation.

        Example API response:
            ```json
            [
              {
                "staticRouteId": "1234",
                "name": "My route",
                "subnet": "192.168.1.0/24",
                "nextHopIp": "1.2.3.4",
                "managementNextHop": "1.2.3.5",
                "vrf": {
                  "name": "Blue",
                  "leakRouteToDefaultVrf": false
                },
                "advertiseViaOspfEnabled": false,
                "preferOverOspfRoutesEnabled": false
              }
            ]
            ```

        """
        serial = urllib.parse.quote(str(serial), safe="")
        path = f"/devices/{serial}/switch/routing/staticRoutes"

        return self._session.get_pages(
            scope="switch",
            operation_id="getDeviceSwitchRoutingStaticRoutes",
            path=path,
            item_schema=GetDeviceSwitchRoutingStaticRoutesResponseItem,
        )

    def create_device_switch_routing_static_route(
        self,
        *,
        serial: str,
        subnet: str,
        next_hop_ip: str,
        name: str | None = None,
        advertise_via_ospf_enabled: bool | None = None,
        prefer_over_ospf_routes_enabled: bool | None = None,
        vrf: CreateDeviceSwitchRoutingStaticRouteVrf | None = None,
    ) -> CreateDeviceSwitchRoutingStaticRouteResponse | None:
        """Create a layer 3 static route for a switch.

        [API documentation: createDeviceSwitchRoutingStaticRoute](https://developer.cisco.com/meraki/api-v1/#!create-device-switch-routing-static-route)

        Args:
            serial: Serial.
            name: Name or description for layer 3 static route.
            subnet: The subnet which is routed via this static route and should be specified in CIDR
                notation (ex. 1.2.3.0/24).
            next_hop_ip: IP address of the next hop device to which the device sends its traffic for
                the subnet.
            advertise_via_ospf_enabled: Option to advertise static route via OSPF.
            prefer_over_ospf_routes_enabled: Option to prefer static route over OSPF routes.
            vrf: The VRF settings of the interface. Requires IOS XE 17.18 or higher.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "staticRouteId": "1234",
              "name": "My route",
              "subnet": "192.168.1.0/24",
              "nextHopIp": "1.2.3.4",
              "managementNextHop": "1.2.3.5",
              "vrf": {
                "name": "Blue",
                "leakRouteToDefaultVrf": false
              },
              "advertiseViaOspfEnabled": false,
              "preferOverOspfRoutesEnabled": false
            }
            ```

        """
        serial = urllib.parse.quote(str(serial), safe="")
        path = f"/devices/{serial}/switch/routing/staticRoutes"

        payload = {}
        if name is not None:
            payload["name"] = name
        if subnet is not None:
            payload["subnet"] = subnet
        if next_hop_ip is not None:
            payload["nextHopIp"] = next_hop_ip
        if advertise_via_ospf_enabled is not None:
            payload["advertiseViaOspfEnabled"] = advertise_via_ospf_enabled
        if prefer_over_ospf_routes_enabled is not None:
            payload["preferOverOspfRoutesEnabled"] = prefer_over_ospf_routes_enabled
        if vrf is not None:
            payload["vrf"] = vrf.model_dump(by_alias=True, exclude_none=True)

        return self._session.post(
            scope="switch",
            operation_id="createDeviceSwitchRoutingStaticRoute",
            path=path,
            json=payload,
            response_schema=CreateDeviceSwitchRoutingStaticRouteResponse,
        )

    def get_device_switch_routing_static_route(
        self, *, serial: str, static_route_id: str
    ) -> GetDeviceSwitchRoutingStaticRouteResponse | None:
        """Return a layer 3 static route for a switch.

        [API documentation: getDeviceSwitchRoutingStaticRoute](https://developer.cisco.com/meraki/api-v1/#!get-device-switch-routing-static-route)

        Args:
            serial: Serial.
            static_route_id: Static route ID.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "staticRouteId": "1234",
              "name": "My route",
              "subnet": "192.168.1.0/24",
              "nextHopIp": "1.2.3.4",
              "managementNextHop": "1.2.3.5",
              "vrf": {
                "name": "Blue",
                "leakRouteToDefaultVrf": false
              },
              "advertiseViaOspfEnabled": false,
              "preferOverOspfRoutesEnabled": false
            }
            ```

        """
        serial = urllib.parse.quote(str(serial), safe="")
        static_route_id = urllib.parse.quote(str(static_route_id), safe="")
        path = f"/devices/{serial}/switch/routing/staticRoutes/{static_route_id}"

        return self._session.get(
            scope="switch",
            operation_id="getDeviceSwitchRoutingStaticRoute",
            path=path,
            response_schema=GetDeviceSwitchRoutingStaticRouteResponse,
        )

    def update_device_switch_routing_static_route(
        self,
        *,
        serial: str,
        static_route_id: str,
        name: str | None = None,
        subnet: str | None = None,
        next_hop_ip: str | None = None,
        management_next_hop: str | None = None,
        advertise_via_ospf_enabled: bool | None = None,
        prefer_over_ospf_routes_enabled: bool | None = None,
        vrf: UpdateDeviceSwitchRoutingStaticRouteVrf | None = None,
    ) -> UpdateDeviceSwitchRoutingStaticRouteResponse | None:
        """Update a layer 3 static route for a switch.

        [API documentation: updateDeviceSwitchRoutingStaticRoute](https://developer.cisco.com/meraki/api-v1/#!update-device-switch-routing-static-route)

        Args:
            serial: Serial.
            static_route_id: Static route ID.
            name: Name or description for layer 3 static route.
            subnet: The subnet which is routed via this static route and should be specified in CIDR
                notation (ex. 1.2.3.0/24).
            next_hop_ip: IP address of the next hop device to which the device sends its traffic for
                the subnet.
            management_next_hop: Optional fallback IP address for management traffic.
            advertise_via_ospf_enabled: Option to advertise static route via OSPF.
            prefer_over_ospf_routes_enabled: Option to prefer static route over OSPF routes.
            vrf: The VRF settings of the interface. Requires IOS XE 17.18 or higher.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "staticRouteId": "1234",
              "name": "My route",
              "subnet": "192.168.1.0/24",
              "nextHopIp": "1.2.3.4",
              "managementNextHop": "1.2.3.5",
              "vrf": {
                "name": "Blue",
                "leakRouteToDefaultVrf": false
              },
              "advertiseViaOspfEnabled": false,
              "preferOverOspfRoutesEnabled": false
            }
            ```

        """
        serial = urllib.parse.quote(str(serial), safe="")
        static_route_id = urllib.parse.quote(str(static_route_id), safe="")
        path = f"/devices/{serial}/switch/routing/staticRoutes/{static_route_id}"

        payload = {}
        if name is not None:
            payload["name"] = name
        if subnet is not None:
            payload["subnet"] = subnet
        if next_hop_ip is not None:
            payload["nextHopIp"] = next_hop_ip
        if management_next_hop is not None:
            payload["managementNextHop"] = management_next_hop
        if advertise_via_ospf_enabled is not None:
            payload["advertiseViaOspfEnabled"] = advertise_via_ospf_enabled
        if prefer_over_ospf_routes_enabled is not None:
            payload["preferOverOspfRoutesEnabled"] = prefer_over_ospf_routes_enabled
        if vrf is not None:
            payload["vrf"] = vrf.model_dump(by_alias=True, exclude_none=True)

        return self._session.put(
            scope="switch",
            operation_id="updateDeviceSwitchRoutingStaticRoute",
            path=path,
            json=payload,
            response_schema=UpdateDeviceSwitchRoutingStaticRouteResponse,
        )

    def delete_device_switch_routing_static_route(
        self, *, serial: str, static_route_id: str
    ) -> None:
        """Delete a layer 3 static route for a switch.

        [API documentation: deleteDeviceSwitchRoutingStaticRoute](https://developer.cisco.com/meraki/api-v1/#!delete-device-switch-routing-static-route)

        Args:
            serial: Serial.
            static_route_id: Static route ID.

        Returns:
            Successful operation.

        """
        serial = urllib.parse.quote(str(serial), safe="")
        static_route_id = urllib.parse.quote(str(static_route_id), safe="")
        path = f"/devices/{serial}/switch/routing/staticRoutes/{static_route_id}"

        return self._session.delete(
            scope="switch", operation_id="deleteDeviceSwitchRoutingStaticRoute", path=path
        )

    def get_device_switch_warm_spare(self, serial: str) -> GetDeviceSwitchWarmSpareResponse | None:
        """Return warm spare configuration for a switch.

        [API documentation: getDeviceSwitchWarmSpare](https://developer.cisco.com/meraki/api-v1/#!get-device-switch-warm-spare)

        Args:
            serial: Serial.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "enabled": true,
              "primarySerial": "Q234-ABCD-0001",
              "spareSerial": "Q234-ABCD-0002"
            }
            ```

        """
        serial = urllib.parse.quote(str(serial), safe="")
        path = f"/devices/{serial}/switch/warmSpare"

        return self._session.get(
            scope="switch",
            operation_id="getDeviceSwitchWarmSpare",
            path=path,
            response_schema=GetDeviceSwitchWarmSpareResponse,
        )

    def update_device_switch_warm_spare(
        self, *, serial: str, enabled: bool, spare_serial: str | None = None
    ) -> UpdateDeviceSwitchWarmSpareResponse | None:
        """Update warm spare configuration for a switch.

        [API documentation: updateDeviceSwitchWarmSpare](https://developer.cisco.com/meraki/api-v1/#!update-device-switch-warm-spare)

        Args:
            serial: Serial.
            enabled: Enable or disable warm spare for a switch.
            spare_serial: Serial number of the warm spare switch.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "enabled": true,
              "primarySerial": "Q234-ABCD-0001",
              "spareSerial": "Q234-ABCD-0002"
            }
            ```

        """
        serial = urllib.parse.quote(str(serial), safe="")
        path = f"/devices/{serial}/switch/warmSpare"

        payload = {}
        if enabled is not None:
            payload["enabled"] = enabled
        if spare_serial is not None:
            payload["spareSerial"] = spare_serial

        return self._session.put(
            scope="switch",
            operation_id="updateDeviceSwitchWarmSpare",
            path=path,
            json=payload,
            response_schema=UpdateDeviceSwitchWarmSpareResponse,
        )

    def get_network_switch_access_control_lists(
        self, network_id: str
    ) -> GetNetworkSwitchAccessControlListsResponse | None:
        """Return the access control lists for a MS network.

        [API documentation: getNetworkSwitchAccessControlLists](https://developer.cisco.com/meraki/api-v1/#!get-network-switch-access-control-lists)

        Args:
            network_id: Network ID.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "rules": [
                {
                  "comment": "Deny SSH",
                  "policy": "deny",
                  "ipVersion": "ipv4",
                  "protocol": "tcp",
                  "srcCidr": "10.1.10.0/24",
                  "srcPort": "any",
                  "dstCidr": "172.16.30/24",
                  "dstPort": "22",
                  "vlan": "10"
                }
              ]
            }
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/switch/accessControlLists"

        return self._session.get(
            scope="switch",
            operation_id="getNetworkSwitchAccessControlLists",
            path=path,
            response_schema=GetNetworkSwitchAccessControlListsResponse,
        )

    def update_network_switch_access_control_lists(
        self, *, network_id: str, rules: list[UpdateNetworkSwitchAccessControlListsRulesItem]
    ) -> UpdateNetworkSwitchAccessControlListsResponse | None:
        """Update the access control lists for a MS network.

        [API documentation: updateNetworkSwitchAccessControlLists](https://developer.cisco.com/meraki/api-v1/#!update-network-switch-access-control-lists)

        Args:
            network_id: Network ID.
            rules: An ordered array of the access control list rules (not including the default
                rule). An empty array will clear the rules.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "rules": [
                {
                  "comment": "Deny SSH",
                  "policy": "deny",
                  "ipVersion": "ipv4",
                  "protocol": "tcp",
                  "srcCidr": "10.1.10.0/24",
                  "srcPort": "any",
                  "dstCidr": "172.16.30/24",
                  "dstPort": "22",
                  "vlan": "10"
                }
              ]
            }
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/switch/accessControlLists"

        payload = {}
        if rules is not None:
            payload["rules"] = [item.model_dump(by_alias=True, exclude_none=True) for item in rules]

        return self._session.put(
            scope="switch",
            operation_id="updateNetworkSwitchAccessControlLists",
            path=path,
            json=payload,
            response_schema=UpdateNetworkSwitchAccessControlListsResponse,
        )

    def get_network_switch_access_policies(
        self, network_id: str
    ) -> PaginatedResponse[GetNetworkSwitchAccessPoliciesResponseItem]:
        """List the access policies for a switch network.

        [API documentation: getNetworkSwitchAccessPolicies](https://developer.cisco.com/meraki/api-v1/#!get-network-switch-access-policies)

        Args:
            network_id: Network ID.

        Returns:
            Successful operation.

        Example API response:
            ```json
            [
              {
                "accessPolicyNumber": "1234",
                "name": "Access policy #1",
                "radiusServers": [
                  {
                    "serverId": "1",
                    "organizationRadiusServerId": "42",
                    "host": "1.2.3.4",
                    "port": 22
                  }
                ],
                "radius": {
                  "criticalAuth": {
                    "dataVlanId": 100,
                    "voiceVlanId": 100,
                    "suspendPortBounce": true,
                    "dataGroupPolicyId": "1234",
                    "voiceGroupPolicyId": "1234",
                    "dataSgtId": 1234,
                    "voiceSgtId": 1234
                  },
                  "failedAuthVlanId": 100,
                  "failedAuthGroupPolicyId": "1234",
                  "failedAuthSgtId": 1284392014819,
                  "reAuthenticationInterval": 120,
                  "cache": {
                    "enabled": false,
                    "timeout": 24
                  },
                  "authentication": {
                    "mode": "Open"
                  },
                  "preAuthenticationGroupPolicyId": "1234"
                },
                "enforceRadiusMonitoring": false,
                "guestPortBouncing": false,
                "radiusTestingEnabled": false,
                "radiusCoaSupportEnabled": false,
                "radiusAccountingEnabled": true,
                "radiusAccountingServers": [
                  {
                    "serverId": "2",
                    "organizationRadiusServerId": "42",
                    "host": "1.2.3.4",
                    "port": 22
                  }
                ],
                "radiusGroupAttribute": "11",
                "hostMode": "Single-Host",
                "accessPolicyType": "Hybrid authentication",
                "increaseAccessSpeed": false,
                "guestVlanId": 100,
                "dot1x": {
                  "controlDirection": "inbound"
                },
                "voiceVlanClients": true,
                "urlRedirectWalledGardenEnabled": true,
                "urlRedirectWalledGardenRanges": [
                  "192.168.1.0/24"
                ],
                "counts": {
                  "ports": {
                    "withThisPolicy": 12
                  }
                },
                "guestGroupPolicyId": "1234",
                "guestSgtId": 1284392014819
              }
            ]
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/switch/accessPolicies"

        return self._session.get_pages(
            scope="switch",
            operation_id="getNetworkSwitchAccessPolicies",
            path=path,
            item_schema=GetNetworkSwitchAccessPoliciesResponseItem,
        )

    def create_network_switch_access_policy(
        self,
        *,
        network_id: str,
        name: str,
        radius_servers: list[CreateNetworkSwitchAccessPolicyRadiusServersItem],
        radius_accounting_enabled: bool,
        radius: CreateNetworkSwitchAccessPolicyRadius | None = None,
        guest_port_bouncing: bool | None = None,
        radius_testing_enabled: bool | None = None,
        radius_coa_support_enabled: bool | None = None,
        radius_accounting_servers: list[CreateNetworkSwitchAccessPolicyRadiusAccountingServersItem]
        | None = None,
        radius_group_attribute: str | None = None,
        host_mode: str | None = None,
        access_policy_type: str | None = None,
        increase_access_speed: bool | None = None,
        guest_vlan_id: int | None = None,
        dot1x: CreateNetworkSwitchAccessPolicyDot1x | None = None,
        voice_vlan_clients: bool | None = None,
        url_redirect_walled_garden_enabled: bool | None = None,
        url_redirect_walled_garden_ranges: list[str] | None = None,
        guest_group_policy_id: str | None = None,
        guest_sgt_id: int | None = None,
    ) -> CreateNetworkSwitchAccessPolicyResponse | None:
        """Create an access policy for a switch network.

        [API documentation: createNetworkSwitchAccessPolicy](https://developer.cisco.com/meraki/api-v1/#!create-network-switch-access-policy)

        Args:
            network_id: Network ID.
            name: Name of the access policy(max length 255).
            radius_servers: List of RADIUS servers to require connecting devices to authenticate
                against before granting network access.
            radius: Object for RADIUS Settings.
            guest_port_bouncing: If enabled, Meraki devices will periodically send access-request
                messages to these RADIUS servers.
            radius_testing_enabled: If enabled, Meraki devices will periodically send access-request
                messages to these RADIUS servers.
            radius_coa_support_enabled: Change of authentication for RADIUS re-authentication and
                disconnection.
            radius_accounting_enabled: Enable to send start, interim-update and stop messages to a
                configured RADIUS accounting server for tracking connected clients.
            radius_accounting_servers: List of RADIUS accounting servers to require connecting
                devices to authenticate against before granting network access.
            radius_group_attribute: Acceptable values are `""` for None, or `"11"` for Group
                Policies ACL.
            host_mode: Choose the Host Mode for the access policy.
            access_policy_type: Access Type of the policy. Automatically 'Hybrid authentication'
                when hostMode is 'Multi-Domain'.
            increase_access_speed: Enabling this option will make switches execute 802.1X and MAC-
                bypass authentication simultaneously so that clients authenticate
                faster. Only required when accessPolicyType is 'Hybrid Authentication.
            guest_vlan_id: ID for the guest VLAN allow unauthorized devices access to limited
                network resources.
            dot1x: 802.1x Settings.
            voice_vlan_clients: CDP/LLDP capable voice clients will be able to use this VLAN.
                Automatically true when hostMode is 'Multi-Domain'.
            url_redirect_walled_garden_enabled: Enable to restrict access for clients to a specific
                set of IP addresses or hostnames prior to authentication.
            url_redirect_walled_garden_ranges: IP address ranges, in CIDR notation, to restrict
                access for clients to a specific set of IP addresses or hostnames prior
                to authentication.
            guest_group_policy_id: Group policy Number for guest group policy.
            guest_sgt_id: Security Group Tag ID for guest group policy.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "accessPolicyNumber": "1234",
              "name": "Access policy #1",
              "radiusServers": [
                {
                  "serverId": "1",
                  "organizationRadiusServerId": "42",
                  "host": "1.2.3.4",
                  "port": 22
                }
              ],
              "radius": {
                "criticalAuth": {
                  "dataVlanId": 100,
                  "voiceVlanId": 100,
                  "suspendPortBounce": true,
                  "dataGroupPolicyId": "1234",
                  "voiceGroupPolicyId": "1234",
                  "dataSgtId": 1234,
                  "voiceSgtId": 1234
                },
                "failedAuthVlanId": 100,
                "failedAuthGroupPolicyId": "1234",
                "failedAuthSgtId": 1284392014819,
                "reAuthenticationInterval": 120,
                "cache": {
                  "enabled": false,
                  "timeout": 24
                },
                "authentication": {
                  "mode": "Open"
                },
                "preAuthenticationGroupPolicyId": "1234"
              },
              "enforceRadiusMonitoring": false,
              "guestPortBouncing": false,
              "radiusTestingEnabled": false,
              "radiusCoaSupportEnabled": false,
              "radiusAccountingEnabled": true,
              "radiusAccountingServers": [
                {
                  "serverId": "2",
                  "organizationRadiusServerId": "42",
                  "host": "1.2.3.4",
                  "port": 22
                }
              ],
              "radiusGroupAttribute": "11",
              "hostMode": "Single-Host",
              "accessPolicyType": "Hybrid authentication",
              "increaseAccessSpeed": false,
              "guestVlanId": 100,
              "dot1x": {
                "controlDirection": "inbound"
              },
              "voiceVlanClients": true,
              "urlRedirectWalledGardenEnabled": true,
              "urlRedirectWalledGardenRanges": [
                "192.168.1.0/24"
              ],
              "counts": {
                "ports": {
                  "withThisPolicy": 12
                }
              },
              "guestGroupPolicyId": "1234",
              "guestSgtId": 1284392014819
            }
            ```

        """
        if host_mode is not None:
            options = ["Multi-Auth", "Multi-Domain", "Multi-Host", "Single-Host"]
            assert host_mode in options, (
                f'"host_mode" cannot be "{host_mode}", & must be set to one of: {options}'
            )
        if access_policy_type is not None:
            options = ["802.1x", "Hybrid authentication", "MAC authentication bypass"]
            assert access_policy_type in options, (
                f'"access_policy_type" cannot be "{access_policy_type}", & must be set to one of: {options}'
            )

        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/switch/accessPolicies"

        payload = {}
        if name is not None:
            payload["name"] = name
        if radius_servers is not None:
            payload["radiusServers"] = [
                item.model_dump(by_alias=True, exclude_none=True) for item in radius_servers
            ]
        if radius is not None:
            payload["radius"] = radius.model_dump(by_alias=True, exclude_none=True)
        if guest_port_bouncing is not None:
            payload["guestPortBouncing"] = guest_port_bouncing
        if radius_testing_enabled is not None:
            payload["radiusTestingEnabled"] = radius_testing_enabled
        if radius_coa_support_enabled is not None:
            payload["radiusCoaSupportEnabled"] = radius_coa_support_enabled
        if radius_accounting_enabled is not None:
            payload["radiusAccountingEnabled"] = radius_accounting_enabled
        if radius_accounting_servers is not None:
            payload["radiusAccountingServers"] = [
                item.model_dump(by_alias=True, exclude_none=True)
                for item in radius_accounting_servers
            ]
        if radius_group_attribute is not None:
            payload["radiusGroupAttribute"] = radius_group_attribute
        if host_mode is not None:
            payload["hostMode"] = host_mode
        if access_policy_type is not None:
            payload["accessPolicyType"] = access_policy_type
        if increase_access_speed is not None:
            payload["increaseAccessSpeed"] = increase_access_speed
        if guest_vlan_id is not None:
            payload["guestVlanId"] = guest_vlan_id
        if dot1x is not None:
            payload["dot1x"] = dot1x.model_dump(by_alias=True, exclude_none=True)
        if voice_vlan_clients is not None:
            payload["voiceVlanClients"] = voice_vlan_clients
        if url_redirect_walled_garden_enabled is not None:
            payload["urlRedirectWalledGardenEnabled"] = url_redirect_walled_garden_enabled
        if url_redirect_walled_garden_ranges is not None:
            payload["urlRedirectWalledGardenRanges"] = url_redirect_walled_garden_ranges
        if guest_group_policy_id is not None:
            payload["guestGroupPolicyId"] = guest_group_policy_id
        if guest_sgt_id is not None:
            payload["guestSgtId"] = guest_sgt_id

        return self._session.post(
            scope="switch",
            operation_id="createNetworkSwitchAccessPolicy",
            path=path,
            json=payload,
            response_schema=CreateNetworkSwitchAccessPolicyResponse,
        )

    def get_network_switch_access_policy(
        self, *, network_id: str, access_policy_number: str
    ) -> GetNetworkSwitchAccessPolicyResponse | None:
        """Return a specific access policy for a switch network.

        [API documentation: getNetworkSwitchAccessPolicy](https://developer.cisco.com/meraki/api-v1/#!get-network-switch-access-policy)

        Args:
            network_id: Network ID.
            access_policy_number: Access policy number.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "accessPolicyNumber": "1234",
              "name": "Access policy #1",
              "radiusServers": [
                {
                  "serverId": "1",
                  "organizationRadiusServerId": "42",
                  "host": "1.2.3.4",
                  "port": 22
                }
              ],
              "radius": {
                "criticalAuth": {
                  "dataVlanId": 100,
                  "voiceVlanId": 100,
                  "suspendPortBounce": true,
                  "dataGroupPolicyId": "1234",
                  "voiceGroupPolicyId": "1234",
                  "dataSgtId": 1234,
                  "voiceSgtId": 1234
                },
                "failedAuthVlanId": 100,
                "failedAuthGroupPolicyId": "1234",
                "failedAuthSgtId": 1284392014819,
                "reAuthenticationInterval": 120,
                "cache": {
                  "enabled": false,
                  "timeout": 24
                },
                "authentication": {
                  "mode": "Open"
                },
                "preAuthenticationGroupPolicyId": "1234"
              },
              "enforceRadiusMonitoring": false,
              "guestPortBouncing": false,
              "radiusTestingEnabled": false,
              "radiusCoaSupportEnabled": false,
              "radiusAccountingEnabled": true,
              "radiusAccountingServers": [
                {
                  "serverId": "2",
                  "organizationRadiusServerId": "42",
                  "host": "1.2.3.4",
                  "port": 22
                }
              ],
              "radiusGroupAttribute": "11",
              "hostMode": "Single-Host",
              "accessPolicyType": "Hybrid authentication",
              "increaseAccessSpeed": false,
              "guestVlanId": 100,
              "dot1x": {
                "controlDirection": "inbound"
              },
              "voiceVlanClients": true,
              "urlRedirectWalledGardenEnabled": true,
              "urlRedirectWalledGardenRanges": [
                "192.168.1.0/24"
              ],
              "counts": {
                "ports": {
                  "withThisPolicy": 12
                }
              },
              "guestGroupPolicyId": "1234",
              "guestSgtId": 1284392014819
            }
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        access_policy_number = urllib.parse.quote(str(access_policy_number), safe="")
        path = f"/networks/{network_id}/switch/accessPolicies/{access_policy_number}"

        return self._session.get(
            scope="switch",
            operation_id="getNetworkSwitchAccessPolicy",
            path=path,
            response_schema=GetNetworkSwitchAccessPolicyResponse,
        )

    def update_network_switch_access_policy(
        self,
        *,
        network_id: str,
        access_policy_number: str,
        name: str | None = None,
        radius_servers: list[UpdateNetworkSwitchAccessPolicyRadiusServersItem] | None = None,
        radius: UpdateNetworkSwitchAccessPolicyRadius | None = None,
        guest_port_bouncing: bool | None = None,
        radius_testing_enabled: bool | None = None,
        radius_coa_support_enabled: bool | None = None,
        radius_accounting_enabled: bool | None = None,
        radius_accounting_servers: list[UpdateNetworkSwitchAccessPolicyRadiusAccountingServersItem]
        | None = None,
        radius_group_attribute: str | None = None,
        host_mode: str | None = None,
        access_policy_type: str | None = None,
        increase_access_speed: bool | None = None,
        guest_vlan_id: int | None = None,
        dot1x: UpdateNetworkSwitchAccessPolicyDot1x | None = None,
        voice_vlan_clients: bool | None = None,
        url_redirect_walled_garden_enabled: bool | None = None,
        url_redirect_walled_garden_ranges: list[str] | None = None,
        guest_group_policy_id: str | None = None,
        guest_sgt_id: int | None = None,
    ) -> UpdateNetworkSwitchAccessPolicyResponse | None:
        """Update an access policy for a switch network.

        [API documentation: updateNetworkSwitchAccessPolicy](https://developer.cisco.com/meraki/api-v1/#!update-network-switch-access-policy)

        Args:
            network_id: Network ID.
            access_policy_number: Access policy number.
            name: Name of the access policy(max length 255).
            radius_servers: List of RADIUS servers to require connecting devices to authenticate
                against before granting network access.
            radius: Object for RADIUS Settings.
            guest_port_bouncing: If enabled, Meraki devices will periodically send access-request
                messages to these RADIUS servers.
            radius_testing_enabled: If enabled, Meraki devices will periodically send access-request
                messages to these RADIUS servers.
            radius_coa_support_enabled: Change of authentication for RADIUS re-authentication and
                disconnection.
            radius_accounting_enabled: Enable to send start, interim-update and stop messages to a
                configured RADIUS accounting server for tracking connected clients.
            radius_accounting_servers: List of RADIUS accounting servers to require connecting
                devices to authenticate against before granting network access.
            radius_group_attribute: Acceptable values are `""` for None, or `"11"` for Group
                Policies ACL.
            host_mode: Choose the Host Mode for the access policy.
            access_policy_type: Access Type of the policy. Automatically 'Hybrid authentication'
                when hostMode is 'Multi-Domain'.
            increase_access_speed: Enabling this option will make switches execute 802.1X and MAC-
                bypass authentication simultaneously so that clients authenticate
                faster. Only required when accessPolicyType is 'Hybrid Authentication.
            guest_vlan_id: ID for the guest VLAN allow unauthorized devices access to limited
                network resources.
            dot1x: 802.1x Settings.
            voice_vlan_clients: CDP/LLDP capable voice clients will be able to use this VLAN.
                Automatically true when hostMode is 'Multi-Domain'.
            url_redirect_walled_garden_enabled: Enable to restrict access for clients to a specific
                set of IP addresses or hostnames prior to authentication.
            url_redirect_walled_garden_ranges: IP address ranges, in CIDR notation, to restrict
                access for clients to a specific set of IP addresses or hostnames prior
                to authentication.
            guest_group_policy_id: Group policy Number for guest group policy.
            guest_sgt_id: Security Group Tag ID for guest group policy.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "accessPolicyNumber": "1234",
              "name": "Access policy #1",
              "radiusServers": [
                {
                  "serverId": "1",
                  "organizationRadiusServerId": "42",
                  "host": "1.2.3.4",
                  "port": 22
                }
              ],
              "radius": {
                "criticalAuth": {
                  "dataVlanId": 100,
                  "voiceVlanId": 100,
                  "suspendPortBounce": true,
                  "dataGroupPolicyId": "1234",
                  "voiceGroupPolicyId": "1234",
                  "dataSgtId": 1234,
                  "voiceSgtId": 1234
                },
                "failedAuthVlanId": 100,
                "failedAuthGroupPolicyId": "1234",
                "failedAuthSgtId": 1284392014819,
                "reAuthenticationInterval": 120,
                "cache": {
                  "enabled": false,
                  "timeout": 24
                },
                "authentication": {
                  "mode": "Open"
                },
                "preAuthenticationGroupPolicyId": "1234"
              },
              "enforceRadiusMonitoring": false,
              "guestPortBouncing": false,
              "radiusTestingEnabled": false,
              "radiusCoaSupportEnabled": false,
              "radiusAccountingEnabled": true,
              "radiusAccountingServers": [
                {
                  "serverId": "2",
                  "organizationRadiusServerId": "42",
                  "host": "1.2.3.4",
                  "port": 22
                }
              ],
              "radiusGroupAttribute": "11",
              "hostMode": "Single-Host",
              "accessPolicyType": "Hybrid authentication",
              "increaseAccessSpeed": false,
              "guestVlanId": 100,
              "dot1x": {
                "controlDirection": "inbound"
              },
              "voiceVlanClients": true,
              "urlRedirectWalledGardenEnabled": true,
              "urlRedirectWalledGardenRanges": [
                "192.168.1.0/24"
              ],
              "counts": {
                "ports": {
                  "withThisPolicy": 12
                }
              },
              "guestGroupPolicyId": "1234",
              "guestSgtId": 1284392014819
            }
            ```

        """
        if host_mode is not None:
            options = ["Multi-Auth", "Multi-Domain", "Multi-Host", "Single-Host"]
            assert host_mode in options, (
                f'"host_mode" cannot be "{host_mode}", & must be set to one of: {options}'
            )
        if access_policy_type is not None:
            options = ["802.1x", "Hybrid authentication", "MAC authentication bypass"]
            assert access_policy_type in options, (
                f'"access_policy_type" cannot be "{access_policy_type}", & must be set to one of: {options}'
            )

        network_id = urllib.parse.quote(str(network_id), safe="")
        access_policy_number = urllib.parse.quote(str(access_policy_number), safe="")
        path = f"/networks/{network_id}/switch/accessPolicies/{access_policy_number}"

        payload = {}
        if name is not None:
            payload["name"] = name
        if radius_servers is not None:
            payload["radiusServers"] = [
                item.model_dump(by_alias=True, exclude_none=True) for item in radius_servers
            ]
        if radius is not None:
            payload["radius"] = radius.model_dump(by_alias=True, exclude_none=True)
        if guest_port_bouncing is not None:
            payload["guestPortBouncing"] = guest_port_bouncing
        if radius_testing_enabled is not None:
            payload["radiusTestingEnabled"] = radius_testing_enabled
        if radius_coa_support_enabled is not None:
            payload["radiusCoaSupportEnabled"] = radius_coa_support_enabled
        if radius_accounting_enabled is not None:
            payload["radiusAccountingEnabled"] = radius_accounting_enabled
        if radius_accounting_servers is not None:
            payload["radiusAccountingServers"] = [
                item.model_dump(by_alias=True, exclude_none=True)
                for item in radius_accounting_servers
            ]
        if radius_group_attribute is not None:
            payload["radiusGroupAttribute"] = radius_group_attribute
        if host_mode is not None:
            payload["hostMode"] = host_mode
        if access_policy_type is not None:
            payload["accessPolicyType"] = access_policy_type
        if increase_access_speed is not None:
            payload["increaseAccessSpeed"] = increase_access_speed
        if guest_vlan_id is not None:
            payload["guestVlanId"] = guest_vlan_id
        if dot1x is not None:
            payload["dot1x"] = dot1x.model_dump(by_alias=True, exclude_none=True)
        if voice_vlan_clients is not None:
            payload["voiceVlanClients"] = voice_vlan_clients
        if url_redirect_walled_garden_enabled is not None:
            payload["urlRedirectWalledGardenEnabled"] = url_redirect_walled_garden_enabled
        if url_redirect_walled_garden_ranges is not None:
            payload["urlRedirectWalledGardenRanges"] = url_redirect_walled_garden_ranges
        if guest_group_policy_id is not None:
            payload["guestGroupPolicyId"] = guest_group_policy_id
        if guest_sgt_id is not None:
            payload["guestSgtId"] = guest_sgt_id

        return self._session.put(
            scope="switch",
            operation_id="updateNetworkSwitchAccessPolicy",
            path=path,
            json=payload,
            response_schema=UpdateNetworkSwitchAccessPolicyResponse,
        )

    def delete_network_switch_access_policy(
        self, *, network_id: str, access_policy_number: str
    ) -> None:
        """Delete an access policy for a switch network.

        [API documentation: deleteNetworkSwitchAccessPolicy](https://developer.cisco.com/meraki/api-v1/#!delete-network-switch-access-policy)

        Args:
            network_id: Network ID.
            access_policy_number: Access policy number.

        Returns:
            Successful operation.

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        access_policy_number = urllib.parse.quote(str(access_policy_number), safe="")
        path = f"/networks/{network_id}/switch/accessPolicies/{access_policy_number}"

        return self._session.delete(
            scope="switch", operation_id="deleteNetworkSwitchAccessPolicy", path=path
        )

    def get_network_switch_alternate_management_interface(
        self, network_id: str
    ) -> GetNetworkSwitchAlternateManagementInterfaceResponse | None:
        """Return the switch alternate management interface for the network.

        [API documentation: getNetworkSwitchAlternateManagementInterface](https://developer.cisco.com/meraki/api-v1/#!get-network-switch-alternate-management-interface)

        Args:
            network_id: Network ID.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "enabled": true,
              "vlanId": 100,
              "protocols": [
                "radius",
                "snmp",
                "syslog"
              ],
              "switches": [
                {
                  "serial": "Q234-ABCD-5678",
                  "alternateManagementIp": "1.2.3.4",
                  "subnetMask": "255.255.255.0",
                  "gateway": "1.2.3.5"
                }
              ]
            }
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/switch/alternateManagementInterface"

        return self._session.get(
            scope="switch",
            operation_id="getNetworkSwitchAlternateManagementInterface",
            path=path,
            response_schema=GetNetworkSwitchAlternateManagementInterfaceResponse,
        )

    def update_network_switch_alternate_management_interface(
        self,
        network_id: str,
        *,
        enabled: bool | None = None,
        vlan_id: int | None = None,
        protocols: list[str] | None = None,
        switches: list[UpdateNetworkSwitchAlternateManagementInterfaceSwitchesItem] | None = None,
    ) -> UpdateNetworkSwitchAlternateManagementInterfaceResponse | None:
        """Update the switch alternate management interface for the network.

        [API documentation: updateNetworkSwitchAlternateManagementInterface](https://developer.cisco.com/meraki/api-v1/#!update-network-switch-alternate-management-interface)

        Args:
            network_id: Network ID.
            enabled: Boolean value to enable or disable AMI configuration. If enabled, VLAN and
                protocols must be set.
            vlan_id: Alternate management VLAN, must be between 1 and 4094.
            protocols: Can be one or more of the following values: 'radius', 'snmp' or 'syslog'.
            switches: Array of switch serial number and IP assignment. If parameter is present, it
                cannot have empty body. Note: switches parameter is not applicable for
                template networks, in other words, do not put 'switches' in the body
                when updating template networks. Also, an empty 'switches' array will
                remove all previous assignments.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "enabled": true,
              "vlanId": 100,
              "protocols": [
                "radius",
                "snmp",
                "syslog"
              ],
              "switches": [
                {
                  "serial": "Q234-ABCD-5678",
                  "alternateManagementIp": "1.2.3.4",
                  "subnetMask": "255.255.255.0",
                  "gateway": "1.2.3.5"
                }
              ]
            }
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/switch/alternateManagementInterface"

        payload = {}
        if enabled is not None:
            payload["enabled"] = enabled
        if vlan_id is not None:
            payload["vlanId"] = vlan_id
        if protocols is not None:
            payload["protocols"] = protocols
        if switches is not None:
            payload["switches"] = [
                item.model_dump(by_alias=True, exclude_none=True) for item in switches
            ]

        return self._session.put(
            scope="switch",
            operation_id="updateNetworkSwitchAlternateManagementInterface",
            path=path,
            json=payload,
            response_schema=UpdateNetworkSwitchAlternateManagementInterfaceResponse,
        )

    def get_network_switch_dhcp_v4_servers_seen(
        self,
        network_id: str,
        *,
        t0: str | None = None,
        timespan: float | None = None,
        per_page: int | None = None,
        starting_after: str | None = None,
        ending_before: str | None = None,
        total_pages: int | Literal["all"] = "all",
        direction: Literal["prev", "next"] = "next",
    ) -> PaginatedResponse[GetNetworkSwitchDhcpV4ServersSeenResponseItem]:
        """Return the network's DHCPv4 servers seen within the selected timeframe (default 1 day).

        [API documentation: getNetworkSwitchDhcpV4ServersSeen](https://developer.cisco.com/meraki/api-v1/#!get-network-switch-dhcp-v-4-servers-seen)

        Args:
            network_id: Network ID.
            t0: The beginning of the timespan for the data. The maximum lookback period is 31 days
                from today.
            timespan: The timespan for which the information will be fetched. If specifying
                timespan, do not specify parameter t0. The value must be in seconds and
                be less than or equal to 31 days. The default is 1 day.
            per_page: The number of entries per page returned. Acceptable range is 3 - 1000. Default
                is 1000.
            starting_after: A token used by the server to indicate the start of the page. Often this
                is a timestamp or an ID but it is not limited to those. This parameter
                should not be defined by client applications. The link for the first,
                last, prev, or next page in the HTTP Link header should define it.
            ending_before: A token used by the server to indicate the end of the page. Often this is
                a timestamp or an ID but it is not limited to those. This parameter
                should not be defined by client applications. The link for the first,
                last, prev, or next page in the HTTP Link header should define it.
            total_pages: use with per_page to get total results up to total_pages * per_page; -1 or
                "all" for all pages.
            direction: direction to paginate, either "next" (default) or "prev" page.

        Returns:
            Successful operation.

        Example API response:
            ```json
            [
              {
                "mac": "00:11:22:33:44:55",
                "vlan": 100,
                "clientId": "k74272e",
                "isAllowed": true,
                "lastSeenAt": "2018-02-11T00:00:00.090210Z",
                "seenBy": [
                  {
                    "serial": "Q234-ABCD-0001",
                    "name": "My switch2",
                    "url": "https://n1.meraki.com//n//manage/nodes/new_list/0000000000001"
                  }
                ],
                "type": "device",
                "device": {
                  "serial": "Q234-ABCD-0002",
                  "name": "My AP",
                  "url": "https://n1.meraki.com//n//manage/nodes/new_list/000000000000",
                  "interface": {
                    "name": "My L3 Interface",
                    "url": "https://n1.meraki.com//n//manage/configure/switch_l3/l3_interface/00000"
                  }
                },
                "ipv4": {
                  "address": "10.0.0.0/24",
                  "subnet": "192.168.1.0/24",
                  "gateway": "1.2.3.5"
                },
                "isConfigured": true,
                "lastAck": {
                  "ts": "2018-02-11T00:00:00.090210Z",
                  "ipv4": {
                    "address": "123.123.123.1"
                  }
                },
                "lastPacket": {
                  "source": {
                    "mac": "00:11:22:33:44:55",
                    "ipv4": {
                      "address": "1.2.3.4"
                    },
                    "port": 443
                  },
                  "destination": {
                    "mac": "22:33:44:55:66:77",
                    "ipv4": {
                      "address": "123.123.123.1"
                    },
                    "port": 444
                  },
                  "type": "ACK",
                  "ethernet": {
                    "type": "0x1212"
                  },
                  "ip": {
                    "id": "0x1313",
                    "version": 4,
                    "length": 24929,
                    "headerLength": 1,
                    "protocol": 1,
                    "ttl": 50,
                    "dscp": {
                      "tag": 24,
                      "ecn": 1
                    }
                  },
                  "udp": {
                    "length": 24929,
                    "checksum": "0x1414"
                  },
                  "fields": {
                    "op": 1,
                    "htype": 1,
                    "hlen": 6,
                    "hops": 0,
                    "xid": "0x11111111",
                    "secs": 1526087474,
                    "flags": "0x0000",
                    "ciaddr": "1.2.3.4",
                    "yiaddr": "123.123.123.1",
                    "siaddr": "1.2.3.4",
                    "giaddr": "1.2.3.5",
                    "chaddr": "abcdefghijkl",
                    "sname": "1.2.3.4",
                    "magicCookie": "0x22222222",
                    "options": [
                      {
                        "name": "Lease time",
                        "value": "86400 seconds"
                      }
                    ]
                  }
                }
              }
            ]
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/switch/dhcp/v4/servers/seen"

        params = {}
        if t0 is not None:
            params["t0"] = t0
        if timespan is not None:
            params["timespan"] = timespan
        if per_page is not None:
            params["perPage"] = per_page
        if starting_after is not None:
            params["startingAfter"] = starting_after
        if ending_before is not None:
            params["endingBefore"] = ending_before

        return self._session.get_pages(
            scope="switch",
            operation_id="getNetworkSwitchDhcpV4ServersSeen",
            path=path,
            params=params,
            total_pages=total_pages,
            direction=direction,
            item_schema=GetNetworkSwitchDhcpV4ServersSeenResponseItem,
        )

    def get_network_switch_dhcp_server_policy(
        self, network_id: str
    ) -> GetNetworkSwitchDhcpServerPolicyResponse | None:
        """Return the DHCP server settings.

        [API documentation: getNetworkSwitchDhcpServerPolicy](https://developer.cisco.com/meraki/api-v1/#!get-network-switch-dhcp-server-policy)

        Args:
            network_id: Network ID.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "alerts": {
                "email": {
                  "enabled": true
                }
              },
              "defaultPolicy": "block",
              "blockedServers": [
                "00:50:56:00:00:03",
                "00:50:56:00:00:04"
              ],
              "allowedServers": [
                "00:50:56:00:00:01",
                "00:50:56:00:00:02"
              ],
              "arpInspection": {
                "enabled": true,
                "unsupportedModels": [
                  "MS120-8",
                  "MS125-24"
                ]
              }
            }
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/switch/dhcpServerPolicy"

        return self._session.get(
            scope="switch",
            operation_id="getNetworkSwitchDhcpServerPolicy",
            path=path,
            response_schema=GetNetworkSwitchDhcpServerPolicyResponse,
        )

    def update_network_switch_dhcp_server_policy(
        self,
        network_id: str,
        *,
        alerts: UpdateNetworkSwitchDhcpServerPolicyAlerts | None = None,
        default_policy: str | None = None,
        allowed_servers: list[str] | None = None,
        blocked_servers: list[str] | None = None,
        arp_inspection: UpdateNetworkSwitchDhcpServerPolicyArpInspection | None = None,
    ) -> UpdateNetworkSwitchDhcpServerPolicyResponse | None:
        """Update the DHCP server settings.

        [API documentation: updateNetworkSwitchDhcpServerPolicy](https://developer.cisco.com/meraki/api-v1/#!update-network-switch-dhcp-server-policy)

        Args:
            network_id: Network ID.
            alerts: Alert settings for DHCP servers.
            default_policy: 'allow' or 'block' new DHCP servers. Default value is 'allow'.
            allowed_servers: List the MAC addresses of DHCP servers to permit on the network when
                defaultPolicy is set to block. An empty array will clear the entries.
            blocked_servers: List the MAC addresses of DHCP servers to block on the network when
                defaultPolicy is set to allow. An empty array will clear the entries.
            arp_inspection: Dynamic ARP Inspection settings.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "alerts": {
                "email": {
                  "enabled": true
                }
              },
              "defaultPolicy": "block",
              "blockedServers": [
                "00:50:56:00:00:03",
                "00:50:56:00:00:04"
              ],
              "allowedServers": [
                "00:50:56:00:00:01",
                "00:50:56:00:00:02"
              ],
              "arpInspection": {
                "enabled": true,
                "unsupportedModels": [
                  "MS120-8",
                  "MS125-24"
                ]
              }
            }
            ```

        """
        if default_policy is not None:
            options = ["allow", "block"]
            assert default_policy in options, (
                f'"default_policy" cannot be "{default_policy}", & must be set to one of: {options}'
            )

        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/switch/dhcpServerPolicy"

        payload = {}
        if alerts is not None:
            payload["alerts"] = alerts.model_dump(by_alias=True, exclude_none=True)
        if default_policy is not None:
            payload["defaultPolicy"] = default_policy
        if allowed_servers is not None:
            payload["allowedServers"] = allowed_servers
        if blocked_servers is not None:
            payload["blockedServers"] = blocked_servers
        if arp_inspection is not None:
            payload["arpInspection"] = arp_inspection.model_dump(by_alias=True, exclude_none=True)

        return self._session.put(
            scope="switch",
            operation_id="updateNetworkSwitchDhcpServerPolicy",
            path=path,
            json=payload,
            response_schema=UpdateNetworkSwitchDhcpServerPolicyResponse,
        )

    def get_network_switch_dhcp_server_policy_arp_inspection_trusted_servers(
        self,
        network_id: str,
        *,
        per_page: int | None = None,
        starting_after: str | None = None,
        ending_before: str | None = None,
        total_pages: int | Literal["all"] = "all",
        direction: Literal["prev", "next"] = "next",
    ) -> PaginatedResponse[GetNetworkSwitchDhcpServerPolicyArpInspectionTrustedServersResponseItem]:
        """Return the list of servers trusted by Dynamic ARP Inspection on this network.

        [API documentation: getNetworkSwitchDhcpServerPolicyArpInspectionTrustedServers](https://developer.cisco.com/meraki/api-v1/#!get-network-switch-dhcp-server-policy-arp-inspection-trusted-servers)

        Args:
            network_id: Network ID.
            per_page: The number of entries per page returned. Acceptable range is 3 - 1000. Default
                is 1000.
            starting_after: A token used by the server to indicate the start of the page. Often this
                is a timestamp or an ID but it is not limited to those. This parameter
                should not be defined by client applications. The link for the first,
                last, prev, or next page in the HTTP Link header should define it.
            ending_before: A token used by the server to indicate the end of the page. Often this is
                a timestamp or an ID but it is not limited to those. This parameter
                should not be defined by client applications. The link for the first,
                last, prev, or next page in the HTTP Link header should define it.
            total_pages: use with per_page to get total results up to total_pages * per_page; -1 or
                "all" for all pages.
            direction: direction to paginate, either "next" (default) or "prev" page.

        Returns:
            Successful operation.

        Example API response:
            ```json
            [
              {
                "trustedServerId": "123",
                "mac": "00:11:22:33:44:55",
                "vlan": 100,
                "ipv4": {
                  "address": "1.2.3.4"
                }
              }
            ]
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/switch/dhcpServerPolicy/arpInspection/trustedServers"

        params = {}
        if per_page is not None:
            params["perPage"] = per_page
        if starting_after is not None:
            params["startingAfter"] = starting_after
        if ending_before is not None:
            params["endingBefore"] = ending_before

        return self._session.get_pages(
            scope="switch",
            operation_id="getNetworkSwitchDhcpServerPolicyArpInspectionTrustedServers",
            path=path,
            params=params,
            total_pages=total_pages,
            direction=direction,
            item_schema=GetNetworkSwitchDhcpServerPolicyArpInspectionTrustedServersResponseItem,
        )

    def create_network_switch_dhcp_server_policy_arp_inspection_trusted_server(
        self,
        *,
        network_id: str,
        mac: str,
        vlan: int,
        ipv4: CreateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerIpv4,
    ) -> CreateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerResponse | None:
        """Add a server to be trusted by Dynamic ARP Inspection on this network.

        [API documentation: createNetworkSwitchDhcpServerPolicyArpInspectionTrustedServer](https://developer.cisco.com/meraki/api-v1/#!create-network-switch-dhcp-server-policy-arp-inspection-trusted-server)

        Args:
            network_id: Network ID.
            mac: The mac address of the trusted server being added.
            vlan: The VLAN of the trusted server being added. It must be between 1 and 4094.
            ipv4: The IPv4 attributes of the trusted server being added.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "trustedServerId": "123",
              "mac": "00:11:22:33:44:55",
              "vlan": 100,
              "ipv4": {
                "address": "1.2.3.4"
              }
            }
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/switch/dhcpServerPolicy/arpInspection/trustedServers"

        payload = {}
        if mac is not None:
            payload["mac"] = mac
        if vlan is not None:
            payload["vlan"] = vlan
        if ipv4 is not None:
            payload["ipv4"] = ipv4.model_dump(by_alias=True, exclude_none=True)

        return self._session.post(
            scope="switch",
            operation_id="createNetworkSwitchDhcpServerPolicyArpInspectionTrustedServer",
            path=path,
            json=payload,
            response_schema=CreateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerResponse,
        )

    def update_network_switch_dhcp_server_policy_arp_inspection_trusted_server(
        self,
        *,
        network_id: str,
        trusted_server_id: str,
        mac: str | None = None,
        vlan: int | None = None,
        ipv4: UpdateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerIpv4 | None = None,
    ) -> UpdateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerResponse | None:
        """Update a server that is trusted by Dynamic ARP Inspection on this network.

        [API documentation: updateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServer](https://developer.cisco.com/meraki/api-v1/#!update-network-switch-dhcp-server-policy-arp-inspection-trusted-server)

        Args:
            network_id: Network ID.
            trusted_server_id: Trusted server ID.
            mac: The updated mac address of the trusted server.
            vlan: The updated VLAN of the trusted server. It must be between 1 and 4094.
            ipv4: The updated IPv4 attributes of the trusted server.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "trustedServerId": "123",
              "mac": "00:11:22:33:44:55",
              "vlan": 100,
              "ipv4": {
                "address": "1.2.3.4"
              }
            }
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        trusted_server_id = urllib.parse.quote(str(trusted_server_id), safe="")
        path = f"/networks/{network_id}/switch/dhcpServerPolicy/arpInspection/trustedServers/{trusted_server_id}"

        payload = {}
        if mac is not None:
            payload["mac"] = mac
        if vlan is not None:
            payload["vlan"] = vlan
        if ipv4 is not None:
            payload["ipv4"] = ipv4.model_dump(by_alias=True, exclude_none=True)

        return self._session.put(
            scope="switch",
            operation_id="updateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServer",
            path=path,
            json=payload,
            response_schema=UpdateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerResponse,
        )

    def delete_network_switch_dhcp_server_policy_arp_inspection_trusted_server(
        self, *, network_id: str, trusted_server_id: str
    ) -> None:
        """Remove a server from being trusted by Dynamic ARP Inspection on this network.

        [API documentation: deleteNetworkSwitchDhcpServerPolicyArpInspectionTrustedServer](https://developer.cisco.com/meraki/api-v1/#!delete-network-switch-dhcp-server-policy-arp-inspection-trusted-server)

        Args:
            network_id: Network ID.
            trusted_server_id: Trusted server ID.

        Returns:
            Successful operation.

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        trusted_server_id = urllib.parse.quote(str(trusted_server_id), safe="")
        path = f"/networks/{network_id}/switch/dhcpServerPolicy/arpInspection/trustedServers/{trusted_server_id}"

        return self._session.delete(
            scope="switch",
            operation_id="deleteNetworkSwitchDhcpServerPolicyArpInspectionTrustedServer",
            path=path,
        )

    def get_network_switch_dhcp_server_policy_arp_inspection_warnings_by_device(
        self,
        network_id: str,
        *,
        per_page: int | None = None,
        starting_after: str | None = None,
        ending_before: str | None = None,
        total_pages: int | Literal["all"] = "all",
        direction: Literal["prev", "next"] = "next",
    ) -> PaginatedResponse[
        GetNetworkSwitchDhcpServerPolicyArpInspectionWarningsByDeviceResponseItem
    ]:
        """Return the devices that have a Dynamic ARP Inspection warning and their warnings.

        [API documentation: getNetworkSwitchDhcpServerPolicyArpInspectionWarningsByDevice](https://developer.cisco.com/meraki/api-v1/#!get-network-switch-dhcp-server-policy-arp-inspection-warnings-by-device)

        Args:
            network_id: Network ID.
            per_page: The number of entries per page returned. Acceptable range is 3 - 1000. Default
                is 1000.
            starting_after: A token used by the server to indicate the start of the page. Often this
                is a timestamp or an ID but it is not limited to those. This parameter
                should not be defined by client applications. The link for the first,
                last, prev, or next page in the HTTP Link header should define it.
            ending_before: A token used by the server to indicate the end of the page. Often this is
                a timestamp or an ID but it is not limited to those. This parameter
                should not be defined by client applications. The link for the first,
                last, prev, or next page in the HTTP Link header should define it.
            total_pages: use with per_page to get total results up to total_pages * per_page; -1 or
                "all" for all pages.
            direction: direction to paginate, either "next" (default) or "prev" page.

        Returns:
            Successful operation.

        Example API response:
            ```json
            [
              {
                "serial": "Q234-ABCD-0001",
                "name": "My switch",
                "url": "https://n1.meraki.com//n//manage/nodes/new_list/000000000000",
                "supportsInspection": false,
                "hasTrustedPort": false
              }
            ]
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/switch/dhcpServerPolicy/arpInspection/warnings/byDevice"

        params = {}
        if per_page is not None:
            params["perPage"] = per_page
        if starting_after is not None:
            params["startingAfter"] = starting_after
        if ending_before is not None:
            params["endingBefore"] = ending_before

        return self._session.get_pages(
            scope="switch",
            operation_id="getNetworkSwitchDhcpServerPolicyArpInspectionWarningsByDevice",
            path=path,
            params=params,
            total_pages=total_pages,
            direction=direction,
            item_schema=GetNetworkSwitchDhcpServerPolicyArpInspectionWarningsByDeviceResponseItem,
        )

    def get_network_switch_dscp_to_cos_mappings(
        self, network_id: str
    ) -> GetNetworkSwitchDscpToCosMappingsResponse | None:
        """Return the DSCP to CoS mappings.

        [API documentation: getNetworkSwitchDscpToCosMappings](https://developer.cisco.com/meraki/api-v1/#!get-network-switch-dscp-to-cos-mappings)

        Args:
            network_id: Network ID.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "mappings": [
                {
                  "dscp": 1,
                  "cos": 1,
                  "title": "Video"
                }
              ]
            }
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/switch/dscpToCosMappings"

        return self._session.get(
            scope="switch",
            operation_id="getNetworkSwitchDscpToCosMappings",
            path=path,
            response_schema=GetNetworkSwitchDscpToCosMappingsResponse,
        )

    def update_network_switch_dscp_to_cos_mappings(
        self, *, network_id: str, mappings: list[UpdateNetworkSwitchDscpToCosMappingsMappingsItem]
    ) -> UpdateNetworkSwitchDscpToCosMappingsResponse | None:
        """Update the DSCP to CoS mappings.

        [API documentation: updateNetworkSwitchDscpToCosMappings](https://developer.cisco.com/meraki/api-v1/#!update-network-switch-dscp-to-cos-mappings)

        Args:
            network_id: Network ID.
            mappings: An array of DSCP to CoS mappings. An empty array will reset the mappings to
                default.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "mappings": [
                {
                  "dscp": 1,
                  "cos": 1,
                  "title": "Video"
                }
              ]
            }
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/switch/dscpToCosMappings"

        payload = {}
        if mappings is not None:
            payload["mappings"] = [
                item.model_dump(by_alias=True, exclude_none=True) for item in mappings
            ]

        return self._session.put(
            scope="switch",
            operation_id="updateNetworkSwitchDscpToCosMappings",
            path=path,
            json=payload,
            response_schema=UpdateNetworkSwitchDscpToCosMappingsResponse,
        )

    def get_network_switch_link_aggregations(
        self, network_id: str
    ) -> PaginatedResponse[GetNetworkSwitchLinkAggregationsResponseItem]:
        """List link aggregation groups.

        [API documentation: getNetworkSwitchLinkAggregations](https://developer.cisco.com/meraki/api-v1/#!get-network-switch-link-aggregations)

        Args:
            network_id: Network ID.

        Returns:
            Successful operation.

        Example API response:
            ```json
            [
              {
                "id": "NDU2N18yXzM=",
                "switchPorts": [
                  {
                    "serial": "Q234-ABCD-0001",
                    "portId": "1"
                  }
                ]
              }
            ]
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/switch/linkAggregations"

        return self._session.get_pages(
            scope="switch",
            operation_id="getNetworkSwitchLinkAggregations",
            path=path,
            item_schema=GetNetworkSwitchLinkAggregationsResponseItem,
        )

    def create_network_switch_link_aggregation(
        self,
        network_id: str,
        *,
        switch_ports: list[CreateNetworkSwitchLinkAggregationSwitchPortsItem] | None = None,
        switch_profile_ports: list[CreateNetworkSwitchLinkAggregationSwitchProfilePortsItem]
        | None = None,
    ) -> CreateNetworkSwitchLinkAggregationResponse | None:
        """Create a link aggregation group.

        [API documentation: createNetworkSwitchLinkAggregation](https://developer.cisco.com/meraki/api-v1/#!create-network-switch-link-aggregation)

        Args:
            network_id: Network ID.
            switch_ports: Array of switch or stack ports for creating aggregation group. Minimum 2
                and maximum 8 ports are supported.
            switch_profile_ports: Array of switch profile ports for creating aggregation group.
                Minimum 2 and maximum 8 ports are supported.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "id": "NDU2N18yXzM=",
              "switchPorts": [
                {
                  "serial": "Q234-ABCD-0001",
                  "portId": "1"
                }
              ]
            }
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/switch/linkAggregations"

        payload = {}
        if switch_ports is not None:
            payload["switchPorts"] = [
                item.model_dump(by_alias=True, exclude_none=True) for item in switch_ports
            ]
        if switch_profile_ports is not None:
            payload["switchProfilePorts"] = [
                item.model_dump(by_alias=True, exclude_none=True) for item in switch_profile_ports
            ]

        return self._session.post(
            scope="switch",
            operation_id="createNetworkSwitchLinkAggregation",
            path=path,
            json=payload,
            response_schema=CreateNetworkSwitchLinkAggregationResponse,
        )

    def update_network_switch_link_aggregation(
        self,
        *,
        network_id: str,
        link_aggregation_id: str,
        switch_ports: list[UpdateNetworkSwitchLinkAggregationSwitchPortsItem] | None = None,
        switch_profile_ports: list[UpdateNetworkSwitchLinkAggregationSwitchProfilePortsItem]
        | None = None,
    ) -> UpdateNetworkSwitchLinkAggregationResponse | None:
        """Update a link aggregation group.

        [API documentation: updateNetworkSwitchLinkAggregation](https://developer.cisco.com/meraki/api-v1/#!update-network-switch-link-aggregation)

        Args:
            network_id: Network ID.
            link_aggregation_id: Link aggregation ID.
            switch_ports: Array of switch or stack ports for updating aggregation group. Minimum 2
                and maximum 8 ports are supported.
            switch_profile_ports: Array of switch profile ports for updating aggregation group.
                Minimum 2 and maximum 8 ports are supported.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "id": "NDU2N18yXzM=",
              "switchPorts": [
                {
                  "serial": "Q234-ABCD-0001",
                  "portId": "1"
                }
              ]
            }
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        link_aggregation_id = urllib.parse.quote(str(link_aggregation_id), safe="")
        path = f"/networks/{network_id}/switch/linkAggregations/{link_aggregation_id}"

        payload = {}
        if switch_ports is not None:
            payload["switchPorts"] = [
                item.model_dump(by_alias=True, exclude_none=True) for item in switch_ports
            ]
        if switch_profile_ports is not None:
            payload["switchProfilePorts"] = [
                item.model_dump(by_alias=True, exclude_none=True) for item in switch_profile_ports
            ]

        return self._session.put(
            scope="switch",
            operation_id="updateNetworkSwitchLinkAggregation",
            path=path,
            json=payload,
            response_schema=UpdateNetworkSwitchLinkAggregationResponse,
        )

    def delete_network_switch_link_aggregation(
        self, *, network_id: str, link_aggregation_id: str
    ) -> None:
        """Split a link aggregation group into separate ports.

        [API documentation: deleteNetworkSwitchLinkAggregation](https://developer.cisco.com/meraki/api-v1/#!delete-network-switch-link-aggregation)

        Args:
            network_id: Network ID.
            link_aggregation_id: Link aggregation ID.

        Returns:
            Successful operation.

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        link_aggregation_id = urllib.parse.quote(str(link_aggregation_id), safe="")
        path = f"/networks/{network_id}/switch/linkAggregations/{link_aggregation_id}"

        return self._session.delete(
            scope="switch", operation_id="deleteNetworkSwitchLinkAggregation", path=path
        )

    def get_network_switch_mtu(self, network_id: str) -> GetNetworkSwitchMtuResponse | None:
        """Return the MTU configuration.

        [API documentation: getNetworkSwitchMtu](https://developer.cisco.com/meraki/api-v1/#!get-network-switch-mtu)

        Args:
            network_id: Network ID.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "defaultMtuSize": 9578,
              "overrides": [
                {
                  "switches": [
                    "Q234-ABCD-0001",
                    "Q234-ABCD-0002",
                    "Q234-ABCD-0003"
                  ],
                  "switchProfiles": [
                    "1284392014819",
                    "2983092129865"
                  ],
                  "mtuSize": 1500
                }
              ]
            }
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/switch/mtu"

        return self._session.get(
            scope="switch",
            operation_id="getNetworkSwitchMtu",
            path=path,
            response_schema=GetNetworkSwitchMtuResponse,
        )

    def update_network_switch_mtu(
        self,
        network_id: str,
        *,
        default_mtu_size: int | None = None,
        overrides: list[UpdateNetworkSwitchMtuOverridesItem] | None = None,
    ) -> UpdateNetworkSwitchMtuResponse | None:
        """Update the MTU configuration.

        [API documentation: updateNetworkSwitchMtu](https://developer.cisco.com/meraki/api-v1/#!update-network-switch-mtu)

        Args:
            network_id: Network ID.
            default_mtu_size: MTU size for the entire network. Default value is 9578.
            overrides: Override MTU size for individual switches or switch templates. An empty array
                will clear overrides.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "defaultMtuSize": 9578,
              "overrides": [
                {
                  "switches": [
                    "Q234-ABCD-0001",
                    "Q234-ABCD-0002",
                    "Q234-ABCD-0003"
                  ],
                  "switchProfiles": [
                    "1284392014819",
                    "2983092129865"
                  ],
                  "mtuSize": 1500
                }
              ]
            }
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/switch/mtu"

        payload = {}
        if default_mtu_size is not None:
            payload["defaultMtuSize"] = default_mtu_size
        if overrides is not None:
            payload["overrides"] = [
                item.model_dump(by_alias=True, exclude_none=True) for item in overrides
            ]

        return self._session.put(
            scope="switch",
            operation_id="updateNetworkSwitchMtu",
            path=path,
            json=payload,
            response_schema=UpdateNetworkSwitchMtuResponse,
        )

    def get_network_switch_port_schedules(
        self, network_id: str
    ) -> PaginatedResponse[GetNetworkSwitchPortSchedulesResponseItem]:
        """List switch port schedules.

        [API documentation: getNetworkSwitchPortSchedules](https://developer.cisco.com/meraki/api-v1/#!get-network-switch-port-schedules)

        Args:
            network_id: Network ID.

        Returns:
            Successful operation.

        Example API response:
            ```json
            [
              {
                "id": "1234",
                "networkId": "N_24329156",
                "name": "Weekdays schedule",
                "portSchedule": {
                  "monday": {
                    "active": true,
                    "from": "9:00",
                    "to": "17:00"
                  },
                  "tuesday": {
                    "active": true,
                    "from": "9:00",
                    "to": "17:00"
                  },
                  "wednesday": {
                    "active": true,
                    "from": "9:00",
                    "to": "17:00"
                  },
                  "thursday": {
                    "active": true,
                    "from": "9:00",
                    "to": "17:00"
                  },
                  "friday": {
                    "active": true,
                    "from": "9:00",
                    "to": "17:00"
                  },
                  "saturday": {
                    "active": false,
                    "from": "0:00",
                    "to": "24:00"
                  },
                  "sunday": {
                    "active": false,
                    "from": "0:00",
                    "to": "24:00"
                  }
                }
              }
            ]
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/switch/portSchedules"

        return self._session.get_pages(
            scope="switch",
            operation_id="getNetworkSwitchPortSchedules",
            path=path,
            item_schema=GetNetworkSwitchPortSchedulesResponseItem,
        )

    def create_network_switch_port_schedule(
        self,
        *,
        network_id: str,
        name: str,
        port_schedule: CreateNetworkSwitchPortSchedulePortSchedule | None = None,
    ) -> CreateNetworkSwitchPortScheduleResponse | None:
        """Add a switch port schedule.

        [API documentation: createNetworkSwitchPortSchedule](https://developer.cisco.com/meraki/api-v1/#!create-network-switch-port-schedule)

        Args:
            network_id: Network ID.
            name: The name for your port schedule. Required.
            port_schedule: The schedule for switch port scheduling. Schedules are applied to days of
                the week. When it's empty, default schedule with all days of a week are
                configured. Any unspecified day in the schedule is added as a default
                schedule configuration of the day.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "id": "1234",
              "networkId": "N_24329156",
              "name": "Weekdays schedule",
              "portSchedule": {
                "monday": {
                  "active": true,
                  "from": "9:00",
                  "to": "17:00"
                },
                "tuesday": {
                  "active": true,
                  "from": "9:00",
                  "to": "17:00"
                },
                "wednesday": {
                  "active": true,
                  "from": "9:00",
                  "to": "17:00"
                },
                "thursday": {
                  "active": true,
                  "from": "9:00",
                  "to": "17:00"
                },
                "friday": {
                  "active": true,
                  "from": "9:00",
                  "to": "17:00"
                },
                "saturday": {
                  "active": false,
                  "from": "0:00",
                  "to": "24:00"
                },
                "sunday": {
                  "active": false,
                  "from": "0:00",
                  "to": "24:00"
                }
              }
            }
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/switch/portSchedules"

        payload = {}
        if name is not None:
            payload["name"] = name
        if port_schedule is not None:
            payload["portSchedule"] = port_schedule.model_dump(by_alias=True, exclude_none=True)

        return self._session.post(
            scope="switch",
            operation_id="createNetworkSwitchPortSchedule",
            path=path,
            json=payload,
            response_schema=CreateNetworkSwitchPortScheduleResponse,
        )

    def update_network_switch_port_schedule(
        self,
        *,
        network_id: str,
        port_schedule_id: str,
        name: str | None = None,
        port_schedule: UpdateNetworkSwitchPortSchedulePortSchedule | None = None,
    ) -> UpdateNetworkSwitchPortScheduleResponse | None:
        """Update a switch port schedule.

        [API documentation: updateNetworkSwitchPortSchedule](https://developer.cisco.com/meraki/api-v1/#!update-network-switch-port-schedule)

        Args:
            network_id: Network ID.
            port_schedule_id: Port schedule ID.
            name: The name for your port schedule.
            port_schedule: The schedule for switch port scheduling. Schedules are applied to days of
                the week. When it's empty, default schedule with all days of a week are
                configured. Any unspecified day in the schedule is added as a default
                schedule configuration of the day.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "id": "1234",
              "networkId": "N_24329156",
              "name": "Weekdays schedule",
              "portSchedule": {
                "monday": {
                  "active": true,
                  "from": "9:00",
                  "to": "17:00"
                },
                "tuesday": {
                  "active": true,
                  "from": "9:00",
                  "to": "17:00"
                },
                "wednesday": {
                  "active": true,
                  "from": "9:00",
                  "to": "17:00"
                },
                "thursday": {
                  "active": true,
                  "from": "9:00",
                  "to": "17:00"
                },
                "friday": {
                  "active": true,
                  "from": "9:00",
                  "to": "17:00"
                },
                "saturday": {
                  "active": false,
                  "from": "0:00",
                  "to": "24:00"
                },
                "sunday": {
                  "active": false,
                  "from": "0:00",
                  "to": "24:00"
                }
              }
            }
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        port_schedule_id = urllib.parse.quote(str(port_schedule_id), safe="")
        path = f"/networks/{network_id}/switch/portSchedules/{port_schedule_id}"

        payload = {}
        if name is not None:
            payload["name"] = name
        if port_schedule is not None:
            payload["portSchedule"] = port_schedule.model_dump(by_alias=True, exclude_none=True)

        return self._session.put(
            scope="switch",
            operation_id="updateNetworkSwitchPortSchedule",
            path=path,
            json=payload,
            response_schema=UpdateNetworkSwitchPortScheduleResponse,
        )

    def delete_network_switch_port_schedule(
        self, *, network_id: str, port_schedule_id: str
    ) -> None:
        """Delete a switch port schedule.

        [API documentation: deleteNetworkSwitchPortSchedule](https://developer.cisco.com/meraki/api-v1/#!delete-network-switch-port-schedule)

        Args:
            network_id: Network ID.
            port_schedule_id: Port schedule ID.

        Returns:
            Successful operation.

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        port_schedule_id = urllib.parse.quote(str(port_schedule_id), safe="")
        path = f"/networks/{network_id}/switch/portSchedules/{port_schedule_id}"

        return self._session.delete(
            scope="switch", operation_id="deleteNetworkSwitchPortSchedule", path=path
        )

    def get_network_switch_qos_rules(
        self, network_id: str
    ) -> PaginatedResponse[GetNetworkSwitchQosRulesResponseItem]:
        """List quality of service rules.

        [API documentation: getNetworkSwitchQosRules](https://developer.cisco.com/meraki/api-v1/#!get-network-switch-qos-rules)

        Args:
            network_id: Network ID.

        Returns:
            Successful operation.

        Example API response:
            ```json
            [
              {
                "id": "1284392014819",
                "vlan": 100,
                "protocol": "TCP",
                "srcPort": 2000,
                "srcPortRange": "70-80",
                "dstPort": 3000,
                "dstPortRange": "3000-3100",
                "dscp": 0
              }
            ]
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/switch/qosRules"

        return self._session.get_pages(
            scope="switch",
            operation_id="getNetworkSwitchQosRules",
            path=path,
            item_schema=GetNetworkSwitchQosRulesResponseItem,
        )

    def create_network_switch_qos_rule(
        self,
        *,
        network_id: str,
        vlan: int,
        protocol: str | None = None,
        src_port: int | None = None,
        src_port_range: str | None = None,
        dst_port: int | None = None,
        dst_port_range: str | None = None,
        dscp: int | None = None,
    ) -> CreateNetworkSwitchQosRuleResponse | None:
        """Add a quality of service rule.

        [API documentation: createNetworkSwitchQosRule](https://developer.cisco.com/meraki/api-v1/#!create-network-switch-qos-rule)

        Args:
            network_id: Network ID.
            vlan: The VLAN of the incoming packet. A null value will match any VLAN.
            protocol: The protocol of the incoming packet. Default value is "ANY".
            src_port: The source port of the incoming packet. Applicable only if protocol is TCP or
                UDP.
            src_port_range: The source port range of the incoming packet. Applicable only if
                protocol is set to TCP or UDP.
            dst_port: The destination port of the incoming packet. Applicable only if protocol is
                TCP or UDP.
            dst_port_range: The destination port range of the incoming packet. Applicable only if
                protocol is set to TCP or UDP.
            dscp: DSCP tag for the incoming packet. Set this to -1 to trust incoming DSCP. Default
                value is 0.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "id": "1284392014819",
              "vlan": 100,
              "protocol": "TCP",
              "srcPort": 2000,
              "srcPortRange": "70-80",
              "dstPort": 3000,
              "dstPortRange": "3000-3100",
              "dscp": 0
            }
            ```

        """
        if protocol is not None:
            options = ["ANY", "TCP", "UDP"]
            assert protocol in options, (
                f'"protocol" cannot be "{protocol}", & must be set to one of: {options}'
            )

        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/switch/qosRules"

        payload = {}
        if vlan is not None:
            payload["vlan"] = vlan
        if protocol is not None:
            payload["protocol"] = protocol
        if src_port is not None:
            payload["srcPort"] = src_port
        if src_port_range is not None:
            payload["srcPortRange"] = src_port_range
        if dst_port is not None:
            payload["dstPort"] = dst_port
        if dst_port_range is not None:
            payload["dstPortRange"] = dst_port_range
        if dscp is not None:
            payload["dscp"] = dscp

        return self._session.post(
            scope="switch",
            operation_id="createNetworkSwitchQosRule",
            path=path,
            json=payload,
            response_schema=CreateNetworkSwitchQosRuleResponse,
        )

    def get_network_switch_qos_rules_order(
        self, network_id: str
    ) -> GetNetworkSwitchQosRulesOrderResponse | None:
        """Return the quality of service rule IDs by order in which they will be processed by the switch.

        [API documentation: getNetworkSwitchQosRulesOrder](https://developer.cisco.com/meraki/api-v1/#!get-network-switch-qos-rules-order)

        Args:
            network_id: Network ID.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "ruleIds": [
                "1284392014819",
                "2983092129865"
              ]
            }
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/switch/qosRules/order"

        return self._session.get(
            scope="switch",
            operation_id="getNetworkSwitchQosRulesOrder",
            path=path,
            response_schema=GetNetworkSwitchQosRulesOrderResponse,
        )

    def update_network_switch_qos_rules_order(
        self, *, network_id: str, rule_ids: list[str]
    ) -> UpdateNetworkSwitchQosRulesOrderResponse | None:
        """Update the order in which the rules should be processed by the switch.

        [API documentation: updateNetworkSwitchQosRulesOrder](https://developer.cisco.com/meraki/api-v1/#!update-network-switch-qos-rules-order)

        Args:
            network_id: Network ID.
            rule_ids: A list of quality of service rule IDs arranged in order in which they should
                be processed by the switch.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "ruleIds": [
                "1284392014819",
                "2983092129865"
              ]
            }
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/switch/qosRules/order"

        payload = {}
        if rule_ids is not None:
            payload["ruleIds"] = rule_ids

        return self._session.put(
            scope="switch",
            operation_id="updateNetworkSwitchQosRulesOrder",
            path=path,
            json=payload,
            response_schema=UpdateNetworkSwitchQosRulesOrderResponse,
        )

    def get_network_switch_qos_rule(
        self, *, network_id: str, qos_rule_id: str
    ) -> GetNetworkSwitchQosRuleResponse | None:
        """Return a quality of service rule.

        [API documentation: getNetworkSwitchQosRule](https://developer.cisco.com/meraki/api-v1/#!get-network-switch-qos-rule)

        Args:
            network_id: Network ID.
            qos_rule_id: Qos rule ID.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "id": "1284392014819",
              "vlan": 100,
              "protocol": "TCP",
              "srcPort": 2000,
              "srcPortRange": "70-80",
              "dstPort": 3000,
              "dstPortRange": "3000-3100",
              "dscp": 0
            }
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        qos_rule_id = urllib.parse.quote(str(qos_rule_id), safe="")
        path = f"/networks/{network_id}/switch/qosRules/{qos_rule_id}"

        return self._session.get(
            scope="switch",
            operation_id="getNetworkSwitchQosRule",
            path=path,
            response_schema=GetNetworkSwitchQosRuleResponse,
        )

    def update_network_switch_qos_rule(
        self,
        *,
        network_id: str,
        qos_rule_id: str,
        vlan: int | None = None,
        protocol: str | None = None,
        src_port: int | None = None,
        src_port_range: str | None = None,
        dst_port: int | None = None,
        dst_port_range: str | None = None,
        dscp: int | None = None,
    ) -> UpdateNetworkSwitchQosRuleResponse | None:
        """Update a quality of service rule.

        [API documentation: updateNetworkSwitchQosRule](https://developer.cisco.com/meraki/api-v1/#!update-network-switch-qos-rule)

        Args:
            network_id: Network ID.
            qos_rule_id: Qos rule ID.
            vlan: The VLAN of the incoming packet. A null value will match any VLAN.
            protocol: The protocol of the incoming packet. Default value is "ANY".
            src_port: The source port of the incoming packet. Applicable only if protocol is TCP or
                UDP.
            src_port_range: The source port range of the incoming packet. Applicable only if
                protocol is set to TCP or UDP.
            dst_port: The destination port of the incoming packet. Applicable only if protocol is
                TCP or UDP.
            dst_port_range: The destination port range of the incoming packet. Applicable only if
                protocol is set to TCP or UDP.
            dscp: DSCP tag that should be assigned to incoming packet. Set this to -1 to trust
                incoming DSCP. Default value is 0.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "id": "1284392014819",
              "vlan": 100,
              "protocol": "TCP",
              "srcPort": 2000,
              "srcPortRange": "70-80",
              "dstPort": 3000,
              "dstPortRange": "3000-3100",
              "dscp": 0
            }
            ```

        """
        if protocol is not None:
            options = ["ANY", "TCP", "UDP"]
            assert protocol in options, (
                f'"protocol" cannot be "{protocol}", & must be set to one of: {options}'
            )

        network_id = urllib.parse.quote(str(network_id), safe="")
        qos_rule_id = urllib.parse.quote(str(qos_rule_id), safe="")
        path = f"/networks/{network_id}/switch/qosRules/{qos_rule_id}"

        payload = {}
        if vlan is not None:
            payload["vlan"] = vlan
        if protocol is not None:
            payload["protocol"] = protocol
        if src_port is not None:
            payload["srcPort"] = src_port
        if src_port_range is not None:
            payload["srcPortRange"] = src_port_range
        if dst_port is not None:
            payload["dstPort"] = dst_port
        if dst_port_range is not None:
            payload["dstPortRange"] = dst_port_range
        if dscp is not None:
            payload["dscp"] = dscp

        return self._session.put(
            scope="switch",
            operation_id="updateNetworkSwitchQosRule",
            path=path,
            json=payload,
            response_schema=UpdateNetworkSwitchQosRuleResponse,
        )

    def delete_network_switch_qos_rule(self, *, network_id: str, qos_rule_id: str) -> None:
        """Delete a quality of service rule.

        [API documentation: deleteNetworkSwitchQosRule](https://developer.cisco.com/meraki/api-v1/#!delete-network-switch-qos-rule)

        Args:
            network_id: Network ID.
            qos_rule_id: Qos rule ID.

        Returns:
            Successful operation.

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        qos_rule_id = urllib.parse.quote(str(qos_rule_id), safe="")
        path = f"/networks/{network_id}/switch/qosRules/{qos_rule_id}"

        return self._session.delete(
            scope="switch", operation_id="deleteNetworkSwitchQosRule", path=path
        )

    def get_network_switch_routing_multicast(
        self, network_id: str
    ) -> GetNetworkSwitchRoutingMulticastResponse | None:
        """Return multicast settings for a network.

        [API documentation: getNetworkSwitchRoutingMulticast](https://developer.cisco.com/meraki/api-v1/#!get-network-switch-routing-multicast)

        Args:
            network_id: Network ID.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "defaultSettings": {
                "igmpSnoopingEnabled": true,
                "floodUnknownMulticastTrafficEnabled": true
              },
              "overrides": [
                {
                  "switches": [
                    "Q234-ABCD-0001",
                    "Q234-ABCD-0002",
                    "Q234-ABCD-0003"
                  ],
                  "stacks": [
                    "789102",
                    "123456",
                    "129102"
                  ],
                  "switchProfiles": [
                    "1234",
                    "4567"
                  ],
                  "igmpSnoopingEnabled": true,
                  "floodUnknownMulticastTrafficEnabled": true
                }
              ]
            }
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/switch/routing/multicast"

        return self._session.get(
            scope="switch",
            operation_id="getNetworkSwitchRoutingMulticast",
            path=path,
            response_schema=GetNetworkSwitchRoutingMulticastResponse,
        )

    def update_network_switch_routing_multicast(
        self,
        network_id: str,
        *,
        default_settings: UpdateNetworkSwitchRoutingMulticastDefaultSettings | None = None,
        overrides: list[UpdateNetworkSwitchRoutingMulticastOverridesItem] | None = None,
    ) -> UpdateNetworkSwitchRoutingMulticastResponse | None:
        """Update multicast settings for a network.

        [API documentation: updateNetworkSwitchRoutingMulticast](https://developer.cisco.com/meraki/api-v1/#!update-network-switch-routing-multicast)

        Args:
            network_id: Network ID.
            default_settings: Default multicast setting for entire network. IGMP snooping and Flood
                unknown multicast traffic settings are enabled by default.
            overrides: Array of paired switches/stacks/profiles and corresponding multicast
                settings. An empty array will clear the multicast settings.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "defaultSettings": {
                "igmpSnoopingEnabled": true,
                "floodUnknownMulticastTrafficEnabled": true
              },
              "overrides": [
                {
                  "switches": [
                    "Q234-ABCD-0001",
                    "Q234-ABCD-0002",
                    "Q234-ABCD-0003"
                  ],
                  "stacks": [
                    "789102",
                    "123456",
                    "129102"
                  ],
                  "switchProfiles": [
                    "1234",
                    "4567"
                  ],
                  "igmpSnoopingEnabled": true,
                  "floodUnknownMulticastTrafficEnabled": true
                }
              ]
            }
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/switch/routing/multicast"

        payload = {}
        if default_settings is not None:
            payload["defaultSettings"] = default_settings.model_dump(
                by_alias=True, exclude_none=True
            )
        if overrides is not None:
            payload["overrides"] = [
                item.model_dump(by_alias=True, exclude_none=True) for item in overrides
            ]

        return self._session.put(
            scope="switch",
            operation_id="updateNetworkSwitchRoutingMulticast",
            path=path,
            json=payload,
            response_schema=UpdateNetworkSwitchRoutingMulticastResponse,
        )

    def get_network_switch_routing_multicast_rendezvous_points(
        self, network_id: str
    ) -> PaginatedResponse[GetNetworkSwitchRoutingMulticastRendezvousPointsResponseItem]:
        """List multicast rendezvous points.

        [API documentation: getNetworkSwitchRoutingMulticastRendezvousPoints](https://developer.cisco.com/meraki/api-v1/#!get-network-switch-routing-multicast-rendezvous-points)

        Args:
            network_id: Network ID.

        Returns:
            Successful operation.

        Example API response:
            ```json
            [
              {
                "rendezvousPointId": "1234",
                "serial": "Q234-ABCD-5678",
                "interfaceName": "l3_interface_0",
                "interfaceIp": "192.168.1.2",
                "multicastGroup": "Any"
              }
            ]
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/switch/routing/multicast/rendezvousPoints"

        return self._session.get_pages(
            scope="switch",
            operation_id="getNetworkSwitchRoutingMulticastRendezvousPoints",
            path=path,
            item_schema=GetNetworkSwitchRoutingMulticastRendezvousPointsResponseItem,
        )

    def create_network_switch_routing_multicast_rendezvous_point(
        self,
        *,
        network_id: str,
        interface_ip: str,
        multicast_group: str,
        vrf: CreateNetworkSwitchRoutingMulticastRendezvousPointVrf | None = None,
    ) -> CreateNetworkSwitchRoutingMulticastRendezvousPointResponse | None:
        """Create a multicast rendezvous point.

        [API documentation: createNetworkSwitchRoutingMulticastRendezvousPoint](https://developer.cisco.com/meraki/api-v1/#!create-network-switch-routing-multicast-rendezvous-point)

        Args:
            network_id: Network ID.
            interface_ip: The IP address of the interface where the RP needs to be created.
            multicast_group: 'Any', or the IP address of a multicast group.
            vrf: The VRF with PIM enabled L3 interface.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "rendezvousPointId": "1234",
              "serial": "Q234-ABCD-5678",
              "interfaceName": "l3_interface_0",
              "interfaceIp": "192.168.1.2",
              "multicastGroup": "Any"
            }
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/switch/routing/multicast/rendezvousPoints"

        payload = {}
        if interface_ip is not None:
            payload["interfaceIp"] = interface_ip
        if multicast_group is not None:
            payload["multicastGroup"] = multicast_group
        if vrf is not None:
            payload["vrf"] = vrf.model_dump(by_alias=True, exclude_none=True)

        return self._session.post(
            scope="switch",
            operation_id="createNetworkSwitchRoutingMulticastRendezvousPoint",
            path=path,
            json=payload,
            response_schema=CreateNetworkSwitchRoutingMulticastRendezvousPointResponse,
        )

    def get_network_switch_routing_multicast_rendezvous_point(
        self, *, network_id: str, rendezvous_point_id: str
    ) -> GetNetworkSwitchRoutingMulticastRendezvousPointResponse | None:
        """Return a multicast rendezvous point.

        [API documentation: getNetworkSwitchRoutingMulticastRendezvousPoint](https://developer.cisco.com/meraki/api-v1/#!get-network-switch-routing-multicast-rendezvous-point)

        Args:
            network_id: Network ID.
            rendezvous_point_id: Rendezvous point ID.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "rendezvousPointId": "1234",
              "serial": "Q234-ABCD-5678",
              "interfaceName": "l3_interface_0",
              "interfaceIp": "192.168.1.2",
              "multicastGroup": "Any"
            }
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        rendezvous_point_id = urllib.parse.quote(str(rendezvous_point_id), safe="")
        path = f"/networks/{network_id}/switch/routing/multicast/rendezvousPoints/{rendezvous_point_id}"

        return self._session.get(
            scope="switch",
            operation_id="getNetworkSwitchRoutingMulticastRendezvousPoint",
            path=path,
            response_schema=GetNetworkSwitchRoutingMulticastRendezvousPointResponse,
        )

    def update_network_switch_routing_multicast_rendezvous_point(
        self,
        *,
        network_id: str,
        rendezvous_point_id: str,
        interface_ip: str,
        multicast_group: str,
        vrf: UpdateNetworkSwitchRoutingMulticastRendezvousPointVrf | None = None,
    ) -> UpdateNetworkSwitchRoutingMulticastRendezvousPointResponse | None:
        """Update a multicast rendezvous point.

        [API documentation: updateNetworkSwitchRoutingMulticastRendezvousPoint](https://developer.cisco.com/meraki/api-v1/#!update-network-switch-routing-multicast-rendezvous-point)

        Args:
            network_id: Network ID.
            rendezvous_point_id: Rendezvous point ID.
            interface_ip: The IP address of the interface where the RP needs to be created.
            multicast_group: 'Any', or the IP address of a multicast group.
            vrf: The VRF with PIM enabled L3 interface.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "rendezvousPointId": "1234",
              "serial": "Q234-ABCD-5678",
              "interfaceName": "l3_interface_0",
              "interfaceIp": "192.168.1.2",
              "multicastGroup": "Any"
            }
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        rendezvous_point_id = urllib.parse.quote(str(rendezvous_point_id), safe="")
        path = f"/networks/{network_id}/switch/routing/multicast/rendezvousPoints/{rendezvous_point_id}"

        payload = {}
        if interface_ip is not None:
            payload["interfaceIp"] = interface_ip
        if multicast_group is not None:
            payload["multicastGroup"] = multicast_group
        if vrf is not None:
            payload["vrf"] = vrf.model_dump(by_alias=True, exclude_none=True)

        return self._session.put(
            scope="switch",
            operation_id="updateNetworkSwitchRoutingMulticastRendezvousPoint",
            path=path,
            json=payload,
            response_schema=UpdateNetworkSwitchRoutingMulticastRendezvousPointResponse,
        )

    def delete_network_switch_routing_multicast_rendezvous_point(
        self, *, network_id: str, rendezvous_point_id: str
    ) -> None:
        """Delete a multicast rendezvous point.

        [API documentation: deleteNetworkSwitchRoutingMulticastRendezvousPoint](https://developer.cisco.com/meraki/api-v1/#!delete-network-switch-routing-multicast-rendezvous-point)

        Args:
            network_id: Network ID.
            rendezvous_point_id: Rendezvous point ID.

        Returns:
            Successful operation.

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        rendezvous_point_id = urllib.parse.quote(str(rendezvous_point_id), safe="")
        path = f"/networks/{network_id}/switch/routing/multicast/rendezvousPoints/{rendezvous_point_id}"

        return self._session.delete(
            scope="switch",
            operation_id="deleteNetworkSwitchRoutingMulticastRendezvousPoint",
            path=path,
        )

    def get_network_switch_routing_ospf(
        self, network_id: str, *, vrf: str | None = None
    ) -> GetNetworkSwitchRoutingOspfResponse | None:
        """Return layer 3 OSPF routing configuration.

        [API documentation: getNetworkSwitchRoutingOspf](https://developer.cisco.com/meraki/api-v1/#!get-network-switch-routing-ospf)

        Args:
            network_id: Network ID.
            vrf: The VRF to return the OSPF routing configuration for. When not provided, the
                default VRF is used. Included on networks with IOS XE 17.18 or higher.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "enabled": true,
              "helloTimerInSeconds": 10,
              "deadTimerInSeconds": 40,
              "areas": [
                {
                  "areaId": "1284392014819",
                  "areaName": "Backbone",
                  "areaType": "normal"
                }
              ],
              "v3": {
                "enabled": true,
                "helloTimerInSeconds": 10,
                "deadTimerInSeconds": 40,
                "areas": [
                  {
                    "areaId": "1284392014819",
                    "areaName": "V3 Backbone",
                    "areaType": "normal"
                  }
                ]
              },
              "md5AuthenticationEnabled": true,
              "md5AuthenticationKey": {
                "id": 1234,
                "passphrase": "abc1234"
              },
              "vrf": {
                "name": "Blue"
              }
            }
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/switch/routing/ospf"

        params = {}
        if vrf is not None:
            params["vrf"] = vrf

        return self._session.get(
            scope="switch",
            operation_id="getNetworkSwitchRoutingOspf",
            path=path,
            params=params,
            response_schema=GetNetworkSwitchRoutingOspfResponse,
        )

    def update_network_switch_routing_ospf(
        self,
        network_id: str,
        *,
        vrf: str | None = None,
        enabled: bool | None = None,
        hello_timer_in_seconds: int | None = None,
        dead_timer_in_seconds: int | None = None,
        areas: list[UpdateNetworkSwitchRoutingOspfAreasItem] | None = None,
        v3: UpdateNetworkSwitchRoutingOspfV3 | None = None,
        md5_authentication_enabled: bool | None = None,
        md5_authentication_key: UpdateNetworkSwitchRoutingOspfMd5AuthenticationKey | None = None,
    ) -> UpdateNetworkSwitchRoutingOspfResponse | None:
        """Update layer 3 OSPF routing configuration.

        [API documentation: updateNetworkSwitchRoutingOspf](https://developer.cisco.com/meraki/api-v1/#!update-network-switch-routing-ospf)

        Args:
            network_id: Network ID.
            vrf: The VRF to return the OSPF routing configuration for. When not provided, the
                default VRF is used. Requires IOS XE 17.18 or higher.
            enabled: Boolean value to enable or disable OSPF routing. OSPF routing is disabled by
                default.
            hello_timer_in_seconds: Time interval in seconds at which hello packet will be sent to
                OSPF neighbors to maintain connectivity. Value must be between 1 and
                255. Default is 10 seconds.
            dead_timer_in_seconds: Time interval to determine when the peer will be declared
                inactive/dead. Value must be between 1 and 65535.
            areas: OSPF areas.
            v3: OSPF v3 configuration.
            md5_authentication_enabled: Boolean value to enable or disable MD5 authentication. MD5
                authentication is disabled by default.
            md5_authentication_key: MD5 authentication credentials. This param is only relevant if
                md5AuthenticationEnabled is true.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "enabled": true,
              "helloTimerInSeconds": 10,
              "deadTimerInSeconds": 40,
              "areas": [
                {
                  "areaId": "1284392014819",
                  "areaName": "Backbone",
                  "areaType": "normal"
                }
              ],
              "v3": {
                "enabled": true,
                "helloTimerInSeconds": 10,
                "deadTimerInSeconds": 40,
                "areas": [
                  {
                    "areaId": "1284392014819",
                    "areaName": "V3 Backbone",
                    "areaType": "normal"
                  }
                ]
              },
              "md5AuthenticationEnabled": true,
              "md5AuthenticationKey": {
                "id": 1234,
                "passphrase": "abc1234"
              },
              "vrf": {
                "name": "Blue"
              }
            }
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/switch/routing/ospf"

        params = {}
        if vrf is not None:
            params["vrf"] = vrf

        payload = {}
        if enabled is not None:
            payload["enabled"] = enabled
        if hello_timer_in_seconds is not None:
            payload["helloTimerInSeconds"] = hello_timer_in_seconds
        if dead_timer_in_seconds is not None:
            payload["deadTimerInSeconds"] = dead_timer_in_seconds
        if areas is not None:
            payload["areas"] = [item.model_dump(by_alias=True, exclude_none=True) for item in areas]
        if v3 is not None:
            payload["v3"] = v3.model_dump(by_alias=True, exclude_none=True)
        if md5_authentication_enabled is not None:
            payload["md5AuthenticationEnabled"] = md5_authentication_enabled
        if md5_authentication_key is not None:
            payload["md5AuthenticationKey"] = md5_authentication_key.model_dump(
                by_alias=True, exclude_none=True
            )

        return self._session.put(
            scope="switch",
            operation_id="updateNetworkSwitchRoutingOspf",
            path=path,
            json=payload,
            response_schema=UpdateNetworkSwitchRoutingOspfResponse,
        )

    def get_network_switch_settings(
        self, network_id: str
    ) -> GetNetworkSwitchSettingsResponse | None:
        """Returns the switch network settings.

        [API documentation: getNetworkSwitchSettings](https://developer.cisco.com/meraki/api-v1/#!get-network-switch-settings)

        Args:
            network_id: Network ID.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "vlan": 100,
              "useCombinedPower": false,
              "powerExceptions": [
                {
                  "serial": "Q234-ABCD-0001",
                  "powerType": "redundant"
                }
              ],
              "uplinkClientSampling": {
                "enabled": true
              },
              "macBlocklist": {
                "enabled": true
              },
              "uplinkSelection": {
                "failback": {
                  "enabled": true
                },
                "candidates": "all"
              }
            }
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/switch/settings"

        return self._session.get(
            scope="switch",
            operation_id="getNetworkSwitchSettings",
            path=path,
            response_schema=GetNetworkSwitchSettingsResponse,
        )

    def update_network_switch_settings(
        self,
        network_id: str,
        *,
        vlan: int | None = None,
        use_combined_power: bool | None = None,
        power_exceptions: list[UpdateNetworkSwitchSettingsPowerExceptionsItem] | None = None,
        uplink_client_sampling: UpdateNetworkSwitchSettingsUplinkClientSampling | None = None,
        mac_blocklist: UpdateNetworkSwitchSettingsMacBlocklist | None = None,
        uplink_selection: UpdateNetworkSwitchSettingsUplinkSelection | None = None,
    ) -> UpdateNetworkSwitchSettingsResponse | None:
        """Update switch network settings.

        [API documentation: updateNetworkSwitchSettings](https://developer.cisco.com/meraki/api-v1/#!update-network-switch-settings)

        Args:
            network_id: Network ID.
            vlan: Management VLAN.
            use_combined_power: The use Combined Power as the default behavior of secondary power
                supplies on supported devices.
            power_exceptions: Exceptions on a per switch basis to "useCombinedPower".
            uplink_client_sampling: Uplink client sampling.
            mac_blocklist: MAC blocklist.
            uplink_selection: Settings related to uplink selection on IOS-XE switches.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "vlan": 100,
              "useCombinedPower": false,
              "powerExceptions": [
                {
                  "serial": "Q234-ABCD-0001",
                  "powerType": "redundant"
                }
              ],
              "uplinkClientSampling": {
                "enabled": true
              },
              "macBlocklist": {
                "enabled": true
              },
              "uplinkSelection": {
                "failback": {
                  "enabled": true
                },
                "candidates": "all"
              }
            }
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/switch/settings"

        payload = {}
        if vlan is not None:
            payload["vlan"] = vlan
        if use_combined_power is not None:
            payload["useCombinedPower"] = use_combined_power
        if power_exceptions is not None:
            payload["powerExceptions"] = [
                item.model_dump(by_alias=True, exclude_none=True) for item in power_exceptions
            ]
        if uplink_client_sampling is not None:
            payload["uplinkClientSampling"] = uplink_client_sampling.model_dump(
                by_alias=True, exclude_none=True
            )
        if mac_blocklist is not None:
            payload["macBlocklist"] = mac_blocklist.model_dump(by_alias=True, exclude_none=True)
        if uplink_selection is not None:
            payload["uplinkSelection"] = uplink_selection.model_dump(
                by_alias=True, exclude_none=True
            )

        return self._session.put(
            scope="switch",
            operation_id="updateNetworkSwitchSettings",
            path=path,
            json=payload,
            response_schema=UpdateNetworkSwitchSettingsResponse,
        )

    def get_network_switch_stacks(
        self, network_id: str
    ) -> PaginatedResponse[GetNetworkSwitchStacksResponseItem]:
        """List the switch stacks in a network.

        [API documentation: getNetworkSwitchStacks](https://developer.cisco.com/meraki/api-v1/#!get-network-switch-stacks)

        Args:
            network_id: Network ID.

        Returns:
            Successful operation.

        Example API response:
            ```json
            [
              {
                "id": "8473",
                "name": "A cool stack",
                "serials": [
                  "QBZY-XWVU-TSRQ",
                  "QBAB-CDEF-GHIJ"
                ],
                "isMonitorOnly": false,
                "virtualMac": "00:18:0a:4f:21:19",
                "members": [
                  {
                    "serial": "QBZY-XWVU-TSRQ",
                    "name": "switch 1",
                    "model": "MS350-24-HW",
                    "mac": "00:18:0a:00:00:09",
                    "role": "active"
                  }
                ]
              }
            ]
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/switch/stacks"

        return self._session.get_pages(
            scope="switch",
            operation_id="getNetworkSwitchStacks",
            path=path,
            item_schema=GetNetworkSwitchStacksResponseItem,
        )

    def create_network_switch_stack(
        self, *, network_id: str, name: str, serials: list[str]
    ) -> CreateNetworkSwitchStackResponse | None:
        """Create a switch stack.

        [API documentation: createNetworkSwitchStack](https://developer.cisco.com/meraki/api-v1/#!create-network-switch-stack)

        Args:
            network_id: Network ID.
            name: The name of the new stack.
            serials: An array of switch serials to be added into the new stack.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "id": "8473",
              "name": "A cool stack",
              "serials": [
                "QBZY-XWVU-TSRQ",
                "QBAB-CDEF-GHIJ"
              ],
              "workflowId": "8473"
            }
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/switch/stacks"

        payload = {}
        if name is not None:
            payload["name"] = name
        if serials is not None:
            payload["serials"] = serials

        return self._session.post(
            scope="switch",
            operation_id="createNetworkSwitchStack",
            path=path,
            json=payload,
            response_schema=CreateNetworkSwitchStackResponse,
        )

    def get_network_switch_stack(
        self, *, network_id: str, switch_stack_id: str
    ) -> GetNetworkSwitchStackResponse | None:
        """Show a switch stack.

        [API documentation: getNetworkSwitchStack](https://developer.cisco.com/meraki/api-v1/#!get-network-switch-stack)

        Args:
            network_id: Network ID.
            switch_stack_id: Switch stack ID.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "id": "8473",
              "name": "A cool stack",
              "serials": [
                "QBZY-XWVU-TSRQ",
                "QBAB-CDEF-GHIJ"
              ],
              "isMonitorOnly": false,
              "virtualMac": "00:18:0a:4f:21:19",
              "members": [
                {
                  "serial": "QBZY-XWVU-TSRQ",
                  "name": "switch 1",
                  "model": "MS350-24-HW",
                  "mac": "00:18:0a:00:00:09",
                  "role": "active"
                }
              ]
            }
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        switch_stack_id = urllib.parse.quote(str(switch_stack_id), safe="")
        path = f"/networks/{network_id}/switch/stacks/{switch_stack_id}"

        return self._session.get(
            scope="switch",
            operation_id="getNetworkSwitchStack",
            path=path,
            response_schema=GetNetworkSwitchStackResponse,
        )

    def delete_network_switch_stack(self, *, network_id: str, switch_stack_id: str) -> None:
        """Delete a stack.

        [API documentation: deleteNetworkSwitchStack](https://developer.cisco.com/meraki/api-v1/#!delete-network-switch-stack)

        Args:
            network_id: Network ID.
            switch_stack_id: Switch stack ID.

        Returns:
            Successful operation.

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        switch_stack_id = urllib.parse.quote(str(switch_stack_id), safe="")
        path = f"/networks/{network_id}/switch/stacks/{switch_stack_id}"

        return self._session.delete(
            scope="switch", operation_id="deleteNetworkSwitchStack", path=path
        )

    def add_network_switch_stack(
        self, *, network_id: str, switch_stack_id: str, serial: str
    ) -> AddNetworkSwitchStackResponse | None:
        """Add a switch to a stack.

        [API documentation: addNetworkSwitchStack](https://developer.cisco.com/meraki/api-v1/#!add-network-switch-stack)

        Args:
            network_id: Network ID.
            switch_stack_id: Switch stack ID.
            serial: The serial of the switch to be added.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "id": "8473",
              "name": "A cool stack",
              "serials": [
                "QBZY-XWVU-TSRQ",
                "QBAB-CDEF-GHIJ"
              ],
              "isMonitorOnly": false,
              "virtualMac": "00:18:0a:4f:21:19",
              "members": [
                {
                  "serial": "QBZY-XWVU-TSRQ",
                  "name": "switch 1",
                  "model": "MS350-24-HW",
                  "mac": "00:18:0a:00:00:09",
                  "role": "active"
                }
              ]
            }
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        switch_stack_id = urllib.parse.quote(str(switch_stack_id), safe="")
        path = f"/networks/{network_id}/switch/stacks/{switch_stack_id}/add"

        payload = {}
        if serial is not None:
            payload["serial"] = serial

        return self._session.post(
            scope="switch",
            operation_id="addNetworkSwitchStack",
            path=path,
            json=payload,
            response_schema=AddNetworkSwitchStackResponse,
        )

    def remove_network_switch_stack(
        self, *, network_id: str, switch_stack_id: str, serial: str
    ) -> RemoveNetworkSwitchStackResponse | None:
        """Remove a switch from a stack.

        [API documentation: removeNetworkSwitchStack](https://developer.cisco.com/meraki/api-v1/#!remove-network-switch-stack)

        Args:
            network_id: Network ID.
            switch_stack_id: Switch stack ID.
            serial: The serial of the switch to be removed.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "id": "8473",
              "name": "A cool stack",
              "serials": [
                "QBZY-XWVU-TSRQ",
                "QBAB-CDEF-GHIJ"
              ],
              "isMonitorOnly": false,
              "virtualMac": "00:18:0a:4f:21:19",
              "members": [
                {
                  "serial": "QBZY-XWVU-TSRQ",
                  "name": "switch 1",
                  "model": "MS350-24-HW",
                  "mac": "00:18:0a:00:00:09",
                  "role": "active"
                }
              ]
            }
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        switch_stack_id = urllib.parse.quote(str(switch_stack_id), safe="")
        path = f"/networks/{network_id}/switch/stacks/{switch_stack_id}/remove"

        payload = {}
        if serial is not None:
            payload["serial"] = serial

        return self._session.post(
            scope="switch",
            operation_id="removeNetworkSwitchStack",
            path=path,
            json=payload,
            response_schema=RemoveNetworkSwitchStackResponse,
        )

    def get_network_switch_stack_routing_interfaces(
        self,
        *,
        network_id: str,
        switch_stack_id: str,
        mode: str | None = None,
        protocol: str | None = None,
    ) -> PaginatedResponse[GetNetworkSwitchStackRoutingInterfacesResponseItem]:
        """List layer 3 interfaces for a switch stack.

        [API documentation: getNetworkSwitchStackRoutingInterfaces](https://developer.cisco.com/meraki/api-v1/#!get-network-switch-stack-routing-interfaces)

        Args:
            network_id: Network ID.
            switch_stack_id: Switch stack ID.
            mode: Optional parameter to filter L3 interfaces by mode.
            protocol: Optional parameter to filter L3 interfaces by protocol.

        Returns:
            Successful operation.

        Example API response:
            ```json
            [
              {
                "interfaceId": "1234",
                "name": "L3 interface",
                "mode": "vlan",
                "subnet": "192.168.1.0/24",
                "interfaceIp": "192.168.1.2",
                "serial": "Q234-ABCD-5678",
                "switchPortId": "1",
                "multicastRouting": "disabled",
                "vlanId": 100,
                "uplinkV4": false,
                "uplinkV6": false,
                "ospfSettings": {
                  "area": "0",
                  "cost": 1,
                  "isPassiveEnabled": true,
                  "networkType": "broadcast"
                },
                "ospfV3": {
                  "area": "1",
                  "cost": 2,
                  "isPassiveEnabled": true,
                  "networkType": "broadcast"
                },
                "ipv6": {
                  "assignmentMode": "static",
                  "address": "2001:db8::1",
                  "prefix": "2001:db8::/32",
                  "gateway": "2001:db8::2"
                },
                "vrf": {
                  "name": "Blue"
                },
                "defaultGateway": "192.168.1.1"
              }
            ]
            ```

        """
        if mode is not None:
            options = ["loopback", "oob_management", "routed", "vlan"]
            assert mode in options, f'"mode" cannot be "{mode}", & must be set to one of: {options}'
        if protocol is not None:
            options = ["ipv4", "ipv6"]
            assert protocol in options, (
                f'"protocol" cannot be "{protocol}", & must be set to one of: {options}'
            )

        network_id = urllib.parse.quote(str(network_id), safe="")
        switch_stack_id = urllib.parse.quote(str(switch_stack_id), safe="")
        path = f"/networks/{network_id}/switch/stacks/{switch_stack_id}/routing/interfaces"

        params = {}
        if mode is not None:
            params["mode"] = mode
        if protocol is not None:
            params["protocol"] = protocol

        return self._session.get_pages(
            scope="switch",
            operation_id="getNetworkSwitchStackRoutingInterfaces",
            path=path,
            params=params,
            item_schema=GetNetworkSwitchStackRoutingInterfacesResponseItem,
        )

    def create_network_switch_stack_routing_interface(
        self,
        *,
        network_id: str,
        switch_stack_id: str,
        name: str,
        mode: str | None = None,
        subnet: str | None = None,
        switch_port_id: str | None = None,
        interface_ip: str | None = None,
        multicast_routing: str | None = None,
        vlan_id: int | None = None,
        default_gateway: str | None = None,
        ospf_settings: CreateNetworkSwitchStackRoutingInterfaceOspfSettings | None = None,
        ipv6: CreateNetworkSwitchStackRoutingInterfaceIpv6 | None = None,
        vrf: CreateNetworkSwitchStackRoutingInterfaceVrf | None = None,
        loopback: dict[str, Any] | None = None,
    ) -> CreateNetworkSwitchStackRoutingInterfaceResponse | None:
        """Create a layer 3 interface for a switch stack.

        [API documentation: createNetworkSwitchStackRoutingInterface](https://developer.cisco.com/meraki/api-v1/#!create-network-switch-stack-routing-interface)

        Args:
            network_id: Network ID.
            switch_stack_id: Switch stack ID.
            name: A friendly name or description for the interface or VLAN (max length 128
                characters).
            mode: L3 Interface mode, can be one of 'vlan', 'routed', 'loopback'. Default is 'vlan'.
                CS 17.18 or higher is required for 'routed' mode.
            subnet: The network that this L3 interface is on, in CIDR notation (ex. 10.1.1.0/24).
            switch_port_id: Switch Port ID when in Routed mode (CS 17.18 or higher required).
            interface_ip: The IP address that will be used for Layer 3 routing on this VLAN or
                subnet. This cannot be the same as the device management IP.
            multicast_routing: Enable multicast support if, multicast routing between VLANs is
                required. Options are: 'disabled', 'enabled' or 'IGMP snooping querier'.
                Default is 'disabled'.
            vlan_id: The VLAN this L3 interface is on. VLAN must be between 1 and 4094.
            default_gateway: The next hop for any traffic that isn't going to a directly connected
                subnet or over a static route. This IP address must exist in a subnet
                with a L3 interface. Required if this is the first IPv4 interface.
            ospf_settings: The OSPF routing settings of the interface.
            ipv6: The IPv6 settings of the interface.
            vrf: The VRF settings of the interface. Requires IOS XE 17.18 or higher.
            loopback: The loopback settings of the interface.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "interfaceId": "1234",
              "name": "L3 interface",
              "mode": "vlan",
              "subnet": "192.168.1.0/24",
              "interfaceIp": "192.168.1.2",
              "serial": "Q234-ABCD-5678",
              "switchPortId": "1",
              "multicastRouting": "disabled",
              "vlanId": 100,
              "uplinkV4": false,
              "uplinkV6": false,
              "ospfSettings": {
                "area": "0",
                "cost": 1,
                "isPassiveEnabled": true,
                "networkType": "broadcast"
              },
              "ospfV3": {
                "area": "1",
                "cost": 2,
                "isPassiveEnabled": true,
                "networkType": "broadcast"
              },
              "ipv6": {
                "assignmentMode": "static",
                "address": "2001:db8::1",
                "prefix": "2001:db8::/32",
                "gateway": "2001:db8::2"
              },
              "vrf": {
                "name": "Blue"
              },
              "defaultGateway": "192.168.1.1"
            }
            ```

        """
        if mode is not None:
            options = ["loopback", "oob_management", "routed", "vlan"]
            assert mode in options, f'"mode" cannot be "{mode}", & must be set to one of: {options}'
        if multicast_routing is not None:
            options = ["IGMP snooping querier", "disabled", "enabled"]
            assert multicast_routing in options, (
                f'"multicast_routing" cannot be "{multicast_routing}", & must be set to one of: {options}'
            )

        network_id = urllib.parse.quote(str(network_id), safe="")
        switch_stack_id = urllib.parse.quote(str(switch_stack_id), safe="")
        path = f"/networks/{network_id}/switch/stacks/{switch_stack_id}/routing/interfaces"

        payload = {}
        if name is not None:
            payload["name"] = name
        if mode is not None:
            payload["mode"] = mode
        if subnet is not None:
            payload["subnet"] = subnet
        if switch_port_id is not None:
            payload["switchPortId"] = switch_port_id
        if interface_ip is not None:
            payload["interfaceIp"] = interface_ip
        if multicast_routing is not None:
            payload["multicastRouting"] = multicast_routing
        if vlan_id is not None:
            payload["vlanId"] = vlan_id
        if default_gateway is not None:
            payload["defaultGateway"] = default_gateway
        if ospf_settings is not None:
            payload["ospfSettings"] = ospf_settings.model_dump(by_alias=True, exclude_none=True)
        if ipv6 is not None:
            payload["ipv6"] = ipv6.model_dump(by_alias=True, exclude_none=True)
        if vrf is not None:
            payload["vrf"] = vrf.model_dump(by_alias=True, exclude_none=True)
        if loopback is not None:
            payload["loopback"] = loopback

        return self._session.post(
            scope="switch",
            operation_id="createNetworkSwitchStackRoutingInterface",
            path=path,
            json=payload,
            response_schema=CreateNetworkSwitchStackRoutingInterfaceResponse,
        )

    def get_network_switch_stack_routing_interface(
        self, *, network_id: str, switch_stack_id: str, interface_id: str
    ) -> GetNetworkSwitchStackRoutingInterfaceResponse | None:
        """Return a layer 3 interface from a switch stack.

        [API documentation: getNetworkSwitchStackRoutingInterface](https://developer.cisco.com/meraki/api-v1/#!get-network-switch-stack-routing-interface)

        Args:
            network_id: Network ID.
            switch_stack_id: Switch stack ID.
            interface_id: Interface ID.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "interfaceId": "1234",
              "name": "L3 interface",
              "mode": "vlan",
              "subnet": "192.168.1.0/24",
              "interfaceIp": "192.168.1.2",
              "serial": "Q234-ABCD-5678",
              "switchPortId": "1",
              "multicastRouting": "disabled",
              "vlanId": 100,
              "uplinkV4": false,
              "uplinkV6": false,
              "ospfSettings": {
                "area": "0",
                "cost": 1,
                "isPassiveEnabled": true,
                "networkType": "broadcast"
              },
              "ospfV3": {
                "area": "1",
                "cost": 2,
                "isPassiveEnabled": true,
                "networkType": "broadcast"
              },
              "ipv6": {
                "assignmentMode": "static",
                "address": "2001:db8::1",
                "prefix": "2001:db8::/32",
                "gateway": "2001:db8::2"
              },
              "vrf": {
                "name": "Blue"
              },
              "defaultGateway": "192.168.1.1"
            }
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        switch_stack_id = urllib.parse.quote(str(switch_stack_id), safe="")
        interface_id = urllib.parse.quote(str(interface_id), safe="")
        path = f"/networks/{network_id}/switch/stacks/{switch_stack_id}/routing/interfaces/{interface_id}"

        return self._session.get(
            scope="switch",
            operation_id="getNetworkSwitchStackRoutingInterface",
            path=path,
            response_schema=GetNetworkSwitchStackRoutingInterfaceResponse,
        )

    def update_network_switch_stack_routing_interface(
        self,
        *,
        network_id: str,
        switch_stack_id: str,
        interface_id: str,
        name: str | None = None,
        subnet: str | None = None,
        switch_port_id: str | None = None,
        interface_ip: str | None = None,
        multicast_routing: str | None = None,
        vlan_id: int | None = None,
        default_gateway: str | None = None,
        ospf_settings: UpdateNetworkSwitchStackRoutingInterfaceOspfSettings | None = None,
        ipv6: UpdateNetworkSwitchStackRoutingInterfaceIpv6 | None = None,
        vrf: UpdateNetworkSwitchStackRoutingInterfaceVrf | None = None,
        loopback: dict[str, Any] | None = None,
    ) -> UpdateNetworkSwitchStackRoutingInterfaceResponse | None:
        """Update a layer 3 interface for a switch stack.

        [API documentation: updateNetworkSwitchStackRoutingInterface](https://developer.cisco.com/meraki/api-v1/#!update-network-switch-stack-routing-interface)

        Args:
            network_id: Network ID.
            switch_stack_id: Switch stack ID.
            interface_id: Interface ID.
            name: A friendly name or description for the interface or VLAN (max length 128
                characters).
            subnet: The network that this L3 interface is on, in CIDR notation (ex. 10.1.1.0/24).
            switch_port_id: Switch Port ID when in Routed mode (CS 17.18 or higher required).
            interface_ip: The IP address that will be used for Layer 3 routing on this VLAN or
                subnet. This cannot be the same as the device management IP.
            multicast_routing: Enable multicast support if, multicast routing between VLANs is
                required. Options are: 'disabled', 'enabled' or 'IGMP snooping querier'.
                Default is 'disabled'.
            vlan_id: The VLAN this L3 interface is on. VLAN must be between 1 and 4094.
            default_gateway: The next hop for any traffic that isn't going to a directly connected
                subnet or over a static route. This IP address must exist in a subnet
                with a L3 interface. Required if this is the first IPv4 interface.
            ospf_settings: The OSPF routing settings of the interface.
            ipv6: The IPv6 settings of the interface.
            vrf: The VRF settings of the interface. Requires IOS XE 17.18 or higher.
            loopback: The loopback settings of the interface.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "interfaceId": "1234",
              "name": "L3 interface",
              "mode": "vlan",
              "subnet": "192.168.1.0/24",
              "interfaceIp": "192.168.1.2",
              "serial": "Q234-ABCD-5678",
              "switchPortId": "1",
              "multicastRouting": "disabled",
              "vlanId": 100,
              "uplinkV4": false,
              "uplinkV6": false,
              "ospfSettings": {
                "area": "0",
                "cost": 1,
                "isPassiveEnabled": true,
                "networkType": "broadcast"
              },
              "ospfV3": {
                "area": "1",
                "cost": 2,
                "isPassiveEnabled": true,
                "networkType": "broadcast"
              },
              "ipv6": {
                "assignmentMode": "static",
                "address": "2001:db8::1",
                "prefix": "2001:db8::/32",
                "gateway": "2001:db8::2"
              },
              "vrf": {
                "name": "Blue"
              }
            }
            ```

        """
        if multicast_routing is not None:
            options = ["IGMP snooping querier", "disabled", "enabled"]
            assert multicast_routing in options, (
                f'"multicast_routing" cannot be "{multicast_routing}", & must be set to one of: {options}'
            )

        network_id = urllib.parse.quote(str(network_id), safe="")
        switch_stack_id = urllib.parse.quote(str(switch_stack_id), safe="")
        interface_id = urllib.parse.quote(str(interface_id), safe="")
        path = f"/networks/{network_id}/switch/stacks/{switch_stack_id}/routing/interfaces/{interface_id}"

        payload = {}
        if name is not None:
            payload["name"] = name
        if subnet is not None:
            payload["subnet"] = subnet
        if switch_port_id is not None:
            payload["switchPortId"] = switch_port_id
        if interface_ip is not None:
            payload["interfaceIp"] = interface_ip
        if multicast_routing is not None:
            payload["multicastRouting"] = multicast_routing
        if vlan_id is not None:
            payload["vlanId"] = vlan_id
        if default_gateway is not None:
            payload["defaultGateway"] = default_gateway
        if ospf_settings is not None:
            payload["ospfSettings"] = ospf_settings.model_dump(by_alias=True, exclude_none=True)
        if ipv6 is not None:
            payload["ipv6"] = ipv6.model_dump(by_alias=True, exclude_none=True)
        if vrf is not None:
            payload["vrf"] = vrf.model_dump(by_alias=True, exclude_none=True)
        if loopback is not None:
            payload["loopback"] = loopback

        return self._session.put(
            scope="switch",
            operation_id="updateNetworkSwitchStackRoutingInterface",
            path=path,
            json=payload,
            response_schema=UpdateNetworkSwitchStackRoutingInterfaceResponse,
        )

    def delete_network_switch_stack_routing_interface(
        self, *, network_id: str, switch_stack_id: str, interface_id: str
    ) -> None:
        """Delete a layer 3 interface from a switch stack.

        [API documentation: deleteNetworkSwitchStackRoutingInterface](https://developer.cisco.com/meraki/api-v1/#!delete-network-switch-stack-routing-interface)

        Args:
            network_id: Network ID.
            switch_stack_id: Switch stack ID.
            interface_id: Interface ID.

        Returns:
            Successful operation.

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        switch_stack_id = urllib.parse.quote(str(switch_stack_id), safe="")
        interface_id = urllib.parse.quote(str(interface_id), safe="")
        path = f"/networks/{network_id}/switch/stacks/{switch_stack_id}/routing/interfaces/{interface_id}"

        return self._session.delete(
            scope="switch", operation_id="deleteNetworkSwitchStackRoutingInterface", path=path
        )

    def get_network_switch_stack_routing_interface_dhcp(
        self, *, network_id: str, switch_stack_id: str, interface_id: str
    ) -> GetNetworkSwitchStackRoutingInterfaceDhcpResponse | None:
        """Return a layer 3 interface DHCP configuration for a switch stack.

        [API documentation: getNetworkSwitchStackRoutingInterfaceDhcp](https://developer.cisco.com/meraki/api-v1/#!get-network-switch-stack-routing-interface-dhcp)

        Args:
            network_id: Network ID.
            switch_stack_id: Switch stack ID.
            interface_id: Interface ID.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "dhcpMode": "dhcpServer",
              "dhcpRelayServerIps": [
                "1.2.3.4"
              ],
              "dhcpLeaseTime": "1 day",
              "dnsNameserversOption": "custom",
              "dnsCustomNameservers": [
                "8.8.8.8, 8.8.4.4"
              ],
              "bootOptionsEnabled": true,
              "bootNextServer": "1.2.3.4",
              "bootFileName": "home_boot_file",
              "dhcpOptions": [
                {
                  "code": "5",
                  "type": "text",
                  "value": "five"
                }
              ],
              "reservedIpRanges": [
                {
                  "start": "192.168.1.1",
                  "end": "192.168.1.10",
                  "comment": "A reserved IP range"
                }
              ],
              "fixedIpAssignments": [
                {
                  "name": "Cisco Meraki valued client",
                  "mac": "22:33:44:55:66:77",
                  "ip": "192.168.1.12"
                }
              ]
            }
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        switch_stack_id = urllib.parse.quote(str(switch_stack_id), safe="")
        interface_id = urllib.parse.quote(str(interface_id), safe="")
        path = f"/networks/{network_id}/switch/stacks/{switch_stack_id}/routing/interfaces/{interface_id}/dhcp"

        return self._session.get(
            scope="switch",
            operation_id="getNetworkSwitchStackRoutingInterfaceDhcp",
            path=path,
            response_schema=GetNetworkSwitchStackRoutingInterfaceDhcpResponse,
        )

    def update_network_switch_stack_routing_interface_dhcp(
        self,
        *,
        network_id: str,
        switch_stack_id: str,
        interface_id: str,
        dhcp_mode: str | None = None,
        dhcp_relay_server_ips: list[str] | None = None,
        dhcp_lease_time: str | None = None,
        dns_nameservers_option: str | None = None,
        dns_custom_nameservers: list[str] | None = None,
        boot_options_enabled: bool | None = None,
        boot_next_server: str | None = None,
        boot_file_name: str | None = None,
        dhcp_options: list[UpdateNetworkSwitchStackRoutingInterfaceDhcpDhcpOptionsItem]
        | None = None,
        reserved_ip_ranges: list[UpdateNetworkSwitchStackRoutingInterfaceDhcpReservedIpRangesItem]
        | None = None,
        fixed_ip_assignments: list[
            UpdateNetworkSwitchStackRoutingInterfaceDhcpFixedIpAssignmentsItem
        ]
        | None = None,
    ) -> UpdateNetworkSwitchStackRoutingInterfaceDhcpResponse | None:
        """Update a layer 3 interface DHCP configuration for a switch stack.

        [API documentation: updateNetworkSwitchStackRoutingInterfaceDhcp](https://developer.cisco.com/meraki/api-v1/#!update-network-switch-stack-routing-interface-dhcp)

        Args:
            network_id: Network ID.
            switch_stack_id: Switch stack ID.
            interface_id: Interface ID.
            dhcp_mode: The DHCP mode options for the switch stack interface ('dhcpDisabled',
                'dhcpRelay' or 'dhcpServer').
            dhcp_relay_server_ips: The DHCP relay server IPs to which DHCP packets would get relayed
                for the switch stack interface.
            dhcp_lease_time: The DHCP lease time config for the dhcp server running on switch stack
                interface ('30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1
                week').
            dns_nameservers_option: The DHCP name server option for the dhcp server running on the
                switch stack interface ('googlePublicDns', 'openDns' or 'custom').
            dns_custom_nameservers: The DHCP name server IPs when DHCP name server option is '
                custom'.
            boot_options_enabled: Enable DHCP boot options to provide PXE boot options configs for
                the dhcp server running on the switch stack interface.
            boot_next_server: The PXE boot server IP for the DHCP server running on the switch stack
                interface.
            boot_file_name: The PXE boot server file name for the DHCP server running on the switch
                stack interface.
            dhcp_options: Array of DHCP options consisting of code, type and value for the DHCP
                server running on the switch stack interface.
            reserved_ip_ranges: Array of DHCP reserved IP assignments for the DHCP server running on
                the switch stack interface.
            fixed_ip_assignments: Array of DHCP fixed IP assignments for the DHCP server running on
                the switch stack interface.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "dhcpMode": "dhcpServer",
              "dhcpRelayServerIps": [
                "1.2.3.4"
              ],
              "dhcpLeaseTime": "1 day",
              "dnsNameserversOption": "custom",
              "dnsCustomNameservers": [
                "8.8.8.8, 8.8.4.4"
              ],
              "bootOptionsEnabled": true,
              "bootNextServer": "1.2.3.4",
              "bootFileName": "home_boot_file",
              "dhcpOptions": [
                {
                  "code": "5",
                  "type": "text",
                  "value": "five"
                }
              ],
              "reservedIpRanges": [
                {
                  "start": "192.168.1.1",
                  "end": "192.168.1.10",
                  "comment": "A reserved IP range"
                }
              ],
              "fixedIpAssignments": [
                {
                  "name": "Cisco Meraki valued client",
                  "mac": "22:33:44:55:66:77",
                  "ip": "192.168.1.12"
                }
              ]
            }
            ```

        """
        if dhcp_mode is not None:
            options = ["dhcpDisabled", "dhcpRelay", "dhcpServer"]
            assert dhcp_mode in options, (
                f'"dhcp_mode" cannot be "{dhcp_mode}", & must be set to one of: {options}'
            )
        if dhcp_lease_time is not None:
            options = ["1 day", "1 hour", "1 week", "12 hours", "30 minutes", "4 hours"]
            assert dhcp_lease_time in options, (
                f'"dhcp_lease_time" cannot be "{dhcp_lease_time}", & must be set to one of: {options}'
            )
        if dns_nameservers_option is not None:
            options = ["custom", "googlePublicDns", "openDns"]
            assert dns_nameservers_option in options, (
                f'"dns_nameservers_option" cannot be "{dns_nameservers_option}", & must be set to one of: {options}'
            )

        network_id = urllib.parse.quote(str(network_id), safe="")
        switch_stack_id = urllib.parse.quote(str(switch_stack_id), safe="")
        interface_id = urllib.parse.quote(str(interface_id), safe="")
        path = f"/networks/{network_id}/switch/stacks/{switch_stack_id}/routing/interfaces/{interface_id}/dhcp"

        payload = {}
        if dhcp_mode is not None:
            payload["dhcpMode"] = dhcp_mode
        if dhcp_relay_server_ips is not None:
            payload["dhcpRelayServerIps"] = dhcp_relay_server_ips
        if dhcp_lease_time is not None:
            payload["dhcpLeaseTime"] = dhcp_lease_time
        if dns_nameservers_option is not None:
            payload["dnsNameserversOption"] = dns_nameservers_option
        if dns_custom_nameservers is not None:
            payload["dnsCustomNameservers"] = dns_custom_nameservers
        if boot_options_enabled is not None:
            payload["bootOptionsEnabled"] = boot_options_enabled
        if boot_next_server is not None:
            payload["bootNextServer"] = boot_next_server
        if boot_file_name is not None:
            payload["bootFileName"] = boot_file_name
        if dhcp_options is not None:
            payload["dhcpOptions"] = [
                item.model_dump(by_alias=True, exclude_none=True) for item in dhcp_options
            ]
        if reserved_ip_ranges is not None:
            payload["reservedIpRanges"] = [
                item.model_dump(by_alias=True, exclude_none=True) for item in reserved_ip_ranges
            ]
        if fixed_ip_assignments is not None:
            payload["fixedIpAssignments"] = [
                item.model_dump(by_alias=True, exclude_none=True) for item in fixed_ip_assignments
            ]

        return self._session.put(
            scope="switch",
            operation_id="updateNetworkSwitchStackRoutingInterfaceDhcp",
            path=path,
            json=payload,
            response_schema=UpdateNetworkSwitchStackRoutingInterfaceDhcpResponse,
        )

    def get_network_switch_stack_routing_static_routes(
        self, *, network_id: str, switch_stack_id: str
    ) -> PaginatedResponse[GetNetworkSwitchStackRoutingStaticRoutesResponseItem]:
        """List layer 3 static routes for a switch stack.

        [API documentation: getNetworkSwitchStackRoutingStaticRoutes](https://developer.cisco.com/meraki/api-v1/#!get-network-switch-stack-routing-static-routes)

        Args:
            network_id: Network ID.
            switch_stack_id: Switch stack ID.

        Returns:
            Successful operation.

        Example API response:
            ```json
            [
              {
                "staticRouteId": "1234",
                "name": "My route",
                "subnet": "192.168.1.0/24",
                "nextHopIp": "1.2.3.4",
                "managementNextHop": "1.2.3.5",
                "vrf": {
                  "name": "Blue",
                  "leakRouteToDefaultVrf": false
                },
                "advertiseViaOspfEnabled": false,
                "preferOverOspfRoutesEnabled": false
              }
            ]
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        switch_stack_id = urllib.parse.quote(str(switch_stack_id), safe="")
        path = f"/networks/{network_id}/switch/stacks/{switch_stack_id}/routing/staticRoutes"

        return self._session.get_pages(
            scope="switch",
            operation_id="getNetworkSwitchStackRoutingStaticRoutes",
            path=path,
            item_schema=GetNetworkSwitchStackRoutingStaticRoutesResponseItem,
        )

    def create_network_switch_stack_routing_static_route(
        self,
        *,
        network_id: str,
        switch_stack_id: str,
        subnet: str,
        next_hop_ip: str,
        name: str | None = None,
        advertise_via_ospf_enabled: bool | None = None,
        prefer_over_ospf_routes_enabled: bool | None = None,
        vrf: CreateNetworkSwitchStackRoutingStaticRouteVrf | None = None,
    ) -> CreateNetworkSwitchStackRoutingStaticRouteResponse | None:
        """Create a layer 3 static route for a switch stack.

        [API documentation: createNetworkSwitchStackRoutingStaticRoute](https://developer.cisco.com/meraki/api-v1/#!create-network-switch-stack-routing-static-route)

        Args:
            network_id: Network ID.
            switch_stack_id: Switch stack ID.
            name: Name or description for layer 3 static route.
            subnet: The subnet which is routed via this static route and should be specified in CIDR
                notation (ex. 1.2.3.0/24).
            next_hop_ip: IP address of the next hop device to which the device sends its traffic for
                the subnet.
            advertise_via_ospf_enabled: Option to advertise static route via OSPF.
            prefer_over_ospf_routes_enabled: Option to prefer static route over OSPF routes.
            vrf: The VRF settings of the interface. Requires IOS XE 17.18 or higher.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "staticRouteId": "1234",
              "name": "My route",
              "subnet": "192.168.1.0/24",
              "nextHopIp": "1.2.3.4",
              "managementNextHop": "1.2.3.5",
              "vrf": {
                "name": "Blue",
                "leakRouteToDefaultVrf": false
              },
              "advertiseViaOspfEnabled": false,
              "preferOverOspfRoutesEnabled": false
            }
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        switch_stack_id = urllib.parse.quote(str(switch_stack_id), safe="")
        path = f"/networks/{network_id}/switch/stacks/{switch_stack_id}/routing/staticRoutes"

        payload = {}
        if name is not None:
            payload["name"] = name
        if subnet is not None:
            payload["subnet"] = subnet
        if next_hop_ip is not None:
            payload["nextHopIp"] = next_hop_ip
        if advertise_via_ospf_enabled is not None:
            payload["advertiseViaOspfEnabled"] = advertise_via_ospf_enabled
        if prefer_over_ospf_routes_enabled is not None:
            payload["preferOverOspfRoutesEnabled"] = prefer_over_ospf_routes_enabled
        if vrf is not None:
            payload["vrf"] = vrf.model_dump(by_alias=True, exclude_none=True)

        return self._session.post(
            scope="switch",
            operation_id="createNetworkSwitchStackRoutingStaticRoute",
            path=path,
            json=payload,
            response_schema=CreateNetworkSwitchStackRoutingStaticRouteResponse,
        )

    def get_network_switch_stack_routing_static_route(
        self, *, network_id: str, switch_stack_id: str, static_route_id: str
    ) -> GetNetworkSwitchStackRoutingStaticRouteResponse | None:
        """Return a layer 3 static route for a switch stack.

        [API documentation: getNetworkSwitchStackRoutingStaticRoute](https://developer.cisco.com/meraki/api-v1/#!get-network-switch-stack-routing-static-route)

        Args:
            network_id: Network ID.
            switch_stack_id: Switch stack ID.
            static_route_id: Static route ID.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "staticRouteId": "1234",
              "name": "My route",
              "subnet": "192.168.1.0/24",
              "nextHopIp": "1.2.3.4",
              "managementNextHop": "1.2.3.5",
              "vrf": {
                "name": "Blue",
                "leakRouteToDefaultVrf": false
              },
              "advertiseViaOspfEnabled": false,
              "preferOverOspfRoutesEnabled": false
            }
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        switch_stack_id = urllib.parse.quote(str(switch_stack_id), safe="")
        static_route_id = urllib.parse.quote(str(static_route_id), safe="")
        path = f"/networks/{network_id}/switch/stacks/{switch_stack_id}/routing/staticRoutes/{static_route_id}"

        return self._session.get(
            scope="switch",
            operation_id="getNetworkSwitchStackRoutingStaticRoute",
            path=path,
            response_schema=GetNetworkSwitchStackRoutingStaticRouteResponse,
        )

    def update_network_switch_stack_routing_static_route(
        self,
        *,
        network_id: str,
        switch_stack_id: str,
        static_route_id: str,
        name: str | None = None,
        subnet: str | None = None,
        next_hop_ip: str | None = None,
        management_next_hop: str | None = None,
        advertise_via_ospf_enabled: bool | None = None,
        prefer_over_ospf_routes_enabled: bool | None = None,
        vrf: UpdateNetworkSwitchStackRoutingStaticRouteVrf | None = None,
    ) -> UpdateNetworkSwitchStackRoutingStaticRouteResponse | None:
        """Update a layer 3 static route for a switch stack.

        [API documentation: updateNetworkSwitchStackRoutingStaticRoute](https://developer.cisco.com/meraki/api-v1/#!update-network-switch-stack-routing-static-route)

        Args:
            network_id: Network ID.
            switch_stack_id: Switch stack ID.
            static_route_id: Static route ID.
            name: Name or description for layer 3 static route.
            subnet: The subnet which is routed via this static route and should be specified in CIDR
                notation (ex. 1.2.3.0/24).
            next_hop_ip: IP address of the next hop device to which the device sends its traffic for
                the subnet.
            management_next_hop: Optional fallback IP address for management traffic.
            advertise_via_ospf_enabled: Option to advertise static route via OSPF.
            prefer_over_ospf_routes_enabled: Option to prefer static route over OSPF routes.
            vrf: The VRF settings of the interface. Requires IOS XE 17.18 or higher.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "staticRouteId": "1234",
              "name": "My route",
              "subnet": "192.168.1.0/24",
              "nextHopIp": "1.2.3.4",
              "managementNextHop": "1.2.3.5",
              "vrf": {
                "name": "Blue",
                "leakRouteToDefaultVrf": false
              },
              "advertiseViaOspfEnabled": false,
              "preferOverOspfRoutesEnabled": false
            }
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        switch_stack_id = urllib.parse.quote(str(switch_stack_id), safe="")
        static_route_id = urllib.parse.quote(str(static_route_id), safe="")
        path = f"/networks/{network_id}/switch/stacks/{switch_stack_id}/routing/staticRoutes/{static_route_id}"

        payload = {}
        if name is not None:
            payload["name"] = name
        if subnet is not None:
            payload["subnet"] = subnet
        if next_hop_ip is not None:
            payload["nextHopIp"] = next_hop_ip
        if management_next_hop is not None:
            payload["managementNextHop"] = management_next_hop
        if advertise_via_ospf_enabled is not None:
            payload["advertiseViaOspfEnabled"] = advertise_via_ospf_enabled
        if prefer_over_ospf_routes_enabled is not None:
            payload["preferOverOspfRoutesEnabled"] = prefer_over_ospf_routes_enabled
        if vrf is not None:
            payload["vrf"] = vrf.model_dump(by_alias=True, exclude_none=True)

        return self._session.put(
            scope="switch",
            operation_id="updateNetworkSwitchStackRoutingStaticRoute",
            path=path,
            json=payload,
            response_schema=UpdateNetworkSwitchStackRoutingStaticRouteResponse,
        )

    def delete_network_switch_stack_routing_static_route(
        self, *, network_id: str, switch_stack_id: str, static_route_id: str
    ) -> None:
        """Delete a layer 3 static route for a switch stack.

        [API documentation: deleteNetworkSwitchStackRoutingStaticRoute](https://developer.cisco.com/meraki/api-v1/#!delete-network-switch-stack-routing-static-route)

        Args:
            network_id: Network ID.
            switch_stack_id: Switch stack ID.
            static_route_id: Static route ID.

        Returns:
            Successful operation.

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        switch_stack_id = urllib.parse.quote(str(switch_stack_id), safe="")
        static_route_id = urllib.parse.quote(str(static_route_id), safe="")
        path = f"/networks/{network_id}/switch/stacks/{switch_stack_id}/routing/staticRoutes/{static_route_id}"

        return self._session.delete(
            scope="switch", operation_id="deleteNetworkSwitchStackRoutingStaticRoute", path=path
        )

    def get_network_switch_storm_control(
        self, network_id: str
    ) -> GetNetworkSwitchStormControlResponse | None:
        """Return the storm control configuration for a switch network.

        [API documentation: getNetworkSwitchStormControl](https://developer.cisco.com/meraki/api-v1/#!get-network-switch-storm-control)

        Args:
            network_id: Network ID.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "broadcastThreshold": 30,
              "multicastThreshold": 30,
              "unknownUnicastThreshold": 30,
              "treatTheseTrafficTypesAsOneThreshold": [
                "broadcast",
                "multicast"
              ]
            }
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/switch/stormControl"

        return self._session.get(
            scope="switch",
            operation_id="getNetworkSwitchStormControl",
            path=path,
            response_schema=GetNetworkSwitchStormControlResponse,
        )

    def update_network_switch_storm_control(
        self,
        network_id: str,
        *,
        broadcast_threshold: int | None = None,
        multicast_threshold: int | None = None,
        unknown_unicast_threshold: int | None = None,
        treat_these_traffic_types_as_one_threshold: list[str] | None = None,
    ) -> UpdateNetworkSwitchStormControlResponse | None:
        """Update the storm control configuration for a switch network.

        [API documentation: updateNetworkSwitchStormControl](https://developer.cisco.com/meraki/api-v1/#!update-network-switch-storm-control)

        Args:
            network_id: Network ID.
            broadcast_threshold: Percentage (1 to 99) of total available port bandwidth for
                broadcast traffic type. Default value 100 percent rate is to clear the
                configuration.
            multicast_threshold: Percentage (1 to 99) of total available port bandwidth for
                multicast traffic type. Default value 100 percent rate is to clear the
                configuration.
            unknown_unicast_threshold: Percentage (1 to 99) of total available port bandwidth for
                unknown unicast (dlf-destination lookup failure) traffic type. Default
                value 100 percent rate is to clear the configuration.
            treat_these_traffic_types_as_one_threshold: Grouped traffic types.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "broadcastThreshold": 30,
              "multicastThreshold": 30,
              "unknownUnicastThreshold": 30,
              "treatTheseTrafficTypesAsOneThreshold": [
                "broadcast",
                "multicast"
              ]
            }
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/switch/stormControl"

        payload = {}
        if broadcast_threshold is not None:
            payload["broadcastThreshold"] = broadcast_threshold
        if multicast_threshold is not None:
            payload["multicastThreshold"] = multicast_threshold
        if unknown_unicast_threshold is not None:
            payload["unknownUnicastThreshold"] = unknown_unicast_threshold
        if treat_these_traffic_types_as_one_threshold is not None:
            payload["treatTheseTrafficTypesAsOneThreshold"] = (
                treat_these_traffic_types_as_one_threshold
            )

        return self._session.put(
            scope="switch",
            operation_id="updateNetworkSwitchStormControl",
            path=path,
            json=payload,
            response_schema=UpdateNetworkSwitchStormControlResponse,
        )

    def get_network_switch_stp(self, network_id: str) -> GetNetworkSwitchStpResponse | None:
        """Returns STP settings.

        [API documentation: getNetworkSwitchStp](https://developer.cisco.com/meraki/api-v1/#!get-network-switch-stp)

        Args:
            network_id: Network ID.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "rstpEnabled": true,
              "stpBridgePriority": [
                {
                  "switches": [
                    "Q234-ABCD-0001",
                    "Q234-ABCD-0002",
                    "Q234-ABCD-0003"
                  ],
                  "stacks": [
                    "789102",
                    "123456",
                    "129102"
                  ],
                  "switchProfiles": [
                    "1098",
                    "1099",
                    "1100"
                  ],
                  "stpPriority": 4096
                }
              ]
            }
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/switch/stp"

        return self._session.get(
            scope="switch",
            operation_id="getNetworkSwitchStp",
            path=path,
            response_schema=GetNetworkSwitchStpResponse,
        )

    def update_network_switch_stp(
        self,
        network_id: str,
        *,
        rstp_enabled: bool | None = None,
        stp_bridge_priority: list[UpdateNetworkSwitchStpStpBridgePriorityItem] | None = None,
    ) -> UpdateNetworkSwitchStpResponse | None:
        """Updates STP settings.

        [API documentation: updateNetworkSwitchStp](https://developer.cisco.com/meraki/api-v1/#!update-network-switch-stp)

        Args:
            network_id: Network ID.
            rstp_enabled: The spanning tree protocol status in network.
            stp_bridge_priority: STP bridge priority for switches/stacks or switch templates. An
                empty array will clear the STP bridge priority settings.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "rstpEnabled": true,
              "stpBridgePriority": [
                {
                  "switches": [
                    "Q234-ABCD-0001",
                    "Q234-ABCD-0002",
                    "Q234-ABCD-0003"
                  ],
                  "stacks": [
                    "789102",
                    "123456",
                    "129102"
                  ],
                  "switchProfiles": [
                    "1098",
                    "1099",
                    "1100"
                  ],
                  "stpPriority": 4096
                }
              ]
            }
            ```

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/switch/stp"

        payload = {}
        if rstp_enabled is not None:
            payload["rstpEnabled"] = rstp_enabled
        if stp_bridge_priority is not None:
            payload["stpBridgePriority"] = [
                item.model_dump(by_alias=True, exclude_none=True) for item in stp_bridge_priority
            ]

        return self._session.put(
            scope="switch",
            operation_id="updateNetworkSwitchStp",
            path=path,
            json=payload,
            response_schema=UpdateNetworkSwitchStpResponse,
        )

    def get_organization_config_template_switch_profiles(
        self, *, organization_id: str, config_template_id: str
    ) -> PaginatedResponse[GetOrganizationConfigTemplateSwitchProfilesResponseItem]:
        """List the switch templates for your switch template configuration.

        [API documentation: getOrganizationConfigTemplateSwitchProfiles](https://developer.cisco.com/meraki/api-v1/#!get-organization-config-template-switch-profiles)

        Args:
            organization_id: Organization ID.
            config_template_id: Config template ID.

        Returns:
            Successful operation.

        Example API response:
            ```json
            [
              {
                "switchProfileId": "1234",
                "name": "A Simple Switch Template",
                "model": "MS450-24"
              }
            ]
            ```

        """
        organization_id = urllib.parse.quote(str(organization_id), safe="")
        config_template_id = urllib.parse.quote(str(config_template_id), safe="")
        path = (
            f"/organizations/{organization_id}/configTemplates/{config_template_id}/switch/profiles"
        )

        return self._session.get_pages(
            scope="switch",
            operation_id="getOrganizationConfigTemplateSwitchProfiles",
            path=path,
            item_schema=GetOrganizationConfigTemplateSwitchProfilesResponseItem,
        )

    def get_organization_config_template_switch_profile_ports(
        self, *, organization_id: str, config_template_id: str, profile_id: str
    ) -> PaginatedResponse[GetOrganizationConfigTemplateSwitchProfilePortsResponseItem]:
        """Return all the ports of a switch template.

        [API documentation: getOrganizationConfigTemplateSwitchProfilePorts](https://developer.cisco.com/meraki/api-v1/#!get-organization-config-template-switch-profile-ports)

        Args:
            organization_id: Organization ID.
            config_template_id: Config template ID.
            profile_id: Profile ID.

        Returns:
            Successful operation.

        Example API response:
            ```json
            [
              {
                "portId": "1",
                "name": "My switch port",
                "tags": [
                  "tag1",
                  "tag2"
                ],
                "enabled": true,
                "poeEnabled": true,
                "type": "access",
                "vlan": 10,
                "voiceVlan": 20,
                "allowedVlans": "1,3,5-10",
                "isolationEnabled": false,
                "rstpEnabled": true,
                "stpGuard": "disabled",
                "stpPortFastTrunk": false,
                "linkNegotiation": "Auto negotiate",
                "linkNegotiationCapabilities": [
                  "Auto negotiate",
                  "1 Gigabit full duplex (auto)"
                ],
                "portScheduleId": "1234",
                "schedule": {
                  "id": "1234",
                  "name": "Port Schedule"
                },
                "udld": "Alert only",
                "accessPolicyType": "Sticky MAC allow list",
                "accessPolicyNumber": 2,
                "macAllowList": [
                  "34:56:fe:ce:8e:a0",
                  "34:56:fe:ce:8e:a1"
                ],
                "macWhitelistLimit": 10,
                "stickyMacAllowList": [
                  "34:56:fe:ce:8e:b0",
                  "34:56:fe:ce:8e:b1"
                ],
                "stickyMacAllowListLimit": 5,
                "stormControlEnabled": true,
                "flexibleStackingEnabled": true,
                "daiTrusted": false,
                "profile": {
                  "enabled": false,
                  "id": "1284392014819",
                  "iname": "iname"
                },
                "module": {
                  "model": "MA-MOD-4X10G",
                  "serial": "3_MA-MOD-4X10G",
                  "slot": 1
                },
                "mirror": {
                  "mode": "Not mirroring traffic"
                },
                "dot3az": {
                  "enabled": false
                },
                "highSpeed": {
                  "enabled": false
                }
              }
            ]
            ```

        """
        organization_id = urllib.parse.quote(str(organization_id), safe="")
        config_template_id = urllib.parse.quote(str(config_template_id), safe="")
        profile_id = urllib.parse.quote(str(profile_id), safe="")
        path = f"/organizations/{organization_id}/configTemplates/{config_template_id}/switch/profiles/{profile_id}/ports"

        return self._session.get_pages(
            scope="switch",
            operation_id="getOrganizationConfigTemplateSwitchProfilePorts",
            path=path,
            item_schema=GetOrganizationConfigTemplateSwitchProfilePortsResponseItem,
        )

    def get_organization_config_template_switch_profile_port(
        self, *, organization_id: str, config_template_id: str, profile_id: str, port_id: str
    ) -> GetOrganizationConfigTemplateSwitchProfilePortResponse | None:
        """Return a switch template port.

        [API documentation: getOrganizationConfigTemplateSwitchProfilePort](https://developer.cisco.com/meraki/api-v1/#!get-organization-config-template-switch-profile-port)

        Args:
            organization_id: Organization ID.
            config_template_id: Config template ID.
            profile_id: Profile ID.
            port_id: Port ID.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "portId": "1",
              "name": "My switch port",
              "tags": [
                "tag1",
                "tag2"
              ],
              "enabled": true,
              "poeEnabled": true,
              "type": "access",
              "vlan": 10,
              "voiceVlan": 20,
              "allowedVlans": "1,3,5-10",
              "isolationEnabled": false,
              "rstpEnabled": true,
              "stpGuard": "disabled",
              "stpPortFastTrunk": false,
              "linkNegotiation": "Auto negotiate",
              "linkNegotiationCapabilities": [
                "Auto negotiate",
                "1 Gigabit full duplex (auto)"
              ],
              "portScheduleId": "1234",
              "schedule": {
                "id": "1234",
                "name": "Port Schedule"
              },
              "udld": "Alert only",
              "accessPolicyType": "Sticky MAC allow list",
              "accessPolicyNumber": 2,
              "macAllowList": [
                "34:56:fe:ce:8e:a0",
                "34:56:fe:ce:8e:a1"
              ],
              "macWhitelistLimit": 10,
              "stickyMacAllowList": [
                "34:56:fe:ce:8e:b0",
                "34:56:fe:ce:8e:b1"
              ],
              "stickyMacAllowListLimit": 5,
              "stormControlEnabled": true,
              "flexibleStackingEnabled": true,
              "daiTrusted": false,
              "profile": {
                "enabled": false,
                "id": "1284392014819",
                "iname": "iname"
              },
              "module": {
                "model": "MA-MOD-4X10G",
                "serial": "3_MA-MOD-4X10G",
                "slot": 1
              },
              "mirror": {
                "mode": "Not mirroring traffic"
              },
              "dot3az": {
                "enabled": false
              },
              "highSpeed": {
                "enabled": false
              }
            }
            ```

        """
        organization_id = urllib.parse.quote(str(organization_id), safe="")
        config_template_id = urllib.parse.quote(str(config_template_id), safe="")
        profile_id = urllib.parse.quote(str(profile_id), safe="")
        port_id = urllib.parse.quote(str(port_id), safe="")
        path = f"/organizations/{organization_id}/configTemplates/{config_template_id}/switch/profiles/{profile_id}/ports/{port_id}"

        return self._session.get(
            scope="switch",
            operation_id="getOrganizationConfigTemplateSwitchProfilePort",
            path=path,
            response_schema=GetOrganizationConfigTemplateSwitchProfilePortResponse,
        )

    def update_organization_config_template_switch_profile_port(
        self,
        *,
        organization_id: str,
        config_template_id: str,
        profile_id: str,
        port_id: str,
        name: str | None = None,
        tags: list[str] | None = None,
        enabled: bool | None = None,
        poe_enabled: bool | None = None,
        type_: str | None = None,
        vlan: int | None = None,
        voice_vlan: int | None = None,
        allowed_vlans: str | None = None,
        isolation_enabled: bool | None = None,
        rstp_enabled: bool | None = None,
        stp_guard: str | None = None,
        stp_port_fast_trunk: bool | None = None,
        link_negotiation: str | None = None,
        port_schedule_id: str | None = None,
        udld: str | None = None,
        access_policy_type: str | None = None,
        access_policy_number: int | None = None,
        mac_allow_list: list[str] | None = None,
        mac_whitelist_limit: int | None = None,
        sticky_mac_allow_list: list[str] | None = None,
        sticky_mac_allow_list_limit: int | None = None,
        storm_control_enabled: bool | None = None,
        flexible_stacking_enabled: bool | None = None,
        dai_trusted: bool | None = None,
        profile: UpdateOrganizationConfigTemplateSwitchProfilePortProfile | None = None,
        dot3az: UpdateOrganizationConfigTemplateSwitchProfilePortDot3az | None = None,
        high_speed: UpdateOrganizationConfigTemplateSwitchProfilePortHighSpeed | None = None,
    ) -> UpdateOrganizationConfigTemplateSwitchProfilePortResponse | None:
        """Update a switch template port.

        [API documentation: updateOrganizationConfigTemplateSwitchProfilePort](https://developer.cisco.com/meraki/api-v1/#!update-organization-config-template-switch-profile-port)

        Args:
            organization_id: Organization ID.
            config_template_id: Config template ID.
            profile_id: Profile ID.
            port_id: Port ID.
            name: The name of the switch template port.
            tags: The list of tags of the switch template port.
            enabled: The status of the switch template port.
            poe_enabled: The PoE status of the switch template port.
            type_: The type of the switch template port ('access', 'trunk', 'stack', 'routed', 'svl'
                or 'dad').
            vlan: The VLAN of the switch template port. For a trunk port, this is the native VLAN. A
                null value will clear the value set for trunk ports.
            voice_vlan: The voice VLAN of the switch template port. Only applicable to access ports.
            allowed_vlans: The VLANs allowed on the switch template port. Only applicable to trunk
                ports.
            isolation_enabled: The isolation status of the switch template port.
            rstp_enabled: The rapid spanning tree protocol status.
            stp_guard: The state of the STP guard ('disabled', 'root guard', 'bpdu guard' or 'loop
                guard').
            stp_port_fast_trunk: The state of STP PortFast Trunk on the switch template port.
            link_negotiation: The link speed for the switch template port.
            port_schedule_id: The ID of the port schedule. A value of null will clear the port
                schedule.
            udld: The action to take when Unidirectional Link is detected (Alert only, Enforce).
                Default configuration is Alert only.
            access_policy_type: The type of the access policy of the switch template port. Only
                applicable to access ports. Can be one of 'Open', 'Custom access
                policy', 'MAC allow list' or 'Sticky MAC allow list'.
            access_policy_number: The number of a custom access policy to configure on the switch
                template port. Only applicable when 'accessPolicyType' is 'Custom access
                policy'.
            mac_allow_list: Only devices with MAC addresses specified in this list will have access
                to this port. Up to 20 MAC addresses can be defined. Only applicable
                when 'accessPolicyType' is 'MAC allow list'.
            mac_whitelist_limit: The maximum number of MAC addresses for regular MAC allow list.
                Only applicable when 'accessPolicyType' is 'MAC allow list'. Note:
                Config only supported on verions greater than ms18 only for classic
                switches.
            sticky_mac_allow_list: The initial list of MAC addresses for sticky Mac allow list. Only
                applicable when 'accessPolicyType' is 'Sticky MAC allow list'.
            sticky_mac_allow_list_limit: The maximum number of MAC addresses for sticky MAC allow
                list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow
                list'.
            storm_control_enabled: The storm control status of the switch template port.
            flexible_stacking_enabled: For supported switches (e.g. MS420/MS425), whether or not the
                port has flexible stacking enabled.
            dai_trusted: If true, ARP packets for this port will be considered trusted, and Dynamic
                ARP Inspection will allow the traffic.
            profile: Profile attributes.
            dot3az: dot3az settings for the port.
            high_speed: High speed port enablement settings for C9500-32QC.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "portId": "1",
              "name": "My switch port",
              "tags": [
                "tag1",
                "tag2"
              ],
              "enabled": true,
              "poeEnabled": true,
              "type": "access",
              "vlan": 10,
              "voiceVlan": 20,
              "allowedVlans": "1,3,5-10",
              "isolationEnabled": false,
              "rstpEnabled": true,
              "stpGuard": "disabled",
              "stpPortFastTrunk": false,
              "linkNegotiation": "Auto negotiate",
              "linkNegotiationCapabilities": [
                "Auto negotiate",
                "1 Gigabit full duplex (auto)"
              ],
              "portScheduleId": "1234",
              "schedule": {
                "id": "1234",
                "name": "Port Schedule"
              },
              "udld": "Alert only",
              "accessPolicyType": "Sticky MAC allow list",
              "accessPolicyNumber": 2,
              "macAllowList": [
                "34:56:fe:ce:8e:a0",
                "34:56:fe:ce:8e:a1"
              ],
              "macWhitelistLimit": 10,
              "stickyMacAllowList": [
                "34:56:fe:ce:8e:b0",
                "34:56:fe:ce:8e:b1"
              ],
              "stickyMacAllowListLimit": 5,
              "stormControlEnabled": true,
              "flexibleStackingEnabled": true,
              "daiTrusted": false,
              "profile": {
                "enabled": false,
                "id": "1284392014819",
                "iname": "iname"
              },
              "module": {
                "model": "MA-MOD-4X10G",
                "serial": "3_MA-MOD-4X10G",
                "slot": 1
              },
              "mirror": {
                "mode": "Not mirroring traffic"
              },
              "dot3az": {
                "enabled": false
              },
              "highSpeed": {
                "enabled": false
              }
            }
            ```

        """
        if type_ is not None:
            options = ["access", "dad", "routed", "stack", "svl", "trunk"]
            assert type_ in options, (
                f'"type_" cannot be "{type_}", & must be set to one of: {options}'
            )
        if stp_guard is not None:
            options = ["bpdu guard", "disabled", "loop guard", "root guard"]
            assert stp_guard in options, (
                f'"stp_guard" cannot be "{stp_guard}", & must be set to one of: {options}'
            )
        if udld is not None:
            options = ["Alert only", "Enforce"]
            assert udld in options, f'"udld" cannot be "{udld}", & must be set to one of: {options}'
        if access_policy_type is not None:
            options = ["Custom access policy", "MAC allow list", "Open", "Sticky MAC allow list"]
            assert access_policy_type in options, (
                f'"access_policy_type" cannot be "{access_policy_type}", & must be set to one of: {options}'
            )

        organization_id = urllib.parse.quote(str(organization_id), safe="")
        config_template_id = urllib.parse.quote(str(config_template_id), safe="")
        profile_id = urllib.parse.quote(str(profile_id), safe="")
        port_id = urllib.parse.quote(str(port_id), safe="")
        path = f"/organizations/{organization_id}/configTemplates/{config_template_id}/switch/profiles/{profile_id}/ports/{port_id}"

        payload = {}
        if name is not None:
            payload["name"] = name
        if tags is not None:
            payload["tags"] = tags
        if enabled is not None:
            payload["enabled"] = enabled
        if poe_enabled is not None:
            payload["poeEnabled"] = poe_enabled
        if type_ is not None:
            payload["type"] = type_
        if vlan is not None:
            payload["vlan"] = vlan
        if voice_vlan is not None:
            payload["voiceVlan"] = voice_vlan
        if allowed_vlans is not None:
            payload["allowedVlans"] = allowed_vlans
        if isolation_enabled is not None:
            payload["isolationEnabled"] = isolation_enabled
        if rstp_enabled is not None:
            payload["rstpEnabled"] = rstp_enabled
        if stp_guard is not None:
            payload["stpGuard"] = stp_guard
        if stp_port_fast_trunk is not None:
            payload["stpPortFastTrunk"] = stp_port_fast_trunk
        if link_negotiation is not None:
            payload["linkNegotiation"] = link_negotiation
        if port_schedule_id is not None:
            payload["portScheduleId"] = port_schedule_id
        if udld is not None:
            payload["udld"] = udld
        if access_policy_type is not None:
            payload["accessPolicyType"] = access_policy_type
        if access_policy_number is not None:
            payload["accessPolicyNumber"] = access_policy_number
        if mac_allow_list is not None:
            payload["macAllowList"] = mac_allow_list
        if mac_whitelist_limit is not None:
            payload["macWhitelistLimit"] = mac_whitelist_limit
        if sticky_mac_allow_list is not None:
            payload["stickyMacAllowList"] = sticky_mac_allow_list
        if sticky_mac_allow_list_limit is not None:
            payload["stickyMacAllowListLimit"] = sticky_mac_allow_list_limit
        if storm_control_enabled is not None:
            payload["stormControlEnabled"] = storm_control_enabled
        if flexible_stacking_enabled is not None:
            payload["flexibleStackingEnabled"] = flexible_stacking_enabled
        if dai_trusted is not None:
            payload["daiTrusted"] = dai_trusted
        if profile is not None:
            payload["profile"] = profile.model_dump(by_alias=True, exclude_none=True)
        if dot3az is not None:
            payload["dot3az"] = dot3az.model_dump(by_alias=True, exclude_none=True)
        if high_speed is not None:
            payload["highSpeed"] = high_speed.model_dump(by_alias=True, exclude_none=True)

        return self._session.put(
            scope="switch",
            operation_id="updateOrganizationConfigTemplateSwitchProfilePort",
            path=path,
            json=payload,
            response_schema=UpdateOrganizationConfigTemplateSwitchProfilePortResponse,
        )

    def get_organization_summary_switch_power_history(
        self,
        organization_id: str,
        *,
        t0: str | None = None,
        t1: str | None = None,
        timespan: float | None = None,
    ) -> PaginatedResponse[GetOrganizationSummarySwitchPowerHistoryResponseItem]:
        """Returns the total PoE power draw for all switch ports in the organization over the requested timespan (by default the last 24 hours).

        [API documentation: getOrganizationSummarySwitchPowerHistory](https://developer.cisco.com/meraki/api-v1/#!get-organization-summary-switch-power-history)

        Args:
            organization_id: Organization ID.
            t0: The beginning of the timespan for the data.
            t1: The end of the timespan for the data. t1 can be a maximum of 186 days after t0.
            timespan: The timespan for which the information will be fetched. If specifying
                timespan, do not specify parameters t0 and t1. The value must be in
                seconds and be less than or equal to 186 days. The default is 1 day.

        Returns:
            Successful operation.

        Example API response:
            ```json
            [
              {
                "ts": "2021-06-20T01:00:00.000Z",
                "draw": 5.4321
              }
            ]
            ```

        """
        organization_id = urllib.parse.quote(str(organization_id), safe="")
        path = f"/organizations/{organization_id}/summary/switch/power/history"

        params = {}
        if t0 is not None:
            params["t0"] = t0
        if t1 is not None:
            params["t1"] = t1
        if timespan is not None:
            params["timespan"] = timespan

        return self._session.get_pages(
            scope="switch",
            operation_id="getOrganizationSummarySwitchPowerHistory",
            path=path,
            params=params,
            item_schema=GetOrganizationSummarySwitchPowerHistoryResponseItem,
        )

    def clone_organization_switch_devices(
        self, *, organization_id: str, source_serial: str, target_serials: list[str]
    ) -> CloneOrganizationSwitchDevicesResponse | None:
        """Clone port-level and some switch-level configuration settings from a source switch to one or more target switches.

        [API documentation: cloneOrganizationSwitchDevices](https://developer.cisco.com/meraki/api-v1/#!clone-organization-switch-devices)

        Args:
            organization_id: Organization ID.
            source_serial: Serial number of the source switch (must be on a network not bound to a
                template).
            target_serials: Array of serial numbers of one or more target switches (must be on a
                network not bound to a template).

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "sourceSerial": "Q234-ABCD-5678",
              "targetSerials": [
                "Q234-ABCD-0001",
                "Q234-ABCD-0002",
                "Q234-ABCD-0003"
              ]
            }
            ```

        """
        organization_id = urllib.parse.quote(str(organization_id), safe="")
        path = f"/organizations/{organization_id}/switch/devices/clone"

        payload = {}
        if source_serial is not None:
            payload["sourceSerial"] = source_serial
        if target_serials is not None:
            payload["targetSerials"] = target_serials

        return self._session.post(
            scope="switch",
            operation_id="cloneOrganizationSwitchDevices",
            path=path,
            json=payload,
            response_schema=CloneOrganizationSwitchDevicesResponse,
        )

    def get_organization_switch_ports_by_switch(
        self,
        organization_id: str,
        *,
        per_page: int | None = None,
        starting_after: str | None = None,
        ending_before: str | None = None,
        configuration_updated_after: str | None = None,
        mac: str | None = None,
        macs: list[str] | None = None,
        name: str | None = None,
        network_ids: list[str] | None = None,
        port_profile_ids: list[str] | None = None,
        serial: str | None = None,
        serials: list[str] | None = None,
        total_pages: int | Literal["all"] = "all",
        direction: Literal["prev", "next"] = "next",
    ) -> PaginatedResponse[GetOrganizationSwitchPortsBySwitchResponsePortsItem]:
        """List the switchports in an organization by switch.

        [API documentation: getOrganizationSwitchPortsBySwitch](https://developer.cisco.com/meraki/api-v1/#!get-organization-switch-ports-by-switch)

        Args:
            organization_id: Organization ID.
            per_page: The number of entries per page returned. Acceptable range is 3 - 50. Default
                is 50.
            starting_after: A token used by the server to indicate the start of the page. Often this
                is a timestamp or an ID but it is not limited to those. This parameter
                should not be defined by client applications. The link for the first,
                last, prev, or next page in the HTTP Link header should define it.
            ending_before: A token used by the server to indicate the end of the page. Often this is
                a timestamp or an ID but it is not limited to those. This parameter
                should not be defined by client applications. The link for the first,
                last, prev, or next page in the HTTP Link header should define it.
            configuration_updated_after: Optional parameter to filter items to switches where the
                configuration has been updated after the given timestamp.
            mac: Optional parameter to filter items to switches with MAC addresses that contain the
                search term or are an exact match.
            macs: Optional parameter to filter items to switches that have one of the provided MAC
                addresses.
            name: Optional parameter to filter items to switches with names that contain the search
                term or are an exact match.
            network_ids: Optional parameter to filter items to switches in one of the provided
                networks.
            port_profile_ids: Optional parameter to filter items to switches that contain
                switchports belonging to one of the specified port profiles.
            serial: Optional parameter to filter items to switches with serial number that contains
                the search term or are an exact match.
            serials: Optional parameter to filter items to switches that have one of the provided
                serials.
            total_pages: use with per_page to get total results up to total_pages * per_page; -1 or
                "all" for all pages.
            direction: direction to paginate, either "next" (default) or "prev" page.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "name": "Example Switch",
              "serial": "Q555-5555-5555",
              "mac": "01:23:45:67:ab:cd",
              "network": {
                "name": "Example Network",
                "id": "L_12345"
              },
              "model": "MS120-8",
              "ports": [
                {
                  "portId": "1",
                  "name": "My switch port",
                  "tags": [
                    "tag1",
                    "tag2"
                  ],
                  "enabled": true,
                  "poeEnabled": true,
                  "type": "access",
                  "vlan": 10,
                  "voiceVlan": 20,
                  "allowedVlans": "1,3,5-10",
                  "rstpEnabled": true,
                  "stpGuard": "disabled",
                  "linkNegotiation": "Auto negotiate",
                  "accessPolicyType": "Sticky MAC allow list",
                  "stickyMacAllowList": [
                    "34:56:fe:ce:8e:b0",
                    "34:56:fe:ce:8e:b1"
                  ],
                  "stickyMacAllowListLimit": 5
                }
              ]
            }
            ```

        """
        organization_id = urllib.parse.quote(str(organization_id), safe="")
        path = f"/organizations/{organization_id}/switch/ports/bySwitch"

        params = {}
        if per_page is not None:
            params["perPage"] = per_page
        if starting_after is not None:
            params["startingAfter"] = starting_after
        if ending_before is not None:
            params["endingBefore"] = ending_before
        if configuration_updated_after is not None:
            params["configurationUpdatedAfter"] = configuration_updated_after
        if mac is not None:
            params["mac"] = mac
        if macs is not None:
            params["macs[]"] = macs
        if name is not None:
            params["name"] = name
        if network_ids is not None:
            params["networkIds[]"] = network_ids
        if port_profile_ids is not None:
            params["portProfileIds[]"] = port_profile_ids
        if serial is not None:
            params["serial"] = serial
        if serials is not None:
            params["serials[]"] = serials

        return self._session.get_pages(
            scope="switch",
            operation_id="getOrganizationSwitchPortsBySwitch",
            path=path,
            params=params,
            total_pages=total_pages,
            direction=direction,
            item_schema=GetOrganizationSwitchPortsBySwitchResponsePortsItem,
        )

    def get_organization_switch_ports_clients_overview_by_device(
        self,
        organization_id: str,
        *,
        t0: str | None = None,
        timespan: float | None = None,
        per_page: int | None = None,
        starting_after: str | None = None,
        ending_before: str | None = None,
        configuration_updated_after: str | None = None,
        mac: str | None = None,
        macs: list[str] | None = None,
        name: str | None = None,
        network_ids: list[str] | None = None,
        port_profile_ids: list[str] | None = None,
        serial: str | None = None,
        serials: list[str] | None = None,
        total_pages: int | Literal["all"] = "all",
        direction: Literal["prev", "next"] = "next",
    ) -> PaginatedResponse[GetOrganizationSwitchPortsClientsOverviewByDeviceResponseItemsItem]:
        """List the number of clients for all switchports with at least one online client in an organization.

        [API documentation: getOrganizationSwitchPortsClientsOverviewByDevice](https://developer.cisco.com/meraki/api-v1/#!get-organization-switch-ports-clients-overview-by-device)

        Args:
            organization_id: Organization ID.
            t0: The beginning of the timespan for the data. The maximum lookback period is 31 days
                from today.
            timespan: The timespan for which the information will be fetched. If specifying
                timespan, do not specify parameter t0. The value must be in seconds and
                be less than or equal to 31 days. The default is 1 day.
            per_page: The number of entries per page returned. Acceptable range is 3 - 20. Default
                is 20.
            starting_after: A token used by the server to indicate the start of the page. Often this
                is a timestamp or an ID but it is not limited to those. This parameter
                should not be defined by client applications. The link for the first,
                last, prev, or next page in the HTTP Link header should define it.
            ending_before: A token used by the server to indicate the end of the page. Often this is
                a timestamp or an ID but it is not limited to those. This parameter
                should not be defined by client applications. The link for the first,
                last, prev, or next page in the HTTP Link header should define it.
            configuration_updated_after: Optional parameter to filter items to switches where the
                configuration has been updated after the given timestamp.
            mac: Optional parameter to filter items to switches with MAC addresses that contain the
                search term or are an exact match.
            macs: Optional parameter to filter items to switches that have one of the provided MAC
                addresses.
            name: Optional parameter to filter items to switches with names that contain the search
                term or are an exact match.
            network_ids: Optional parameter to filter items to switches in one of the provided
                networks.
            port_profile_ids: Optional parameter to filter items to switches that contain
                switchports belonging to one of the specified port profiles.
            serial: Optional parameter to filter items to switches with serial number that contains
                the search term or are an exact match.
            serials: Optional parameter to filter items to switches that have one of the provided
                serials.
            total_pages: use with per_page to get total results up to total_pages * per_page; -1 or
                "all" for all pages.
            direction: direction to paginate, either "next" (default) or "prev" page.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "items": [
                {
                  "name": "Example Switch",
                  "serial": "Q555-5555-5555",
                  "mac": "01:23:45:67:ab:cd",
                  "network": {
                    "name": "Example Network",
                    "id": "L_12345"
                  },
                  "model": "MS120-8",
                  "ports": [
                    {
                      "portId": "1",
                      "counts": {
                        "byStatus": {
                          "online": 0
                        }
                      }
                    }
                  ]
                }
              ],
              "meta": {
                "counts": {
                  "items": {
                    "total": 1,
                    "remaining": 0
                  }
                }
              }
            }
            ```

        """
        organization_id = urllib.parse.quote(str(organization_id), safe="")
        path = f"/organizations/{organization_id}/switch/ports/clients/overview/byDevice"

        params = {}
        if t0 is not None:
            params["t0"] = t0
        if timespan is not None:
            params["timespan"] = timespan
        if per_page is not None:
            params["perPage"] = per_page
        if starting_after is not None:
            params["startingAfter"] = starting_after
        if ending_before is not None:
            params["endingBefore"] = ending_before
        if configuration_updated_after is not None:
            params["configurationUpdatedAfter"] = configuration_updated_after
        if mac is not None:
            params["mac"] = mac
        if macs is not None:
            params["macs[]"] = macs
        if name is not None:
            params["name"] = name
        if network_ids is not None:
            params["networkIds[]"] = network_ids
        if port_profile_ids is not None:
            params["portProfileIds[]"] = port_profile_ids
        if serial is not None:
            params["serial"] = serial
        if serials is not None:
            params["serials[]"] = serials

        return self._session.get_pages(
            scope="switch",
            operation_id="getOrganizationSwitchPortsClientsOverviewByDevice",
            path=path,
            params=params,
            total_pages=total_pages,
            direction=direction,
            item_schema=GetOrganizationSwitchPortsClientsOverviewByDeviceResponseItemsItem,
        )

    def get_organization_switch_ports_overview(
        self,
        organization_id: str,
        *,
        t0: str | None = None,
        t1: str | None = None,
        timespan: float | None = None,
    ) -> GetOrganizationSwitchPortsOverviewResponse | None:
        """Returns the counts of all active ports for the requested timespan, grouped by speed.

        [API documentation: getOrganizationSwitchPortsOverview](https://developer.cisco.com/meraki/api-v1/#!get-organization-switch-ports-overview)

        Args:
            organization_id: Organization ID.
            t0: The beginning of the timespan for the data.
            t1: The end of the timespan for the data. t1 can be a maximum of 186 days after t0.
            timespan: The timespan for which the information will be fetched. If specifying
                timespan, do not specify parameters t0 and t1. The value must be in
                seconds and be greater than or equal to 12 hours and be less than or
                equal to 186 days. The default is 1 day.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "counts": {
                "total": 120,
                "byStatus": {
                  "active": {
                    "total": 87,
                    "byMediaAndLinkSpeed": {
                      "rj45": {
                        "total": 24,
                        "10": 0,
                        "100": 0,
                        "1000": 24,
                        "2500": 0,
                        "5000": 0,
                        "10000": 0
                      },
                      "sfp": {
                        "total": 63,
                        "100": 8,
                        "1000": 40,
                        "10000": 10,
                        "20000": 0,
                        "25000": 0,
                        "40000": 1,
                        "50000": 0,
                        "100000": 0
                      }
                    }
                  },
                  "inactive": {
                    "total": 33,
                    "byMedia": {
                      "rj45": {
                        "total": 16
                      },
                      "sfp": {
                        "total": 17
                      }
                    }
                  }
                }
              }
            }
            ```

        """
        organization_id = urllib.parse.quote(str(organization_id), safe="")
        path = f"/organizations/{organization_id}/switch/ports/overview"

        params = {}
        if t0 is not None:
            params["t0"] = t0
        if t1 is not None:
            params["t1"] = t1
        if timespan is not None:
            params["timespan"] = timespan

        return self._session.get(
            scope="switch",
            operation_id="getOrganizationSwitchPortsOverview",
            path=path,
            params=params,
            response_schema=GetOrganizationSwitchPortsOverviewResponse,
        )

    def get_organization_switch_ports_statuses_by_switch(
        self,
        organization_id: str,
        *,
        per_page: int | None = None,
        starting_after: str | None = None,
        ending_before: str | None = None,
        configuration_updated_after: str | None = None,
        mac: str | None = None,
        macs: list[str] | None = None,
        name: str | None = None,
        network_ids: list[str] | None = None,
        port_profile_ids: list[str] | None = None,
        serial: str | None = None,
        serials: list[str] | None = None,
        total_pages: int | Literal["all"] = "all",
        direction: Literal["prev", "next"] = "next",
    ) -> PaginatedResponse[GetOrganizationSwitchPortsStatusesBySwitchResponseItemsItem]:
        """List the switchports in an organization.

        [API documentation: getOrganizationSwitchPortsStatusesBySwitch](https://developer.cisco.com/meraki/api-v1/#!get-organization-switch-ports-statuses-by-switch)

        Args:
            organization_id: Organization ID.
            per_page: The number of entries per page returned. Acceptable range is 3 - 20. Default
                is 10.
            starting_after: A token used by the server to indicate the start of the page. Often this
                is a timestamp or an ID but it is not limited to those. This parameter
                should not be defined by client applications. The link for the first,
                last, prev, or next page in the HTTP Link header should define it.
            ending_before: A token used by the server to indicate the end of the page. Often this is
                a timestamp or an ID but it is not limited to those. This parameter
                should not be defined by client applications. The link for the first,
                last, prev, or next page in the HTTP Link header should define it.
            configuration_updated_after: Optional parameter to filter items to switches where the
                configuration has been updated after the given timestamp.
            mac: Optional parameter to filter items to switches with MAC addresses that contain the
                search term or are an exact match.
            macs: Optional parameter to filter items to switches that have one of the provided MAC
                addresses.
            name: Optional parameter to filter items to switches with names that contain the search
                term or are an exact match.
            network_ids: Optional parameter to filter items to switches in one of the provided
                networks.
            port_profile_ids: Optional parameter to filter items to switches that contain
                switchports belonging to one of the specified port profiles.
            serial: Optional parameter to filter items to switches with serial number that contains
                the search term or are an exact match.
            serials: Optional parameter to filter items to switches that have one of the provided
                serials.
            total_pages: use with per_page to get total results up to total_pages * per_page; -1 or
                "all" for all pages.
            direction: direction to paginate, either "next" (default) or "prev" page.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "items": [
                {
                  "name": "Example Switch",
                  "serial": "Q555-5555-5555",
                  "mac": "01:23:45:67:ab:cd",
                  "network": {
                    "name": "Example Network",
                    "id": "L_12345"
                  },
                  "model": "MS120-8",
                  "ports": [
                    {
                      "portId": "1",
                      "enabled": true,
                      "status": "Connected",
                      "isUplink": false,
                      "errors": [
                        "PoE overload",
                        "Very high proportion of CRC errors"
                      ],
                      "warnings": [
                        "SecurePort authentication in progress",
                        "PoE port was denied power",
                        "High proportion of CRC errors"
                      ],
                      "speed": "10 Gbps",
                      "duplex": "full",
                      "spanningTree": {
                        "statuses": [
                          "Learning"
                        ]
                      },
                      "poe": {
                        "isAllocated": false
                      },
                      "securePort": {
                        "active": true,
                        "authenticationStatus": "Authentication in progress"
                      }
                    }
                  ]
                }
              ],
              "meta": {
                "counts": {
                  "items": {
                    "total": 1,
                    "remaining": 0
                  }
                }
              }
            }
            ```

        """
        organization_id = urllib.parse.quote(str(organization_id), safe="")
        path = f"/organizations/{organization_id}/switch/ports/statuses/bySwitch"

        params = {}
        if per_page is not None:
            params["perPage"] = per_page
        if starting_after is not None:
            params["startingAfter"] = starting_after
        if ending_before is not None:
            params["endingBefore"] = ending_before
        if configuration_updated_after is not None:
            params["configurationUpdatedAfter"] = configuration_updated_after
        if mac is not None:
            params["mac"] = mac
        if macs is not None:
            params["macs[]"] = macs
        if name is not None:
            params["name"] = name
        if network_ids is not None:
            params["networkIds[]"] = network_ids
        if port_profile_ids is not None:
            params["portProfileIds[]"] = port_profile_ids
        if serial is not None:
            params["serial"] = serial
        if serials is not None:
            params["serials[]"] = serials

        return self._session.get_pages(
            scope="switch",
            operation_id="getOrganizationSwitchPortsStatusesBySwitch",
            path=path,
            params=params,
            total_pages=total_pages,
            direction=direction,
            item_schema=GetOrganizationSwitchPortsStatusesBySwitchResponseItemsItem,
        )

    def get_organization_switch_ports_topology_discovery_by_device(
        self,
        organization_id: str,
        *,
        t0: str | None = None,
        timespan: float | None = None,
        per_page: int | None = None,
        starting_after: str | None = None,
        ending_before: str | None = None,
        configuration_updated_after: str | None = None,
        mac: str | None = None,
        macs: list[str] | None = None,
        name: str | None = None,
        network_ids: list[str] | None = None,
        port_profile_ids: list[str] | None = None,
        serial: str | None = None,
        serials: list[str] | None = None,
        total_pages: int | Literal["all"] = "all",
        direction: Literal["prev", "next"] = "next",
    ) -> PaginatedResponse[GetOrganizationSwitchPortsTopologyDiscoveryByDeviceResponseItemsItem]:
        """List most recently seen LLDP/CDP discovery and topology information per switch port in an organization.

        [API documentation: getOrganizationSwitchPortsTopologyDiscoveryByDevice](https://developer.cisco.com/meraki/api-v1/#!get-organization-switch-ports-topology-discovery-by-device)

        Args:
            organization_id: Organization ID.
            t0: The beginning of the timespan for the data. The maximum lookback period is 31 days
                from today.
            timespan: The timespan for which the information will be fetched. If specifying
                timespan, do not specify parameter t0. The value must be in seconds and
                be less than or equal to 31 days. The default is 1 day.
            per_page: The number of entries per page returned. Acceptable range is 3 - 20. Default
                is 10.
            starting_after: A token used by the server to indicate the start of the page. Often this
                is a timestamp or an ID but it is not limited to those. This parameter
                should not be defined by client applications. The link for the first,
                last, prev, or next page in the HTTP Link header should define it.
            ending_before: A token used by the server to indicate the end of the page. Often this is
                a timestamp or an ID but it is not limited to those. This parameter
                should not be defined by client applications. The link for the first,
                last, prev, or next page in the HTTP Link header should define it.
            configuration_updated_after: Optional parameter to filter items to switches where the
                configuration has been updated after the given timestamp.
            mac: Optional parameter to filter items to switches with MAC addresses that contain the
                search term or are an exact match.
            macs: Optional parameter to filter items to switches that have one of the provided MAC
                addresses.
            name: Optional parameter to filter items to switches with names that contain the search
                term or are an exact match.
            network_ids: Optional parameter to filter items to switches in one of the provided
                networks.
            port_profile_ids: Optional parameter to filter items to switches that contain
                switchports belonging to one of the specified port profiles.
            serial: Optional parameter to filter items to switches with serial number that contains
                the search term or are an exact match.
            serials: Optional parameter to filter items to switches that have one of the provided
                serials.
            total_pages: use with per_page to get total results up to total_pages * per_page; -1 or
                "all" for all pages.
            direction: direction to paginate, either "next" (default) or "prev" page.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "items": [
                {
                  "name": "Example Switch",
                  "serial": "Q555-5555-5555",
                  "mac": "01:23:45:67:ab:cd",
                  "network": {
                    "name": "Example Network",
                    "id": "L_12345"
                  },
                  "model": "MS120-8",
                  "ports": [
                    {
                      "portId": "1",
                      "lastUpdatedAt": "ISO8061Z",
                      "cdp": [
                        {
                          "name": "System name",
                          "value": "MS350-24X - Test"
                        }
                      ],
                      "lldp": [
                        {
                          "name": "System name",
                          "value": "MS350-24X - Test"
                        }
                      ]
                    }
                  ]
                }
              ],
              "meta": {
                "counts": {
                  "items": {
                    "total": 1,
                    "remaining": 0
                  }
                }
              }
            }
            ```

        """
        organization_id = urllib.parse.quote(str(organization_id), safe="")
        path = f"/organizations/{organization_id}/switch/ports/topology/discovery/byDevice"

        params = {}
        if t0 is not None:
            params["t0"] = t0
        if timespan is not None:
            params["timespan"] = timespan
        if per_page is not None:
            params["perPage"] = per_page
        if starting_after is not None:
            params["startingAfter"] = starting_after
        if ending_before is not None:
            params["endingBefore"] = ending_before
        if configuration_updated_after is not None:
            params["configurationUpdatedAfter"] = configuration_updated_after
        if mac is not None:
            params["mac"] = mac
        if macs is not None:
            params["macs[]"] = macs
        if name is not None:
            params["name"] = name
        if network_ids is not None:
            params["networkIds[]"] = network_ids
        if port_profile_ids is not None:
            params["portProfileIds[]"] = port_profile_ids
        if serial is not None:
            params["serial"] = serial
        if serials is not None:
            params["serials[]"] = serials

        return self._session.get_pages(
            scope="switch",
            operation_id="getOrganizationSwitchPortsTopologyDiscoveryByDevice",
            path=path,
            params=params,
            total_pages=total_pages,
            direction=direction,
            item_schema=GetOrganizationSwitchPortsTopologyDiscoveryByDeviceResponseItemsItem,
        )

    def get_organization_switch_ports_usage_history_by_device_by_interval(
        self,
        organization_id: str,
        *,
        t0: str | None = None,
        t1: str | None = None,
        timespan: float | None = None,
        interval: int | None = None,
        per_page: int | None = None,
        starting_after: str | None = None,
        ending_before: str | None = None,
        configuration_updated_after: str | None = None,
        mac: str | None = None,
        macs: list[str] | None = None,
        name: str | None = None,
        network_ids: list[str] | None = None,
        port_profile_ids: list[str] | None = None,
        serial: str | None = None,
        serials: list[str] | None = None,
        total_pages: int | Literal["all"] = "all",
        direction: Literal["prev", "next"] = "next",
    ) -> PaginatedResponse[
        GetOrganizationSwitchPortsUsageHistoryByDeviceByIntervalResponseItemsItem
    ]:
        """List the historical usage and traffic data of switchports in an organization.

        [API documentation: getOrganizationSwitchPortsUsageHistoryByDeviceByInterval](https://developer.cisco.com/meraki/api-v1/#!get-organization-switch-ports-usage-history-by-device-by-interval)

        Args:
            organization_id: Organization ID.
            t0: The beginning of the timespan for the data. The maximum lookback period is 31 days
                from today.
            t1: The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
            timespan: The timespan for which the information will be fetched. If specifying
                timespan, do not specify parameters t0 and t1. The value must be in
                seconds and be less than or equal to 31 days. The default is 1 day. If
                interval is provided, the timespan will be autocalculated.
            interval: The time interval in seconds for returned data. The valid intervals are: 300,
                1200, 14400, 86400. The default is 1200. Interval is calculated if time
                params are provided.
            per_page: The number of entries per page returned. Acceptable range is 3 - 50. Default
                is 10.
            starting_after: A token used by the server to indicate the start of the page. Often this
                is a timestamp or an ID but it is not limited to those. This parameter
                should not be defined by client applications. The link for the first,
                last, prev, or next page in the HTTP Link header should define it.
            ending_before: A token used by the server to indicate the end of the page. Often this is
                a timestamp or an ID but it is not limited to those. This parameter
                should not be defined by client applications. The link for the first,
                last, prev, or next page in the HTTP Link header should define it.
            configuration_updated_after: Optional parameter to filter items to switches where the
                configuration has been updated after the given timestamp.
            mac: Optional parameter to filter items to switches with MAC addresses that contain the
                search term or are an exact match.
            macs: Optional parameter to filter items to switches that have one of the provided MAC
                addresses.
            name: Optional parameter to filter items to switches with names that contain the search
                term or are an exact match.
            network_ids: Optional parameter to filter items to switches in one of the provided
                networks.
            port_profile_ids: Optional parameter to filter items to switches that contain
                switchports belonging to one of the specified port profiles.
            serial: Optional parameter to filter items to switches with serial number that contains
                the search term or are an exact match.
            serials: Optional parameter to filter items to switches that have one of the provided
                serials.
            total_pages: use with per_page to get total results up to total_pages * per_page; -1 or
                "all" for all pages.
            direction: direction to paginate, either "next" (default) or "prev" page.

        Returns:
            Successful operation.

        Example API response:
            ```json
            {
              "items": [
                {
                  "name": "Example Switch",
                  "serial": "Q555-5555-5555",
                  "mac": "01:23:45:67:ab:cd",
                  "network": {
                    "name": "Example Network",
                    "id": "L_12345"
                  },
                  "model": "MS120-8",
                  "ports": [
                    {
                      "portId": "1",
                      "intervals": [
                        {
                          "startTs": "2024-02-11T00:00:00.090210Z",
                          "endTs": "2024-02-11T00:20:00.090210Z",
                          "data": {
                            "usage": {
                              "total": 40867,
                              "upstream": 23008,
                              "downstream": 17859
                            }
                          },
                          "bandwidth": {
                            "usage": {
                              "total": 2.2,
                              "upstream": 1.2,
                              "downstream": 1.0
                            }
                          },
                          "energy": {
                            "usage": {
                              "total": 2.2
                            }
                          }
                        }
                      ]
                    }
                  ]
                }
              ],
              "meta": {
                "counts": {
                  "items": {
                    "total": 1,
                    "remaining": 0
                  }
                }
              }
            }
            ```

        """
        organization_id = urllib.parse.quote(str(organization_id), safe="")
        path = f"/organizations/{organization_id}/switch/ports/usage/history/byDevice/byInterval"

        params = {}
        if t0 is not None:
            params["t0"] = t0
        if t1 is not None:
            params["t1"] = t1
        if timespan is not None:
            params["timespan"] = timespan
        if interval is not None:
            params["interval"] = interval
        if per_page is not None:
            params["perPage"] = per_page
        if starting_after is not None:
            params["startingAfter"] = starting_after
        if ending_before is not None:
            params["endingBefore"] = ending_before
        if configuration_updated_after is not None:
            params["configurationUpdatedAfter"] = configuration_updated_after
        if mac is not None:
            params["mac"] = mac
        if macs is not None:
            params["macs[]"] = macs
        if name is not None:
            params["name"] = name
        if network_ids is not None:
            params["networkIds[]"] = network_ids
        if port_profile_ids is not None:
            params["portProfileIds[]"] = port_profile_ids
        if serial is not None:
            params["serial"] = serial
        if serials is not None:
            params["serials[]"] = serials

        return self._session.get_pages(
            scope="switch",
            operation_id="getOrganizationSwitchPortsUsageHistoryByDeviceByInterval",
            path=path,
            params=params,
            total_pages=total_pages,
            direction=direction,
            item_schema=GetOrganizationSwitchPortsUsageHistoryByDeviceByIntervalResponseItemsItem,
        )
