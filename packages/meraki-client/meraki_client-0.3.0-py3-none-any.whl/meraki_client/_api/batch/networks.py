"""ActionBatchNetworks API endpoints.

This file is automatically @generated from the Meraki API specification.
Do not edit this file manually.

"""

import urllib.parse

from meraki_client.schemas import (
    BatchNetworkFloorPlansAutoLocateJobsJobsItem,
    BatchNetworkFloorPlansDevicesUpdateAssignmentsItem,
    ClaimNetworkDevicesDetailsByDeviceItem,
    CreateNetworkFirmwareUpgradesRollbackReasonsItem,
    CreateNetworkFirmwareUpgradesRollbackToVersion,
    CreateNetworkFirmwareUpgradesStagedGroupAssignedDevices,
    CreateNetworkGroupPolicyBandwidth,
    CreateNetworkGroupPolicyBonjourForwarding,
    CreateNetworkGroupPolicyContentFiltering,
    CreateNetworkGroupPolicyFirewallAndTrafficShaping,
    CreateNetworkGroupPolicyScheduling,
    CreateNetworkGroupPolicyVlanTagging,
    CreateNetworkMerakiAuthUserAuthorizationsItem,
    CreateNetworkMqttBrokerAuthentication,
    CreateNetworkMqttBrokerSecurity,
    CreateNetworkVlanProfileVlanGroupsItem,
    CreateNetworkVlanProfileVlanNamesItem,
    CreateNetworkWebhooksPayloadTemplateHeadersItem,
    CreateOrganizationActionBatchActionsItem,
    ProvisionNetworkClientsClientsItem,
    ProvisionNetworkClientsPoliciesBySecurityAppliance,
    ProvisionNetworkClientsPoliciesBySsid,
    PublishNetworkFloorPlansAutoLocateJobDevicesItem,
    RecalculateNetworkFloorPlansAutoLocateJobDevicesItem,
    UpdateNetworkFirmwareUpgradesProducts,
    UpdateNetworkFirmwareUpgradesUpgradeWindow,
    UpdateNetworkFloorPlanBottomLeftCorner,
    UpdateNetworkFloorPlanBottomRightCorner,
    UpdateNetworkFloorPlanCenter,
    UpdateNetworkFloorPlanTopLeftCorner,
    UpdateNetworkFloorPlanTopRightCorner,
    UpdateNetworkGroupPolicyBandwidth,
    UpdateNetworkGroupPolicyBonjourForwarding,
    UpdateNetworkGroupPolicyContentFiltering,
    UpdateNetworkGroupPolicyFirewallAndTrafficShaping,
    UpdateNetworkGroupPolicyScheduling,
    UpdateNetworkGroupPolicyVlanTagging,
    UpdateNetworkMerakiAuthUserAuthorizationsItem,
    UpdateNetworkMqttBrokerAuthentication,
    UpdateNetworkMqttBrokerSecurity,
    UpdateNetworkSettingsLocalStatusPage,
    UpdateNetworkSettingsNamedVlans,
    UpdateNetworkSettingsSecurePort,
    UpdateNetworkWebhooksPayloadTemplateHeadersItem,
)


class ActionBatchNetworks:
    """ActionBatchNetworks class."""

    def __init__(self) -> None:
        pass

    def update_network(
        self,
        network_id: str,
        *,
        name: str | None = None,
        time_zone: str | None = None,
        tags: list[str] | None = None,
        enrollment_string: str | None = None,
        notes: str | None = None,
    ) -> CreateOrganizationActionBatchActionsItem:
        """Update a network.

        [API documentation: updateNetwork](https://developer.cisco.com/meraki/api-v1/#!update-network)

        Args:
            network_id: Network ID.
            name: The name of the network.
            time_zone: The timezone of the network. For a list of allowed timezones, please see the
                'TZ' column in the table in <a target='_blank'
                href='https://en.wikipedia.org/wiki/List_of_tz_database_time_zones'>this
                article.</a>.
            tags: A list of tags to be applied to the network.
            enrollment_string: A unique identifier which can be used for device enrollment or easy
                access through the Meraki SM Registration page or the Self Service
                Portal. Please note that changing this field may cause existing
                bookmarks to break.
            notes: Add any notes or additional information about this network here.

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}"

        payload = {}
        if name is not None:
            payload["name"] = name
        if time_zone is not None:
            payload["timeZone"] = time_zone
        if tags is not None:
            payload["tags"] = tags
        if enrollment_string is not None:
            payload["enrollmentString"] = enrollment_string
        if notes is not None:
            payload["notes"] = notes

        return CreateOrganizationActionBatchActionsItem(
            resource=path,
            operation="update",
            body=payload,
        )

    def delete_network(self, network_id: str) -> CreateOrganizationActionBatchActionsItem:
        """Delete a network.

        [API documentation: deleteNetwork](https://developer.cisco.com/meraki/api-v1/#!delete-network)

        Args:
            network_id: Network ID.

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}"

        return CreateOrganizationActionBatchActionsItem(
            resource=path,
            operation="destroy",
        )

    def bind_network(
        self, *, network_id: str, config_template_id: str, auto_bind: bool | None = None
    ) -> CreateOrganizationActionBatchActionsItem:
        """Bind a network to a template.

        [API documentation: bindNetwork](https://developer.cisco.com/meraki/api-v1/#!bind-network)

        Args:
            network_id: Network ID.
            config_template_id: The ID of the template to which the network should be bound.
            auto_bind: Optional boolean indicating whether the network's switches should
                automatically bind to profiles of the same model. Defaults to false if
                left unspecified. This option only affects switch networks and switch
                templates. Auto-bind is not valid unless the switch template has at
                least one profile and has at most one profile per switch model.

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/bind"

        payload = {}
        if config_template_id is not None:
            payload["configTemplateId"] = config_template_id
        if auto_bind is not None:
            payload["autoBind"] = auto_bind

        return CreateOrganizationActionBatchActionsItem(
            resource=path,
            operation="bind",
            body=payload,
        )

    def provision_network_clients(
        self,
        *,
        network_id: str,
        clients: list[ProvisionNetworkClientsClientsItem],
        device_policy: str,
        group_policy_id: str | None = None,
        policies_by_security_appliance: ProvisionNetworkClientsPoliciesBySecurityAppliance
        | None = None,
        policies_by_ssid: ProvisionNetworkClientsPoliciesBySsid | None = None,
    ) -> CreateOrganizationActionBatchActionsItem:
        """Provisions a client with a name and policy.

        [API documentation: provisionNetworkClients](https://developer.cisco.com/meraki/api-v1/#!provision-network-clients)

        Args:
            network_id: Network ID.
            clients: The array of clients to provision.
            device_policy: The policy to apply to the specified client. Can be 'Group policy',
                'Allowed', 'Blocked', 'Per connection' or 'Normal'. Required.
            group_policy_id: The ID of the desired group policy to apply to the client. Required if
                'devicePolicy' is set to "Group policy". Otherwise this is ignored.
            policies_by_security_appliance: An object, describing what the policy-connection
                association is for the security appliance. (Only relevant if the
                security appliance is actually within the network).
            policies_by_ssid: An object, describing the policy-connection associations for each
                active SSID within the network. Keys should be the number of enabled
                SSIDs, mapping to an object describing the client's policy.

        """
        if device_policy is not None:
            options = ["Allowed", "Blocked", "Group policy", "Normal", "Per connection"]
            assert device_policy in options, (
                f'"device_policy" cannot be "{device_policy}", & must be set to one of: {options}'
            )

        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/clients/provision"

        payload = {}
        if clients is not None:
            payload["clients"] = [
                item.model_dump(by_alias=True, exclude_none=True) for item in clients
            ]
        if device_policy is not None:
            payload["devicePolicy"] = device_policy
        if group_policy_id is not None:
            payload["groupPolicyId"] = group_policy_id
        if policies_by_security_appliance is not None:
            payload["policiesBySecurityAppliance"] = policies_by_security_appliance.model_dump(
                by_alias=True, exclude_none=True
            )
        if policies_by_ssid is not None:
            payload["policiesBySsid"] = policies_by_ssid.model_dump(
                by_alias=True, exclude_none=True
            )

        return CreateOrganizationActionBatchActionsItem(
            resource=path,
            operation="provision",
            body=payload,
        )

    def claim_network_devices(
        self,
        *,
        network_id: str,
        serials: list[str],
        add_atomically: bool | None = None,
        details_by_device: list[ClaimNetworkDevicesDetailsByDeviceItem] | None = None,
    ) -> CreateOrganizationActionBatchActionsItem:
        """Claim devices into a network. (Note: for recently claimed devices, it may take a few minutes for API requests against that device to succeed).

        [API documentation: claimNetworkDevices](https://developer.cisco.com/meraki/api-v1/#!claim-network-devices)

        Args:
            network_id: Network ID.
            add_atomically: Whether to claim devices atomically. If true, all devices will be
                claimed or none will be claimed. Default is true.
            serials: A list of serials of devices to claim.
            details_by_device: Optional details for claimed devices (currently only used for
                Catalyst devices).

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/devices/claim"

        params = {}
        if add_atomically is not None:
            params["addAtomically"] = add_atomically

        payload = {}
        if serials is not None:
            payload["serials"] = serials
        if details_by_device is not None:
            payload["detailsByDevice"] = [
                item.model_dump(by_alias=True, exclude_none=True) for item in details_by_device
            ]

        return CreateOrganizationActionBatchActionsItem(
            resource=path,
            operation="claim",
            body=payload,
        )

    def vmx_network_devices_claim(
        self, *, network_id: str, size: str
    ) -> CreateOrganizationActionBatchActionsItem:
        """Claim a vMX into a network.

        [API documentation: vmxNetworkDevicesClaim](https://developer.cisco.com/meraki/api-v1/#!vmx-network-devices-claim)

        Args:
            network_id: Network ID.
            size: The size of the vMX you claim. It can be one of: small, medium, large, xlarge,
                100.

        """
        if size is not None:
            options = ["100", "large", "medium", "small", "xlarge"]
            assert size in options, f'"size" cannot be "{size}", & must be set to one of: {options}'

        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/devices/claim/vmx"

        payload = {}
        if size is not None:
            payload["size"] = size

        return CreateOrganizationActionBatchActionsItem(
            resource=path,
            operation="claim",
            body=payload,
        )

    def remove_network_devices(
        self, *, network_id: str, serial: str
    ) -> CreateOrganizationActionBatchActionsItem:
        """Remove a single device.

        [API documentation: removeNetworkDevices](https://developer.cisco.com/meraki/api-v1/#!remove-network-devices)

        Args:
            network_id: Network ID.
            serial: The serial of a device.

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/devices/remove"

        payload = {}
        if serial is not None:
            payload["serial"] = serial

        return CreateOrganizationActionBatchActionsItem(
            resource=path,
            operation="remove",
            body=payload,
        )

    def update_network_firmware_upgrades(
        self,
        network_id: str,
        *,
        upgrade_window: UpdateNetworkFirmwareUpgradesUpgradeWindow | None = None,
        timezone: str | None = None,
        products: UpdateNetworkFirmwareUpgradesProducts | None = None,
    ) -> CreateOrganizationActionBatchActionsItem:
        """Update firmware upgrade information for a network.

        [API documentation: updateNetworkFirmwareUpgrades](https://developer.cisco.com/meraki/api-v1/#!update-network-firmware-upgrades)

        Args:
            network_id: Network ID.
            upgrade_window: Upgrade window for devices in network.
            timezone: The timezone for the network.
            products: Contains information about the network to update.

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/firmwareUpgrades"

        payload = {}
        if upgrade_window is not None:
            payload["upgradeWindow"] = upgrade_window.model_dump(by_alias=True, exclude_none=True)
        if timezone is not None:
            payload["timezone"] = timezone
        if products is not None:
            payload["products"] = products.model_dump(by_alias=True, exclude_none=True)

        return CreateOrganizationActionBatchActionsItem(
            resource=path,
            operation="update",
            body=payload,
        )

    def create_network_firmware_upgrades_rollback(
        self,
        *,
        network_id: str,
        reasons: list[CreateNetworkFirmwareUpgradesRollbackReasonsItem],
        product: str | None = None,
        time: str | None = None,
        to_version: CreateNetworkFirmwareUpgradesRollbackToVersion | None = None,
    ) -> CreateOrganizationActionBatchActionsItem:
        """Rollback a Firmware Upgrade For A Network.

        [API documentation: createNetworkFirmwareUpgradesRollback](https://developer.cisco.com/meraki/api-v1/#!create-network-firmware-upgrades-rollback)

        Args:
            network_id: Network ID.
            product: Product type to rollback (if the network is a combined network).
            time: Scheduled time for the rollback.
            reasons: Reasons for the rollback.
            to_version: Version to downgrade to (if the network has firmware flexibility).

        """
        if product is not None:
            options = [
                "appliance",
                "camera",
                "cellularGateway",
                "secureConnect",
                "switch",
                "switchCatalyst",
                "wireless",
                "wirelessController",
            ]
            assert product in options, (
                f'"product" cannot be "{product}", & must be set to one of: {options}'
            )

        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/firmwareUpgrades/rollbacks"

        payload = {}
        if product is not None:
            payload["product"] = product
        if time is not None:
            payload["time"] = time
        if reasons is not None:
            payload["reasons"] = [
                item.model_dump(by_alias=True, exclude_none=True) for item in reasons
            ]
        if to_version is not None:
            payload["toVersion"] = to_version.model_dump(by_alias=True, exclude_none=True)

        return CreateOrganizationActionBatchActionsItem(
            resource=path,
            operation="create",
            body=payload,
        )

    def create_network_firmware_upgrades_staged_group(
        self,
        *,
        network_id: str,
        name: str,
        is_default: bool,
        description: str | None = None,
        assigned_devices: CreateNetworkFirmwareUpgradesStagedGroupAssignedDevices | None = None,
    ) -> CreateOrganizationActionBatchActionsItem:
        """Create a Staged Upgrade Group for a network.

        [API documentation: createNetworkFirmwareUpgradesStagedGroup](https://developer.cisco.com/meraki/api-v1/#!create-network-firmware-upgrades-staged-group)

        Args:
            network_id: Network ID.
            name: Name of the Staged Upgrade Group. Length must be 1 to 255 characters.
            description: Description of the Staged Upgrade Group. Length must be 1 to 255
                characters.
            is_default: Boolean indicating the default Group. Any device that does not have a group
                explicitly assigned will upgrade with this group.
            assigned_devices: The devices and Switch Stacks assigned to the Group.

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/firmwareUpgrades/staged/groups"

        payload = {}
        if name is not None:
            payload["name"] = name
        if description is not None:
            payload["description"] = description
        if is_default is not None:
            payload["isDefault"] = is_default
        if assigned_devices is not None:
            payload["assignedDevices"] = assigned_devices.model_dump(
                by_alias=True, exclude_none=True
            )

        return CreateOrganizationActionBatchActionsItem(
            resource=path,
            operation="create",
            body=payload,
        )

    def delete_network_firmware_upgrades_staged_group(
        self, *, network_id: str, group_id: str
    ) -> CreateOrganizationActionBatchActionsItem:
        """Delete a Staged Upgrade Group.

        [API documentation: deleteNetworkFirmwareUpgradesStagedGroup](https://developer.cisco.com/meraki/api-v1/#!delete-network-firmware-upgrades-staged-group)

        Args:
            network_id: Network ID.
            group_id: Group ID.

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        group_id = urllib.parse.quote(str(group_id), safe="")
        path = f"/networks/{network_id}/firmwareUpgrades/staged/groups/{group_id}"

        return CreateOrganizationActionBatchActionsItem(
            resource=path,
            operation="destroy",
        )

    def batch_network_floor_plans_auto_locate_jobs(
        self, *, network_id: str, jobs: list[BatchNetworkFloorPlansAutoLocateJobsJobsItem]
    ) -> CreateOrganizationActionBatchActionsItem:
        """Schedule auto locate jobs for one or more floor plans in a network.

        [API documentation: batchNetworkFloorPlansAutoLocateJobs](https://developer.cisco.com/meraki/api-v1/#!batch-network-floor-plans-auto-locate-jobs)

        Args:
            network_id: Network ID.
            jobs: The list of auto locate jobs to be scheduled. Up to 100 jobs can be provided in a
                request.

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/floorPlans/autoLocate/jobs/batch"

        payload = {}
        if jobs is not None:
            payload["jobs"] = [item.model_dump(by_alias=True, exclude_none=True) for item in jobs]

        return CreateOrganizationActionBatchActionsItem(
            resource=path,
            operation="batch_create",
            body=payload,
        )

    def cancel_network_floor_plans_auto_locate_job(
        self, *, network_id: str, job_id: str
    ) -> CreateOrganizationActionBatchActionsItem:
        """Cancel a scheduled or running auto locate job.

        [API documentation: cancelNetworkFloorPlansAutoLocateJob](https://developer.cisco.com/meraki/api-v1/#!cancel-network-floor-plans-auto-locate-job)

        Args:
            network_id: Network ID.
            job_id: Job ID.

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        job_id = urllib.parse.quote(str(job_id), safe="")
        path = f"/networks/{network_id}/floorPlans/autoLocate/jobs/{job_id}/cancel"

        return CreateOrganizationActionBatchActionsItem(
            resource=path,
            operation="cancel",
        )

    def publish_network_floor_plans_auto_locate_job(
        self,
        *,
        network_id: str,
        job_id: str,
        devices: list[PublishNetworkFloorPlansAutoLocateJobDevicesItem] | None = None,
    ) -> CreateOrganizationActionBatchActionsItem:
        """Update the status of a finished auto locate job to be published, and update device locations.

        [API documentation: publishNetworkFloorPlansAutoLocateJob](https://developer.cisco.com/meraki/api-v1/#!publish-network-floor-plans-auto-locate-job)

        Args:
            network_id: Network ID.
            job_id: Job ID.
            devices: The list of devices to publish positions for.

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        job_id = urllib.parse.quote(str(job_id), safe="")
        path = f"/networks/{network_id}/floorPlans/autoLocate/jobs/{job_id}/publish"

        payload = {}
        if devices is not None:
            payload["devices"] = [
                item.model_dump(by_alias=True, exclude_none=True) for item in devices
            ]

        return CreateOrganizationActionBatchActionsItem(
            resource=path,
            operation="publish",
            body=payload,
        )

    def recalculate_network_floor_plans_auto_locate_job(
        self,
        *,
        network_id: str,
        job_id: str,
        devices: list[RecalculateNetworkFloorPlansAutoLocateJobDevicesItem] | None = None,
    ) -> CreateOrganizationActionBatchActionsItem:
        """Trigger auto locate recalculation for a job, and optionally set anchors.

        [API documentation: recalculateNetworkFloorPlansAutoLocateJob](https://developer.cisco.com/meraki/api-v1/#!recalculate-network-floor-plans-auto-locate-job)

        Args:
            network_id: Network ID.
            job_id: Job ID.
            devices: The list of devices to update anchor positions for.

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        job_id = urllib.parse.quote(str(job_id), safe="")
        path = f"/networks/{network_id}/floorPlans/autoLocate/jobs/{job_id}/recalculate"

        payload = {}
        if devices is not None:
            payload["devices"] = [
                item.model_dump(by_alias=True, exclude_none=True) for item in devices
            ]

        return CreateOrganizationActionBatchActionsItem(
            resource=path,
            operation="recalculate",
            body=payload,
        )

    def batch_network_floor_plans_devices_update(
        self,
        *,
        network_id: str,
        assignments: list[BatchNetworkFloorPlansDevicesUpdateAssignmentsItem],
    ) -> CreateOrganizationActionBatchActionsItem:
        """Update floorplan assignments for a batch of devices.

        [API documentation: batchNetworkFloorPlansDevicesUpdate](https://developer.cisco.com/meraki/api-v1/#!batch-network-floor-plans-devices-update)

        Args:
            network_id: Network ID.
            assignments: List of floorplan assignments to update. Up to 100 floor plan assignments
                can be provided in a request.

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/floorPlans/devices/batchUpdate"

        payload = {}
        if assignments is not None:
            payload["assignments"] = [
                item.model_dump(by_alias=True, exclude_none=True) for item in assignments
            ]

        return CreateOrganizationActionBatchActionsItem(
            resource=path,
            operation="batch_update",
            body=payload,
        )

    def update_network_floor_plan(
        self,
        *,
        network_id: str,
        floor_plan_id: str,
        name: str | None = None,
        center: UpdateNetworkFloorPlanCenter | None = None,
        bottom_left_corner: UpdateNetworkFloorPlanBottomLeftCorner | None = None,
        bottom_right_corner: UpdateNetworkFloorPlanBottomRightCorner | None = None,
        top_left_corner: UpdateNetworkFloorPlanTopLeftCorner | None = None,
        top_right_corner: UpdateNetworkFloorPlanTopRightCorner | None = None,
        floor_number: float | None = None,
        image_contents: str | None = None,
    ) -> CreateOrganizationActionBatchActionsItem:
        """Update a floor plan's geolocation and other meta data.

        [API documentation: updateNetworkFloorPlan](https://developer.cisco.com/meraki/api-v1/#!update-network-floor-plan)

        Args:
            network_id: Network ID.
            floor_plan_id: Floor plan ID.
            name: The name of your floor plan.
            center: The longitude and latitude of the center of your floor plan. If you want to
                change the geolocation data of your floor plan, either the 'center' or
                two adjacent corners (e.g. 'topLeftCorner' and 'bottomLeftCorner') must
                be specified. If 'center' is specified, the floor plan is placed over
                that point with no rotation. If two adjacent corners are specified, the
                floor plan is rotated to line up with the two specified points. The
                aspect ratio of the floor plan's image is preserved regardless of which
                corners/center are specified. (This means if that more than two corners
                are specified, only two corners may be used to preserve the floor plan's
                aspect ratio.). No two points can have the same latitude, longitude
                pair.
            bottom_left_corner: The longitude and latitude of the bottom left corner of your floor
                plan.
            bottom_right_corner: The longitude and latitude of the bottom right corner of your floor
                plan.
            top_left_corner: The longitude and latitude of the top left corner of your floor plan.
            top_right_corner: The longitude and latitude of the top right corner of your floor plan.
            floor_number: The floor number of the floors within the building.
            image_contents: The file contents (a base 64 encoded string) of your new image.
                Supported formats are PNG, GIF, and JPG. Note that all images are saved
                as PNG files, regardless of the format they are uploaded in. If you
                upload a new image, and you do NOT specify any new geolocation fields
                ('center, 'topLeftCorner', etc), the floor plan will be recentered with
                no rotation in order to maintain the aspect ratio of your new image.

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        floor_plan_id = urllib.parse.quote(str(floor_plan_id), safe="")
        path = f"/networks/{network_id}/floorPlans/{floor_plan_id}"

        payload = {}
        if name is not None:
            payload["name"] = name
        if center is not None:
            payload["center"] = center.model_dump(by_alias=True, exclude_none=True)
        if bottom_left_corner is not None:
            payload["bottomLeftCorner"] = bottom_left_corner.model_dump(
                by_alias=True, exclude_none=True
            )
        if bottom_right_corner is not None:
            payload["bottomRightCorner"] = bottom_right_corner.model_dump(
                by_alias=True, exclude_none=True
            )
        if top_left_corner is not None:
            payload["topLeftCorner"] = top_left_corner.model_dump(by_alias=True, exclude_none=True)
        if top_right_corner is not None:
            payload["topRightCorner"] = top_right_corner.model_dump(
                by_alias=True, exclude_none=True
            )
        if floor_number is not None:
            payload["floorNumber"] = floor_number
        if image_contents is not None:
            payload["imageContents"] = image_contents

        return CreateOrganizationActionBatchActionsItem(
            resource=path,
            operation="update",
            body=payload,
        )

    def delete_network_floor_plan(
        self, *, network_id: str, floor_plan_id: str
    ) -> CreateOrganizationActionBatchActionsItem:
        """Destroy a floor plan.

        [API documentation: deleteNetworkFloorPlan](https://developer.cisco.com/meraki/api-v1/#!delete-network-floor-plan)

        Args:
            network_id: Network ID.
            floor_plan_id: Floor plan ID.

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        floor_plan_id = urllib.parse.quote(str(floor_plan_id), safe="")
        path = f"/networks/{network_id}/floorPlans/{floor_plan_id}"

        return CreateOrganizationActionBatchActionsItem(
            resource=path,
            operation="destroy",
        )

    def create_network_group_policy(
        self,
        *,
        network_id: str,
        name: str,
        scheduling: CreateNetworkGroupPolicyScheduling | None = None,
        bandwidth: CreateNetworkGroupPolicyBandwidth | None = None,
        firewall_and_traffic_shaping: CreateNetworkGroupPolicyFirewallAndTrafficShaping
        | None = None,
        content_filtering: CreateNetworkGroupPolicyContentFiltering | None = None,
        splash_auth_settings: str | None = None,
        vlan_tagging: CreateNetworkGroupPolicyVlanTagging | None = None,
        bonjour_forwarding: CreateNetworkGroupPolicyBonjourForwarding | None = None,
    ) -> CreateOrganizationActionBatchActionsItem:
        """Create a group policy.

        [API documentation: createNetworkGroupPolicy](https://developer.cisco.com/meraki/api-v1/#!create-network-group-policy)

        Args:
            network_id: Network ID.
            name: The name for your group policy. Required.
            scheduling: The schedule for the group policy. Schedules are applied to days of the
                week.
            bandwidth: The bandwidth settings for clients bound to your group policy.
            firewall_and_traffic_shaping: The firewall and traffic shaping rules and settings for
                your policy.
            content_filtering: The content filtering settings for your group policy.
            splash_auth_settings: Whether clients bound to your policy will bypass splash
                authorization or behave according to the network's rules. Can be one of
                'network default' or 'bypass'. Only available if your network has a
                wireless configuration.
            vlan_tagging: The VLAN tagging settings for your group policy. Only available if your
                network has a wireless configuration.
            bonjour_forwarding: The Bonjour settings for your group policy. Only valid if your
                network has a wireless configuration.

        """
        if splash_auth_settings is not None:
            options = ["bypass", "network default"]
            assert splash_auth_settings in options, (
                f'"splash_auth_settings" cannot be "{splash_auth_settings}", & must be set to one of: {options}'
            )

        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/groupPolicies"

        payload = {}
        if name is not None:
            payload["name"] = name
        if scheduling is not None:
            payload["scheduling"] = scheduling.model_dump(by_alias=True, exclude_none=True)
        if bandwidth is not None:
            payload["bandwidth"] = bandwidth.model_dump(by_alias=True, exclude_none=True)
        if firewall_and_traffic_shaping is not None:
            payload["firewallAndTrafficShaping"] = firewall_and_traffic_shaping.model_dump(
                by_alias=True, exclude_none=True
            )
        if content_filtering is not None:
            payload["contentFiltering"] = content_filtering.model_dump(
                by_alias=True, exclude_none=True
            )
        if splash_auth_settings is not None:
            payload["splashAuthSettings"] = splash_auth_settings
        if vlan_tagging is not None:
            payload["vlanTagging"] = vlan_tagging.model_dump(by_alias=True, exclude_none=True)
        if bonjour_forwarding is not None:
            payload["bonjourForwarding"] = bonjour_forwarding.model_dump(
                by_alias=True, exclude_none=True
            )

        return CreateOrganizationActionBatchActionsItem(
            resource=path,
            operation="create",
            body=payload,
        )

    def update_network_group_policy(
        self,
        *,
        network_id: str,
        group_policy_id: str,
        name: str | None = None,
        scheduling: UpdateNetworkGroupPolicyScheduling | None = None,
        bandwidth: UpdateNetworkGroupPolicyBandwidth | None = None,
        firewall_and_traffic_shaping: UpdateNetworkGroupPolicyFirewallAndTrafficShaping
        | None = None,
        content_filtering: UpdateNetworkGroupPolicyContentFiltering | None = None,
        splash_auth_settings: str | None = None,
        vlan_tagging: UpdateNetworkGroupPolicyVlanTagging | None = None,
        bonjour_forwarding: UpdateNetworkGroupPolicyBonjourForwarding | None = None,
    ) -> CreateOrganizationActionBatchActionsItem:
        """Update a group policy.

        [API documentation: updateNetworkGroupPolicy](https://developer.cisco.com/meraki/api-v1/#!update-network-group-policy)

        Args:
            network_id: Network ID.
            group_policy_id: Group policy ID.
            name: The name for your group policy.
            scheduling: The schedule for the group policy. Schedules are applied to days of the
                week.
            bandwidth: The bandwidth settings for clients bound to your group policy.
            firewall_and_traffic_shaping: The firewall and traffic shaping rules and settings for
                your policy.
            content_filtering: The content filtering settings for your group policy.
            splash_auth_settings: Whether clients bound to your policy will bypass splash
                authorization or behave according to the network's rules. Can be one of
                'network default' or 'bypass'. Only available if your network has a
                wireless configuration.
            vlan_tagging: The VLAN tagging settings for your group policy. Only available if your
                network has a wireless configuration.
            bonjour_forwarding: The Bonjour settings for your group policy. Only valid if your
                network has a wireless configuration.

        """
        if splash_auth_settings is not None:
            options = ["bypass", "network default"]
            assert splash_auth_settings in options, (
                f'"splash_auth_settings" cannot be "{splash_auth_settings}", & must be set to one of: {options}'
            )

        network_id = urllib.parse.quote(str(network_id), safe="")
        group_policy_id = urllib.parse.quote(str(group_policy_id), safe="")
        path = f"/networks/{network_id}/groupPolicies/{group_policy_id}"

        payload = {}
        if name is not None:
            payload["name"] = name
        if scheduling is not None:
            payload["scheduling"] = scheduling.model_dump(by_alias=True, exclude_none=True)
        if bandwidth is not None:
            payload["bandwidth"] = bandwidth.model_dump(by_alias=True, exclude_none=True)
        if firewall_and_traffic_shaping is not None:
            payload["firewallAndTrafficShaping"] = firewall_and_traffic_shaping.model_dump(
                by_alias=True, exclude_none=True
            )
        if content_filtering is not None:
            payload["contentFiltering"] = content_filtering.model_dump(
                by_alias=True, exclude_none=True
            )
        if splash_auth_settings is not None:
            payload["splashAuthSettings"] = splash_auth_settings
        if vlan_tagging is not None:
            payload["vlanTagging"] = vlan_tagging.model_dump(by_alias=True, exclude_none=True)
        if bonjour_forwarding is not None:
            payload["bonjourForwarding"] = bonjour_forwarding.model_dump(
                by_alias=True, exclude_none=True
            )

        return CreateOrganizationActionBatchActionsItem(
            resource=path,
            operation="update",
            body=payload,
        )

    def delete_network_group_policy(
        self, *, network_id: str, group_policy_id: str, force: bool | None = None
    ) -> CreateOrganizationActionBatchActionsItem:
        """Delete a group policy.

        [API documentation: deleteNetworkGroupPolicy](https://developer.cisco.com/meraki/api-v1/#!delete-network-group-policy)

        Args:
            network_id: Network ID.
            group_policy_id: Group policy ID.
            force: If true, the system deletes the GP even if there are active clients using the GP.
                After deletion, active clients that were assigned to that Group Policy
                will be left without any policy applied. Default is false.

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        group_policy_id = urllib.parse.quote(str(group_policy_id), safe="")
        path = f"/networks/{network_id}/groupPolicies/{group_policy_id}"

        params = {}
        if force is not None:
            params["force"] = force

        return CreateOrganizationActionBatchActionsItem(
            resource=path,
            operation="destroy",
        )

    def create_network_meraki_auth_user(
        self,
        *,
        network_id: str,
        email: str,
        authorizations: list[CreateNetworkMerakiAuthUserAuthorizationsItem],
        name: str | None = None,
        password: str | None = None,
        account_type: str | None = None,
        email_password_to_user: bool | None = None,
        is_admin: bool | None = None,
    ) -> CreateOrganizationActionBatchActionsItem:
        """Authorize a user configured with Meraki Authentication for a network (currently supports 802.1X, splash guest, and client VPN users, and currently, organizations have a 50,000 user cap).

        [API documentation: createNetworkMerakiAuthUser](https://developer.cisco.com/meraki/api-v1/#!create-network-meraki-auth-user)

        Args:
            network_id: Network ID.
            email: Email address of the user.
            name: Name of the user. Only required If the user is not a Dashboard administrator.
            password: The password for this user account. Only required If the user is not a
                Dashboard administrator.
            account_type: Authorization type for user. Can be 'Guest' or '802.1X' for wireless
                networks, or 'Client VPN' for MX networks. Defaults to '802.1X'.
            email_password_to_user: Whether or not Meraki should email the password to user. Default
                is false.
            is_admin: Whether or not the user is a Dashboard administrator.
            authorizations: Authorization zones and expiration dates for the user.

        """
        if account_type is not None:
            options = ["802.1X", "Client VPN", "Guest"]
            assert account_type in options, (
                f'"account_type" cannot be "{account_type}", & must be set to one of: {options}'
            )

        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/merakiAuthUsers"

        payload = {}
        if email is not None:
            payload["email"] = email
        if name is not None:
            payload["name"] = name
        if password is not None:
            payload["password"] = password
        if account_type is not None:
            payload["accountType"] = account_type
        if email_password_to_user is not None:
            payload["emailPasswordToUser"] = email_password_to_user
        if is_admin is not None:
            payload["isAdmin"] = is_admin
        if authorizations is not None:
            payload["authorizations"] = [
                item.model_dump(by_alias=True, exclude_none=True) for item in authorizations
            ]

        return CreateOrganizationActionBatchActionsItem(
            resource=path,
            operation="create",
            body=payload,
        )

    def update_network_meraki_auth_user(
        self,
        *,
        network_id: str,
        meraki_auth_user_id: str,
        name: str | None = None,
        password: str | None = None,
        email_password_to_user: bool | None = None,
        authorizations: list[UpdateNetworkMerakiAuthUserAuthorizationsItem] | None = None,
    ) -> CreateOrganizationActionBatchActionsItem:
        """Update a user configured with Meraki Authentication (currently, 802.1X RADIUS, splash guest, and client VPN users can be updated).

        [API documentation: updateNetworkMerakiAuthUser](https://developer.cisco.com/meraki/api-v1/#!update-network-meraki-auth-user)

        Args:
            network_id: Network ID.
            meraki_auth_user_id: Meraki auth user ID.
            name: Name of the user. Only allowed If the user is not Dashboard administrator.
            password: The password for this user account. Only allowed If the user is not Dashboard
                administrator.
            email_password_to_user: Whether or not Meraki should email the password to user. Default
                is false.
            authorizations: Authorization zones and expiration dates for the user.

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        meraki_auth_user_id = urllib.parse.quote(str(meraki_auth_user_id), safe="")
        path = f"/networks/{network_id}/merakiAuthUsers/{meraki_auth_user_id}"

        payload = {}
        if name is not None:
            payload["name"] = name
        if password is not None:
            payload["password"] = password
        if email_password_to_user is not None:
            payload["emailPasswordToUser"] = email_password_to_user
        if authorizations is not None:
            payload["authorizations"] = [
                item.model_dump(by_alias=True, exclude_none=True) for item in authorizations
            ]

        return CreateOrganizationActionBatchActionsItem(
            resource=path,
            operation="update",
            body=payload,
        )

    def delete_network_meraki_auth_user(
        self, *, network_id: str, meraki_auth_user_id: str, delete: bool | None = None
    ) -> CreateOrganizationActionBatchActionsItem:
        """Delete an 802.1X RADIUS user, or deauthorize and optionally delete a splash guest or client VPN user.

        [API documentation: deleteNetworkMerakiAuthUser](https://developer.cisco.com/meraki/api-v1/#!delete-network-meraki-auth-user)

        Args:
            network_id: Network ID.
            meraki_auth_user_id: Meraki auth user ID.
            delete: If the ID supplied is for a splash guest or client VPN user, and that user is
                not authorized for any other networks in the organization, then also
                delete the user. 802.1X RADIUS users are always deleted regardless of
                this optional attribute.

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        meraki_auth_user_id = urllib.parse.quote(str(meraki_auth_user_id), safe="")
        path = f"/networks/{network_id}/merakiAuthUsers/{meraki_auth_user_id}"

        params = {}
        if delete is not None:
            params["delete"] = delete

        return CreateOrganizationActionBatchActionsItem(
            resource=path,
            operation="destroy",
        )

    def create_network_mqtt_broker(
        self,
        *,
        network_id: str,
        name: str,
        host: str,
        port: int,
        security: CreateNetworkMqttBrokerSecurity | None = None,
        authentication: CreateNetworkMqttBrokerAuthentication | None = None,
    ) -> CreateOrganizationActionBatchActionsItem:
        """Add an MQTT broker.

        [API documentation: createNetworkMqttBroker](https://developer.cisco.com/meraki/api-v1/#!create-network-mqtt-broker)

        Args:
            network_id: Network ID.
            name: Name of the MQTT broker.
            host: Host name/IP address where the MQTT broker runs.
            port: Host port though which the MQTT broker can be reached.
            security: Security settings of the MQTT broker.
            authentication: Authentication settings of the MQTT broker.

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/mqttBrokers"

        payload = {}
        if name is not None:
            payload["name"] = name
        if host is not None:
            payload["host"] = host
        if port is not None:
            payload["port"] = port
        if security is not None:
            payload["security"] = security.model_dump(by_alias=True, exclude_none=True)
        if authentication is not None:
            payload["authentication"] = authentication.model_dump(by_alias=True, exclude_none=True)

        return CreateOrganizationActionBatchActionsItem(
            resource=path,
            operation="create",
            body=payload,
        )

    def update_network_mqtt_broker(
        self,
        *,
        network_id: str,
        mqtt_broker_id: str,
        name: str | None = None,
        host: str | None = None,
        port: int | None = None,
        security: UpdateNetworkMqttBrokerSecurity | None = None,
        authentication: UpdateNetworkMqttBrokerAuthentication | None = None,
    ) -> CreateOrganizationActionBatchActionsItem:
        """Update an MQTT broker.

        [API documentation: updateNetworkMqttBroker](https://developer.cisco.com/meraki/api-v1/#!update-network-mqtt-broker)

        Args:
            network_id: Network ID.
            mqtt_broker_id: Mqtt broker ID.
            name: Name of the MQTT broker.
            host: Host name/IP address where the MQTT broker runs.
            port: Host port though which the MQTT broker can be reached.
            security: Security settings of the MQTT broker.
            authentication: Authentication settings of the MQTT broker.

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        mqtt_broker_id = urllib.parse.quote(str(mqtt_broker_id), safe="")
        path = f"/networks/{network_id}/mqttBrokers/{mqtt_broker_id}"

        payload = {}
        if name is not None:
            payload["name"] = name
        if host is not None:
            payload["host"] = host
        if port is not None:
            payload["port"] = port
        if security is not None:
            payload["security"] = security.model_dump(by_alias=True, exclude_none=True)
        if authentication is not None:
            payload["authentication"] = authentication.model_dump(by_alias=True, exclude_none=True)

        return CreateOrganizationActionBatchActionsItem(
            resource=path,
            operation="update",
            body=payload,
        )

    def delete_network_mqtt_broker(
        self, *, network_id: str, mqtt_broker_id: str
    ) -> CreateOrganizationActionBatchActionsItem:
        """Delete an MQTT broker.

        [API documentation: deleteNetworkMqttBroker](https://developer.cisco.com/meraki/api-v1/#!delete-network-mqtt-broker)

        Args:
            network_id: Network ID.
            mqtt_broker_id: Mqtt broker ID.

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        mqtt_broker_id = urllib.parse.quote(str(mqtt_broker_id), safe="")
        path = f"/networks/{network_id}/mqttBrokers/{mqtt_broker_id}"

        return CreateOrganizationActionBatchActionsItem(
            resource=path,
            operation="destroy",
        )

    def update_network_settings(
        self,
        network_id: str,
        *,
        local_status_page_enabled: bool | None = None,
        remote_status_page_enabled: bool | None = None,
        local_status_page: UpdateNetworkSettingsLocalStatusPage | None = None,
        secure_port: UpdateNetworkSettingsSecurePort | None = None,
        named_vlans: UpdateNetworkSettingsNamedVlans | None = None,
    ) -> CreateOrganizationActionBatchActionsItem:
        """Update the settings for a network.

        [API documentation: updateNetworkSettings](https://developer.cisco.com/meraki/api-v1/#!update-network-settings)

        Args:
            network_id: Network ID.
            local_status_page_enabled: Enables / disables the local device status pages (<a
                target='_blank' href='http://my.meraki.com/'>my.meraki.com, </a><a
                target='_blank' href='http://ap.meraki.com/'>ap.meraki.com, </a><a
                target='_blank' href='http://switch.meraki.com/'>switch.meraki.com,
                </a><a target='_blank'
                href='http://wired.meraki.com/'>wired.meraki.com</a>). Optional
                (defaults to false).
            remote_status_page_enabled: Enables / disables access to the device status page (<a
                target='_blank'>http://[device's LAN IP])</a>. Optional. Can only be set
                if localStatusPageEnabled is set to true.
            local_status_page: A hash of Local Status page(s)' authentication options applied to the
                Network.
            secure_port: A hash of SecureConnect options applied to the Network.
            named_vlans: A hash of Named VLANs options applied to the Network.

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/settings"

        payload = {}
        if local_status_page_enabled is not None:
            payload["localStatusPageEnabled"] = local_status_page_enabled
        if remote_status_page_enabled is not None:
            payload["remoteStatusPageEnabled"] = remote_status_page_enabled
        if local_status_page is not None:
            payload["localStatusPage"] = local_status_page.model_dump(
                by_alias=True, exclude_none=True
            )
        if secure_port is not None:
            payload["securePort"] = secure_port.model_dump(by_alias=True, exclude_none=True)
        if named_vlans is not None:
            payload["namedVlans"] = named_vlans.model_dump(by_alias=True, exclude_none=True)

        return CreateOrganizationActionBatchActionsItem(
            resource=path,
            operation="update",
            body=payload,
        )

    def split_network(self, network_id: str) -> CreateOrganizationActionBatchActionsItem:
        """Split a combined network into individual networks for each type of device.

        [API documentation: splitNetwork](https://developer.cisco.com/meraki/api-v1/#!split-network)

        Args:
            network_id: Network ID.

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/split"

        return CreateOrganizationActionBatchActionsItem(
            resource=path,
            operation="split",
        )

    def unbind_network(
        self, network_id: str, *, retain_configs: bool | None = None
    ) -> CreateOrganizationActionBatchActionsItem:
        """Unbind a network from a template.

        [API documentation: unbindNetwork](https://developer.cisco.com/meraki/api-v1/#!unbind-network)

        Args:
            network_id: Network ID.
            retain_configs: Optional boolean to retain all the current configs given by the
                template.

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/unbind"

        payload = {}
        if retain_configs is not None:
            payload["retainConfigs"] = retain_configs

        return CreateOrganizationActionBatchActionsItem(
            resource=path,
            operation="unbind",
            body=payload,
        )

    def create_network_vlan_profile(
        self,
        *,
        network_id: str,
        name: str,
        vlan_names: list[CreateNetworkVlanProfileVlanNamesItem],
        vlan_groups: list[CreateNetworkVlanProfileVlanGroupsItem],
        iname: str,
    ) -> CreateOrganizationActionBatchActionsItem:
        """Create a VLAN profile for a network.

        [API documentation: createNetworkVlanProfile](https://developer.cisco.com/meraki/api-v1/#!create-network-vlan-profile)

        Args:
            network_id: Network ID.
            name: Name of the profile, string length must be from 1 to 255 characters.
            vlan_names: An array of named VLANs.
            vlan_groups: An array of VLAN groups.
            iname: IName of the profile.

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/vlanProfiles"

        payload = {}
        if name is not None:
            payload["name"] = name
        if vlan_names is not None:
            payload["vlanNames"] = [
                item.model_dump(by_alias=True, exclude_none=True) for item in vlan_names
            ]
        if vlan_groups is not None:
            payload["vlanGroups"] = [
                item.model_dump(by_alias=True, exclude_none=True) for item in vlan_groups
            ]
        if iname is not None:
            payload["iname"] = iname

        return CreateOrganizationActionBatchActionsItem(
            resource=path,
            operation="create",
            body=payload,
        )

    def delete_network_vlan_profile(
        self, *, network_id: str, iname: str
    ) -> CreateOrganizationActionBatchActionsItem:
        """Delete a VLAN profile of a network.

        [API documentation: deleteNetworkVlanProfile](https://developer.cisco.com/meraki/api-v1/#!delete-network-vlan-profile)

        Args:
            network_id: Network ID.
            iname: Iname.

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        iname = urllib.parse.quote(str(iname), safe="")
        path = f"/networks/{network_id}/vlanProfiles/{iname}"

        return CreateOrganizationActionBatchActionsItem(
            resource=path,
            operation="destroy",
        )

    def create_network_webhooks_payload_template(
        self,
        *,
        network_id: str,
        name: str,
        body: str | None = None,
        headers: list[CreateNetworkWebhooksPayloadTemplateHeadersItem] | None = None,
        body_file: str | None = None,
        headers_file: str | None = None,
    ) -> CreateOrganizationActionBatchActionsItem:
        """Create a webhook payload template for a network.

        [API documentation: createNetworkWebhooksPayloadTemplate](https://developer.cisco.com/meraki/api-v1/#!create-network-webhooks-payload-template)

        Args:
            network_id: Network ID.
            name: The name of the new template.
            body: The liquid template used for the body of the webhook message. Either `body` or
                `bodyFile` must be specified.
            headers: The liquid template used with the webhook headers.
            body_file: A Base64 encoded file containing liquid template used for the body of the
                webhook message. Either `body` or `bodyFile` must be specified.
            headers_file: A Base64 encoded file containing the liquid template used with the webhook
                headers.

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        path = f"/networks/{network_id}/webhooks/payloadTemplates"

        payload = {}
        if name is not None:
            payload["name"] = name
        if body is not None:
            payload["body"] = body
        if headers is not None:
            payload["headers"] = [
                item.model_dump(by_alias=True, exclude_none=True) for item in headers
            ]
        if body_file is not None:
            payload["bodyFile"] = body_file
        if headers_file is not None:
            payload["headersFile"] = headers_file

        return CreateOrganizationActionBatchActionsItem(
            resource=path,
            operation="create",
            body=payload,
        )

    def update_network_webhooks_payload_template(
        self,
        *,
        network_id: str,
        payload_template_id: str,
        name: str | None = None,
        body: str | None = None,
        headers: list[UpdateNetworkWebhooksPayloadTemplateHeadersItem] | None = None,
        body_file: str | None = None,
        headers_file: str | None = None,
    ) -> CreateOrganizationActionBatchActionsItem:
        """Update a webhook payload template for a network.

        [API documentation: updateNetworkWebhooksPayloadTemplate](https://developer.cisco.com/meraki/api-v1/#!update-network-webhooks-payload-template)

        Args:
            network_id: Network ID.
            payload_template_id: Payload template ID.
            name: The name of the template.
            body: The liquid template used for the body of the webhook message.
            headers: The liquid template used with the webhook headers.
            body_file: A file containing liquid template used for the body of the webhook message.
            headers_file: A file containing the liquid template used with the webhook headers.

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        payload_template_id = urllib.parse.quote(str(payload_template_id), safe="")
        path = f"/networks/{network_id}/webhooks/payloadTemplates/{payload_template_id}"

        payload = {}
        if name is not None:
            payload["name"] = name
        if body is not None:
            payload["body"] = body
        if headers is not None:
            payload["headers"] = [
                item.model_dump(by_alias=True, exclude_none=True) for item in headers
            ]
        if body_file is not None:
            payload["bodyFile"] = body_file
        if headers_file is not None:
            payload["headersFile"] = headers_file

        return CreateOrganizationActionBatchActionsItem(
            resource=path,
            operation="update",
            body=payload,
        )

    def delete_network_webhooks_payload_template(
        self, *, network_id: str, payload_template_id: str
    ) -> CreateOrganizationActionBatchActionsItem:
        """Destroy a webhook payload template for a network.

        [API documentation: deleteNetworkWebhooksPayloadTemplate](https://developer.cisco.com/meraki/api-v1/#!delete-network-webhooks-payload-template)

        Args:
            network_id: Network ID.
            payload_template_id: Payload template ID.

        """
        network_id = urllib.parse.quote(str(network_id), safe="")
        payload_template_id = urllib.parse.quote(str(payload_template_id), safe="")
        path = f"/networks/{network_id}/webhooks/payloadTemplates/{payload_template_id}"

        return CreateOrganizationActionBatchActionsItem(
            resource=path,
            operation="destroy",
        )
