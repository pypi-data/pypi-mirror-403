# Generated by ariadne-codegen
# Source: python/atoti-client/graphql/schema.gql

from typing import List, Optional

from pydantic import Field

from ..._constant import Constant, ScalarConstant
from .base_model import BaseModel
from .enums import (
    AggregateProviderFilterLogicalConditionOperator,
    AggregateProviderFilterMembershipConditionOperator,
    AggregateProviderFilterRelationalConditionOperator,
    AggregateProviderPluginKey,
    CubeFilterLogicalConditionOperator,
    CubeFilterMembershipConditionOperator,
    CubeFilterRelationalConditionOperator,
    CubeRestrictionLogicalConditionOperator,
    CubeRestrictionMembershipConditionOperator,
    CubeRestrictionRelationalConditionOperator,
    DatabaseRestrictionLogicalConditionOperator,
    DatabaseRestrictionMembershipConditionOperator,
    DatabaseRestrictionRelationalConditionOperator,
    DataType,
    FileSystemFileType,
    HierarchiesCreationMode,
    MeasuresCreationMode,
    QuantileInterpolation,
    QuantileMode,
    Readiness,
    RelationshipOptionality,
)


class AddExternalTableInput(BaseModel):
    catalog_name: Optional[str] = Field(
        serialization_alias="catalogName", default=None, validation_alias="catalogName"
    )
    data_model_transaction_id: Optional[str] = Field(
        serialization_alias="dataModelTransactionId",
        default=None,
        validation_alias="dataModelTransactionId",
    )
    local_name: Optional[str] = Field(
        serialization_alias="localName", default=None, validation_alias="localName"
    )
    "If not omitted, the table will be renamed to this value in the local schema."
    primary_index: Optional[List[str]] = Field(
        serialization_alias="primaryIndex",
        default=None,
        validation_alias="primaryIndex",
    )
    "If omitted, the one in the external database will be used."
    schema_name: Optional[str] = Field(
        serialization_alias="schemaName", default=None, validation_alias="schemaName"
    )
    table_name: str = Field(
        serialization_alias="tableName", validation_alias="tableName"
    )


class AggregateProviderFilterCondition(BaseModel):
    leaf: Optional["AggregateProviderFilterLeafCondition"] = None
    logical: Optional["AggregateProviderFilterLogicalCondition"] = None


class AggregateProviderFilterLeafCondition(BaseModel):
    membership: Optional["AggregateProviderFilterMembershipCondition"] = None
    relational: Optional["AggregateProviderFilterRelationalCondition"] = None


class AggregateProviderFilterLogicalCondition(BaseModel):
    operands: List["AggregateProviderFilterCondition"]
    operator: AggregateProviderFilterLogicalConditionOperator


class AggregateProviderFilterMembershipCondition(BaseModel):
    elements: List[ScalarConstant]
    operator: AggregateProviderFilterMembershipConditionOperator
    subject: "LevelIdentifier"


class AggregateProviderFilterRelationalCondition(BaseModel):
    operator: AggregateProviderFilterRelationalConditionOperator
    subject: "LevelIdentifier"
    target: ScalarConstant


class AggregationMeasureDefinition(BaseModel):
    mean: Optional["MeanAggregationMeasureDefinition"] = None
    sum: Optional["SumAggregationMeasureDefinition"] = None
    max: Optional["MaxAggregationMeasureDefinition"] = None
    quantile: Optional["QuantileAggregationMeasureDefinition"] = None
    min: Optional["MinAggregationMeasureDefinition"] = None


class BeginDataModelTransactionInput(BaseModel):
    timeout: Optional[float] = None
    "Timeout in seconds to start the transaction.\nIf an already running transaction prevents this new one to start before this timeout elapses, this new one is aborted.\n\nIf `null`, the new transaction will wait indefinitely until it is able to start."
    transaction_id: Optional[str] = Field(
        serialization_alias="transactionId",
        default=None,
        validation_alias="transactionId",
    )
    "The client can pass its own ID to begin the transaction, make changes, and commit the transaction in a single document.\nThis makes the transaction non interactive and could allow the server to optimize its execution since it has the full picture.\nClient-generated IDs should be unique (e.g. UUIDs) to ensure that no other client can piggy back on the transaction.\nIf omitted, the server will generate a random ID."


class ColumnIdentifier(BaseModel):
    column_name: str = Field(
        serialization_alias="columnName", validation_alias="columnName"
    )
    table_name: str = Field(
        serialization_alias="tableName", validation_alias="tableName"
    )


class CommitDataModelTransactionInput(BaseModel):
    transaction_id: str = Field(
        serialization_alias="transactionId", validation_alias="transactionId"
    )


class ConnectToExternalDatabaseInput(BaseModel):
    data_source_name: Optional[str] = Field(
        serialization_alias="dataSourceName",
        default=None,
        validation_alias="dataSourceName",
    )


class ConstantMeasureDefinition(BaseModel):
    value: Constant


class CreateAggregateProviderInput(BaseModel):
    aggregate_provider_name: str = Field(
        serialization_alias="aggregateProviderName",
        validation_alias="aggregateProviderName",
    )
    cube_name: str = Field(serialization_alias="cubeName", validation_alias="cubeName")
    data_model_transaction_id: Optional[str] = Field(
        serialization_alias="dataModelTransactionId",
        default=None,
        validation_alias="dataModelTransactionId",
    )
    filter: Optional["AggregateProviderFilterCondition"] = None
    level_identifiers: Optional[List["LevelIdentifier"]] = Field(
        serialization_alias="levelIdentifiers",
        default=None,
        validation_alias="levelIdentifiers",
    )
    measure_names: Optional[List[str]] = Field(
        serialization_alias="measureNames",
        default=None,
        validation_alias="measureNames",
    )
    partitioning: Optional[str] = None
    plugin_key: AggregateProviderPluginKey = Field(
        serialization_alias="pluginKey", validation_alias="pluginKey"
    )


class CreateBasicAuthenticationUserInput(BaseModel):
    password: str
    username: str


class CreateCubeInput(BaseModel):
    application_name: Optional[str] = Field(
        serialization_alias="applicationName",
        default=None,
        validation_alias="applicationName",
    )
    catalog_names: List[str] = Field(
        serialization_alias="catalogNames", validation_alias="catalogNames"
    )
    cube_name: Optional[str] = Field(
        serialization_alias="cubeName", default=None, validation_alias="cubeName"
    )
    "If omitted, the cube will be named after the fact table."
    data_model_transaction_id: Optional[str] = Field(
        serialization_alias="dataModelTransactionId",
        default=None,
        validation_alias="dataModelTransactionId",
    )
    fact_table_name: str = Field(
        serialization_alias="factTableName", validation_alias="factTableName"
    )
    filter: Optional["CubeFilterCondition"] = None
    hierarchies: HierarchiesCreationMode = HierarchiesCreationMode.MANUAL
    id_in_cluster: Optional[str] = Field(
        serialization_alias="idInCluster", default=None, validation_alias="idInCluster"
    )
    measures: MeasuresCreationMode = MeasuresCreationMode.MANUAL
    priority: Optional[int] = None


class CreateCubeRestrictionInput(BaseModel):
    condition: "CubeRestrictionCondition"
    cube_name: str = Field(serialization_alias="cubeName", validation_alias="cubeName")
    data_model_transaction_id: Optional[str] = Field(
        serialization_alias="dataModelTransactionId",
        default=None,
        validation_alias="dataModelTransactionId",
    )
    role: str


class CreateDatabaseRestrictionInput(BaseModel):
    condition: "DatabaseRestrictionCondition"
    "The condition in disjunctive normal form.\nFor now only conjunction is supported so the outer list must have a single element."
    data_model_transaction_id: Optional[str] = Field(
        serialization_alias="dataModelTransactionId",
        default=None,
        validation_alias="dataModelTransactionId",
    )
    role: str


class CreateHierarchyInput(BaseModel):
    cube_name: str = Field(serialization_alias="cubeName", validation_alias="cubeName")
    data_model_transaction_id: Optional[str] = Field(
        serialization_alias="dataModelTransactionId",
        default=None,
        validation_alias="dataModelTransactionId",
    )
    definition: "HierarchyDefinition"
    hierarchy_identifier: "HierarchyIdentifier" = Field(
        serialization_alias="hierarchyIdentifier",
        validation_alias="hierarchyIdentifier",
    )


class CreateInMemoryTableColumnInput(BaseModel):
    column_name: str = Field(
        serialization_alias="columnName", validation_alias="columnName"
    )
    data_type: Optional[DataType] = Field(
        serialization_alias="dataType", default=None, validation_alias="dataType"
    )
    "Must be non-`null` unless `CreateTableInput.dataLoad` allows inferring a data type for this column."
    default_value: Optional[Constant] = Field(
        serialization_alias="defaultValue",
        default=None,
        validation_alias="defaultValue",
    )
    "Pass `null` to make the column nullable.\n\nIf omitted, it will be inferred from the column data type and whether the column is part of `CreateTableInput.primaryIndex` or not."


class CreateInMemoryTableInput(BaseModel):
    columns: List["CreateInMemoryTableColumnInput"] = Field(default_factory=lambda: [])
    "Can only be empty if `dataLoad` allows inferring some columns."
    data_load: Optional["DataLoadInput"] = Field(
        serialization_alias="dataLoad", default=None, validation_alias="dataLoad"
    )
    "If not `null`, the corresponding data will be used to infer the columns of the table and their data type."
    data_model_transaction_id: Optional[str] = Field(
        serialization_alias="dataModelTransactionId",
        default=None,
        validation_alias="dataModelTransactionId",
    )
    is_parameter_table: bool = Field(
        serialization_alias="isParameterTable",
        default=False,
        validation_alias="isParameterTable",
    )
    "This field is private."
    partitioning: Optional[str] = None
    "This field is private."
    primary_index: List[str] = Field(
        serialization_alias="primaryIndex",
        default_factory=lambda: [],
        validation_alias="primaryIndex",
    )
    "The names of the columns constituting the primary index of the table."
    table_name: str = Field(
        serialization_alias="tableName", validation_alias="tableName"
    )


class CreateIndividualRolesItemInput(BaseModel):
    individual_roles: List[str] = Field(
        serialization_alias="individualRoles", validation_alias="individualRoles"
    )
    username: str


class CreateJoinInput(BaseModel):
    data_model_transaction_id: Optional[str] = Field(
        serialization_alias="dataModelTransactionId",
        default=None,
        validation_alias="dataModelTransactionId",
    )
    join_name: str = Field(serialization_alias="joinName", validation_alias="joinName")
    mapping_items: Optional[List["JoinMappingItemInput"]] = Field(
        serialization_alias="mappingItems",
        default=None,
        validation_alias="mappingItems",
    )
    "If omitted, the source and target columns with the same name will be used as the mapping items."
    source_table_name: str = Field(
        serialization_alias="sourceTableName", validation_alias="sourceTableName"
    )
    target_optionality: RelationshipOptionality = Field(
        serialization_alias="targetOptionality",
        default=RelationshipOptionality.OPTIONAL,
        validation_alias="targetOptionality",
    )
    target_table_name: str = Field(
        serialization_alias="targetTableName", validation_alias="targetTableName"
    )


class CreateMeasureInput(BaseModel):
    cube_name: str = Field(serialization_alias="cubeName", validation_alias="cubeName")
    data_model_transaction_id: Optional[str] = Field(
        serialization_alias="dataModelTransactionId",
        default=None,
        validation_alias="dataModelTransactionId",
    )
    definition: "MeasureDefinition"
    measure_name: str = Field(
        serialization_alias="measureName", validation_alias="measureName"
    )


class CreateMemberPropertyInput(BaseModel):
    column_identifier: "ColumnIdentifier" = Field(
        serialization_alias="columnIdentifier", validation_alias="columnIdentifier"
    )
    cube_name: str = Field(serialization_alias="cubeName", validation_alias="cubeName")
    data_model_transaction_id: Optional[str] = Field(
        serialization_alias="dataModelTransactionId",
        default=None,
        validation_alias="dataModelTransactionId",
    )
    level_identifier: "LevelIdentifier" = Field(
        serialization_alias="levelIdentifier", validation_alias="levelIdentifier"
    )
    property_name: str = Field(
        serialization_alias="propertyName", validation_alias="propertyName"
    )


class CreateRoleMappingItemInput(BaseModel):
    external_role: str = Field(
        serialization_alias="externalRole", validation_alias="externalRole"
    )
    internal_roles: List[str] = Field(
        serialization_alias="internalRoles", validation_alias="internalRoles"
    )


class CubeFilterCondition(BaseModel):
    leaf: Optional["CubeFilterLeafCondition"] = None
    logical: Optional["CubeFilterLogicalCondition"] = None


class CubeFilterLeafCondition(BaseModel):
    membership: Optional["CubeFilterMembershipCondition"] = None
    relational: Optional["CubeFilterRelationalCondition"] = None


class CubeFilterLogicalCondition(BaseModel):
    operands: List["CubeFilterCondition"]
    operator: CubeFilterLogicalConditionOperator


class CubeFilterMembershipCondition(BaseModel):
    elements: List[Optional[ScalarConstant]]
    operator: CubeFilterMembershipConditionOperator
    subject: "SelectionFieldIdentifier"


class CubeFilterRelationalCondition(BaseModel):
    operator: CubeFilterRelationalConditionOperator
    subject: "SelectionFieldIdentifier"
    target: Optional[ScalarConstant] = None


class CubeRestrictionCondition(BaseModel):
    leaf: Optional["CubeRestrictionLeafCondition"] = None
    logical: Optional["CubeRestrictionLogicalCondition"] = None


class CubeRestrictionLeafCondition(BaseModel):
    membership: Optional["CubeRestrictionMembershipCondition"] = None
    relational: Optional["CubeRestrictionRelationalCondition"] = None


class CubeRestrictionLogicalCondition(BaseModel):
    operands: List["CubeRestrictionCondition"]
    operator: CubeRestrictionLogicalConditionOperator


class CubeRestrictionMembershipCondition(BaseModel):
    elements: List[ScalarConstant]
    operator: CubeRestrictionMembershipConditionOperator
    subject: "LevelIdentifier"


class CubeRestrictionRelationalCondition(BaseModel):
    operator: CubeRestrictionRelationalConditionOperator
    subject: "LevelIdentifier"
    target: ScalarConstant


class DataLoadInput(BaseModel):
    data_source: Optional["NamedDataSourceLoadInput"] = Field(
        serialization_alias="dataSource", default=None, validation_alias="dataSource"
    )


class DataSourceLoadInput(BaseModel):
    file_system: Optional["FileSystemDataSourceLoadInput"] = Field(
        serialization_alias="fileSystem", default=None, validation_alias="fileSystem"
    )
    jdbc: Optional["JdbcDataSourceLoadInput"] = None


class DatabaseRestrictionCondition(BaseModel):
    leaf: Optional["DatabaseRestrictionLeafCondition"] = None
    logical: Optional["DatabaseRestrictionLogicalCondition"] = None


class DatabaseRestrictionLeafCondition(BaseModel):
    membership: Optional["DatabaseRestrictionMembershipCondition"] = None
    relational: Optional["DatabaseRestrictionRelationalCondition"] = None


class DatabaseRestrictionLogicalCondition(BaseModel):
    operands: List["DatabaseRestrictionCondition"]
    operator: DatabaseRestrictionLogicalConditionOperator


class DatabaseRestrictionMembershipCondition(BaseModel):
    elements: List[ScalarConstant]
    operator: DatabaseRestrictionMembershipConditionOperator
    subject: "ColumnIdentifier"


class DatabaseRestrictionRelationalCondition(BaseModel):
    operator: DatabaseRestrictionRelationalConditionOperator
    subject: "ColumnIdentifier"
    target: ScalarConstant


class DeleteAggregateProviderInput(BaseModel):
    aggregate_provider_name: str = Field(
        serialization_alias="aggregateProviderName",
        validation_alias="aggregateProviderName",
    )
    cube_name: str = Field(serialization_alias="cubeName", validation_alias="cubeName")
    data_model_transaction_id: Optional[str] = Field(
        serialization_alias="dataModelTransactionId",
        default=None,
        validation_alias="dataModelTransactionId",
    )


class DeleteBasicAuthenticationUserInput(BaseModel):
    username: str


class DeleteCubeInput(BaseModel):
    cube_name: str = Field(serialization_alias="cubeName", validation_alias="cubeName")
    data_model_transaction_id: Optional[str] = Field(
        serialization_alias="dataModelTransactionId",
        default=None,
        validation_alias="dataModelTransactionId",
    )


class DeleteCubeRestrictionInput(BaseModel):
    cube_name: str = Field(serialization_alias="cubeName", validation_alias="cubeName")
    data_model_transaction_id: Optional[str] = Field(
        serialization_alias="dataModelTransactionId",
        default=None,
        validation_alias="dataModelTransactionId",
    )
    role: str


class DeleteDatabaseRestrictionInput(BaseModel):
    data_model_transaction_id: Optional[str] = Field(
        serialization_alias="dataModelTransactionId",
        default=None,
        validation_alias="dataModelTransactionId",
    )
    role: str


class DeleteHierarchyInput(BaseModel):
    cube_name: str = Field(serialization_alias="cubeName", validation_alias="cubeName")
    data_model_transaction_id: Optional[str] = Field(
        serialization_alias="dataModelTransactionId",
        default=None,
        validation_alias="dataModelTransactionId",
    )
    hierarchy_identifier: "HierarchyIdentifier" = Field(
        serialization_alias="hierarchyIdentifier",
        validation_alias="hierarchyIdentifier",
    )


class DeleteIndividualRolesItemInput(BaseModel):
    username: str


class DeleteJoinInput(BaseModel):
    data_model_transaction_id: Optional[str] = Field(
        serialization_alias="dataModelTransactionId",
        default=None,
        validation_alias="dataModelTransactionId",
    )
    join_name: str = Field(serialization_alias="joinName", validation_alias="joinName")
    source_table_name: str = Field(
        serialization_alias="sourceTableName", validation_alias="sourceTableName"
    )


class DeleteMeasureInput(BaseModel):
    cube_name: str = Field(serialization_alias="cubeName", validation_alias="cubeName")
    data_model_transaction_id: Optional[str] = Field(
        serialization_alias="dataModelTransactionId",
        default=None,
        validation_alias="dataModelTransactionId",
    )
    measure_name: str = Field(
        serialization_alias="measureName", validation_alias="measureName"
    )


class DeleteMemberPropertyInput(BaseModel):
    cube_name: str = Field(serialization_alias="cubeName", validation_alias="cubeName")
    data_model_transaction_id: Optional[str] = Field(
        serialization_alias="dataModelTransactionId",
        default=None,
        validation_alias="dataModelTransactionId",
    )
    level_identifier: "LevelIdentifier" = Field(
        serialization_alias="levelIdentifier", validation_alias="levelIdentifier"
    )
    property_name: str = Field(
        serialization_alias="propertyName", validation_alias="propertyName"
    )


class DeleteRoleMappingItemInput(BaseModel):
    external_role: str = Field(
        serialization_alias="externalRole", validation_alias="externalRole"
    )


class DeleteTableInput(BaseModel):
    data_model_transaction_id: Optional[str] = Field(
        serialization_alias="dataModelTransactionId",
        default=None,
        validation_alias="dataModelTransactionId",
    )
    table_name: str = Field(
        serialization_alias="tableName", validation_alias="tableName"
    )


class FileSystemDataSourceLoadInput(BaseModel):
    glob: str
    type: FileSystemFileType


class HierarchyDefinition(BaseModel):
    selection: Optional["SelectionHierarchyDefinition"] = None


class HierarchyIdentifier(BaseModel):
    dimension_name: str = Field(
        serialization_alias="dimensionName", validation_alias="dimensionName"
    )
    hierarchy_name: str = Field(
        serialization_alias="hierarchyName", validation_alias="hierarchyName"
    )


class JdbcDataSourceLoadInput(BaseModel):
    parameters: List["ParameterInput"] = Field(default_factory=lambda: [])
    query: str


class JoinMappingItemInput(BaseModel):
    source_column_name: str = Field(
        serialization_alias="sourceColumnName", validation_alias="sourceColumnName"
    )
    target_column_name: str = Field(
        serialization_alias="targetColumnName", validation_alias="targetColumnName"
    )


class LevelIdentifier(BaseModel):
    dimension_name: str = Field(
        serialization_alias="dimensionName", validation_alias="dimensionName"
    )
    hierarchy_name: str = Field(
        serialization_alias="hierarchyName", validation_alias="hierarchyName"
    )
    level_name: str = Field(
        serialization_alias="levelName", validation_alias="levelName"
    )


class LoadInMemoryTableSourcesInput(BaseModel):
    data_transaction_id: Optional[str] = Field(
        serialization_alias="dataTransactionId",
        default=None,
        validation_alias="dataTransactionId",
    )


class MaxAggregationMeasureDefinition(BaseModel):
    value: "MeasureDefinition"


class MeanAggregationMeasureDefinition(BaseModel):
    value: "MeasureDefinition"


class MeasureDefinition(BaseModel):
    aggregation: Optional["ScopedAggregationMeasureDefinition"] = None
    constant: Optional["ConstantMeasureDefinition"] = None
    selection_field: Optional["SelectionFieldMeasureDefinition"] = Field(
        serialization_alias="selectionField",
        default=None,
        validation_alias="selectionField",
    )
    multiplication: Optional["MultiplicationMeasureDefinition"] = None


class MinAggregationMeasureDefinition(BaseModel):
    value: "MeasureDefinition"


class MultiplicationMeasureDefinition(BaseModel):
    factors: List["MeasureDefinition"]


class NamedDataSourceLoadInput(BaseModel):
    data_source_load: "DataSourceLoadInput" = Field(
        serialization_alias="dataSourceLoad", validation_alias="dataSourceLoad"
    )
    data_source_name: str = Field(
        serialization_alias="dataSourceName", validation_alias="dataSourceName"
    )


class ParameterInput(BaseModel):
    name: Optional[str] = None
    'This field can be set when the client needs to keep track of which variable it bound to this parameter.\n\nFor example, a client can pass this input:\n\n```\nJdbcDataSourceLoadInput(\n  parameters: [{name: "cityName", value: $cityName}],\n  query: "SELECT * FROM cities WHERE name = ?"\n)\n```\n\nand then query:\n\n```\n{\n  ... on JdbcDataSourceLoad {\n    parameters {\n      name\n    }\n    query\n  }\n}\n```\n\nto get back:\n\n```\n{\n  parameters: [{"name": "cityName"}],\n  query: "SELECT * FROM cities WHERE name = ?"\n}\n```\n\nTypically, the client will set the `name` field to the name of the variable it bound to the `value` field.\n\nIt is nullable because clients are free to not name parameters if they do not need to query the parameter name back.'
    value: Constant


class QuantileAggregationMeasureDefinition(BaseModel):
    interpolation: QuantileInterpolation
    mode: QuantileMode
    quantile: "MeasureDefinition"
    value: "MeasureDefinition"


class RollbackDataModelTransactionInput(BaseModel):
    transaction_id: str = Field(
        serialization_alias="transactionId", validation_alias="transactionId"
    )


class ScopedAggregationMeasureDefinition(BaseModel):
    definition: "AggregationMeasureDefinition"


class SelectionFieldIdentifier(BaseModel):
    column_name: str = Field(
        serialization_alias="columnName", validation_alias="columnName"
    )
    join_names: List[str] = Field(
        serialization_alias="joinNames", validation_alias="joinNames"
    )
    "The names of the joins from `Cube.factTable` to the `Table` holding the `Column` named `columnName`."


class SelectionFieldMeasureDefinition(BaseModel):
    selection_field_identifier: "SelectionFieldIdentifier" = Field(
        serialization_alias="selectionFieldIdentifier",
        validation_alias="selectionFieldIdentifier",
    )


class SelectionHierarchyDefinition(BaseModel):
    levels: List["SelectionHierarchyLevelDefinition"]


class SelectionHierarchyLevelDefinition(BaseModel):
    level_name: str = Field(
        serialization_alias="levelName", validation_alias="levelName"
    )
    selection_field_identifier: "SelectionFieldIdentifier" = Field(
        serialization_alias="selectionFieldIdentifier",
        validation_alias="selectionFieldIdentifier",
    )


class SumAggregationMeasureDefinition(BaseModel):
    value: "MeasureDefinition"


class UnloadMembersFromDataCubeInput(BaseModel):
    branch_name: str = Field(
        serialization_alias="branchName", validation_alias="branchName"
    )
    data_cube_id: str = Field(
        serialization_alias="dataCubeId", validation_alias="dataCubeId"
    )
    level_identifier: "LevelIdentifier" = Field(
        serialization_alias="levelIdentifier", validation_alias="levelIdentifier"
    )
    members: List[ScalarConstant]
    query_cube_name: str = Field(
        serialization_alias="queryCubeName", validation_alias="queryCubeName"
    )


class UpdateAggregateCacheInput(BaseModel):
    capacity: Optional[int] = None
    "Must be omitted or >= 0."
    measure_names: Optional[List[str]] = Field(
        serialization_alias="measureNames",
        default=None,
        validation_alias="measureNames",
    )
    "Pass `null` to cache all measures."


class UpdateColumnInput(BaseModel):
    column_identifier: "ColumnIdentifier" = Field(
        serialization_alias="columnIdentifier", validation_alias="columnIdentifier"
    )
    data_model_transaction_id: Optional[str] = Field(
        serialization_alias="dataModelTransactionId",
        default=None,
        validation_alias="dataModelTransactionId",
    )
    default_value: Optional[Constant] = Field(
        serialization_alias="defaultValue",
        default=None,
        validation_alias="defaultValue",
    )
    "Pass `null` to make the column nullable."


class UpdateCubeInput(BaseModel):
    aggregate_cache: Optional["UpdateAggregateCacheInput"] = Field(
        serialization_alias="aggregateCache",
        default=None,
        validation_alias="aggregateCache",
    )
    cube_name: str = Field(serialization_alias="cubeName", validation_alias="cubeName")
    data_model_transaction_id: Optional[str] = Field(
        serialization_alias="dataModelTransactionId",
        default=None,
        validation_alias="dataModelTransactionId",
    )
    updateable_cells: Optional["UpdateUpdateableCellsInput"] = Field(
        serialization_alias="updateableCells",
        default=None,
        validation_alias="updateableCells",
    )


class UpdateDataModelInput(BaseModel):
    database: Optional["UpdateDatabaseInput"] = None
    data_model_transaction_id: Optional[str] = Field(
        serialization_alias="dataModelTransactionId",
        default=None,
        validation_alias="dataModelTransactionId",
    )


class UpdateDatabaseInput(BaseModel):
    owners: Optional[List[str]] = None
    readers: Optional[List[str]] = None


class UpdateDimensionInput(BaseModel):
    cube_name: str = Field(serialization_alias="cubeName", validation_alias="cubeName")
    data_model_transaction_id: Optional[str] = Field(
        serialization_alias="dataModelTransactionId",
        default=None,
        validation_alias="dataModelTransactionId",
    )
    default_hierarchy_name: Optional[str] = Field(
        serialization_alias="defaultHierarchyName",
        default=None,
        validation_alias="defaultHierarchyName",
    )
    dimension_name: str = Field(
        serialization_alias="dimensionName", validation_alias="dimensionName"
    )


class UpdateHierarchyInput(BaseModel):
    are_members_indexed_by_name: Optional[bool] = Field(
        serialization_alias="areMembersIndexedByName",
        default=None,
        validation_alias="areMembersIndexedByName",
    )
    cube_name: str = Field(serialization_alias="cubeName", validation_alias="cubeName")
    data_model_transaction_id: Optional[str] = Field(
        serialization_alias="dataModelTransactionId",
        default=None,
        validation_alias="dataModelTransactionId",
    )
    description: Optional[str] = None
    folder: Optional[str] = None
    "See `Hierarchy.folder`."
    hierarchy_identifier: "HierarchyIdentifier" = Field(
        serialization_alias="hierarchyIdentifier",
        validation_alias="hierarchyIdentifier",
    )
    is_slicing: Optional[bool] = Field(
        serialization_alias="isSlicing", default=None, validation_alias="isSlicing"
    )
    viewers: Optional[List[str]] = None


class UpdateMeasureInput(BaseModel):
    cube_name: str = Field(serialization_alias="cubeName", validation_alias="cubeName")
    data_model_transaction_id: Optional[str] = Field(
        serialization_alias="dataModelTransactionId",
        default=None,
        validation_alias="dataModelTransactionId",
    )
    description: Optional[str] = None
    folder: Optional[str] = None
    formatter: Optional[str] = None
    is_visible: Optional[bool] = Field(
        serialization_alias="isVisible", default=None, validation_alias="isVisible"
    )
    measure_name: str = Field(
        serialization_alias="measureName", validation_alias="measureName"
    )


class UpdateProxyInput(BaseModel):
    url: Optional[str] = None


class UpdateReadinessInput(BaseModel):
    readiness: Readiness


class UpdateSsoSecurityInput(BaseModel):
    default_roles: Optional[List[str]] = Field(
        serialization_alias="defaultRoles",
        default=None,
        validation_alias="defaultRoles",
    )


class UpdateUpdateableCellsInput(BaseModel):
    hierarchy_identifiers: Optional[List["HierarchyIdentifier"]] = Field(
        serialization_alias="hierarchyIdentifiers",
        default=None,
        validation_alias="hierarchyIdentifiers",
    )
    level_identifiers: Optional[List["LevelIdentifier"]] = Field(
        serialization_alias="levelIdentifiers",
        default=None,
        validation_alias="levelIdentifiers",
    )
    roles: Optional[List[str]] = None
    "If not omitted, it must contain at least one element."


AggregateProviderFilterCondition.model_rebuild()
AggregateProviderFilterLeafCondition.model_rebuild()
AggregateProviderFilterLogicalCondition.model_rebuild()
AggregateProviderFilterMembershipCondition.model_rebuild()
AggregateProviderFilterRelationalCondition.model_rebuild()
AggregationMeasureDefinition.model_rebuild()
CreateAggregateProviderInput.model_rebuild()
CreateCubeInput.model_rebuild()
CreateCubeRestrictionInput.model_rebuild()
CreateDatabaseRestrictionInput.model_rebuild()
CreateHierarchyInput.model_rebuild()
CreateInMemoryTableInput.model_rebuild()
CreateJoinInput.model_rebuild()
CreateMeasureInput.model_rebuild()
CreateMemberPropertyInput.model_rebuild()
CubeFilterCondition.model_rebuild()
CubeFilterLeafCondition.model_rebuild()
CubeFilterLogicalCondition.model_rebuild()
CubeFilterMembershipCondition.model_rebuild()
CubeFilterRelationalCondition.model_rebuild()
CubeRestrictionCondition.model_rebuild()
CubeRestrictionLeafCondition.model_rebuild()
CubeRestrictionLogicalCondition.model_rebuild()
CubeRestrictionMembershipCondition.model_rebuild()
CubeRestrictionRelationalCondition.model_rebuild()
DataLoadInput.model_rebuild()
DataSourceLoadInput.model_rebuild()
DatabaseRestrictionCondition.model_rebuild()
DatabaseRestrictionLeafCondition.model_rebuild()
DatabaseRestrictionLogicalCondition.model_rebuild()
DatabaseRestrictionMembershipCondition.model_rebuild()
DatabaseRestrictionRelationalCondition.model_rebuild()
DeleteHierarchyInput.model_rebuild()
DeleteMemberPropertyInput.model_rebuild()
HierarchyDefinition.model_rebuild()
JdbcDataSourceLoadInput.model_rebuild()
MaxAggregationMeasureDefinition.model_rebuild()
MeanAggregationMeasureDefinition.model_rebuild()
MeasureDefinition.model_rebuild()
MinAggregationMeasureDefinition.model_rebuild()
MultiplicationMeasureDefinition.model_rebuild()
NamedDataSourceLoadInput.model_rebuild()
QuantileAggregationMeasureDefinition.model_rebuild()
ScopedAggregationMeasureDefinition.model_rebuild()
SelectionFieldMeasureDefinition.model_rebuild()
SelectionHierarchyDefinition.model_rebuild()
SelectionHierarchyLevelDefinition.model_rebuild()
SumAggregationMeasureDefinition.model_rebuild()
UnloadMembersFromDataCubeInput.model_rebuild()
UpdateColumnInput.model_rebuild()
UpdateCubeInput.model_rebuild()
UpdateDataModelInput.model_rebuild()
UpdateHierarchyInput.model_rebuild()
UpdateUpdateableCellsInput.model_rebuild()
