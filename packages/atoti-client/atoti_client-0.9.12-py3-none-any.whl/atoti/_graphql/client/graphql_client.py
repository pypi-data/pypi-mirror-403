# Generated by ariadne-codegen
# Source: python/atoti-client/graphql/operations.gql

from collections.abc import Callable, Mapping
from textwrap import dedent
from typing import IO, Any, Dict, Final, Optional, Union, final

import httpx
from pydantic import ValidationError
from typing_extensions import Unpack, override

from ..._mime_type import GRAPHQL_RESPONSE_MIME_TYPE
from .._batching import BatchedOperationFutureOutput, OperationBatcher
from .._empty import Empty
from .base_client import BaseClient
from .base_model import UNSET, BaseModel, UnsetType
from .create_aggregate_provider import CreateAggregateProvider
from .create_basic_authentication_user import CreateBasicAuthenticationUser
from .create_cube import CreateCube
from .create_cube_restriction import CreateCubeRestriction
from .create_database_restriction import CreateDatabaseRestriction
from .create_hierarchy import CreateHierarchy
from .create_in_memory_table import CreateInMemoryTable
from .create_individual_roles_item import CreateIndividualRolesItem
from .create_join import CreateJoin
from .create_measure import CreateMeasure
from .create_member_property import CreateMemberProperty
from .create_role_mapping_item import CreateRoleMappingItem
from .delete_aggregate_provider import DeleteAggregateProvider
from .delete_basic_authentication_user import DeleteBasicAuthenticationUser
from .delete_cube import DeleteCube
from .delete_cube_restriction import DeleteCubeRestriction
from .delete_database_restriction import DeleteDatabaseRestriction
from .delete_hierarchy import DeleteHierarchy
from .delete_individual_roles_item import DeleteIndividualRolesItem
from .delete_measure import DeleteMeasure
from .delete_member_property import DeleteMemberProperty
from .delete_role_mapping_item import DeleteRoleMappingItem
from .delete_table import DeleteTable
from .find_aggregate_provider import FindAggregateProvider
from .find_column import FindColumn
from .find_cube import FindCube
from .find_cube_restriction import FindCubeRestriction
from .find_hierarchy import FindHierarchy
from .find_hierarchy_across_dimensions import FindHierarchyAcrossDimensions
from .find_level import FindLevel
from .find_level_across_dimensions import FindLevelAcrossDimensions
from .find_level_across_hierarchies import FindLevelAcrossHierarchies
from .find_level_in_hierarchy import FindLevelInHierarchy
from .find_measure import FindMeasure
from .find_member_property import FindMemberProperty
from .find_table import FindTable
from .get_aggregate_cache import GetAggregateCache
from .get_aggregate_providers import GetAggregateProviders
from .get_basic_authentication_users import GetBasicAuthenticationUsers
from .get_cluster_members import GetClusterMembers
from .get_column_data_type import GetColumnDataType
from .get_column_default_value import GetColumnDefaultValue
from .get_cube_fact_table import GetCubeFactTable
from .get_cube_restrictions import GetCubeRestrictions
from .get_cubes import GetCubes
from .get_current_user import GetCurrentUser
from .get_database_fields import GetDatabaseFields
from .get_database_owners import GetDatabaseOwners
from .get_database_readers import GetDatabaseReaders
from .get_database_restriction import GetDatabaseRestriction
from .get_database_restrictions import GetDatabaseRestrictions
from .get_database_schema import GetDatabaseSchema
from .get_default_roles import GetDefaultRoles
from .get_dimension_default_hierarchy import GetDimensionDefaultHierarchy
from .get_hierarchies import GetHierarchies
from .get_hierarchy_are_members_indexed_by_name import (
    GetHierarchyAreMembersIndexedByName,
)
from .get_hierarchy_description import GetHierarchyDescription
from .get_hierarchy_folder import GetHierarchyFolder
from .get_hierarchy_is_slicing import GetHierarchyIsSlicing
from .get_hierarchy_is_virtual import GetHierarchyIsVirtual
from .get_hierarchy_is_visible import GetHierarchyIsVisible
from .get_hierarchy_levels import GetHierarchyLevels
from .get_hierarchy_viewers import GetHierarchyViewers
from .get_individual_roles_item import GetIndividualRolesItem
from .get_individual_roles_items import GetIndividualRolesItems
from .get_level_selection_field import GetLevelSelectionField
from .get_levels import GetLevels
from .get_measure_definition import GetMeasureDefinition
from .get_measure_description import GetMeasureDescription
from .get_measures import GetMeasures
from .get_member_properties import GetMemberProperties
from .get_proxy_url import GetProxyUrl
from .get_readiness import GetReadiness
from .get_role_mapping_item import GetRoleMappingItem
from .get_role_mapping_items import GetRoleMappingItems
from .get_table_columns import GetTableColumns
from .get_table_primary_index import GetTablePrimaryIndex
from .get_tables import GetTables
from .get_updateable_cells import GetUpdateableCells
from .input_types import (
    CreateAggregateProviderInput,
    CreateBasicAuthenticationUserInput,
    CreateCubeInput,
    CreateCubeRestrictionInput,
    CreateDatabaseRestrictionInput,
    CreateHierarchyInput,
    CreateIndividualRolesItemInput,
    CreateInMemoryTableInput,
    CreateJoinInput,
    CreateMeasureInput,
    CreateMemberPropertyInput,
    CreateRoleMappingItemInput,
    DeleteAggregateProviderInput,
    DeleteBasicAuthenticationUserInput,
    DeleteCubeInput,
    DeleteCubeRestrictionInput,
    DeleteDatabaseRestrictionInput,
    DeleteHierarchyInput,
    DeleteIndividualRolesItemInput,
    DeleteMeasureInput,
    DeleteMemberPropertyInput,
    DeleteRoleMappingItemInput,
    DeleteTableInput,
    UnloadMembersFromDataCubeInput,
    UpdateColumnInput,
    UpdateCubeInput,
    UpdateDataModelInput,
    UpdateDimensionInput,
    UpdateHierarchyInput,
    UpdateMeasureInput,
    UpdateProxyInput,
    UpdateReadinessInput,
    UpdateSsoSecurityInput,
)
from .reset_application import ResetApplication
from .unload_members_from_data_cube import UnloadMembersFromDataCube
from .update_column import UpdateColumn
from .update_cube import UpdateCube
from .update_data_model import UpdateDataModel
from .update_dimension import UpdateDimension
from .update_hierarchy import UpdateHierarchy
from .update_measure import UpdateMeasure
from .update_proxy import UpdateProxy
from .update_readiness import UpdateReadiness
from .update_sso_security import UpdateSsoSecurity


def gql(q: str) -> str:
    return dedent(q).strip()


@final
class GraphqlClient(BaseClient):
    def __init__(
        self,
        *,
        get_data_model_transaction_id: Callable[[], str | None],
        http_client: httpx.Client,
        url: str = "graphql",
    ) -> None:
        headers = {"Accept": GRAPHQL_RESPONSE_MIME_TYPE}
        super().__init__(headers=headers, http_client=http_client, url=url)
        self._get_data_model_transaction_id: Final = get_data_model_transaction_id

        def execute_operation(
            document: str, /, variables: Mapping[str, object]
        ) -> dict[str, object]:
            response = self.execute(document, variables=dict(variables))
            return self.get_data(response)

        self.mutation_batcher: Final = OperationBatcher(
            execute_operation=execute_operation
        )

    @override
    def execute(
        self,
        query: str,
        operation_name: str | None = None,
        variables: dict[str, Any] | None = None,
        **kwargs: Any,
    ) -> httpx.Response:
        kwargs["headers"] = {**self.headers, **kwargs.pop("headers", {})}
        return super().execute(
            query=query, operation_name=operation_name, variables=variables, **kwargs
        )

    @override
    def _process_variables(
        self, variables: dict[str, Any] | None
    ) -> tuple[
        dict[str, Any], dict[str, tuple[str, IO[bytes], str]], dict[str, list[str]]
    ]:
        reason = "Do not manually set the transaction ID."
        if variables is not None:  # pragma: no cover
            if "dataModelTransactionId" in variables:
                assert variables["dataModelTransactionId"] is UNSET, reason
                match self._get_data_model_transaction_id():
                    case str() as data_model_transaction_id:
                        variables["dataModelTransactionId"] = data_model_transaction_id
                    case None:
                        del variables["dataModelTransactionId"]
            for value in variables.values():
                if (
                    not isinstance(value, BaseModel)
                    or not "data_model_transaction_id" in type(value).model_fields
                ):
                    continue
                assert "data_model_transaction_id" not in value.model_fields_set, reason
                match self._get_data_model_transaction_id():
                    case str() as data_model_transaction_id:
                        value.data_model_transaction_id = data_model_transaction_id
                    case None:
                        ...
        return super()._process_variables(variables)

    def create_aggregate_provider(
        self,
        *,
        input: CreateAggregateProviderInput,
        validate_future_output: Callable[
            [CreateAggregateProvider], None
        ] = lambda _: None,
        **kwargs: Unpack[Empty],
    ) -> BatchedOperationFutureOutput[Mapping[str, object], CreateAggregateProvider]:
        query = gql(
            """
            mutation CreateAggregateProvider($input: CreateAggregateProviderInput!) {
              createAggregateProvider(input: $input) {
                __typename
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}

        def validate_output(data: Mapping[str, object], /) -> CreateAggregateProvider:
            try:
                return CreateAggregateProvider.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        def process_future_output(
            data: Mapping[str, object], /
        ) -> CreateAggregateProvider:
            output = validate_output(data)
            validate_future_output(output)
            return output

        return self.mutation_batcher.submit(
            document=query,
            variables=variables,
            process_future_output=process_future_output,
        )

    def create_basic_authentication_user(
        self,
        *,
        input: CreateBasicAuthenticationUserInput,
        validate_future_output: Callable[
            [CreateBasicAuthenticationUser], None
        ] = lambda _: None,
        **kwargs: Unpack[Empty],
    ) -> BatchedOperationFutureOutput[
        Mapping[str, object], CreateBasicAuthenticationUser
    ]:
        query = gql(
            """
            mutation CreateBasicAuthenticationUser($input: CreateBasicAuthenticationUserInput!) {
              createBasicAuthenticationUser(input: $input) {
                __typename
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}

        def validate_output(
            data: Mapping[str, object], /
        ) -> CreateBasicAuthenticationUser:
            try:
                return CreateBasicAuthenticationUser.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        def process_future_output(
            data: Mapping[str, object], /
        ) -> CreateBasicAuthenticationUser:
            output = validate_output(data)
            validate_future_output(output)
            return output

        return self.mutation_batcher.submit(
            document=query,
            variables=variables,
            process_future_output=process_future_output,
        )

    def create_cube(
        self,
        *,
        input: CreateCubeInput,
        validate_future_output: Callable[[CreateCube], None] = lambda _: None,
        **kwargs: Unpack[Empty],
    ) -> BatchedOperationFutureOutput[Mapping[str, object], CreateCube]:
        query = gql(
            """
            mutation CreateCube($input: CreateCubeInput!) {
              createCube(input: $input) {
                __typename
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}

        def validate_output(data: Mapping[str, object], /) -> CreateCube:
            try:
                return CreateCube.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        def process_future_output(data: Mapping[str, object], /) -> CreateCube:
            output = validate_output(data)
            validate_future_output(output)
            return output

        return self.mutation_batcher.submit(
            document=query,
            variables=variables,
            process_future_output=process_future_output,
        )

    def create_cube_restriction(
        self,
        *,
        input: CreateCubeRestrictionInput,
        validate_future_output: Callable[
            [CreateCubeRestriction], None
        ] = lambda _: None,
        **kwargs: Unpack[Empty],
    ) -> BatchedOperationFutureOutput[Mapping[str, object], CreateCubeRestriction]:
        query = gql(
            """
            mutation CreateCubeRestriction($input: CreateCubeRestrictionInput!) {
              createCubeRestriction(input: $input) {
                __typename
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}

        def validate_output(data: Mapping[str, object], /) -> CreateCubeRestriction:
            try:
                return CreateCubeRestriction.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        def process_future_output(
            data: Mapping[str, object], /
        ) -> CreateCubeRestriction:
            output = validate_output(data)
            validate_future_output(output)
            return output

        return self.mutation_batcher.submit(
            document=query,
            variables=variables,
            process_future_output=process_future_output,
        )

    def create_database_restriction(
        self,
        *,
        input: CreateDatabaseRestrictionInput,
        validate_future_output: Callable[
            [CreateDatabaseRestriction], None
        ] = lambda _: None,
        **kwargs: Unpack[Empty],
    ) -> BatchedOperationFutureOutput[Mapping[str, object], CreateDatabaseRestriction]:
        query = gql(
            """
            mutation CreateDatabaseRestriction($input: CreateDatabaseRestrictionInput!) {
              createDatabaseRestriction(input: $input) {
                __typename
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}

        def validate_output(data: Mapping[str, object], /) -> CreateDatabaseRestriction:
            try:
                return CreateDatabaseRestriction.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        def process_future_output(
            data: Mapping[str, object], /
        ) -> CreateDatabaseRestriction:
            output = validate_output(data)
            validate_future_output(output)
            return output

        return self.mutation_batcher.submit(
            document=query,
            variables=variables,
            process_future_output=process_future_output,
        )

    def create_hierarchy(
        self,
        *,
        input: CreateHierarchyInput,
        validate_future_output: Callable[[CreateHierarchy], None] = lambda _: None,
        **kwargs: Unpack[Empty],
    ) -> BatchedOperationFutureOutput[Mapping[str, object], CreateHierarchy]:
        query = gql(
            """
            mutation CreateHierarchy($input: CreateHierarchyInput!) {
              createHierarchy(input: $input) {
                __typename
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}

        def validate_output(data: Mapping[str, object], /) -> CreateHierarchy:
            try:
                return CreateHierarchy.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        def process_future_output(data: Mapping[str, object], /) -> CreateHierarchy:
            output = validate_output(data)
            validate_future_output(output)
            return output

        return self.mutation_batcher.submit(
            document=query,
            variables=variables,
            process_future_output=process_future_output,
        )

    def create_individual_roles_item(
        self,
        *,
        input: CreateIndividualRolesItemInput,
        validate_future_output: Callable[
            [CreateIndividualRolesItem], None
        ] = lambda _: None,
        **kwargs: Unpack[Empty],
    ) -> BatchedOperationFutureOutput[Mapping[str, object], CreateIndividualRolesItem]:
        query = gql(
            """
            mutation CreateIndividualRolesItem($input: CreateIndividualRolesItemInput!) {
              createIndividualRolesItem(input: $input) {
                __typename
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}

        def validate_output(data: Mapping[str, object], /) -> CreateIndividualRolesItem:
            try:
                return CreateIndividualRolesItem.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        def process_future_output(
            data: Mapping[str, object], /
        ) -> CreateIndividualRolesItem:
            output = validate_output(data)
            validate_future_output(output)
            return output

        return self.mutation_batcher.submit(
            document=query,
            variables=variables,
            process_future_output=process_future_output,
        )

    def create_in_memory_table(
        self,
        *,
        input: CreateInMemoryTableInput,
        validate_future_output: Callable[[CreateInMemoryTable], None] = lambda _: None,
        **kwargs: Unpack[Empty],
    ) -> BatchedOperationFutureOutput[Mapping[str, object], CreateInMemoryTable]:
        query = gql(
            """
            mutation CreateInMemoryTable($input: CreateInMemoryTableInput!) {
              createInMemoryTable(input: $input) {
                __typename
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}

        def validate_output(data: Mapping[str, object], /) -> CreateInMemoryTable:
            try:
                return CreateInMemoryTable.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        def process_future_output(data: Mapping[str, object], /) -> CreateInMemoryTable:
            output = validate_output(data)
            validate_future_output(output)
            return output

        return self.mutation_batcher.submit(
            document=query,
            variables=variables,
            process_future_output=process_future_output,
        )

    def create_join(
        self,
        *,
        input: CreateJoinInput,
        validate_future_output: Callable[[CreateJoin], None] = lambda _: None,
        **kwargs: Unpack[Empty],
    ) -> BatchedOperationFutureOutput[Mapping[str, object], CreateJoin]:
        query = gql(
            """
            mutation CreateJoin($input: CreateJoinInput!) {
              createJoin(input: $input) {
                __typename
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}

        def validate_output(data: Mapping[str, object], /) -> CreateJoin:
            try:
                return CreateJoin.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        def process_future_output(data: Mapping[str, object], /) -> CreateJoin:
            output = validate_output(data)
            validate_future_output(output)
            return output

        return self.mutation_batcher.submit(
            document=query,
            variables=variables,
            process_future_output=process_future_output,
        )

    def create_measure(
        self,
        *,
        input: CreateMeasureInput,
        validate_future_output: Callable[[CreateMeasure], None] = lambda _: None,
        **kwargs: Unpack[Empty],
    ) -> BatchedOperationFutureOutput[Mapping[str, object], CreateMeasure]:
        query = gql(
            """
            mutation CreateMeasure($input: CreateMeasureInput!) {
              createMeasure(input: $input) {
                __typename
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}

        def validate_output(data: Mapping[str, object], /) -> CreateMeasure:
            try:
                return CreateMeasure.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        def process_future_output(data: Mapping[str, object], /) -> CreateMeasure:
            output = validate_output(data)
            validate_future_output(output)
            return output

        return self.mutation_batcher.submit(
            document=query,
            variables=variables,
            process_future_output=process_future_output,
        )

    def create_member_property(
        self,
        *,
        input: CreateMemberPropertyInput,
        validate_future_output: Callable[[CreateMemberProperty], None] = lambda _: None,
        **kwargs: Unpack[Empty],
    ) -> BatchedOperationFutureOutput[Mapping[str, object], CreateMemberProperty]:
        query = gql(
            """
            mutation CreateMemberProperty($input: CreateMemberPropertyInput!) {
              createMemberProperty(input: $input) {
                __typename
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}

        def validate_output(data: Mapping[str, object], /) -> CreateMemberProperty:
            try:
                return CreateMemberProperty.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        def process_future_output(
            data: Mapping[str, object], /
        ) -> CreateMemberProperty:
            output = validate_output(data)
            validate_future_output(output)
            return output

        return self.mutation_batcher.submit(
            document=query,
            variables=variables,
            process_future_output=process_future_output,
        )

    def create_role_mapping_item(
        self,
        *,
        input: CreateRoleMappingItemInput,
        validate_future_output: Callable[
            [CreateRoleMappingItem], None
        ] = lambda _: None,
        **kwargs: Unpack[Empty],
    ) -> BatchedOperationFutureOutput[Mapping[str, object], CreateRoleMappingItem]:
        query = gql(
            """
            mutation CreateRoleMappingItem($input: CreateRoleMappingItemInput!) {
              createRoleMappingItem(input: $input) {
                __typename
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}

        def validate_output(data: Mapping[str, object], /) -> CreateRoleMappingItem:
            try:
                return CreateRoleMappingItem.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        def process_future_output(
            data: Mapping[str, object], /
        ) -> CreateRoleMappingItem:
            output = validate_output(data)
            validate_future_output(output)
            return output

        return self.mutation_batcher.submit(
            document=query,
            variables=variables,
            process_future_output=process_future_output,
        )

    def delete_aggregate_provider(
        self,
        *,
        input: DeleteAggregateProviderInput,
        validate_future_output: Callable[
            [DeleteAggregateProvider], None
        ] = lambda _: None,
        **kwargs: Unpack[Empty],
    ) -> BatchedOperationFutureOutput[Mapping[str, object], DeleteAggregateProvider]:
        query = gql(
            """
            mutation DeleteAggregateProvider($input: DeleteAggregateProviderInput!) {
              deleteAggregateProvider(input: $input) {
                status
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}

        def validate_output(data: Mapping[str, object], /) -> DeleteAggregateProvider:
            try:
                return DeleteAggregateProvider.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        def process_future_output(
            data: Mapping[str, object], /
        ) -> DeleteAggregateProvider:
            output = validate_output(data)
            validate_future_output(output)
            return output

        return self.mutation_batcher.submit(
            document=query,
            variables=variables,
            process_future_output=process_future_output,
        )

    def delete_basic_authentication_user(
        self,
        *,
        input: DeleteBasicAuthenticationUserInput,
        validate_future_output: Callable[
            [DeleteBasicAuthenticationUser], None
        ] = lambda _: None,
        **kwargs: Unpack[Empty],
    ) -> BatchedOperationFutureOutput[
        Mapping[str, object], DeleteBasicAuthenticationUser
    ]:
        query = gql(
            """
            mutation DeleteBasicAuthenticationUser($input: DeleteBasicAuthenticationUserInput!) {
              deleteBasicAuthenticationUser(input: $input) {
                status
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}

        def validate_output(
            data: Mapping[str, object], /
        ) -> DeleteBasicAuthenticationUser:
            try:
                return DeleteBasicAuthenticationUser.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        def process_future_output(
            data: Mapping[str, object], /
        ) -> DeleteBasicAuthenticationUser:
            output = validate_output(data)
            validate_future_output(output)
            return output

        return self.mutation_batcher.submit(
            document=query,
            variables=variables,
            process_future_output=process_future_output,
        )

    def delete_cube(
        self,
        *,
        input: DeleteCubeInput,
        validate_future_output: Callable[[DeleteCube], None] = lambda _: None,
        **kwargs: Unpack[Empty],
    ) -> BatchedOperationFutureOutput[Mapping[str, object], DeleteCube]:
        query = gql(
            """
            mutation DeleteCube($input: DeleteCubeInput!) {
              deleteCube(input: $input) {
                status
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}

        def validate_output(data: Mapping[str, object], /) -> DeleteCube:
            try:
                return DeleteCube.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        def process_future_output(data: Mapping[str, object], /) -> DeleteCube:
            output = validate_output(data)
            validate_future_output(output)
            return output

        return self.mutation_batcher.submit(
            document=query,
            variables=variables,
            process_future_output=process_future_output,
        )

    def delete_cube_restriction(
        self,
        *,
        input: DeleteCubeRestrictionInput,
        validate_future_output: Callable[
            [DeleteCubeRestriction], None
        ] = lambda _: None,
        **kwargs: Unpack[Empty],
    ) -> BatchedOperationFutureOutput[Mapping[str, object], DeleteCubeRestriction]:
        query = gql(
            """
            mutation DeleteCubeRestriction($input: DeleteCubeRestrictionInput!) {
              deleteCubeRestriction(input: $input) {
                status
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}

        def validate_output(data: Mapping[str, object], /) -> DeleteCubeRestriction:
            try:
                return DeleteCubeRestriction.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        def process_future_output(
            data: Mapping[str, object], /
        ) -> DeleteCubeRestriction:
            output = validate_output(data)
            validate_future_output(output)
            return output

        return self.mutation_batcher.submit(
            document=query,
            variables=variables,
            process_future_output=process_future_output,
        )

    def delete_database_restriction(
        self,
        *,
        input: DeleteDatabaseRestrictionInput,
        validate_future_output: Callable[
            [DeleteDatabaseRestriction], None
        ] = lambda _: None,
        **kwargs: Unpack[Empty],
    ) -> BatchedOperationFutureOutput[Mapping[str, object], DeleteDatabaseRestriction]:
        query = gql(
            """
            mutation DeleteDatabaseRestriction($input: DeleteDatabaseRestrictionInput!) {
              deleteDatabaseRestriction(input: $input) {
                status
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}

        def validate_output(data: Mapping[str, object], /) -> DeleteDatabaseRestriction:
            try:
                return DeleteDatabaseRestriction.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        def process_future_output(
            data: Mapping[str, object], /
        ) -> DeleteDatabaseRestriction:
            output = validate_output(data)
            validate_future_output(output)
            return output

        return self.mutation_batcher.submit(
            document=query,
            variables=variables,
            process_future_output=process_future_output,
        )

    def delete_hierarchy(
        self,
        *,
        input: DeleteHierarchyInput,
        validate_future_output: Callable[[DeleteHierarchy], None] = lambda _: None,
        **kwargs: Unpack[Empty],
    ) -> BatchedOperationFutureOutput[Mapping[str, object], DeleteHierarchy]:
        query = gql(
            """
            mutation DeleteHierarchy($input: DeleteHierarchyInput!) {
              deleteHierarchy(input: $input) {
                status
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}

        def validate_output(data: Mapping[str, object], /) -> DeleteHierarchy:
            try:
                return DeleteHierarchy.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        def process_future_output(data: Mapping[str, object], /) -> DeleteHierarchy:
            output = validate_output(data)
            validate_future_output(output)
            return output

        return self.mutation_batcher.submit(
            document=query,
            variables=variables,
            process_future_output=process_future_output,
        )

    def delete_individual_roles_item(
        self,
        *,
        input: DeleteIndividualRolesItemInput,
        validate_future_output: Callable[
            [DeleteIndividualRolesItem], None
        ] = lambda _: None,
        **kwargs: Unpack[Empty],
    ) -> BatchedOperationFutureOutput[Mapping[str, object], DeleteIndividualRolesItem]:
        query = gql(
            """
            mutation DeleteIndividualRolesItem($input: DeleteIndividualRolesItemInput!) {
              deleteIndividualRolesItem(input: $input) {
                status
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}

        def validate_output(data: Mapping[str, object], /) -> DeleteIndividualRolesItem:
            try:
                return DeleteIndividualRolesItem.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        def process_future_output(
            data: Mapping[str, object], /
        ) -> DeleteIndividualRolesItem:
            output = validate_output(data)
            validate_future_output(output)
            return output

        return self.mutation_batcher.submit(
            document=query,
            variables=variables,
            process_future_output=process_future_output,
        )

    def delete_measure(
        self,
        *,
        input: DeleteMeasureInput,
        validate_future_output: Callable[[DeleteMeasure], None] = lambda _: None,
        **kwargs: Unpack[Empty],
    ) -> BatchedOperationFutureOutput[Mapping[str, object], DeleteMeasure]:
        query = gql(
            """
            mutation DeleteMeasure($input: DeleteMeasureInput!) {
              deleteMeasure(input: $input) {
                status
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}

        def validate_output(data: Mapping[str, object], /) -> DeleteMeasure:
            try:
                return DeleteMeasure.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        def process_future_output(data: Mapping[str, object], /) -> DeleteMeasure:
            output = validate_output(data)
            validate_future_output(output)
            return output

        return self.mutation_batcher.submit(
            document=query,
            variables=variables,
            process_future_output=process_future_output,
        )

    def delete_member_property(
        self,
        *,
        input: DeleteMemberPropertyInput,
        validate_future_output: Callable[[DeleteMemberProperty], None] = lambda _: None,
        **kwargs: Unpack[Empty],
    ) -> BatchedOperationFutureOutput[Mapping[str, object], DeleteMemberProperty]:
        query = gql(
            """
            mutation DeleteMemberProperty($input: DeleteMemberPropertyInput!) {
              deleteMemberProperty(input: $input) {
                status
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}

        def validate_output(data: Mapping[str, object], /) -> DeleteMemberProperty:
            try:
                return DeleteMemberProperty.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        def process_future_output(
            data: Mapping[str, object], /
        ) -> DeleteMemberProperty:
            output = validate_output(data)
            validate_future_output(output)
            return output

        return self.mutation_batcher.submit(
            document=query,
            variables=variables,
            process_future_output=process_future_output,
        )

    def delete_role_mapping_item(
        self,
        *,
        input: DeleteRoleMappingItemInput,
        validate_future_output: Callable[
            [DeleteRoleMappingItem], None
        ] = lambda _: None,
        **kwargs: Unpack[Empty],
    ) -> BatchedOperationFutureOutput[Mapping[str, object], DeleteRoleMappingItem]:
        query = gql(
            """
            mutation DeleteRoleMappingItem($input: DeleteRoleMappingItemInput!) {
              deleteRoleMappingItem(input: $input) {
                status
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}

        def validate_output(data: Mapping[str, object], /) -> DeleteRoleMappingItem:
            try:
                return DeleteRoleMappingItem.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        def process_future_output(
            data: Mapping[str, object], /
        ) -> DeleteRoleMappingItem:
            output = validate_output(data)
            validate_future_output(output)
            return output

        return self.mutation_batcher.submit(
            document=query,
            variables=variables,
            process_future_output=process_future_output,
        )

    def delete_table(
        self,
        *,
        input: DeleteTableInput,
        validate_future_output: Callable[[DeleteTable], None] = lambda _: None,
        **kwargs: Unpack[Empty],
    ) -> BatchedOperationFutureOutput[Mapping[str, object], DeleteTable]:
        query = gql(
            """
            mutation DeleteTable($input: DeleteTableInput!) {
              deleteTable(input: $input) {
                status
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}

        def validate_output(data: Mapping[str, object], /) -> DeleteTable:
            try:
                return DeleteTable.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        def process_future_output(data: Mapping[str, object], /) -> DeleteTable:
            output = validate_output(data)
            validate_future_output(output)
            return output

        return self.mutation_batcher.submit(
            document=query,
            variables=variables,
            process_future_output=process_future_output,
        )

    def find_aggregate_provider(
        self,
        *,
        cube_name: str,
        name: str,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> FindAggregateProvider:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query FindAggregateProvider($cubeName: String!, $dataModelTransactionId: ID, $name: String!) {
              dataModel(transactionId: $dataModelTransactionId) {
                cube(name: $cubeName) {
                  aggregateProvider(name: $name) {
                    ...aggregateProviderFragment
                  }
                }
              }
            }

            fragment aggregateProviderFragment on AggregateProvider {
              filter {
                value
              }
              levels {
                ...levelIdentifierFragment
              }
              measures {
                ...measureIdentifierFragment
              }
              partitioning
              pluginKey
            }

            fragment dimensionIdentifierFragment on Dimension {
              name
            }

            fragment hierarchyIdentifierFragment on Hierarchy {
              dimension {
                ...dimensionIdentifierFragment
              }
              name
            }

            fragment levelIdentifierFragment on Level {
              hierarchy {
                ...hierarchyIdentifierFragment
              }
              name
            }

            fragment measureIdentifierFragment on Measure {
              name
            }
            """
        )
        variables: Dict[str, object] = {
            "cubeName": cube_name,
            "dataModelTransactionId": data_model_transaction_id,
            "name": name,
        }
        response = self.execute(
            query=query,
            operation_name="FindAggregateProvider",
            variables=variables,
            **kwargs,
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> FindAggregateProvider:
            try:
                return FindAggregateProvider.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def find_column(
        self,
        *,
        column_name: str,
        table_name: str,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> FindColumn:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query FindColumn($columnName: String!, $dataModelTransactionId: ID, $tableName: String!) {
              dataModel(transactionId: $dataModelTransactionId) {
                database {
                  table(name: $tableName) {
                    __typename
                    column(name: $columnName) {
                      __typename
                      ...columnIdentifierFragment
                    }
                  }
                }
              }
            }

            fragment columnIdentifierFragment on Column {
              __typename
              name
              table {
                ...tableIdentifierFragment
              }
            }

            fragment tableIdentifierFragment on Table {
              __typename
              name
            }
            """
        )
        variables: Dict[str, object] = {
            "columnName": column_name,
            "dataModelTransactionId": data_model_transaction_id,
            "tableName": table_name,
        }
        response = self.execute(
            query=query, operation_name="FindColumn", variables=variables, **kwargs
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> FindColumn:
            try:
                return FindColumn.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def find_cube(
        self,
        *,
        cube_name: str,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> FindCube:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query FindCube($cubeName: String!, $dataModelTransactionId: ID) {
              dataModel(transactionId: $dataModelTransactionId) {
                cube(name: $cubeName) {
                  ...cubeIdentifierFragment
                }
              }
            }

            fragment cubeIdentifierFragment on Cube {
              name
            }
            """
        )
        variables: Dict[str, object] = {
            "cubeName": cube_name,
            "dataModelTransactionId": data_model_transaction_id,
        }
        response = self.execute(
            query=query, operation_name="FindCube", variables=variables, **kwargs
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> FindCube:
            try:
                return FindCube.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def find_cube_restriction(
        self,
        *,
        cube_name: str,
        role: str,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> FindCubeRestriction:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query FindCubeRestriction($cubeName: String!, $dataModelTransactionId: ID, $role: String!) {
              dataModel(transactionId: $dataModelTransactionId) {
                cube(name: $cubeName) {
                  restriction(role: $role) {
                    ...cubeRestrictionFragment
                  }
                }
              }
            }

            fragment cubeRestrictionFragment on CubeRestriction {
              condition {
                value
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "cubeName": cube_name,
            "dataModelTransactionId": data_model_transaction_id,
            "role": role,
        }
        response = self.execute(
            query=query,
            operation_name="FindCubeRestriction",
            variables=variables,
            **kwargs,
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> FindCubeRestriction:
            try:
                return FindCubeRestriction.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def find_hierarchy(
        self,
        *,
        cube_name: str,
        dimension_name: str,
        hierarchy_name: str,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> FindHierarchy:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query FindHierarchy($cubeName: String!, $dataModelTransactionId: ID, $dimensionName: String!, $hierarchyName: String!) {
              dataModel(transactionId: $dataModelTransactionId) {
                cube(name: $cubeName) {
                  dimension(name: $dimensionName) {
                    hierarchy(name: $hierarchyName) {
                      ...hierarchyIdentifierFragment
                    }
                  }
                }
              }
            }

            fragment dimensionIdentifierFragment on Dimension {
              name
            }

            fragment hierarchyIdentifierFragment on Hierarchy {
              dimension {
                ...dimensionIdentifierFragment
              }
              name
            }
            """
        )
        variables: Dict[str, object] = {
            "cubeName": cube_name,
            "dataModelTransactionId": data_model_transaction_id,
            "dimensionName": dimension_name,
            "hierarchyName": hierarchy_name,
        }
        response = self.execute(
            query=query, operation_name="FindHierarchy", variables=variables, **kwargs
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> FindHierarchy:
            try:
                return FindHierarchy.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def find_hierarchy_across_dimensions(
        self,
        *,
        cube_name: str,
        hierarchy_name: str,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> FindHierarchyAcrossDimensions:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query FindHierarchyAcrossDimensions($cubeName: String!, $dataModelTransactionId: ID, $hierarchyName: String!) {
              dataModel(transactionId: $dataModelTransactionId) {
                cube(name: $cubeName) {
                  dimensions {
                    hierarchy(name: $hierarchyName) {
                      name
                    }
                    name
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "cubeName": cube_name,
            "dataModelTransactionId": data_model_transaction_id,
            "hierarchyName": hierarchy_name,
        }
        response = self.execute(
            query=query,
            operation_name="FindHierarchyAcrossDimensions",
            variables=variables,
            **kwargs,
        )
        data = self.get_data(response)

        def validate_output(
            data: Mapping[str, object], /
        ) -> FindHierarchyAcrossDimensions:
            try:
                return FindHierarchyAcrossDimensions.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def find_level(
        self,
        *,
        cube_name: str,
        dimension_name: str,
        hierarchy_name: str,
        level_name: str,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> FindLevel:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query FindLevel($cubeName: String!, $dataModelTransactionId: ID, $dimensionName: String!, $hierarchyName: String!, $levelName: String!) {
              dataModel(transactionId: $dataModelTransactionId) {
                cube(name: $cubeName) {
                  dimension(name: $dimensionName) {
                    hierarchy(name: $hierarchyName) {
                      level(name: $levelName) {
                        ...levelIdentifierFragment
                        type
                      }
                    }
                  }
                }
              }
            }

            fragment dimensionIdentifierFragment on Dimension {
              name
            }

            fragment hierarchyIdentifierFragment on Hierarchy {
              dimension {
                ...dimensionIdentifierFragment
              }
              name
            }

            fragment levelIdentifierFragment on Level {
              hierarchy {
                ...hierarchyIdentifierFragment
              }
              name
            }
            """
        )
        variables: Dict[str, object] = {
            "cubeName": cube_name,
            "dataModelTransactionId": data_model_transaction_id,
            "dimensionName": dimension_name,
            "hierarchyName": hierarchy_name,
            "levelName": level_name,
        }
        response = self.execute(
            query=query, operation_name="FindLevel", variables=variables, **kwargs
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> FindLevel:
            try:
                return FindLevel.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def find_level_across_dimensions(
        self,
        *,
        cube_name: str,
        hierarchy_name: str,
        level_name: str,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> FindLevelAcrossDimensions:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query FindLevelAcrossDimensions($cubeName: String!, $dataModelTransactionId: ID, $hierarchyName: String!, $levelName: String!) {
              dataModel(transactionId: $dataModelTransactionId) {
                cube(name: $cubeName) {
                  dimensions {
                    hierarchy(name: $hierarchyName) {
                      level(name: $levelName) {
                        name
                        type
                      }
                      name
                    }
                    name
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "cubeName": cube_name,
            "dataModelTransactionId": data_model_transaction_id,
            "hierarchyName": hierarchy_name,
            "levelName": level_name,
        }
        response = self.execute(
            query=query,
            operation_name="FindLevelAcrossDimensions",
            variables=variables,
            **kwargs,
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> FindLevelAcrossDimensions:
            try:
                return FindLevelAcrossDimensions.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def find_level_across_hierarchies(
        self,
        *,
        cube_name: str,
        level_name: str,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> FindLevelAcrossHierarchies:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query FindLevelAcrossHierarchies($cubeName: String!, $dataModelTransactionId: ID, $levelName: String!) {
              dataModel(transactionId: $dataModelTransactionId) {
                cube(name: $cubeName) {
                  dimensions {
                    hierarchies {
                      level(name: $levelName) {
                        name
                        type
                      }
                      name
                    }
                    name
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "cubeName": cube_name,
            "dataModelTransactionId": data_model_transaction_id,
            "levelName": level_name,
        }
        response = self.execute(
            query=query,
            operation_name="FindLevelAcrossHierarchies",
            variables=variables,
            **kwargs,
        )
        data = self.get_data(response)

        def validate_output(
            data: Mapping[str, object], /
        ) -> FindLevelAcrossHierarchies:
            try:
                return FindLevelAcrossHierarchies.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def find_level_in_hierarchy(
        self,
        *,
        cube_name: str,
        dimension_name: str,
        hierarchy_name: str,
        level_name: str,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> FindLevelInHierarchy:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query FindLevelInHierarchy($cubeName: String!, $dataModelTransactionId: ID, $dimensionName: String!, $hierarchyName: String!, $levelName: String!) {
              dataModel(transactionId: $dataModelTransactionId) {
                cube(name: $cubeName) {
                  dimension(name: $dimensionName) {
                    hierarchy(name: $hierarchyName) {
                      level(name: $levelName) {
                        ...levelIdentifierFragment
                        type
                      }
                    }
                  }
                }
              }
            }

            fragment dimensionIdentifierFragment on Dimension {
              name
            }

            fragment hierarchyIdentifierFragment on Hierarchy {
              dimension {
                ...dimensionIdentifierFragment
              }
              name
            }

            fragment levelIdentifierFragment on Level {
              hierarchy {
                ...hierarchyIdentifierFragment
              }
              name
            }
            """
        )
        variables: Dict[str, object] = {
            "cubeName": cube_name,
            "dataModelTransactionId": data_model_transaction_id,
            "dimensionName": dimension_name,
            "hierarchyName": hierarchy_name,
            "levelName": level_name,
        }
        response = self.execute(
            query=query,
            operation_name="FindLevelInHierarchy",
            variables=variables,
            **kwargs,
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> FindLevelInHierarchy:
            try:
                return FindLevelInHierarchy.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def find_measure(
        self,
        *,
        cube_name: str,
        measure_name: str,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> FindMeasure:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query FindMeasure($cubeName: String!, $dataModelTransactionId: ID, $measureName: String!) {
              dataModel(transactionId: $dataModelTransactionId) {
                cube(name: $cubeName) {
                  measure(name: $measureName) {
                    name
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "cubeName": cube_name,
            "dataModelTransactionId": data_model_transaction_id,
            "measureName": measure_name,
        }
        response = self.execute(
            query=query, operation_name="FindMeasure", variables=variables, **kwargs
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> FindMeasure:
            try:
                return FindMeasure.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def find_member_property(
        self,
        *,
        cube_name: str,
        dimension_name: str,
        hierarchy_name: str,
        level_name: str,
        property_name: str,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> FindMemberProperty:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query FindMemberProperty($cubeName: String!, $dataModelTransactionId: ID, $dimensionName: String!, $hierarchyName: String!, $levelName: String!, $propertyName: String!) {
              dataModel(transactionId: $dataModelTransactionId) {
                cube(name: $cubeName) {
                  dimension(name: $dimensionName) {
                    hierarchy(name: $hierarchyName) {
                      level(name: $levelName) {
                        memberProperty(name: $propertyName) {
                          ...memberPropertyFragment
                        }
                      }
                    }
                  }
                }
              }
            }

            fragment columnIdentifierFragment on Column {
              __typename
              name
              table {
                ...tableIdentifierFragment
              }
            }

            fragment memberPropertyFragment on MemberProperty {
              column {
                ...columnIdentifierFragment
              }
              name
            }

            fragment tableIdentifierFragment on Table {
              __typename
              name
            }
            """
        )
        variables: Dict[str, object] = {
            "cubeName": cube_name,
            "dataModelTransactionId": data_model_transaction_id,
            "dimensionName": dimension_name,
            "hierarchyName": hierarchy_name,
            "levelName": level_name,
            "propertyName": property_name,
        }
        response = self.execute(
            query=query,
            operation_name="FindMemberProperty",
            variables=variables,
            **kwargs,
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> FindMemberProperty:
            try:
                return FindMemberProperty.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def find_table(
        self,
        *,
        table_name: str,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> FindTable:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query FindTable($dataModelTransactionId: ID, $tableName: String!) {
              dataModel(transactionId: $dataModelTransactionId) {
                database {
                  table(name: $tableName) {
                    __typename
                    ...tableIdentifierFragment
                  }
                }
              }
            }

            fragment tableIdentifierFragment on Table {
              __typename
              name
            }
            """
        )
        variables: Dict[str, object] = {
            "dataModelTransactionId": data_model_transaction_id,
            "tableName": table_name,
        }
        response = self.execute(
            query=query, operation_name="FindTable", variables=variables, **kwargs
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> FindTable:
            try:
                return FindTable.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_aggregate_cache(
        self,
        *,
        cube_name: str,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> GetAggregateCache:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetAggregateCache($cubeName: String!, $dataModelTransactionId: ID) {
              dataModel(transactionId: $dataModelTransactionId) {
                cube(name: $cubeName) {
                  aggregateCache {
                    capacity
                    measures {
                      ...measureIdentifierFragment
                    }
                  }
                }
              }
            }

            fragment measureIdentifierFragment on Measure {
              name
            }
            """
        )
        variables: Dict[str, object] = {
            "cubeName": cube_name,
            "dataModelTransactionId": data_model_transaction_id,
        }
        response = self.execute(
            query=query,
            operation_name="GetAggregateCache",
            variables=variables,
            **kwargs,
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> GetAggregateCache:
            try:
                return GetAggregateCache.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_aggregate_providers(
        self,
        *,
        cube_name: str,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> GetAggregateProviders:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetAggregateProviders($cubeName: String!, $dataModelTransactionId: ID) {
              dataModel(transactionId: $dataModelTransactionId) {
                cube(name: $cubeName) {
                  aggregateProviders {
                    ...aggregateProviderFragment
                    name
                  }
                }
              }
            }

            fragment aggregateProviderFragment on AggregateProvider {
              filter {
                value
              }
              levels {
                ...levelIdentifierFragment
              }
              measures {
                ...measureIdentifierFragment
              }
              partitioning
              pluginKey
            }

            fragment dimensionIdentifierFragment on Dimension {
              name
            }

            fragment hierarchyIdentifierFragment on Hierarchy {
              dimension {
                ...dimensionIdentifierFragment
              }
              name
            }

            fragment levelIdentifierFragment on Level {
              hierarchy {
                ...hierarchyIdentifierFragment
              }
              name
            }

            fragment measureIdentifierFragment on Measure {
              name
            }
            """
        )
        variables: Dict[str, object] = {
            "cubeName": cube_name,
            "dataModelTransactionId": data_model_transaction_id,
        }
        response = self.execute(
            query=query,
            operation_name="GetAggregateProviders",
            variables=variables,
            **kwargs,
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> GetAggregateProviders:
            try:
                return GetAggregateProviders.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_basic_authentication_users(
        self, **kwargs: Unpack[Empty]
    ) -> GetBasicAuthenticationUsers:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetBasicAuthenticationUsers {
              security {
                basicAuthentication {
                  usernames
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {}
        response = self.execute(
            query=query,
            operation_name="GetBasicAuthenticationUsers",
            variables=variables,
            **kwargs,
        )
        data = self.get_data(response)

        def validate_output(
            data: Mapping[str, object], /
        ) -> GetBasicAuthenticationUsers:
            try:
                return GetBasicAuthenticationUsers.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_cluster_members(
        self,
        *,
        cube_name: str,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> GetClusterMembers:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetClusterMembers($cubeName: String!, $dataModelTransactionId: ID) {
              dataModel(transactionId: $dataModelTransactionId) {
                cube(name: $cubeName) {
                  cluster {
                    nodes {
                      name
                    }
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "cubeName": cube_name,
            "dataModelTransactionId": data_model_transaction_id,
        }
        response = self.execute(
            query=query,
            operation_name="GetClusterMembers",
            variables=variables,
            **kwargs,
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> GetClusterMembers:
            try:
                return GetClusterMembers.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_column_data_type(
        self,
        *,
        column_name: str,
        table_name: str,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> GetColumnDataType:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetColumnDataType($columnName: String!, $dataModelTransactionId: ID, $tableName: String!) {
              dataModel(transactionId: $dataModelTransactionId) {
                database {
                  table(name: $tableName) {
                    __typename
                    column(name: $columnName) {
                      __typename
                      dataType
                    }
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "columnName": column_name,
            "dataModelTransactionId": data_model_transaction_id,
            "tableName": table_name,
        }
        response = self.execute(
            query=query,
            operation_name="GetColumnDataType",
            variables=variables,
            **kwargs,
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> GetColumnDataType:
            try:
                return GetColumnDataType.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_column_default_value(
        self,
        *,
        column_name: str,
        table_name: str,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> GetColumnDefaultValue:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetColumnDefaultValue($columnName: String!, $dataModelTransactionId: ID, $tableName: String!) {
              dataModel(transactionId: $dataModelTransactionId) {
                database {
                  table(name: $tableName) {
                    __typename
                    column(name: $columnName) {
                      __typename
                      defaultValue
                    }
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "columnName": column_name,
            "dataModelTransactionId": data_model_transaction_id,
            "tableName": table_name,
        }
        response = self.execute(
            query=query,
            operation_name="GetColumnDefaultValue",
            variables=variables,
            **kwargs,
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> GetColumnDefaultValue:
            try:
                return GetColumnDefaultValue.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_cube_fact_table(
        self,
        *,
        cube_name: str,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> GetCubeFactTable:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetCubeFactTable($cubeName: String!, $dataModelTransactionId: ID) {
              dataModel(transactionId: $dataModelTransactionId) {
                cube(name: $cubeName) {
                  factTable {
                    __typename
                    ...tableIdentifierFragment
                  }
                }
              }
            }

            fragment tableIdentifierFragment on Table {
              __typename
              name
            }
            """
        )
        variables: Dict[str, object] = {
            "cubeName": cube_name,
            "dataModelTransactionId": data_model_transaction_id,
        }
        response = self.execute(
            query=query,
            operation_name="GetCubeFactTable",
            variables=variables,
            **kwargs,
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> GetCubeFactTable:
            try:
                return GetCubeFactTable.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_cube_restrictions(
        self,
        *,
        cube_name: str,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> GetCubeRestrictions:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetCubeRestrictions($cubeName: String!, $dataModelTransactionId: ID) {
              dataModel(transactionId: $dataModelTransactionId) {
                cube(name: $cubeName) {
                  restrictions {
                    ...cubeRestrictionFragment
                    role
                  }
                }
              }
            }

            fragment cubeRestrictionFragment on CubeRestriction {
              condition {
                value
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "cubeName": cube_name,
            "dataModelTransactionId": data_model_transaction_id,
        }
        response = self.execute(
            query=query,
            operation_name="GetCubeRestrictions",
            variables=variables,
            **kwargs,
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> GetCubeRestrictions:
            try:
                return GetCubeRestrictions.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_cubes(
        self,
        *,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> GetCubes:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetCubes($dataModelTransactionId: ID) {
              dataModel(transactionId: $dataModelTransactionId) {
                cubes {
                  ...cubeIdentifierFragment
                }
              }
            }

            fragment cubeIdentifierFragment on Cube {
              name
            }
            """
        )
        variables: Dict[str, object] = {
            "dataModelTransactionId": data_model_transaction_id
        }
        response = self.execute(
            query=query, operation_name="GetCubes", variables=variables, **kwargs
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> GetCubes:
            try:
                return GetCubes.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_current_user(self, **kwargs: Unpack[Empty]) -> GetCurrentUser:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetCurrentUser {
              currentUser {
                name
                roles
              }
            }
            """
        )
        variables: Dict[str, object] = {}
        response = self.execute(
            query=query, operation_name="GetCurrentUser", variables=variables, **kwargs
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> GetCurrentUser:
            try:
                return GetCurrentUser.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_database_fields(
        self,
        *,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> GetDatabaseFields:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetDatabaseFields($dataModelTransactionId: ID) {
              databaseDataModel: dataModel(transactionId: $dataModelTransactionId) {
                database {
                  tables {
                    __typename
                    columns {
                      __typename
                      name
                    }
                    joins {
                      __typename
                      ...joinIdentifierFragment
                      target {
                        __typename
                        ...tableIdentifierFragment
                      }
                    }
                    ...tableIdentifierFragment
                  }
                }
              }
            }

            fragment joinIdentifierFragment on Join {
              __typename
              name
              source {
                ...tableIdentifierFragment
              }
            }

            fragment tableIdentifierFragment on Table {
              __typename
              name
            }
            """
        )
        variables: Dict[str, object] = {
            "dataModelTransactionId": data_model_transaction_id
        }
        response = self.execute(
            query=query,
            operation_name="GetDatabaseFields",
            variables=variables,
            **kwargs,
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> GetDatabaseFields:
            try:
                return GetDatabaseFields.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_database_owners(
        self,
        *,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> GetDatabaseOwners:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetDatabaseOwners($dataModelTransactionId: ID) {
              dataModel(transactionId: $dataModelTransactionId) {
                database {
                  owners
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "dataModelTransactionId": data_model_transaction_id
        }
        response = self.execute(
            query=query,
            operation_name="GetDatabaseOwners",
            variables=variables,
            **kwargs,
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> GetDatabaseOwners:
            try:
                return GetDatabaseOwners.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_database_readers(
        self,
        *,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> GetDatabaseReaders:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetDatabaseReaders($dataModelTransactionId: ID) {
              dataModel(transactionId: $dataModelTransactionId) {
                database {
                  readers
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "dataModelTransactionId": data_model_transaction_id
        }
        response = self.execute(
            query=query,
            operation_name="GetDatabaseReaders",
            variables=variables,
            **kwargs,
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> GetDatabaseReaders:
            try:
                return GetDatabaseReaders.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_database_restriction(
        self,
        *,
        role: str,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> GetDatabaseRestriction:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetDatabaseRestriction($dataModelTransactionId: ID, $role: String!) {
              dataModel(transactionId: $dataModelTransactionId) {
                database {
                  restriction(role: $role) {
                    ...databaseRestrictionFragment
                  }
                }
              }
            }

            fragment databaseRestrictionFragment on DatabaseRestriction {
              condition {
                value
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "dataModelTransactionId": data_model_transaction_id,
            "role": role,
        }
        response = self.execute(
            query=query,
            operation_name="GetDatabaseRestriction",
            variables=variables,
            **kwargs,
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> GetDatabaseRestriction:
            try:
                return GetDatabaseRestriction.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_database_restrictions(
        self,
        *,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> GetDatabaseRestrictions:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetDatabaseRestrictions($dataModelTransactionId: ID) {
              dataModel(transactionId: $dataModelTransactionId) {
                database {
                  restrictions {
                    ...databaseRestrictionFragment
                    role
                  }
                }
              }
            }

            fragment databaseRestrictionFragment on DatabaseRestriction {
              condition {
                value
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "dataModelTransactionId": data_model_transaction_id
        }
        response = self.execute(
            query=query,
            operation_name="GetDatabaseRestrictions",
            variables=variables,
            **kwargs,
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> GetDatabaseRestrictions:
            try:
                return GetDatabaseRestrictions.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_database_schema(
        self,
        *,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> GetDatabaseSchema:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetDatabaseSchema($dataModelTransactionId: ID) {
              dataModel(transactionId: $dataModelTransactionId) {
                database {
                  tables {
                    __typename
                    columns {
                      __typename
                      dataType
                      defaultValue
                      name
                    }
                    joins {
                      __typename
                      isPartial
                      mappingItems {
                        __typename
                        source {
                          __typename
                          name
                        }
                        target {
                          __typename
                          name
                        }
                      }
                      target {
                        __typename
                        ...tableIdentifierFragment
                      }
                      targetOptionality
                    }
                    primaryIndex {
                      __typename
                      name
                    }
                    ...tableIdentifierFragment
                  }
                }
              }
            }

            fragment tableIdentifierFragment on Table {
              __typename
              name
            }
            """
        )
        variables: Dict[str, object] = {
            "dataModelTransactionId": data_model_transaction_id
        }
        response = self.execute(
            query=query,
            operation_name="GetDatabaseSchema",
            variables=variables,
            **kwargs,
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> GetDatabaseSchema:
            try:
                return GetDatabaseSchema.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_default_roles(self, **kwargs: Unpack[Empty]) -> GetDefaultRoles:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetDefaultRoles {
              security {
                sso {
                  __typename
                  defaultRoles
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {}
        response = self.execute(
            query=query, operation_name="GetDefaultRoles", variables=variables, **kwargs
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> GetDefaultRoles:
            try:
                return GetDefaultRoles.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_dimension_default_hierarchy(
        self,
        *,
        cube_name: str,
        dimension_name: str,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> GetDimensionDefaultHierarchy:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetDimensionDefaultHierarchy($cubeName: String!, $dataModelTransactionId: ID, $dimensionName: String!) {
              dataModel(transactionId: $dataModelTransactionId) {
                cube(name: $cubeName) {
                  dimension(name: $dimensionName) {
                    defaultHierarchy {
                      name
                    }
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "cubeName": cube_name,
            "dataModelTransactionId": data_model_transaction_id,
            "dimensionName": dimension_name,
        }
        response = self.execute(
            query=query,
            operation_name="GetDimensionDefaultHierarchy",
            variables=variables,
            **kwargs,
        )
        data = self.get_data(response)

        def validate_output(
            data: Mapping[str, object], /
        ) -> GetDimensionDefaultHierarchy:
            try:
                return GetDimensionDefaultHierarchy.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_hierarchies(
        self,
        *,
        cube_name: str,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> GetHierarchies:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetHierarchies($cubeName: String!, $dataModelTransactionId: ID) {
              dataModel(transactionId: $dataModelTransactionId) {
                cube(name: $cubeName) {
                  dimensions {
                    hierarchies {
                      name
                    }
                    name
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "cubeName": cube_name,
            "dataModelTransactionId": data_model_transaction_id,
        }
        response = self.execute(
            query=query, operation_name="GetHierarchies", variables=variables, **kwargs
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> GetHierarchies:
            try:
                return GetHierarchies.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_hierarchy_are_members_indexed_by_name(
        self,
        *,
        cube_name: str,
        dimension_name: str,
        hierarchy_name: str,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> GetHierarchyAreMembersIndexedByName:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetHierarchyAreMembersIndexedByName($cubeName: String!, $dataModelTransactionId: ID, $dimensionName: String!, $hierarchyName: String!) {
              dataModel(transactionId: $dataModelTransactionId) {
                cube(name: $cubeName) {
                  dimension(name: $dimensionName) {
                    hierarchy(name: $hierarchyName) {
                      areMembersIndexedByName
                    }
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "cubeName": cube_name,
            "dataModelTransactionId": data_model_transaction_id,
            "dimensionName": dimension_name,
            "hierarchyName": hierarchy_name,
        }
        response = self.execute(
            query=query,
            operation_name="GetHierarchyAreMembersIndexedByName",
            variables=variables,
            **kwargs,
        )
        data = self.get_data(response)

        def validate_output(
            data: Mapping[str, object], /
        ) -> GetHierarchyAreMembersIndexedByName:
            try:
                return GetHierarchyAreMembersIndexedByName.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_hierarchy_description(
        self,
        *,
        cube_name: str,
        dimension_name: str,
        hierarchy_name: str,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> GetHierarchyDescription:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetHierarchyDescription($cubeName: String!, $dataModelTransactionId: ID, $dimensionName: String!, $hierarchyName: String!) {
              dataModel(transactionId: $dataModelTransactionId) {
                cube(name: $cubeName) {
                  dimension(name: $dimensionName) {
                    hierarchy(name: $hierarchyName) {
                      description
                    }
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "cubeName": cube_name,
            "dataModelTransactionId": data_model_transaction_id,
            "dimensionName": dimension_name,
            "hierarchyName": hierarchy_name,
        }
        response = self.execute(
            query=query,
            operation_name="GetHierarchyDescription",
            variables=variables,
            **kwargs,
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> GetHierarchyDescription:
            try:
                return GetHierarchyDescription.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_hierarchy_folder(
        self,
        *,
        cube_name: str,
        dimension_name: str,
        hierarchy_name: str,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> GetHierarchyFolder:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetHierarchyFolder($cubeName: String!, $dataModelTransactionId: ID, $dimensionName: String!, $hierarchyName: String!) {
              dataModel(transactionId: $dataModelTransactionId) {
                cube(name: $cubeName) {
                  dimension(name: $dimensionName) {
                    hierarchy(name: $hierarchyName) {
                      folder
                    }
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "cubeName": cube_name,
            "dataModelTransactionId": data_model_transaction_id,
            "dimensionName": dimension_name,
            "hierarchyName": hierarchy_name,
        }
        response = self.execute(
            query=query,
            operation_name="GetHierarchyFolder",
            variables=variables,
            **kwargs,
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> GetHierarchyFolder:
            try:
                return GetHierarchyFolder.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_hierarchy_is_slicing(
        self,
        *,
        cube_name: str,
        dimension_name: str,
        hierarchy_name: str,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> GetHierarchyIsSlicing:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetHierarchyIsSlicing($cubeName: String!, $dataModelTransactionId: ID, $dimensionName: String!, $hierarchyName: String!) {
              dataModel(transactionId: $dataModelTransactionId) {
                cube(name: $cubeName) {
                  dimension(name: $dimensionName) {
                    hierarchy(name: $hierarchyName) {
                      isSlicing
                    }
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "cubeName": cube_name,
            "dataModelTransactionId": data_model_transaction_id,
            "dimensionName": dimension_name,
            "hierarchyName": hierarchy_name,
        }
        response = self.execute(
            query=query,
            operation_name="GetHierarchyIsSlicing",
            variables=variables,
            **kwargs,
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> GetHierarchyIsSlicing:
            try:
                return GetHierarchyIsSlicing.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_hierarchy_is_virtual(
        self,
        *,
        cube_name: str,
        dimension_name: str,
        hierarchy_name: str,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> GetHierarchyIsVirtual:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetHierarchyIsVirtual($cubeName: String!, $dataModelTransactionId: ID, $dimensionName: String!, $hierarchyName: String!) {
              dataModel(transactionId: $dataModelTransactionId) {
                cube(name: $cubeName) {
                  dimension(name: $dimensionName) {
                    hierarchy(name: $hierarchyName) {
                      isVirtual
                    }
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "cubeName": cube_name,
            "dataModelTransactionId": data_model_transaction_id,
            "dimensionName": dimension_name,
            "hierarchyName": hierarchy_name,
        }
        response = self.execute(
            query=query,
            operation_name="GetHierarchyIsVirtual",
            variables=variables,
            **kwargs,
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> GetHierarchyIsVirtual:
            try:
                return GetHierarchyIsVirtual.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_hierarchy_is_visible(
        self,
        *,
        cube_name: str,
        dimension_name: str,
        hierarchy_name: str,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> GetHierarchyIsVisible:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetHierarchyIsVisible($cubeName: String!, $dataModelTransactionId: ID, $dimensionName: String!, $hierarchyName: String!) {
              dataModel(transactionId: $dataModelTransactionId) {
                cube(name: $cubeName) {
                  dimension(name: $dimensionName) {
                    hierarchy(name: $hierarchyName) {
                      isVisible
                    }
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "cubeName": cube_name,
            "dataModelTransactionId": data_model_transaction_id,
            "dimensionName": dimension_name,
            "hierarchyName": hierarchy_name,
        }
        response = self.execute(
            query=query,
            operation_name="GetHierarchyIsVisible",
            variables=variables,
            **kwargs,
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> GetHierarchyIsVisible:
            try:
                return GetHierarchyIsVisible.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_hierarchy_levels(
        self,
        *,
        cube_name: str,
        dimension_name: str,
        hierarchy_name: str,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> GetHierarchyLevels:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetHierarchyLevels($cubeName: String!, $dataModelTransactionId: ID, $dimensionName: String!, $hierarchyName: String!) {
              dataModel(transactionId: $dataModelTransactionId) {
                cube(name: $cubeName) {
                  dimension(name: $dimensionName) {
                    hierarchy(name: $hierarchyName) {
                      levels {
                        name
                        type
                      }
                      name
                    }
                    name
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "cubeName": cube_name,
            "dataModelTransactionId": data_model_transaction_id,
            "dimensionName": dimension_name,
            "hierarchyName": hierarchy_name,
        }
        response = self.execute(
            query=query,
            operation_name="GetHierarchyLevels",
            variables=variables,
            **kwargs,
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> GetHierarchyLevels:
            try:
                return GetHierarchyLevels.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_hierarchy_viewers(
        self,
        *,
        cube_name: str,
        dimension_name: str,
        hierarchy_name: str,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> GetHierarchyViewers:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetHierarchyViewers($cubeName: String!, $dataModelTransactionId: ID, $dimensionName: String!, $hierarchyName: String!) {
              dataModel(transactionId: $dataModelTransactionId) {
                cube(name: $cubeName) {
                  dimension(name: $dimensionName) {
                    hierarchy(name: $hierarchyName) {
                      viewers
                    }
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "cubeName": cube_name,
            "dataModelTransactionId": data_model_transaction_id,
            "dimensionName": dimension_name,
            "hierarchyName": hierarchy_name,
        }
        response = self.execute(
            query=query,
            operation_name="GetHierarchyViewers",
            variables=variables,
            **kwargs,
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> GetHierarchyViewers:
            try:
                return GetHierarchyViewers.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_individual_roles_item(
        self, *, username: str, **kwargs: Unpack[Empty]
    ) -> GetIndividualRolesItem:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetIndividualRolesItem($username: String!) {
              security {
                individualRolesItem(username: $username) {
                  individualRoles
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"username": username}
        response = self.execute(
            query=query,
            operation_name="GetIndividualRolesItem",
            variables=variables,
            **kwargs,
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> GetIndividualRolesItem:
            try:
                return GetIndividualRolesItem.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_individual_roles_items(
        self, **kwargs: Unpack[Empty]
    ) -> GetIndividualRolesItems:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetIndividualRolesItems {
              security {
                individualRolesItems {
                  individualRoles
                  username
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {}
        response = self.execute(
            query=query,
            operation_name="GetIndividualRolesItems",
            variables=variables,
            **kwargs,
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> GetIndividualRolesItems:
            try:
                return GetIndividualRolesItems.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_levels(
        self,
        *,
        cube_name: str,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> GetLevels:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetLevels($cubeName: String!, $dataModelTransactionId: ID) {
              dataModel(transactionId: $dataModelTransactionId) {
                cube(name: $cubeName) {
                  dimensions {
                    hierarchies {
                      levels {
                        name
                        type
                      }
                      name
                    }
                    name
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "cubeName": cube_name,
            "dataModelTransactionId": data_model_transaction_id,
        }
        response = self.execute(
            query=query, operation_name="GetLevels", variables=variables, **kwargs
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> GetLevels:
            try:
                return GetLevels.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_level_selection_field(
        self,
        *,
        cube_name: str,
        dimension_name: str,
        hierarchy_name: str,
        level_name: str,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> GetLevelSelectionField:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetLevelSelectionField($cubeName: String!, $dataModelTransactionId: ID, $dimensionName: String!, $hierarchyName: String!, $levelName: String!) {
              dataModel(transactionId: $dataModelTransactionId) {
                cube(name: $cubeName) {
                  dimension(name: $dimensionName) {
                    hierarchy(name: $hierarchyName) {
                      level(name: $levelName) {
                        selectionField {
                          ...selectionFieldIdentifierFragment
                        }
                      }
                    }
                  }
                }
              }
            }

            fragment columnIdentifierFragment on Column {
              __typename
              name
              table {
                ...tableIdentifierFragment
              }
            }

            fragment joinIdentifierFragment on Join {
              __typename
              name
              source {
                ...tableIdentifierFragment
              }
            }

            fragment selectionFieldIdentifierFragment on SelectionField {
              column {
                ...columnIdentifierFragment
              }
              joins {
                ...joinIdentifierFragment
              }
            }

            fragment tableIdentifierFragment on Table {
              __typename
              name
            }
            """
        )
        variables: Dict[str, object] = {
            "cubeName": cube_name,
            "dataModelTransactionId": data_model_transaction_id,
            "dimensionName": dimension_name,
            "hierarchyName": hierarchy_name,
            "levelName": level_name,
        }
        response = self.execute(
            query=query,
            operation_name="GetLevelSelectionField",
            variables=variables,
            **kwargs,
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> GetLevelSelectionField:
            try:
                return GetLevelSelectionField.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_measure_definition(
        self,
        *,
        cube_name: str,
        measure_name: str,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> GetMeasureDefinition:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetMeasureDefinition($cubeName: String!, $dataModelTransactionId: ID, $measureName: String!) {
              dataModel(transactionId: $dataModelTransactionId) {
                cube(name: $cubeName) {
                  measure(name: $measureName) {
                    definition {
                      value
                    }
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "cubeName": cube_name,
            "dataModelTransactionId": data_model_transaction_id,
            "measureName": measure_name,
        }
        response = self.execute(
            query=query,
            operation_name="GetMeasureDefinition",
            variables=variables,
            **kwargs,
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> GetMeasureDefinition:
            try:
                return GetMeasureDefinition.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_measure_description(
        self,
        *,
        cube_name: str,
        measure_name: str,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> GetMeasureDescription:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetMeasureDescription($cubeName: String!, $dataModelTransactionId: ID, $measureName: String!) {
              dataModel(transactionId: $dataModelTransactionId) {
                cube(name: $cubeName) {
                  measure(name: $measureName) {
                    description
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "cubeName": cube_name,
            "dataModelTransactionId": data_model_transaction_id,
            "measureName": measure_name,
        }
        response = self.execute(
            query=query,
            operation_name="GetMeasureDescription",
            variables=variables,
            **kwargs,
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> GetMeasureDescription:
            try:
                return GetMeasureDescription.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_measures(
        self,
        *,
        cube_name: str,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> GetMeasures:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetMeasures($cubeName: String!, $dataModelTransactionId: ID) {
              dataModel(transactionId: $dataModelTransactionId) {
                cube(name: $cubeName) {
                  measures {
                    name
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "cubeName": cube_name,
            "dataModelTransactionId": data_model_transaction_id,
        }
        response = self.execute(
            query=query, operation_name="GetMeasures", variables=variables, **kwargs
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> GetMeasures:
            try:
                return GetMeasures.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_member_properties(
        self,
        *,
        cube_name: str,
        dimension_name: str,
        hierarchy_name: str,
        level_name: str,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> GetMemberProperties:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetMemberProperties($cubeName: String!, $dataModelTransactionId: ID, $dimensionName: String!, $hierarchyName: String!, $levelName: String!) {
              dataModel(transactionId: $dataModelTransactionId) {
                cube(name: $cubeName) {
                  dimension(name: $dimensionName) {
                    hierarchy(name: $hierarchyName) {
                      level(name: $levelName) {
                        memberProperties {
                          ...memberPropertyFragment
                        }
                      }
                    }
                  }
                }
              }
            }

            fragment columnIdentifierFragment on Column {
              __typename
              name
              table {
                ...tableIdentifierFragment
              }
            }

            fragment memberPropertyFragment on MemberProperty {
              column {
                ...columnIdentifierFragment
              }
              name
            }

            fragment tableIdentifierFragment on Table {
              __typename
              name
            }
            """
        )
        variables: Dict[str, object] = {
            "cubeName": cube_name,
            "dataModelTransactionId": data_model_transaction_id,
            "dimensionName": dimension_name,
            "hierarchyName": hierarchy_name,
            "levelName": level_name,
        }
        response = self.execute(
            query=query,
            operation_name="GetMemberProperties",
            variables=variables,
            **kwargs,
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> GetMemberProperties:
            try:
                return GetMemberProperties.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_proxy_url(self, **kwargs: Unpack[Empty]) -> GetProxyUrl:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetProxyUrl {
              proxy {
                url
              }
            }
            """
        )
        variables: Dict[str, object] = {}
        response = self.execute(
            query=query, operation_name="GetProxyUrl", variables=variables, **kwargs
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> GetProxyUrl:
            try:
                return GetProxyUrl.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_readiness(self, **kwargs: Unpack[Empty]) -> GetReadiness:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetReadiness {
              readiness
            }
            """
        )
        variables: Dict[str, object] = {}
        response = self.execute(
            query=query, operation_name="GetReadiness", variables=variables, **kwargs
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> GetReadiness:
            try:
                return GetReadiness.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_role_mapping_item(
        self, *, username: str, **kwargs: Unpack[Empty]
    ) -> GetRoleMappingItem:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetRoleMappingItem($username: String!) {
              security {
                sso {
                  __typename
                  ... on OidcSecurity {
                    roleMappingItem(externalRole: $username) {
                      ...roleMappingItemFragment
                    }
                  }
                  ... on LdapSecurity {
                    roleMappingItem(externalRole: $username) {
                      ...roleMappingItemFragment
                    }
                  }
                }
              }
            }

            fragment roleMappingItemFragment on RoleMappingItem {
              externalRole
              internalRoles
            }
            """
        )
        variables: Dict[str, object] = {"username": username}
        response = self.execute(
            query=query,
            operation_name="GetRoleMappingItem",
            variables=variables,
            **kwargs,
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> GetRoleMappingItem:
            try:
                return GetRoleMappingItem.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_role_mapping_items(self, **kwargs: Unpack[Empty]) -> GetRoleMappingItems:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetRoleMappingItems {
              security {
                sso {
                  __typename
                  ... on OidcSecurity {
                    ...roleMappingFragment
                  }
                  ... on LdapSecurity {
                    ...roleMappingFragment
                  }
                }
              }
            }

            fragment roleMappingFragment on SsoSecurityWithRoleMapping {
              roleMappingItems {
                ...roleMappingItemFragment
              }
            }

            fragment roleMappingItemFragment on RoleMappingItem {
              externalRole
              internalRoles
            }
            """
        )
        variables: Dict[str, object] = {}
        response = self.execute(
            query=query,
            operation_name="GetRoleMappingItems",
            variables=variables,
            **kwargs,
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> GetRoleMappingItems:
            try:
                return GetRoleMappingItems.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_table_columns(
        self,
        *,
        table_name: str,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> GetTableColumns:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetTableColumns($dataModelTransactionId: ID, $tableName: String!) {
              dataModel(transactionId: $dataModelTransactionId) {
                database {
                  table(name: $tableName) {
                    __typename
                    columns {
                      __typename
                      name
                    }
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "dataModelTransactionId": data_model_transaction_id,
            "tableName": table_name,
        }
        response = self.execute(
            query=query, operation_name="GetTableColumns", variables=variables, **kwargs
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> GetTableColumns:
            try:
                return GetTableColumns.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_table_primary_index(
        self,
        *,
        table_name: str,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> GetTablePrimaryIndex:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetTablePrimaryIndex($dataModelTransactionId: ID, $tableName: String!) {
              dataModel(transactionId: $dataModelTransactionId) {
                database {
                  table(name: $tableName) {
                    __typename
                    primaryIndex {
                      __typename
                      name
                    }
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "dataModelTransactionId": data_model_transaction_id,
            "tableName": table_name,
        }
        response = self.execute(
            query=query,
            operation_name="GetTablePrimaryIndex",
            variables=variables,
            **kwargs,
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> GetTablePrimaryIndex:
            try:
                return GetTablePrimaryIndex.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_tables(
        self,
        *,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> GetTables:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetTables($dataModelTransactionId: ID) {
              dataModel(transactionId: $dataModelTransactionId) {
                database {
                  tables {
                    __typename
                    ...tableIdentifierFragment
                  }
                }
              }
            }

            fragment tableIdentifierFragment on Table {
              __typename
              name
            }
            """
        )
        variables: Dict[str, object] = {
            "dataModelTransactionId": data_model_transaction_id
        }
        response = self.execute(
            query=query, operation_name="GetTables", variables=variables, **kwargs
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> GetTables:
            try:
                return GetTables.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def get_updateable_cells(
        self,
        *,
        cube_name: str,
        data_model_transaction_id: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Unpack[Empty],
    ) -> GetUpdateableCells:
        if self.mutation_batcher.batching:  # pragma: no cover
            raise RuntimeError(
                "This operation is not supported while batching mutations."
            )
        query = gql(
            """
            query GetUpdateableCells($cubeName: String!, $dataModelTransactionId: ID) {
              dataModel(transactionId: $dataModelTransactionId) {
                cube(name: $cubeName) {
                  updateableCells {
                    hierarchies {
                      ...hierarchyIdentifierFragment
                    }
                    levels {
                      ...levelIdentifierFragment
                    }
                    roles
                  }
                }
              }
            }

            fragment dimensionIdentifierFragment on Dimension {
              name
            }

            fragment hierarchyIdentifierFragment on Hierarchy {
              dimension {
                ...dimensionIdentifierFragment
              }
              name
            }

            fragment levelIdentifierFragment on Level {
              hierarchy {
                ...hierarchyIdentifierFragment
              }
              name
            }
            """
        )
        variables: Dict[str, object] = {
            "cubeName": cube_name,
            "dataModelTransactionId": data_model_transaction_id,
        }
        response = self.execute(
            query=query,
            operation_name="GetUpdateableCells",
            variables=variables,
            **kwargs,
        )
        data = self.get_data(response)

        def validate_output(data: Mapping[str, object], /) -> GetUpdateableCells:
            try:
                return GetUpdateableCells.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        return validate_output(data)

    def reset_application(
        self,
        *,
        validate_future_output: Callable[[ResetApplication], None] = lambda _: None,
        **kwargs: Unpack[Empty],
    ) -> BatchedOperationFutureOutput[Mapping[str, object], ResetApplication]:
        query = gql(
            """
            mutation ResetApplication {
              reset {
                __typename
              }
            }
            """
        )
        variables: Dict[str, object] = {}

        def validate_output(data: Mapping[str, object], /) -> ResetApplication:
            try:
                return ResetApplication.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        def process_future_output(data: Mapping[str, object], /) -> ResetApplication:
            output = validate_output(data)
            validate_future_output(output)
            return output

        return self.mutation_batcher.submit(
            document=query,
            variables=variables,
            process_future_output=process_future_output,
        )

    def unload_members_from_data_cube(
        self,
        *,
        input: UnloadMembersFromDataCubeInput,
        validate_future_output: Callable[
            [UnloadMembersFromDataCube], None
        ] = lambda _: None,
        **kwargs: Unpack[Empty],
    ) -> BatchedOperationFutureOutput[Mapping[str, object], UnloadMembersFromDataCube]:
        query = gql(
            """
            mutation UnloadMembersFromDataCube($input: UnloadMembersFromDataCubeInput!) {
              unloadMembersFromDataCube(input: $input) {
                __typename
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}

        def validate_output(data: Mapping[str, object], /) -> UnloadMembersFromDataCube:
            try:
                return UnloadMembersFromDataCube.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        def process_future_output(
            data: Mapping[str, object], /
        ) -> UnloadMembersFromDataCube:
            output = validate_output(data)
            validate_future_output(output)
            return output

        return self.mutation_batcher.submit(
            document=query,
            variables=variables,
            process_future_output=process_future_output,
        )

    def update_column(
        self,
        *,
        input: UpdateColumnInput,
        validate_future_output: Callable[[UpdateColumn], None] = lambda _: None,
        **kwargs: Unpack[Empty],
    ) -> BatchedOperationFutureOutput[Mapping[str, object], UpdateColumn]:
        query = gql(
            """
            mutation UpdateColumn($input: UpdateColumnInput!) {
              updateColumn(input: $input) {
                __typename
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}

        def validate_output(data: Mapping[str, object], /) -> UpdateColumn:
            try:
                return UpdateColumn.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        def process_future_output(data: Mapping[str, object], /) -> UpdateColumn:
            output = validate_output(data)
            validate_future_output(output)
            return output

        return self.mutation_batcher.submit(
            document=query,
            variables=variables,
            process_future_output=process_future_output,
        )

    def update_cube(
        self,
        *,
        input: UpdateCubeInput,
        validate_future_output: Callable[[UpdateCube], None] = lambda _: None,
        **kwargs: Unpack[Empty],
    ) -> BatchedOperationFutureOutput[Mapping[str, object], UpdateCube]:
        query = gql(
            """
            mutation UpdateCube($input: UpdateCubeInput!) {
              updateCube(input: $input) {
                __typename
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}

        def validate_output(data: Mapping[str, object], /) -> UpdateCube:
            try:
                return UpdateCube.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        def process_future_output(data: Mapping[str, object], /) -> UpdateCube:
            output = validate_output(data)
            validate_future_output(output)
            return output

        return self.mutation_batcher.submit(
            document=query,
            variables=variables,
            process_future_output=process_future_output,
        )

    def update_data_model(
        self,
        *,
        input: UpdateDataModelInput,
        validate_future_output: Callable[[UpdateDataModel], None] = lambda _: None,
        **kwargs: Unpack[Empty],
    ) -> BatchedOperationFutureOutput[Mapping[str, object], UpdateDataModel]:
        query = gql(
            """
            mutation UpdateDataModel($input: UpdateDataModelInput!) {
              updateDataModel(input: $input) {
                __typename
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}

        def validate_output(data: Mapping[str, object], /) -> UpdateDataModel:
            try:
                return UpdateDataModel.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        def process_future_output(data: Mapping[str, object], /) -> UpdateDataModel:
            output = validate_output(data)
            validate_future_output(output)
            return output

        return self.mutation_batcher.submit(
            document=query,
            variables=variables,
            process_future_output=process_future_output,
        )

    def update_dimension(
        self,
        *,
        input: UpdateDimensionInput,
        validate_future_output: Callable[[UpdateDimension], None] = lambda _: None,
        **kwargs: Unpack[Empty],
    ) -> BatchedOperationFutureOutput[Mapping[str, object], UpdateDimension]:
        query = gql(
            """
            mutation UpdateDimension($input: UpdateDimensionInput!) {
              updateDimension(input: $input) {
                __typename
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}

        def validate_output(data: Mapping[str, object], /) -> UpdateDimension:
            try:
                return UpdateDimension.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        def process_future_output(data: Mapping[str, object], /) -> UpdateDimension:
            output = validate_output(data)
            validate_future_output(output)
            return output

        return self.mutation_batcher.submit(
            document=query,
            variables=variables,
            process_future_output=process_future_output,
        )

    def update_hierarchy(
        self,
        *,
        input: UpdateHierarchyInput,
        validate_future_output: Callable[[UpdateHierarchy], None] = lambda _: None,
        **kwargs: Unpack[Empty],
    ) -> BatchedOperationFutureOutput[Mapping[str, object], UpdateHierarchy]:
        query = gql(
            """
            mutation UpdateHierarchy($input: UpdateHierarchyInput!) {
              updateHierarchy(input: $input) {
                __typename
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}

        def validate_output(data: Mapping[str, object], /) -> UpdateHierarchy:
            try:
                return UpdateHierarchy.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        def process_future_output(data: Mapping[str, object], /) -> UpdateHierarchy:
            output = validate_output(data)
            validate_future_output(output)
            return output

        return self.mutation_batcher.submit(
            document=query,
            variables=variables,
            process_future_output=process_future_output,
        )

    def update_measure(
        self,
        *,
        input: UpdateMeasureInput,
        validate_future_output: Callable[[UpdateMeasure], None] = lambda _: None,
        **kwargs: Unpack[Empty],
    ) -> BatchedOperationFutureOutput[Mapping[str, object], UpdateMeasure]:
        query = gql(
            """
            mutation UpdateMeasure($input: UpdateMeasureInput!) {
              updateMeasure(input: $input) {
                __typename
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}

        def validate_output(data: Mapping[str, object], /) -> UpdateMeasure:
            try:
                return UpdateMeasure.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        def process_future_output(data: Mapping[str, object], /) -> UpdateMeasure:
            output = validate_output(data)
            validate_future_output(output)
            return output

        return self.mutation_batcher.submit(
            document=query,
            variables=variables,
            process_future_output=process_future_output,
        )

    def update_proxy(
        self,
        *,
        input: UpdateProxyInput,
        validate_future_output: Callable[[UpdateProxy], None] = lambda _: None,
        **kwargs: Unpack[Empty],
    ) -> BatchedOperationFutureOutput[Mapping[str, object], UpdateProxy]:
        query = gql(
            """
            mutation UpdateProxy($input: UpdateProxyInput!) {
              updateProxy(input: $input) {
                __typename
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}

        def validate_output(data: Mapping[str, object], /) -> UpdateProxy:
            try:
                return UpdateProxy.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        def process_future_output(data: Mapping[str, object], /) -> UpdateProxy:
            output = validate_output(data)
            validate_future_output(output)
            return output

        return self.mutation_batcher.submit(
            document=query,
            variables=variables,
            process_future_output=process_future_output,
        )

    def update_readiness(
        self,
        *,
        input: UpdateReadinessInput,
        validate_future_output: Callable[[UpdateReadiness], None] = lambda _: None,
        **kwargs: Unpack[Empty],
    ) -> BatchedOperationFutureOutput[Mapping[str, object], UpdateReadiness]:
        query = gql(
            """
            mutation UpdateReadiness($input: UpdateReadinessInput!) {
              updateReadiness(input: $input) {
                __typename
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}

        def validate_output(data: Mapping[str, object], /) -> UpdateReadiness:
            try:
                return UpdateReadiness.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        def process_future_output(data: Mapping[str, object], /) -> UpdateReadiness:
            output = validate_output(data)
            validate_future_output(output)
            return output

        return self.mutation_batcher.submit(
            document=query,
            variables=variables,
            process_future_output=process_future_output,
        )

    def update_sso_security(
        self,
        *,
        input: UpdateSsoSecurityInput,
        validate_future_output: Callable[[UpdateSsoSecurity], None] = lambda _: None,
        **kwargs: Unpack[Empty],
    ) -> BatchedOperationFutureOutput[Mapping[str, object], UpdateSsoSecurity]:
        query = gql(
            """
            mutation UpdateSsoSecurity($input: UpdateSsoSecurityInput!) {
              updateSsoSecurity(input: $input) {
                __typename
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}

        def validate_output(data: Mapping[str, object], /) -> UpdateSsoSecurity:
            try:
                return UpdateSsoSecurity.model_validate(data)
            except ValidationError as error:  # pragma: no cover
                raise RuntimeError(
                    f"Unexpected output for variables: {variables}."
                ) from error

        def process_future_output(data: Mapping[str, object], /) -> UpdateSsoSecurity:
            output = validate_output(data)
            validate_future_output(output)
            return output

        return self.mutation_batcher.submit(
            document=query,
            variables=variables,
            process_future_output=process_future_output,
        )
