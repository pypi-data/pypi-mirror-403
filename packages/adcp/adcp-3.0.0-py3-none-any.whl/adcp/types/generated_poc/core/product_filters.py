# generated by datamodel-codegen:
#   filename:  core/product_filters.json
#   timestamp: 2026-01-26T11:40:01+00:00

from __future__ import annotations

from datetime import date
from typing import Annotated

from adcp.types.base import AdCPBaseModel
from pydantic import AnyUrl, ConfigDict, Field, RootModel

from ..enums import channels as channels_1
from ..enums import delivery_type as delivery_type_1
from ..enums import format_category, geo_level, metro_system
from . import format_id, media_buy_features


class BudgetRange(AdCPBaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    currency: Annotated[
        str,
        Field(
            description="ISO 4217 currency code (e.g., 'USD', 'EUR', 'GBP')", pattern='^[A-Z]{3}$'
        ),
    ]
    max: Annotated[float | None, Field(description='Maximum budget amount', ge=0.0)] = None
    min: Annotated[float, Field(description='Minimum budget amount', ge=0.0)]


class BudgetRange1(AdCPBaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    currency: Annotated[
        str,
        Field(
            description="ISO 4217 currency code (e.g., 'USD', 'EUR', 'GBP')", pattern='^[A-Z]{3}$'
        ),
    ]
    max: Annotated[float, Field(description='Maximum budget amount', ge=0.0)]
    min: Annotated[float | None, Field(description='Minimum budget amount', ge=0.0)] = None


class Country(RootModel[str]):
    root: Annotated[str, Field(pattern='^[A-Z]{2}$')]


class Metro(AdCPBaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    code: Annotated[
        str, Field(description="Metro code within the system (e.g., '501' for NYC DMA)")
    ]
    system: Annotated[
        metro_system.MetroAreaSystem, Field(description='Metro classification system')
    ]


class Region(RootModel[str]):
    root: Annotated[str, Field(pattern='^[A-Z]{2}-[A-Z0-9]+$')]


class RequiredGeoTargetingItem(AdCPBaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    level: Annotated[
        geo_level.GeographicTargetingLevel,
        Field(description='Geographic targeting level (country, region, metro, postal_area)'),
    ]
    system: Annotated[
        str | None,
        Field(
            description="Classification system within the level. Required for metro (e.g., 'nielsen_dma') and postal_area (e.g., 'us_zip'). Not applicable for country/region which use ISO standards."
        ),
    ] = None


class ProductFilters(AdCPBaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    budget_range: Annotated[
        BudgetRange | BudgetRange1 | None,
        Field(description='Budget range to filter appropriate products'),
    ] = None
    channels: Annotated[
        list[channels_1.MediaChannel] | None,
        Field(description="Filter by advertising channels (e.g., ['display', 'video', 'dooh'])"),
    ] = None
    countries: Annotated[
        list[Country] | None,
        Field(
            description="Filter by country coverage using ISO 3166-1 alpha-2 codes (e.g., ['US', 'CA', 'GB']). Works for all inventory types."
        ),
    ] = None
    delivery_type: delivery_type_1.DeliveryType | None = None
    end_date: Annotated[
        date | None,
        Field(
            description='Campaign end date (ISO 8601 date format: YYYY-MM-DD) for availability checks'
        ),
    ] = None
    format_ids: Annotated[
        list[format_id.FormatId] | None, Field(description='Filter by specific format IDs')
    ] = None
    format_types: Annotated[
        list[format_category.FormatCategory] | None, Field(description='Filter by format types')
    ] = None
    is_fixed_price: Annotated[
        bool | None,
        Field(
            description='Filter by pricing availability: true = products offering fixed pricing (at least one option with fixed_price), false = products offering auction pricing (at least one option without fixed_price). Products with both fixed and auction options match both true and false.'
        ),
    ] = None
    metros: Annotated[
        list[Metro] | None,
        Field(
            description='Filter by metro coverage for locally-bound inventory (radio, DOOH, local TV). Use when products have DMA/metro-specific coverage. For digital inventory where products have broad coverage, use required_geo_targeting instead to filter by seller capability.'
        ),
    ] = None
    min_exposures: Annotated[
        int | None,
        Field(description='Minimum exposures/impressions needed for measurement validity', ge=1),
    ] = None
    regions: Annotated[
        list[Region] | None,
        Field(
            description="Filter by region coverage using ISO 3166-2 codes (e.g., ['US-NY', 'US-CA', 'GB-SCT']). Use for locally-bound inventory (regional OOH, local TV) where products have region-specific coverage."
        ),
    ] = None
    required_axe_integrations: Annotated[
        list[AnyUrl] | None,
        Field(
            description='Filter to products executable through specific agentic ad exchanges. URLs are canonical identifiers.'
        ),
    ] = None
    required_features: Annotated[
        media_buy_features.MediaBuyFeatures | None,
        Field(
            description='Filter to products from sellers supporting specific protocol features. Only features set to true are used for filtering.'
        ),
    ] = None
    required_geo_targeting: Annotated[
        list[RequiredGeoTargetingItem] | None,
        Field(
            description='Filter to products from sellers supporting specific geo targeting capabilities. Each entry specifies a targeting level (country, region, metro, postal_area) and optionally a system for levels that have multiple classification systems.'
        ),
    ] = None
    standard_formats_only: Annotated[
        bool | None, Field(description='Only return products accepting IAB standard formats')
    ] = None
    start_date: Annotated[
        date | None,
        Field(
            description='Campaign start date (ISO 8601 date format: YYYY-MM-DD) for availability checks'
        ),
    ] = None
