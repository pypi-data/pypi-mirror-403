# generated by datamodel-codegen:
#   filename:  media_buy/update_media_buy_request.json
#   timestamp: 2026-01-25T21:17:54+00:00

from __future__ import annotations

from typing import Annotated

from adcp.types.base import AdCPBaseModel
from pydantic import AwareDatetime, ConfigDict, Field, RootModel

from ..core import context as context_1
from ..core import ext as ext_1
from ..core import push_notification_config as push_notification_config_1
from ..core import reporting_webhook as reporting_webhook_1
from ..core import start_timing
from . import package_update


class UpdateMediaBuyRequest1(AdCPBaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    buyer_ref: Annotated[
        str | None, Field(description="Buyer's reference for the media buy to update")
    ] = None
    context: context_1.ContextObject | None = None
    end_time: Annotated[
        AwareDatetime | None, Field(description='New end date/time in ISO 8601 format')
    ] = None
    ext: ext_1.ExtensionObject | None = None
    media_buy_id: Annotated[str, Field(description="Publisher's ID of the media buy to update")]
    packages: Annotated[
        list[package_update.PackageUpdate] | None, Field(description='Package-specific updates')
    ] = None
    paused: Annotated[
        bool | None,
        Field(description='Pause/resume the entire media buy (true = paused, false = active)'),
    ] = None
    push_notification_config: Annotated[
        push_notification_config_1.PushNotificationConfig | None,
        Field(
            description='Optional webhook configuration for async update notifications. Publisher will send webhook when update completes if operation takes longer than immediate response time. This is separate from reporting_webhook which configures ongoing campaign reporting.'
        ),
    ] = None
    reporting_webhook: Annotated[
        reporting_webhook_1.ReportingWebhook | None,
        Field(
            description='Optional webhook configuration for automated reporting delivery. Updates the reporting configuration for this media buy.'
        ),
    ] = None
    start_time: start_timing.StartTiming | None = None


class UpdateMediaBuyRequest2(AdCPBaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    buyer_ref: Annotated[str, Field(description="Buyer's reference for the media buy to update")]
    context: context_1.ContextObject | None = None
    end_time: Annotated[
        AwareDatetime | None, Field(description='New end date/time in ISO 8601 format')
    ] = None
    ext: ext_1.ExtensionObject | None = None
    media_buy_id: Annotated[
        str | None, Field(description="Publisher's ID of the media buy to update")
    ] = None
    packages: Annotated[
        list[package_update.PackageUpdate] | None, Field(description='Package-specific updates')
    ] = None
    paused: Annotated[
        bool | None,
        Field(description='Pause/resume the entire media buy (true = paused, false = active)'),
    ] = None
    push_notification_config: Annotated[
        push_notification_config_1.PushNotificationConfig | None,
        Field(
            description='Optional webhook configuration for async update notifications. Publisher will send webhook when update completes if operation takes longer than immediate response time. This is separate from reporting_webhook which configures ongoing campaign reporting.'
        ),
    ] = None
    reporting_webhook: Annotated[
        reporting_webhook_1.ReportingWebhook | None,
        Field(
            description='Optional webhook configuration for automated reporting delivery. Updates the reporting configuration for this media buy.'
        ),
    ] = None
    start_time: start_timing.StartTiming | None = None


class UpdateMediaBuyRequest(RootModel[UpdateMediaBuyRequest1 | UpdateMediaBuyRequest2]):
    root: Annotated[
        UpdateMediaBuyRequest1 | UpdateMediaBuyRequest2,
        Field(
            description='Request parameters for updating campaign and package settings',
            title='Update Media Buy Request',
        ),
    ]
