# IRIS Graph-AI Implementation Assessment Against GRAPH_PRIMITIVES.md

## Overview

This document provides a detailed assessment of how the current IRIS Graph-AI implementation does or doesn't support the indexing and primitive "view" outlined in [`docs/GRAPH_PRIMITIVES.md`](GRAPH_PRIMITIVES.md). The assessment maps each proposed primitive to concrete implementations in the codebase, identifying gaps and providing actionable recommendations.

## Executive Summary

The implementation **largely aligns** with the proposed baseline indexing palette:
- ✅ **Edge Identity (EdgePK)**: Fully implemented
- ⚠️ **Node Identity (NodePK)**: Implicit across tables (recommendation: add explicit NodePK table)
- ✅ **Topology (Forward/Reverse Adjacency)**: Strong support via IRIS globals and SQL indexes
- ✅ **Labels/Types & Properties**: Posting-style structures in both SQL and globals
- ⚠️ **Full-text Search**: Docs table indexed; qualifiers use LIKE with JSON_TABLE fallback
- ❌ **Geospatial/Temporal**: Not implemented (add when needed)
- ❌ **Advanced Path Accelerators**: Not implemented (consistent with "workload-driven" guidance)

## What GRAPH_PRIMITIVES.md Proposes

The document outlines a comprehensive indexing palette including:

1. **Identity**: NodePK, EdgePK for exact lookups
2. **Topology**: Forward/reverse adjacency, CSR offsets, optional all-type adjacency
3. **Labels/Types**: Posting lists/bitmaps for fast filtering
4. **Properties**: Per-(label, property) B-tree/LSM indexes with composite variants
5. **Full-text/Fuzzy**: Inverted indexes for text search
6. **Geospatial/Temporal**: R-tree/S2/H3 for geo, interval trees for time
7. **Path/Reachability**: 2-hop labels, landmarks, hub labels (workload-driven)
8. **Statistics**: Degree histograms, property histograms, sampled neighbors
9. **Caching**: Neighbor-list cache, posting-list cache, compiled plan cache

**Minimal Baseline**: NodePK/EdgePK + forward/reverse adjacency + label/type postings + property indexes + optional full-text.

## Implementation Analysis by Primitive

### 1. Identity (NodePK/EdgePK)

#### ✅ EdgePK - Fully Implemented
- **Location**: [`sql/schema.sql:21`](sql/schema.sql) - `edge_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY`
- **Core Schema**: [`iris_vector_graph/schema.py:44`](iris_vector_graph/schema.py) - Edge identity with auto-increment
- **Status**: Complete edge identity implementation

#### ⚠️ NodePK - Implicit Implementation
- **Current Approach**: Node identity via string `s`/`o_id` repeated across tables
  - Labels: [`sql/schema.sql:6`](sql/schema.sql)
  - Properties: [`sql/schema.sql:13`](sql/schema.sql)
  - Edges: [`sql/schema.sql:21`](sql/schema.sql)
- **Vector Identity**: Separate PK on embeddings tables
  - [`sql/schema.sql:32`](sql/schema.sql) - `kg_NodeEmbeddings(id VARCHAR(256) PRIMARY KEY)`
  - [`iris_vector_graph/schema.py:56`](iris_vector_graph/schema.py) - Domain-agnostic schema
- **Gap**: No explicit nodes table with enforced uniqueness constraints
- **Recommendation**: Add explicit NodePK table for referential integrity

### 2. Topology (Forward/Reverse Adjacency)

#### ✅ Strong Implementation via Globals + SQL

**SQL Adjacency Indexes**:
- Forward lookup (s,p): [`sql/schema.sql:28`](sql/schema.sql) - `idx_edges_s_p`
- Reverse lookup (p,o_id): [`sql/schema.sql:29`](sql/schema.sql) - `idx_edges_p_oid`

**IRIS Globals B-tree Adjacency**:
- **Structure**: `^KG("out", s, p, o)` and `^KG("in", o, p, s)`
- **Builder**: [`Graph.KG.Traversal.BuildKG()`](iris_src/src/Graph/KG/Traversal.cls:4-31)
- **Design**: [`sql/globals_schema.sql:10`](sql/globals_schema.sql) - Global structure documentation

**Degree Counters**:
- **Implementation**: [`Graph.KG.Traversal.BuildKG()`](iris_src/src/Graph/KG/Traversal.cls:23-24)
- **Globals**: `^KG("deg", s)`, `^KG("degp", s, p)`

**All-Type Adjacency**:
- **Support**: Via global iteration when predicate filter empty
- **Implementation**: [`Graph.KG.Traversal.BFS_JSON()`](iris_src/src/Graph/KG/Traversal.cls:66-79)

**Ordering/CSR Notes**:
- ✅ **Sorted Access**: IRIS globals provide B-tree lexicographic ordering via `g.next()`
- ❌ **CSR Offsets**: Not implemented (O(1) degree via `^KG("deg", s)` only)
- ❌ **Time-sorted Shadow Lists**: Not implemented

### 3. Labels/Types (Fast Filtering)

#### ✅ Full Implementation

**SQL Indexes**:
- [`sql/schema.sql:10-11`](sql/schema.sql) - `idx_labels_label_s`, `idx_labels_s_label`

**Globals Postings**:
- **Structure**: `^KG("label", label, s)`
- **Builder**: [`Graph.KG.Traversal.BuildKG()`](iris_src/src/Graph/KG/Traversal.cls:8-11)

**Usage in Queries**:
- **Test Validation**: [`tests/python/test_sql_queries.py:147`](tests/python/test_sql_queries.py) - Entity type filtering

### 4. Properties (Secondary Access)

#### ✅ Basic Implementation, Missing Composites

**SQL Indexes**:
- (s,key): [`sql/schema.sql:18`](sql/schema.sql) - `idx_props_s_key`
- (key,val): [`sql/schema.sql:19`](sql/schema.sql) - `idx_props_key_val`

**Globals Property Postings**:
- **Structures**: `^KG("prop", key, val, s)` and `^KG("prop:", key, s)`
- **Builder**: [`Graph.KG.Traversal.BuildKG()`](iris_src/src/Graph/KG/Traversal.cls:13-16)

**Gaps**:
- ❌ **Composite Indexes**: Not implemented
- ❌ **Uniqueness Constraints**: Not implemented

### 5. Full-text/Fuzzy Search

#### ⚠️ Partial Implementation

**Documents Table with iFind**:
- **Schema**: [`sql/schema.sql:49-53`](sql/schema.sql) - Text index with %FIND
- **Engine**: [`TextSearchEngine.search_documents()`](iris_vector_graph/text_search.py:24-55)

**Qualifier Text Search**:
- **Current**: LIKE-based search in [`IRISGraphOperators._kg_TXT_fallback()`](python/iris_vector_graph_operators.py:263-291)
- **Advanced**: JSON_TABLE attempts in [`IRISGraphEngine.kg_TXT()`](iris_vector_graph/engine.py:159-197)
- **Validation**: [`tests/python/test_sql_queries.py:257`](tests/python/test_sql_queries.py) - Qualifier text search

**Gap**: Qualifiers not indexed with inverted index (using LIKE unless JSON_TABLE available)

### 6. Geospatial & Temporal

#### ❌ Not Implemented
- **Geospatial**: No spatial columns or R-tree/S2/H3 indexes
- **Temporal**: Qualifiers can store time fields but no interval trees or temporal indexes
- **Status**: Add when domain requires geo/temporal queries

### 7. Path/Reachability Accelerators

#### ✅ Basic Traversal, Missing Advanced Accelerators

**Working Traversal**:
- **BFS over Globals**: [`Graph.KG.Traversal.BFS_JSON()`](iris_src/src/Graph/KG/Traversal.cls:33-84)
- **Python Alternative**: [`IRISGraphOperators.kg_GRAPH_WALK()`](python/iris_vector_graph_operators.py:390-488)
- **Shortest Path**: [`sql/graph_path_globals.sql:143`](sql/graph_path_globals.sql) - Bidirectional BFS

**Missing Advanced Accelerators**:
- ❌ **2-hop Labeling**: Not implemented
- ❌ **Landmarks/ALT**: Not implemented  
- ❌ **Hub Labels**: Not implemented
- ❌ **Contraction Hierarchies**: Not implemented

**Status**: Consistent with "workload-driven" guidance - add only if SLOs demand sub-millisecond path tests

### 8. Statistics for Query Planning

#### ⚠️ Partial Implementation

**Available Statistics**:
- **Degree Stats**: [`Graph.KG.Traversal.BuildKG()`](iris_src/src/Graph/KG/Traversal.cls:23-24) - `^KG("deg", s)`, `^KG("degp", s, p)`
- **Node Stats TVF**: [`sql/graph_path_globals.sql:282`](sql/graph_path_globals.sql) - Degree and label statistics

**Missing Statistics**:
- ❌ **Property Histograms/NDV**: Not implemented
- ❌ **Sampled Neighbor Lists**: Not implemented
- ❌ **Selectivity Estimates**: Basic predicate stats only

### 9. Caching

#### ⚠️ Materialized Adjacency Only

**Available Caching**:
- **Materialized Adjacency**: IRIS globals `^KG` act as read-optimized adjacency cache
- **Design**: [`sql/globals_schema.sql:28`](sql/globals_schema.sql) - Globals as caching layer

**Missing Caching**:
- ❌ **Neighbor-list Cache**: Not implemented
- ❌ **Posting-list Cache**: Not implemented  
- ❌ **Compiled Plan Cache**: Not implemented

## Implementation Architecture

### Core Schema and Indexes

**RDF-Style Schema**:
- [`sql/schema.sql`](sql/schema.sql) - Complete SQL schema with indexes
- [`iris_vector_graph/schema.py:15`](iris_vector_graph/schema.py) - Domain-agnostic schema utilities

**Globals-Based Graph Layer**:
- [`Graph.KG.Traversal.BuildKG()`](iris_src/src/Graph/KG/Traversal.cls:4-31) - Builder for B-tree adjacency
- [`sql/globals_schema.sql`](sql/globals_schema.sql) - Design documentation and triggers

### Query Primitives Implementation

**Graph Traversal**:
- **REST MetaPath**: [`Graph.KG.Traversal.BFS_JSON()`](iris_src/src/Graph/KG/Traversal.cls:33-84) via [`Graph.KG.Service.MetaPath`](iris_src/src/Graph/KG/Service.cls:66)
- **Python Traversal**: [`IRISGraphOperators.kg_GRAPH_WALK()`](python/iris_vector_graph_operators.py:390-488)
- **SQL Procedures**: [`sql/graph_path_globals.sql:5`](sql/graph_path_globals.sql) - Globals-based traversal

**Vector Search (Dual Implementation)**:
- **HNSW Optimized**: [`IRISGraphEngine._kg_KNN_VEC_hnsw_optimized()`](iris_vector_graph/engine.py:53-90) - Uses VECTOR_COSINE/TO_VECTOR
- **Python CSV Fallback**: [`IRISGraphEngine._kg_KNN_VEC_python_optimized()`](iris_vector_graph/engine.py:93-155) - When IRIS vector functions unavailable
- **Migration Utilities**: [`VectorOptimizer.migrate_to_optimized()`](iris_vector_graph/vector_utils.py:86-208)

**Text Search**:
- **Documents**: [`TextSearchEngine.search_documents()`](iris_vector_graph/text_search.py:24-82) - %FIND with fallback
- **Qualifiers**: [`IRISGraphOperators.kg_TXT()`](python/iris_vector_graph_operators.py:210-261) - JSON_TABLE with LIKE fallback

**Hybrid Fusion**:
- **RRF Implementation**: [`IRISGraphEngine.kg_RRF_FUSE()`](iris_vector_graph/engine.py:250-305)
- **Advanced Fusion**: [`HybridSearchFusion.multi_modal_search()`](iris_vector_graph/fusion.py:109-237)

### REST API Exposure

**IRIS-Native REST**:
- **Route Map**: [`Graph.KG.Service.UrlMap`](iris_src/src/Graph/KG/Service.cls:4-11)
- **Vector Search**: [`Graph.KG.Service.VectorSearch`](iris_src/src/Graph/KG/Service.cls:43-52) → [`Graph.KG.PyOps.VectorSearch()`](iris_src/src/Graph/KG/PyOps.cls:4-30)
- **Hybrid Search**: [`Graph.KG.Service.HybridSearch`](iris_src/src/Graph/KG/Service.cls:54-64) → [`Graph.KG.PyOps.HybridSearch()`](iris_src/src/Graph/KG/PyOps.cls:32-58)
- **Graph Traversal**: [`Graph.KG.Service.MetaPath`](iris_src/src/Graph/KG/Service.cls:66-76) → [`Graph.KG.PyOps.MetaPath()`](iris_src/src/Graph/KG/PyOps.cls:60-67)

## Validation and Testing

### Working SQL Patterns
- **Multi-hop Traversal**: [`tests/python/test_sql_queries.py:183`](tests/python/test_sql_queries.py) - 2-hop joins validated
- **Bidirectional Neighbors**: [`tests/python/test_sql_queries.py:205`](tests/python/test_sql_queries.py) - Incoming/outgoing edges
- **Complex Joins**: [`tests/python/test_sql_queries.py:308`](tests/python/test_sql_queries.py) - Multi-table joins with labels/properties

### Python Operators Coverage
- **Vector Search**: [`IRISGraphOperators.kg_KNN_VEC()`](python/iris_vector_graph_operators.py:28-49)
- **Text Search**: [`IRISGraphOperators.kg_TXT()`](python/iris_vector_graph_operators.py:210-261)
- **Hybrid Fusion**: [`IRISGraphOperators.kg_RRF_FUSE()`](python/iris_vector_graph_operators.py:294-348)
- **Graph Traversal**: [`IRISGraphOperators.kg_GRAPH_WALK()`](python/iris_vector_graph_operators.py:390-488)

### REST API Testing
- **Health/Vector/Hybrid**: [`tests/python/test_iris_rest_api.py:36`](tests/python/test_iris_rest_api.py) - Comprehensive endpoint validation

## Critical Dependencies

### InterSystems IRIS Features
- **Native REST**: [`Graph.KG.Service`](iris_src/src/Graph/KG/Service.cls:1) extends `%CSP.REST`
- **Embedded Python**: [`Graph.KG.PyOps`](iris_src/src/Graph/KG/PyOps.cls:1), [`iris_vector_graph.GraphOperators`](iris_src/src/iris_vector_graph/GraphOperators.cls:1)
- **VECTOR Types**: [`IRISGraphOperators._kg_KNN_VEC_hnsw_optimized()`](python/iris_vector_graph_operators.py:51-89) uses VECTOR_COSINE/TO_VECTOR
- **iFind Text Search**: [`TextSearchEngine.search_documents()`](iris_vector_graph/text_search.py:24-82) uses %FIND
- **Globals**: [`Graph.KG.Traversal.BuildKG()`](iris_src/src/Graph/KG/Traversal.cls:4-31) uses `^KG` globals

### Python Libraries
- **iris**: Python driver used throughout operators and tests
- **numpy**: Vector computation fallback when IRIS VECTOR functions unavailable
- **JSON_TABLE**: Attempted for qualifier parsing; availability varies by IRIS version

## Gap Analysis vs. Baseline Requirements

### ✅ Baseline Coverage (90%+)
1. **EdgePK**: Complete via `edge_id` identity
2. **Forward/Reverse Adjacency**: Strong implementation via globals + SQL indexes
3. **Label/Type Postings**: Both SQL and globals implementations
4. **Property Indexes**: Basic (s,key) and (key,val) coverage
5. **Optional Full-text**: Docs table with %FIND; qualifiers with LIKE/JSON_TABLE

### ⚠️ Baseline Gaps
1. **NodePK**: Implicit only - recommend explicit nodes table
2. **Composite Property Indexes**: Not implemented
3. **Uniqueness Constraints**: Not enforced
4. **Qualifier Full-text**: LIKE-based, not inverted index

### ❌ Advanced Features (Appropriately Missing)
1. **Geospatial/Temporal**: Domain-specific, add when needed
2. **Path Accelerators**: Workload-driven, add if SLOs demand
3. **CSR Offsets**: Not critical with globals B-tree performance
4. **Advanced Caching**: Beyond materialized adjacency

## Environment-Specific Considerations

Based on [`docs/architecture/ACTUAL_SCHEMA.md`](docs/architecture/ACTUAL_SCHEMA.md) findings:

### IRIS Vector Function Availability
- **If Available**: Use optimized HNSW path with VECTOR_COSINE/TO_VECTOR
- **If Missing**: Python CSV fallback automatically activates
- **Migration**: [`VectorOptimizer.migrate_to_optimized()`](iris_vector_graph/vector_utils.py:86-208) converts CSV to VECTOR format

### JSON_TABLE Function Availability  
- **If Available**: Enhanced qualifier parsing with structured extraction
- **If Missing**: LIKE-based fallback maintains functionality
- **Fallback**: [`IRISGraphOperators._kg_TXT_fallback()`](python/iris_vector_graph_operators.py:263-291)

### TVF Implementation
- **SQL TVFs**: Require class-based implementation in IRIS
- **Working Alternative**: Globals-based BFS traversal via [`Graph.KG.Traversal.BFS_JSON()`](iris_src/src/Graph/KG/Traversal.cls:33-84)

## Recommendations

### Immediate (High Priority)
1. **Add NodePK Table**: Create explicit `nodes(node_id PK, ...)` with foreign keys from rdf_* tables
2. **Globals Maintenance**: Promote stub triggers to real incremental updates or schedule periodic rebuilds
3. **Vector Function Detection**: Use [`VectorOptimizer.check_hnsw_availability()`](iris_vector_graph/vector_utils.py:30-84) to determine optimal path

### Near-term (Medium Priority)  
1. **Composite Property Indexes**: Add for common (label, property) query patterns
2. **Qualifier Full-text**: Move from LIKE to %FIND over derived index if JSON_TABLE unavailable
3. **Statistics Enhancement**: Add property histograms and selectivity estimates

### Long-term (Workload-Driven)
1. **Path Accelerators**: Only if SLOs demand sub-millisecond path tests at scale
2. **CSR Optimization**: Only if globals B-tree traversal becomes bottleneck
3. **Advanced Caching**: Only if neighbor-list or posting-list access patterns justify

## Conclusion

The IRIS Graph-AI implementation **strongly aligns** with the proposed indexing palette baseline, achieving 90%+ coverage of core primitives through a sophisticated combination of:

- **SQL Schema**: Standard RDF-style tables with comprehensive indexes
- **IRIS Globals**: B-tree adjacency optimization for fast traversal  
- **Dual Implementation**: Optimized HNSW + Python CSV fallbacks for environment compatibility
- **REST API**: Native IRIS endpoints exposing graph primitives
- **Comprehensive Testing**: Validated SQL patterns, Python operators, and REST endpoints

The missing elements (NodePK table, composite indexes, advanced accelerators) represent clear opportunities for enhancement while maintaining the document's principle of adding complexity only when workload demands justify it.

The implementation successfully balances performance optimization with operational simplicity, providing a solid foundation that can scale from development through enterprise deployment.