
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_result_or_op_results as _get_op_result_or_op_results,
    get_op_result_or_value as _get_op_result_or_value,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir

import builtins
from typing import Sequence as _Sequence, Union as _Union


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "amdgpu"

@_ods_cext.register_operation(_Dialect)
class ExtPackedFp8Op(_ods_ir.OpView):
  OPERATION_NAME = "amdgpu.ext_packed_fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, source, index, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(source))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["index"] = (index if (
    isinstance(index, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(index, context=_ods_context))
    results.append(res)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def source(self):
    return self.operation.operands[0]

  @builtins.property
  def index(self):
    return self.operation.attributes["index"]

  @index.setter
  def index(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["index"] = value

  @builtins.property
  def res(self):
    return self.operation.results[0]

def ext_packed_fp8(res, source, index, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ExtPackedFp8Op(res=res, source=source, index=index, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class LDSBarrierOp(_ods_ir.OpView):
  OPERATION_NAME = "amdgpu.lds_barrier"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

def lds_barrier(*, loc=None, ip=None) -> _ods_ir.Operation:
  return _get_op_result_or_op_results(LDSBarrierOp(loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class MFMAOp(_ods_ir.OpView):
  OPERATION_NAME = "amdgpu.mfma"

  _ODS_REGIONS = (0, True)

  def __init__(self, destD, m, n, k, blocks, sourceA, sourceB, destC, *, cbsz=None, abid=None, blgp=None, reducePrecision=None, negateA=None, negateB=None, negateC=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(sourceA))
    operands.append(_get_op_result_or_value(sourceB))
    operands.append(_get_op_result_or_value(destC))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["m"] = (m if (
    isinstance(m, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(m, context=_ods_context))
    attributes["n"] = (n if (
    isinstance(n, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(n, context=_ods_context))
    attributes["k"] = (k if (
    isinstance(k, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(k, context=_ods_context))
    attributes["blocks"] = (blocks if (
    isinstance(blocks, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(blocks, context=_ods_context))
    if cbsz is not None: attributes["cbsz"] = (cbsz if (
        isinstance(cbsz, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(cbsz, context=_ods_context))
    if abid is not None: attributes["abid"] = (abid if (
        isinstance(abid, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(abid, context=_ods_context))
    if blgp is not None: attributes["blgp"] = (blgp if (
        isinstance(blgp, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('AMDGPU_MFMAPermBAttr')) else
          _ods_ir.AttrBuilder.get('AMDGPU_MFMAPermBAttr')(blgp, context=_ods_context))
    if bool(reducePrecision): attributes["reducePrecision"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(negateA): attributes["negateA"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(negateB): attributes["negateB"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(negateC): attributes["negateC"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results.append(destD)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def sourceA(self):
    return self.operation.operands[0]

  @builtins.property
  def sourceB(self):
    return self.operation.operands[1]

  @builtins.property
  def destC(self):
    return self.operation.operands[2]

  @builtins.property
  def m(self):
    return self.operation.attributes["m"]

  @m.setter
  def m(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["m"] = value

  @builtins.property
  def n(self):
    return self.operation.attributes["n"]

  @n.setter
  def n(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["n"] = value

  @builtins.property
  def k(self):
    return self.operation.attributes["k"]

  @k.setter
  def k(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["k"] = value

  @builtins.property
  def blocks(self):
    return self.operation.attributes["blocks"]

  @blocks.setter
  def blocks(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["blocks"] = value

  @builtins.property
  def cbsz(self):
    return self.operation.attributes["cbsz"]

  @cbsz.setter
  def cbsz(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["cbsz"] = value

  @builtins.property
  def abid(self):
    return self.operation.attributes["abid"]

  @abid.setter
  def abid(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["abid"] = value

  @builtins.property
  def blgp(self):
    return self.operation.attributes["blgp"]

  @blgp.setter
  def blgp(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["blgp"] = value

  @builtins.property
  def reducePrecision(self):
    return "reducePrecision" in self.operation.attributes

  @reducePrecision.setter
  def reducePrecision(self, value):
    if bool(value):
      self.operation.attributes["reducePrecision"] = _ods_ir.UnitAttr.get()
    elif "reducePrecision" in self.operation.attributes:
      del self.operation.attributes["reducePrecision"]

  @reducePrecision.deleter
  def reducePrecision(self):
    del self.operation.attributes["reducePrecision"]

  @builtins.property
  def negateA(self):
    return "negateA" in self.operation.attributes

  @negateA.setter
  def negateA(self, value):
    if bool(value):
      self.operation.attributes["negateA"] = _ods_ir.UnitAttr.get()
    elif "negateA" in self.operation.attributes:
      del self.operation.attributes["negateA"]

  @negateA.deleter
  def negateA(self):
    del self.operation.attributes["negateA"]

  @builtins.property
  def negateB(self):
    return "negateB" in self.operation.attributes

  @negateB.setter
  def negateB(self, value):
    if bool(value):
      self.operation.attributes["negateB"] = _ods_ir.UnitAttr.get()
    elif "negateB" in self.operation.attributes:
      del self.operation.attributes["negateB"]

  @negateB.deleter
  def negateB(self):
    del self.operation.attributes["negateB"]

  @builtins.property
  def negateC(self):
    return "negateC" in self.operation.attributes

  @negateC.setter
  def negateC(self, value):
    if bool(value):
      self.operation.attributes["negateC"] = _ods_ir.UnitAttr.get()
    elif "negateC" in self.operation.attributes:
      del self.operation.attributes["negateC"]

  @negateC.deleter
  def negateC(self):
    del self.operation.attributes["negateC"]

  @builtins.property
  def destD(self):
    return self.operation.results[0]

def mfma(dest_d, m, n, k, blocks, source_a, source_b, dest_c, *, cbsz=None, abid=None, blgp=None, reduce_precision=None, negate_a=None, negate_b=None, negate_c=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(MFMAOp(destD=dest_d, m=m, n=n, k=k, blocks=blocks, sourceA=source_a, sourceB=source_b, destC=dest_c, cbsz=cbsz, abid=abid, blgp=blgp, reducePrecision=reduce_precision, negateA=negate_a, negateB=negate_b, negateC=negate_c, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class PackedStochRoundFp8Op(_ods_ir.OpView):
  OPERATION_NAME = "amdgpu.packed_stoch_round_fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, source, stochiasticParam, storeIndex, *, existing=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(source))
    operands.append(_get_op_result_or_value(stochiasticParam))
    if existing is not None: operands.append(_get_op_result_or_value(existing))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["storeIndex"] = (storeIndex if (
    isinstance(storeIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(storeIndex, context=_ods_context))
    results.append(res)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def source(self):
    return self.operation.operands[0]

  @builtins.property
  def stochiasticParam(self):
    return self.operation.operands[1]

  @builtins.property
  def existing(self):
    return None if len(self.operation.operands) < 3 else self.operation.operands[2]

  @builtins.property
  def storeIndex(self):
    return self.operation.attributes["storeIndex"]

  @storeIndex.setter
  def storeIndex(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["storeIndex"] = value

  @builtins.property
  def res(self):
    return self.operation.results[0]

def packed_stoch_round_fp8(res, source, stochiastic_param, store_index, *, existing=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(PackedStochRoundFp8Op(res=res, source=source, stochiasticParam=stochiastic_param, storeIndex=store_index, existing=existing, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class PackedTrunc2xFp8Op(_ods_ir.OpView):
  OPERATION_NAME = "amdgpu.packed_trunc_2xfp8"

  _ODS_OPERAND_SEGMENTS = [1,0,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, res, sourceA, wordIndex, *, sourceB=None, existing=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(sourceA))
    operands.append(_get_op_result_or_value(sourceB) if sourceB is not None else None)
    operands.append(_get_op_result_or_value(existing) if existing is not None else None)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["wordIndex"] = (wordIndex if (
    isinstance(wordIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(wordIndex, context=_ods_context))
    results.append(res)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def sourceA(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def sourceB(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def existing(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def wordIndex(self):
    return self.operation.attributes["wordIndex"]

  @wordIndex.setter
  def wordIndex(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["wordIndex"] = value

  @builtins.property
  def res(self):
    return self.operation.results[0]

def packed_trunc_2xfp8(res, source_a, word_index, *, source_b=None, existing=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(PackedTrunc2xFp8Op(res=res, sourceA=source_a, wordIndex=word_index, sourceB=source_b, existing=existing, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class RawBufferAtomicCmpswapOp(_ods_ir.OpView):
  OPERATION_NAME = "amdgpu.raw_buffer_atomic_cmpswap"

  _ODS_OPERAND_SEGMENTS = [1,1,1,-1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, value, src, cmp, memref, indices, *, boundsCheck=None, indexOffset=None, sgprOffset=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(src))
    operands.append(_get_op_result_or_value(cmp))
    operands.append(_get_op_result_or_value(memref))
    operands.append(_get_op_results_or_values(indices))
    operands.append(_get_op_result_or_value(sgprOffset) if sgprOffset is not None else None)
    _ods_context = _ods_get_default_loc_context(loc)
    if boundsCheck is not None: attributes["boundsCheck"] = (boundsCheck if (
        isinstance(boundsCheck, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(boundsCheck, context=_ods_context))
    if indexOffset is not None: attributes["indexOffset"] = (indexOffset if (
        isinstance(indexOffset, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(indexOffset, context=_ods_context))
    results.append(value)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def src(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def cmp(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def memref(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def indices(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def sgprOffset(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def boundsCheck(self):
    return self.operation.attributes["boundsCheck"]

  @boundsCheck.setter
  def boundsCheck(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["boundsCheck"] = value

  @builtins.property
  def indexOffset(self):
    if "indexOffset" not in self.operation.attributes:
      return None
    return self.operation.attributes["indexOffset"]

  @indexOffset.setter
  def indexOffset(self, value):
    if value is not None:
      self.operation.attributes["indexOffset"] = value
    elif "indexOffset" in self.operation.attributes:
      del self.operation.attributes["indexOffset"]

  @indexOffset.deleter
  def indexOffset(self):
    del self.operation.attributes["indexOffset"]

  @builtins.property
  def value(self):
    return self.operation.results[0]

def raw_buffer_atomic_cmpswap(value, src, cmp, memref, indices, *, bounds_check=None, index_offset=None, sgpr_offset=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(RawBufferAtomicCmpswapOp(value=value, src=src, cmp=cmp, memref=memref, indices=indices, boundsCheck=bounds_check, indexOffset=index_offset, sgprOffset=sgpr_offset, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class RawBufferAtomicFaddOp(_ods_ir.OpView):
  OPERATION_NAME = "amdgpu.raw_buffer_atomic_fadd"

  _ODS_OPERAND_SEGMENTS = [1,1,-1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, value, memref, indices, *, boundsCheck=None, indexOffset=None, sgprOffset=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(value))
    operands.append(_get_op_result_or_value(memref))
    operands.append(_get_op_results_or_values(indices))
    operands.append(_get_op_result_or_value(sgprOffset) if sgprOffset is not None else None)
    _ods_context = _ods_get_default_loc_context(loc)
    if boundsCheck is not None: attributes["boundsCheck"] = (boundsCheck if (
        isinstance(boundsCheck, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(boundsCheck, context=_ods_context))
    if indexOffset is not None: attributes["indexOffset"] = (indexOffset if (
        isinstance(indexOffset, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(indexOffset, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def value(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def memref(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def indices(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def sgprOffset(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def boundsCheck(self):
    return self.operation.attributes["boundsCheck"]

  @boundsCheck.setter
  def boundsCheck(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["boundsCheck"] = value

  @builtins.property
  def indexOffset(self):
    if "indexOffset" not in self.operation.attributes:
      return None
    return self.operation.attributes["indexOffset"]

  @indexOffset.setter
  def indexOffset(self, value):
    if value is not None:
      self.operation.attributes["indexOffset"] = value
    elif "indexOffset" in self.operation.attributes:
      del self.operation.attributes["indexOffset"]

  @indexOffset.deleter
  def indexOffset(self):
    del self.operation.attributes["indexOffset"]

def raw_buffer_atomic_fadd(value, memref, indices, *, bounds_check=None, index_offset=None, sgpr_offset=None, loc=None, ip=None) -> _ods_ir.Operation:
  return _get_op_result_or_op_results(RawBufferAtomicFaddOp(value=value, memref=memref, indices=indices, boundsCheck=bounds_check, indexOffset=index_offset, sgprOffset=sgpr_offset, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class RawBufferAtomicFmaxOp(_ods_ir.OpView):
  OPERATION_NAME = "amdgpu.raw_buffer_atomic_fmax"

  _ODS_OPERAND_SEGMENTS = [1,1,-1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, value, memref, indices, *, boundsCheck=None, indexOffset=None, sgprOffset=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(value))
    operands.append(_get_op_result_or_value(memref))
    operands.append(_get_op_results_or_values(indices))
    operands.append(_get_op_result_or_value(sgprOffset) if sgprOffset is not None else None)
    _ods_context = _ods_get_default_loc_context(loc)
    if boundsCheck is not None: attributes["boundsCheck"] = (boundsCheck if (
        isinstance(boundsCheck, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(boundsCheck, context=_ods_context))
    if indexOffset is not None: attributes["indexOffset"] = (indexOffset if (
        isinstance(indexOffset, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(indexOffset, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def value(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def memref(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def indices(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def sgprOffset(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def boundsCheck(self):
    return self.operation.attributes["boundsCheck"]

  @boundsCheck.setter
  def boundsCheck(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["boundsCheck"] = value

  @builtins.property
  def indexOffset(self):
    if "indexOffset" not in self.operation.attributes:
      return None
    return self.operation.attributes["indexOffset"]

  @indexOffset.setter
  def indexOffset(self, value):
    if value is not None:
      self.operation.attributes["indexOffset"] = value
    elif "indexOffset" in self.operation.attributes:
      del self.operation.attributes["indexOffset"]

  @indexOffset.deleter
  def indexOffset(self):
    del self.operation.attributes["indexOffset"]

def raw_buffer_atomic_fmax(value, memref, indices, *, bounds_check=None, index_offset=None, sgpr_offset=None, loc=None, ip=None) -> _ods_ir.Operation:
  return _get_op_result_or_op_results(RawBufferAtomicFmaxOp(value=value, memref=memref, indices=indices, boundsCheck=bounds_check, indexOffset=index_offset, sgprOffset=sgpr_offset, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class RawBufferAtomicSmaxOp(_ods_ir.OpView):
  OPERATION_NAME = "amdgpu.raw_buffer_atomic_smax"

  _ODS_OPERAND_SEGMENTS = [1,1,-1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, value, memref, indices, *, boundsCheck=None, indexOffset=None, sgprOffset=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(value))
    operands.append(_get_op_result_or_value(memref))
    operands.append(_get_op_results_or_values(indices))
    operands.append(_get_op_result_or_value(sgprOffset) if sgprOffset is not None else None)
    _ods_context = _ods_get_default_loc_context(loc)
    if boundsCheck is not None: attributes["boundsCheck"] = (boundsCheck if (
        isinstance(boundsCheck, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(boundsCheck, context=_ods_context))
    if indexOffset is not None: attributes["indexOffset"] = (indexOffset if (
        isinstance(indexOffset, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(indexOffset, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def value(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def memref(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def indices(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def sgprOffset(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def boundsCheck(self):
    return self.operation.attributes["boundsCheck"]

  @boundsCheck.setter
  def boundsCheck(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["boundsCheck"] = value

  @builtins.property
  def indexOffset(self):
    if "indexOffset" not in self.operation.attributes:
      return None
    return self.operation.attributes["indexOffset"]

  @indexOffset.setter
  def indexOffset(self, value):
    if value is not None:
      self.operation.attributes["indexOffset"] = value
    elif "indexOffset" in self.operation.attributes:
      del self.operation.attributes["indexOffset"]

  @indexOffset.deleter
  def indexOffset(self):
    del self.operation.attributes["indexOffset"]

def raw_buffer_atomic_smax(value, memref, indices, *, bounds_check=None, index_offset=None, sgpr_offset=None, loc=None, ip=None) -> _ods_ir.Operation:
  return _get_op_result_or_op_results(RawBufferAtomicSmaxOp(value=value, memref=memref, indices=indices, boundsCheck=bounds_check, indexOffset=index_offset, sgprOffset=sgpr_offset, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class RawBufferAtomicUminOp(_ods_ir.OpView):
  OPERATION_NAME = "amdgpu.raw_buffer_atomic_umin"

  _ODS_OPERAND_SEGMENTS = [1,1,-1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, value, memref, indices, *, boundsCheck=None, indexOffset=None, sgprOffset=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(value))
    operands.append(_get_op_result_or_value(memref))
    operands.append(_get_op_results_or_values(indices))
    operands.append(_get_op_result_or_value(sgprOffset) if sgprOffset is not None else None)
    _ods_context = _ods_get_default_loc_context(loc)
    if boundsCheck is not None: attributes["boundsCheck"] = (boundsCheck if (
        isinstance(boundsCheck, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(boundsCheck, context=_ods_context))
    if indexOffset is not None: attributes["indexOffset"] = (indexOffset if (
        isinstance(indexOffset, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(indexOffset, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def value(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def memref(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def indices(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def sgprOffset(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def boundsCheck(self):
    return self.operation.attributes["boundsCheck"]

  @boundsCheck.setter
  def boundsCheck(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["boundsCheck"] = value

  @builtins.property
  def indexOffset(self):
    if "indexOffset" not in self.operation.attributes:
      return None
    return self.operation.attributes["indexOffset"]

  @indexOffset.setter
  def indexOffset(self, value):
    if value is not None:
      self.operation.attributes["indexOffset"] = value
    elif "indexOffset" in self.operation.attributes:
      del self.operation.attributes["indexOffset"]

  @indexOffset.deleter
  def indexOffset(self):
    del self.operation.attributes["indexOffset"]

def raw_buffer_atomic_umin(value, memref, indices, *, bounds_check=None, index_offset=None, sgpr_offset=None, loc=None, ip=None) -> _ods_ir.Operation:
  return _get_op_result_or_op_results(RawBufferAtomicUminOp(value=value, memref=memref, indices=indices, boundsCheck=bounds_check, indexOffset=index_offset, sgprOffset=sgpr_offset, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class RawBufferLoadOp(_ods_ir.OpView):
  OPERATION_NAME = "amdgpu.raw_buffer_load"

  _ODS_OPERAND_SEGMENTS = [1,-1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, value, memref, indices, *, boundsCheck=None, indexOffset=None, sgprOffset=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(memref))
    operands.append(_get_op_results_or_values(indices))
    operands.append(_get_op_result_or_value(sgprOffset) if sgprOffset is not None else None)
    _ods_context = _ods_get_default_loc_context(loc)
    if boundsCheck is not None: attributes["boundsCheck"] = (boundsCheck if (
        isinstance(boundsCheck, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(boundsCheck, context=_ods_context))
    if indexOffset is not None: attributes["indexOffset"] = (indexOffset if (
        isinstance(indexOffset, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(indexOffset, context=_ods_context))
    results.append(value)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def memref(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def indices(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def sgprOffset(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def boundsCheck(self):
    return self.operation.attributes["boundsCheck"]

  @boundsCheck.setter
  def boundsCheck(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["boundsCheck"] = value

  @builtins.property
  def indexOffset(self):
    if "indexOffset" not in self.operation.attributes:
      return None
    return self.operation.attributes["indexOffset"]

  @indexOffset.setter
  def indexOffset(self, value):
    if value is not None:
      self.operation.attributes["indexOffset"] = value
    elif "indexOffset" in self.operation.attributes:
      del self.operation.attributes["indexOffset"]

  @indexOffset.deleter
  def indexOffset(self):
    del self.operation.attributes["indexOffset"]

  @builtins.property
  def value(self):
    return self.operation.results[0]

def raw_buffer_load(value, memref, indices, *, bounds_check=None, index_offset=None, sgpr_offset=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(RawBufferLoadOp(value=value, memref=memref, indices=indices, boundsCheck=bounds_check, indexOffset=index_offset, sgprOffset=sgpr_offset, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class RawBufferStoreOp(_ods_ir.OpView):
  OPERATION_NAME = "amdgpu.raw_buffer_store"

  _ODS_OPERAND_SEGMENTS = [1,1,-1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, value, memref, indices, *, boundsCheck=None, indexOffset=None, sgprOffset=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(value))
    operands.append(_get_op_result_or_value(memref))
    operands.append(_get_op_results_or_values(indices))
    operands.append(_get_op_result_or_value(sgprOffset) if sgprOffset is not None else None)
    _ods_context = _ods_get_default_loc_context(loc)
    if boundsCheck is not None: attributes["boundsCheck"] = (boundsCheck if (
        isinstance(boundsCheck, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(boundsCheck, context=_ods_context))
    if indexOffset is not None: attributes["indexOffset"] = (indexOffset if (
        isinstance(indexOffset, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(indexOffset, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def value(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def memref(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def indices(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def sgprOffset(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def boundsCheck(self):
    return self.operation.attributes["boundsCheck"]

  @boundsCheck.setter
  def boundsCheck(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["boundsCheck"] = value

  @builtins.property
  def indexOffset(self):
    if "indexOffset" not in self.operation.attributes:
      return None
    return self.operation.attributes["indexOffset"]

  @indexOffset.setter
  def indexOffset(self, value):
    if value is not None:
      self.operation.attributes["indexOffset"] = value
    elif "indexOffset" in self.operation.attributes:
      del self.operation.attributes["indexOffset"]

  @indexOffset.deleter
  def indexOffset(self):
    del self.operation.attributes["indexOffset"]

def raw_buffer_store(value, memref, indices, *, bounds_check=None, index_offset=None, sgpr_offset=None, loc=None, ip=None) -> _ods_ir.Operation:
  return _get_op_result_or_op_results(RawBufferStoreOp(value=value, memref=memref, indices=indices, boundsCheck=bounds_check, indexOffset=index_offset, sgprOffset=sgpr_offset, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class WMMAOp(_ods_ir.OpView):
  OPERATION_NAME = "amdgpu.wmma"

  _ODS_REGIONS = (0, True)

  def __init__(self, destD, sourceA, sourceB, destC, *, subwordOffset=None, unsignedA=None, unsignedB=None, clamp=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(sourceA))
    operands.append(_get_op_result_or_value(sourceB))
    operands.append(_get_op_result_or_value(destC))
    _ods_context = _ods_get_default_loc_context(loc)
    if subwordOffset is not None: attributes["subwordOffset"] = (subwordOffset if (
        isinstance(subwordOffset, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(subwordOffset, context=_ods_context))
    if bool(unsignedA): attributes["unsignedA"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(unsignedB): attributes["unsignedB"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(clamp): attributes["clamp"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results.append(destD)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def sourceA(self):
    return self.operation.operands[0]

  @builtins.property
  def sourceB(self):
    return self.operation.operands[1]

  @builtins.property
  def destC(self):
    return self.operation.operands[2]

  @builtins.property
  def subwordOffset(self):
    return self.operation.attributes["subwordOffset"]

  @subwordOffset.setter
  def subwordOffset(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["subwordOffset"] = value

  @builtins.property
  def unsignedA(self):
    return "unsignedA" in self.operation.attributes

  @unsignedA.setter
  def unsignedA(self, value):
    if bool(value):
      self.operation.attributes["unsignedA"] = _ods_ir.UnitAttr.get()
    elif "unsignedA" in self.operation.attributes:
      del self.operation.attributes["unsignedA"]

  @unsignedA.deleter
  def unsignedA(self):
    del self.operation.attributes["unsignedA"]

  @builtins.property
  def unsignedB(self):
    return "unsignedB" in self.operation.attributes

  @unsignedB.setter
  def unsignedB(self, value):
    if bool(value):
      self.operation.attributes["unsignedB"] = _ods_ir.UnitAttr.get()
    elif "unsignedB" in self.operation.attributes:
      del self.operation.attributes["unsignedB"]

  @unsignedB.deleter
  def unsignedB(self):
    del self.operation.attributes["unsignedB"]

  @builtins.property
  def clamp(self):
    return "clamp" in self.operation.attributes

  @clamp.setter
  def clamp(self, value):
    if bool(value):
      self.operation.attributes["clamp"] = _ods_ir.UnitAttr.get()
    elif "clamp" in self.operation.attributes:
      del self.operation.attributes["clamp"]

  @clamp.deleter
  def clamp(self):
    del self.operation.attributes["clamp"]

  @builtins.property
  def destD(self):
    return self.operation.results[0]

def wmma(dest_d, source_a, source_b, dest_c, *, subword_offset=None, unsigned_a=None, unsigned_b=None, clamp=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(WMMAOp(destD=dest_d, sourceA=source_a, sourceB=source_b, destC=dest_c, subwordOffset=subword_offset, unsignedA=unsigned_a, unsignedB=unsigned_b, clamp=clamp, loc=loc, ip=ip))
