
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_result_or_op_results as _get_op_result_or_op_results,
    get_op_result_or_value as _get_op_result_or_value,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir

import builtins
from typing import Sequence as _Sequence, Union as _Union


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "tosa"

@_ods_cext.register_operation(_Dialect)
class AbsOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.abs"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input1))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input1(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def abs(output, input1, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(AbsOp(output=output, input1=input1, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class AddOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.add"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input1))
    operands.append(_get_op_result_or_value(input2))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input1(self):
    return self.operation.operands[0]

  @builtins.property
  def input2(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def add(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(AddOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ApplyScaleOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.apply_scale"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, value, multiplier, shift, double_round, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(value))
    operands.append(_get_op_result_or_value(multiplier))
    operands.append(_get_op_result_or_value(shift))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["double_round"] = (double_round if (
    isinstance(double_round, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(double_round, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def multiplier(self):
    return self.operation.operands[1]

  @builtins.property
  def shift(self):
    return self.operation.operands[2]

  @builtins.property
  def double_round(self):
    return self.operation.attributes["double_round"]

  @double_round.setter
  def double_round(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["double_round"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def apply_scale(output, value, multiplier, shift, double_round, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ApplyScaleOp(output=output, value=value, multiplier=multiplier, shift=shift, double_round=double_round, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ArgMaxOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.argmax"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, axis, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    isinstance(axis, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(axis, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def argmax(output, input, axis, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ArgMaxOp(output=output, input=input, axis=axis, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ArithmeticRightShiftOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.arithmetic_right_shift"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, round, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input1))
    operands.append(_get_op_result_or_value(input2))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["round"] = (round if (
    isinstance(round, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(round, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input1(self):
    return self.operation.operands[0]

  @builtins.property
  def input2(self):
    return self.operation.operands[1]

  @builtins.property
  def round(self):
    return self.operation.attributes["round"]

  @round.setter
  def round(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def arithmetic_right_shift(output, input1, input2, round, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ArithmeticRightShiftOp(output=output, input1=input1, input2=input2, round=round, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class AvgPool2dOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.avg_pool2d"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, kernel, stride, pad, acc_type, *, quantization_info=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["kernel"] = (kernel if (
    isinstance(kernel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_IntArrayAttr2')) else
      _ods_ir.AttrBuilder.get('Tosa_IntArrayAttr2')(kernel, context=_ods_context))
    attributes["stride"] = (stride if (
    isinstance(stride, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_IntArrayAttr2')) else
      _ods_ir.AttrBuilder.get('Tosa_IntArrayAttr2')(stride, context=_ods_context))
    attributes["pad"] = (pad if (
    isinstance(pad, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_IntArrayAttr4')) else
      _ods_ir.AttrBuilder.get('Tosa_IntArrayAttr4')(pad, context=_ods_context))
    attributes["acc_type"] = (acc_type if (
    isinstance(acc_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_490')) else
      _ods_ir.AttrBuilder.get('anonymous_490')(acc_type, context=_ods_context))
    if quantization_info is not None: attributes["quantization_info"] = (quantization_info if (
        isinstance(quantization_info, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tosa_UnaryOpQuantizationAttr')) else
          _ods_ir.AttrBuilder.get('Tosa_UnaryOpQuantizationAttr')(quantization_info, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def kernel(self):
    return self.operation.attributes["kernel"]

  @kernel.setter
  def kernel(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kernel"] = value

  @builtins.property
  def stride(self):
    return self.operation.attributes["stride"]

  @stride.setter
  def stride(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["stride"] = value

  @builtins.property
  def pad(self):
    return self.operation.attributes["pad"]

  @pad.setter
  def pad(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pad"] = value

  @builtins.property
  def acc_type(self):
    return self.operation.attributes["acc_type"]

  @acc_type.setter
  def acc_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["acc_type"] = value

  @builtins.property
  def quantization_info(self):
    if "quantization_info" not in self.operation.attributes:
      return None
    return self.operation.attributes["quantization_info"]

  @quantization_info.setter
  def quantization_info(self, value):
    if value is not None:
      self.operation.attributes["quantization_info"] = value
    elif "quantization_info" in self.operation.attributes:
      del self.operation.attributes["quantization_info"]

  @quantization_info.deleter
  def quantization_info(self):
    del self.operation.attributes["quantization_info"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def avg_pool2d(output, input, kernel, stride, pad, acc_type, *, quantization_info=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(AvgPool2dOp(output=output, input=input, kernel=kernel, stride=stride, pad=pad, acc_type=acc_type, quantization_info=quantization_info, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class BitwiseAndOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.bitwise_and"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input1))
    operands.append(_get_op_result_or_value(input2))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input1(self):
    return self.operation.operands[0]

  @builtins.property
  def input2(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def bitwise_and(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(BitwiseAndOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class BitwiseNotOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.bitwise_not"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input1))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input1(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def bitwise_not(output, input1, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(BitwiseNotOp(output=output, input1=input1, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class BitwiseOrOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.bitwise_or"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input1))
    operands.append(_get_op_result_or_value(input2))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input1(self):
    return self.operation.operands[0]

  @builtins.property
  def input2(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def bitwise_or(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(BitwiseOrOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class BitwiseXorOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.bitwise_xor"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input1))
    operands.append(_get_op_result_or_value(input2))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input1(self):
    return self.operation.operands[0]

  @builtins.property
  def input2(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def bitwise_xor(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(BitwiseXorOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class CastOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.cast"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def cast(output, input, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(CastOp(output=output, input=input, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class CeilOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.ceil"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input1))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input1(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def ceil(output, input1, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(CeilOp(output=output, input1=input1, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ClampOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.clamp"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, min_int, max_int, min_fp, max_fp, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["min_int"] = (min_int if (
    isinstance(min_int, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(min_int, context=_ods_context))
    attributes["max_int"] = (max_int if (
    isinstance(max_int, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(max_int, context=_ods_context))
    attributes["min_fp"] = (min_fp if (
    isinstance(min_fp, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_FloatAttr')) else
      _ods_ir.AttrBuilder.get('Tosa_FloatAttr')(min_fp, context=_ods_context))
    attributes["max_fp"] = (max_fp if (
    isinstance(max_fp, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_FloatAttr')) else
      _ods_ir.AttrBuilder.get('Tosa_FloatAttr')(max_fp, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def min_int(self):
    return self.operation.attributes["min_int"]

  @min_int.setter
  def min_int(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["min_int"] = value

  @builtins.property
  def max_int(self):
    return self.operation.attributes["max_int"]

  @max_int.setter
  def max_int(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["max_int"] = value

  @builtins.property
  def min_fp(self):
    return self.operation.attributes["min_fp"]

  @min_fp.setter
  def min_fp(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["min_fp"] = value

  @builtins.property
  def max_fp(self):
    return self.operation.attributes["max_fp"]

  @max_fp.setter
  def max_fp(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["max_fp"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def clamp(output, input, min_int, max_int, min_fp, max_fp, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ClampOp(output=output, input=input, min_int=min_int, max_int=max_int, min_fp=min_fp, max_fp=max_fp, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ClzOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.clz"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input1))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input1(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def clz(output, input1, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ClzOp(output=output, input1=input1, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ConcatOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.concat"

  _ODS_REGIONS = (0, True)

  def __init__(self, input1, axis, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(input1))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    isinstance(axis, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(axis, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input1(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def concat(input1, axis, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ConcatOp(input1=input1, axis=axis, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ConstOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.const"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ElementsAttr')) else
      _ods_ir.AttrBuilder.get('ElementsAttr')(value, context=_ods_context))
    _ods_result_type_source_attr = attributes["value"]
    _ods_derived_result_type = (
        _ods_ir.TypeAttr(_ods_result_type_source_attr).value
        if _ods_ir.TypeAttr.isinstance(_ods_result_type_source_attr) else
        _ods_result_type_source_attr.type)
    results.extend([_ods_derived_result_type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def value(self):
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def const(value, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ConstOp(value=value, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class Conv2DOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.conv2d"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, weight, bias, pad, stride, dilation, *, quantization_info=None, local_bound=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(weight))
    operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["pad"] = (pad if (
    isinstance(pad, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_IntArrayAttr4')) else
      _ods_ir.AttrBuilder.get('Tosa_IntArrayAttr4')(pad, context=_ods_context))
    attributes["stride"] = (stride if (
    isinstance(stride, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_IntArrayAttr2')) else
      _ods_ir.AttrBuilder.get('Tosa_IntArrayAttr2')(stride, context=_ods_context))
    attributes["dilation"] = (dilation if (
    isinstance(dilation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_IntArrayAttr2')) else
      _ods_ir.AttrBuilder.get('Tosa_IntArrayAttr2')(dilation, context=_ods_context))
    if quantization_info is not None: attributes["quantization_info"] = (quantization_info if (
        isinstance(quantization_info, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tosa_ConvOpQuantizationAttr')) else
          _ods_ir.AttrBuilder.get('Tosa_ConvOpQuantizationAttr')(quantization_info, context=_ods_context))
    if local_bound is not None: attributes["local_bound"] = (local_bound if (
        isinstance(local_bound, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(local_bound, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def pad(self):
    return self.operation.attributes["pad"]

  @pad.setter
  def pad(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pad"] = value

  @builtins.property
  def stride(self):
    return self.operation.attributes["stride"]

  @stride.setter
  def stride(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["stride"] = value

  @builtins.property
  def dilation(self):
    return self.operation.attributes["dilation"]

  @dilation.setter
  def dilation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dilation"] = value

  @builtins.property
  def quantization_info(self):
    if "quantization_info" not in self.operation.attributes:
      return None
    return self.operation.attributes["quantization_info"]

  @quantization_info.setter
  def quantization_info(self, value):
    if value is not None:
      self.operation.attributes["quantization_info"] = value
    elif "quantization_info" in self.operation.attributes:
      del self.operation.attributes["quantization_info"]

  @quantization_info.deleter
  def quantization_info(self):
    del self.operation.attributes["quantization_info"]

  @builtins.property
  def local_bound(self):
    if "local_bound" not in self.operation.attributes:
      return None
    return self.operation.attributes["local_bound"]

  @local_bound.setter
  def local_bound(self, value):
    if value is not None:
      self.operation.attributes["local_bound"] = value
    elif "local_bound" in self.operation.attributes:
      del self.operation.attributes["local_bound"]

  @local_bound.deleter
  def local_bound(self):
    del self.operation.attributes["local_bound"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def conv2d(output, input, weight, bias, pad, stride, dilation, *, quantization_info=None, local_bound=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(Conv2DOp(output=output, input=input, weight=weight, bias=bias, pad=pad, stride=stride, dilation=dilation, quantization_info=quantization_info, local_bound=local_bound, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class Conv3DOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.conv3d"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, weight, bias, pad, stride, dilation, *, quantization_info=None, local_bound=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(weight))
    operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["pad"] = (pad if (
    isinstance(pad, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_IntArrayAttr6')) else
      _ods_ir.AttrBuilder.get('Tosa_IntArrayAttr6')(pad, context=_ods_context))
    attributes["stride"] = (stride if (
    isinstance(stride, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_IntArrayAttr3')) else
      _ods_ir.AttrBuilder.get('Tosa_IntArrayAttr3')(stride, context=_ods_context))
    attributes["dilation"] = (dilation if (
    isinstance(dilation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_IntArrayAttr3')) else
      _ods_ir.AttrBuilder.get('Tosa_IntArrayAttr3')(dilation, context=_ods_context))
    if quantization_info is not None: attributes["quantization_info"] = (quantization_info if (
        isinstance(quantization_info, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tosa_ConvOpQuantizationAttr')) else
          _ods_ir.AttrBuilder.get('Tosa_ConvOpQuantizationAttr')(quantization_info, context=_ods_context))
    if local_bound is not None: attributes["local_bound"] = (local_bound if (
        isinstance(local_bound, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(local_bound, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def pad(self):
    return self.operation.attributes["pad"]

  @pad.setter
  def pad(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pad"] = value

  @builtins.property
  def stride(self):
    return self.operation.attributes["stride"]

  @stride.setter
  def stride(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["stride"] = value

  @builtins.property
  def dilation(self):
    return self.operation.attributes["dilation"]

  @dilation.setter
  def dilation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dilation"] = value

  @builtins.property
  def quantization_info(self):
    if "quantization_info" not in self.operation.attributes:
      return None
    return self.operation.attributes["quantization_info"]

  @quantization_info.setter
  def quantization_info(self, value):
    if value is not None:
      self.operation.attributes["quantization_info"] = value
    elif "quantization_info" in self.operation.attributes:
      del self.operation.attributes["quantization_info"]

  @quantization_info.deleter
  def quantization_info(self):
    del self.operation.attributes["quantization_info"]

  @builtins.property
  def local_bound(self):
    if "local_bound" not in self.operation.attributes:
      return None
    return self.operation.attributes["local_bound"]

  @local_bound.setter
  def local_bound(self, value):
    if value is not None:
      self.operation.attributes["local_bound"] = value
    elif "local_bound" in self.operation.attributes:
      del self.operation.attributes["local_bound"]

  @local_bound.deleter
  def local_bound(self):
    del self.operation.attributes["local_bound"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def conv3d(output, input, weight, bias, pad, stride, dilation, *, quantization_info=None, local_bound=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(Conv3DOp(output=output, input=input, weight=weight, bias=bias, pad=pad, stride=stride, dilation=dilation, quantization_info=quantization_info, local_bound=local_bound, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class CosOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.cos"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def cos(output, input, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(CosOp(output=output, input=input, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class CustomOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.custom"

  _ODS_REGIONS = (0, True)

  def __init__(self, outputs, operator_name, domain_name, implementation_attrs, inputs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["operator_name"] = (operator_name if (
    isinstance(operator_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(operator_name, context=_ods_context))
    attributes["domain_name"] = (domain_name if (
    isinstance(domain_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(domain_name, context=_ods_context))
    attributes["implementation_attrs"] = (implementation_attrs if (
    isinstance(implementation_attrs, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(implementation_attrs, context=_ods_context))
    results.extend(outputs)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def operator_name(self):
    return self.operation.attributes["operator_name"]

  @operator_name.setter
  def operator_name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["operator_name"] = value

  @builtins.property
  def domain_name(self):
    return self.operation.attributes["domain_name"]

  @domain_name.setter
  def domain_name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["domain_name"] = value

  @builtins.property
  def implementation_attrs(self):
    return self.operation.attributes["implementation_attrs"]

  @implementation_attrs.setter
  def implementation_attrs(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["implementation_attrs"] = value

  @builtins.property
  def outputs(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def custom(outputs, operator_name, domain_name, implementation_attrs, inputs, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(CustomOp(outputs=outputs, operator_name=operator_name, domain_name=domain_name, implementation_attrs=implementation_attrs, inputs=inputs, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class DepthwiseConv2DOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.depthwise_conv2d"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, weight, bias, pad, stride, dilation, *, quantization_info=None, local_bound=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(weight))
    operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["pad"] = (pad if (
    isinstance(pad, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_IntArrayAttr4')) else
      _ods_ir.AttrBuilder.get('Tosa_IntArrayAttr4')(pad, context=_ods_context))
    attributes["stride"] = (stride if (
    isinstance(stride, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_IntArrayAttr2')) else
      _ods_ir.AttrBuilder.get('Tosa_IntArrayAttr2')(stride, context=_ods_context))
    attributes["dilation"] = (dilation if (
    isinstance(dilation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_IntArrayAttr2')) else
      _ods_ir.AttrBuilder.get('Tosa_IntArrayAttr2')(dilation, context=_ods_context))
    if quantization_info is not None: attributes["quantization_info"] = (quantization_info if (
        isinstance(quantization_info, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tosa_ConvOpQuantizationAttr')) else
          _ods_ir.AttrBuilder.get('Tosa_ConvOpQuantizationAttr')(quantization_info, context=_ods_context))
    if local_bound is not None: attributes["local_bound"] = (local_bound if (
        isinstance(local_bound, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(local_bound, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def pad(self):
    return self.operation.attributes["pad"]

  @pad.setter
  def pad(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pad"] = value

  @builtins.property
  def stride(self):
    return self.operation.attributes["stride"]

  @stride.setter
  def stride(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["stride"] = value

  @builtins.property
  def dilation(self):
    return self.operation.attributes["dilation"]

  @dilation.setter
  def dilation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dilation"] = value

  @builtins.property
  def quantization_info(self):
    if "quantization_info" not in self.operation.attributes:
      return None
    return self.operation.attributes["quantization_info"]

  @quantization_info.setter
  def quantization_info(self, value):
    if value is not None:
      self.operation.attributes["quantization_info"] = value
    elif "quantization_info" in self.operation.attributes:
      del self.operation.attributes["quantization_info"]

  @quantization_info.deleter
  def quantization_info(self):
    del self.operation.attributes["quantization_info"]

  @builtins.property
  def local_bound(self):
    if "local_bound" not in self.operation.attributes:
      return None
    return self.operation.attributes["local_bound"]

  @local_bound.setter
  def local_bound(self, value):
    if value is not None:
      self.operation.attributes["local_bound"] = value
    elif "local_bound" in self.operation.attributes:
      del self.operation.attributes["local_bound"]

  @local_bound.deleter
  def local_bound(self):
    del self.operation.attributes["local_bound"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def depthwise_conv2d(output, input, weight, bias, pad, stride, dilation, *, quantization_info=None, local_bound=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(DepthwiseConv2DOp(output=output, input=input, weight=weight, bias=bias, pad=pad, stride=stride, dilation=dilation, quantization_info=quantization_info, local_bound=local_bound, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class EqualOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.equal"

  _ODS_REGIONS = (0, True)

  def __init__(self, input1, input2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input1))
    operands.append(_get_op_result_or_value(input2))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input1(self):
    return self.operation.operands[0]

  @builtins.property
  def input2(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def equal(input1, input2, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(EqualOp(input1=input1, input2=input2, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ErfOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.erf"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def erf(output, input, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ErfOp(output=output, input=input, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ExpOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.exp"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input1))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input1(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def exp(output, input1, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ExpOp(output=output, input1=input1, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class FFT2dOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.fft2d"

  _ODS_REGIONS = (0, True)

  def __init__(self, output_real, output_imag, input_real, input_imag, inverse, *, local_bound=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input_real))
    operands.append(_get_op_result_or_value(input_imag))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["inverse"] = (inverse if (
    isinstance(inverse, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(inverse, context=_ods_context))
    if local_bound is not None: attributes["local_bound"] = (local_bound if (
        isinstance(local_bound, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(local_bound, context=_ods_context))
    results.append(output_real)
    results.append(output_imag)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input_real(self):
    return self.operation.operands[0]

  @builtins.property
  def input_imag(self):
    return self.operation.operands[1]

  @builtins.property
  def inverse(self):
    return self.operation.attributes["inverse"]

  @inverse.setter
  def inverse(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["inverse"] = value

  @builtins.property
  def local_bound(self):
    if "local_bound" not in self.operation.attributes:
      return None
    return self.operation.attributes["local_bound"]

  @local_bound.setter
  def local_bound(self, value):
    if value is not None:
      self.operation.attributes["local_bound"] = value
    elif "local_bound" in self.operation.attributes:
      del self.operation.attributes["local_bound"]

  @local_bound.deleter
  def local_bound(self):
    del self.operation.attributes["local_bound"]

  @builtins.property
  def output_real(self):
    return self.operation.results[0]

  @builtins.property
  def output_imag(self):
    return self.operation.results[1]

def fft2d(output_real, output_imag, input_real, input_imag, inverse, *, local_bound=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return _get_op_result_or_op_results(FFT2dOp(output_real=output_real, output_imag=output_imag, input_real=input_real, input_imag=input_imag, inverse=inverse, local_bound=local_bound, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class FloorOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.floor"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input1))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input1(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def floor(output, input1, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(FloorOp(output=output, input1=input1, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class FullyConnectedOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.fully_connected"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, weight, bias, *, quantization_info=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(weight))
    operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    if quantization_info is not None: attributes["quantization_info"] = (quantization_info if (
        isinstance(quantization_info, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tosa_ConvOpQuantizationAttr')) else
          _ods_ir.AttrBuilder.get('Tosa_ConvOpQuantizationAttr')(quantization_info, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def quantization_info(self):
    if "quantization_info" not in self.operation.attributes:
      return None
    return self.operation.attributes["quantization_info"]

  @quantization_info.setter
  def quantization_info(self, value):
    if value is not None:
      self.operation.attributes["quantization_info"] = value
    elif "quantization_info" in self.operation.attributes:
      del self.operation.attributes["quantization_info"]

  @quantization_info.deleter
  def quantization_info(self):
    del self.operation.attributes["quantization_info"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def fully_connected(output, input, weight, bias, *, quantization_info=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(FullyConnectedOp(output=output, input=input, weight=weight, bias=bias, quantization_info=quantization_info, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class GatherOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.gather"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, values, indices, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(values))
    operands.append(_get_op_result_or_value(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def values(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def gather(output, values, indices, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(GatherOp(output=output, values=values, indices=indices, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class GreaterEqualOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.greater_equal"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input1))
    operands.append(_get_op_result_or_value(input2))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input1(self):
    return self.operation.operands[0]

  @builtins.property
  def input2(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def greater_equal(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(GreaterEqualOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class GreaterOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.greater"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input1))
    operands.append(_get_op_result_or_value(input2))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input1(self):
    return self.operation.operands[0]

  @builtins.property
  def input2(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def greater(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(GreaterOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class IdentityOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.identity"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input1))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input1(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def identity(output, input1, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(IdentityOp(output=output, input1=input1, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class IfOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.cond_if"

  _ODS_REGIONS = (2, True)

  def __init__(self, output, cond, inputs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(cond))
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def cond(self):
    return self.operation.operands[0]

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def output(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def then_branch(self):
    return self.regions[0]

  @builtins.property
  def else_branch(self):
    return self.regions[1]

def cond_if(output, cond, inputs, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(IfOp(output=output, cond=cond, inputs=inputs, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class IntDivOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.int_div"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input1))
    operands.append(_get_op_result_or_value(input2))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input1(self):
    return self.operation.operands[0]

  @builtins.property
  def input2(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def int_div(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(IntDivOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class LogOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.log"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input1))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input1(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def log(output, input1, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(LogOp(output=output, input1=input1, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class LogicalAndOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.logical_and"

  _ODS_REGIONS = (0, True)

  def __init__(self, z, input1, input2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input1))
    operands.append(_get_op_result_or_value(input2))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(z)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input1(self):
    return self.operation.operands[0]

  @builtins.property
  def input2(self):
    return self.operation.operands[1]

  @builtins.property
  def z(self):
    return self.operation.results[0]

def logical_and(z, input1, input2, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(LogicalAndOp(z=z, input1=input1, input2=input2, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class LogicalLeftShiftOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.logical_left_shift"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input1))
    operands.append(_get_op_result_or_value(input2))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input1(self):
    return self.operation.operands[0]

  @builtins.property
  def input2(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def logical_left_shift(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(LogicalLeftShiftOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class LogicalNotOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.logical_not"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input1))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input1(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def logical_not(output, input1, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(LogicalNotOp(output=output, input1=input1, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class LogicalOrOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.logical_or"

  _ODS_REGIONS = (0, True)

  def __init__(self, z, input1, input2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input1))
    operands.append(_get_op_result_or_value(input2))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(z)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input1(self):
    return self.operation.operands[0]

  @builtins.property
  def input2(self):
    return self.operation.operands[1]

  @builtins.property
  def z(self):
    return self.operation.results[0]

def logical_or(z, input1, input2, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(LogicalOrOp(z=z, input1=input1, input2=input2, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class LogicalRightShiftOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.logical_right_shift"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input1))
    operands.append(_get_op_result_or_value(input2))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input1(self):
    return self.operation.operands[0]

  @builtins.property
  def input2(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def logical_right_shift(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(LogicalRightShiftOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class LogicalXorOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.logical_xor"

  _ODS_REGIONS = (0, True)

  def __init__(self, z, input1, input2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input1))
    operands.append(_get_op_result_or_value(input2))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(z)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input1(self):
    return self.operation.operands[0]

  @builtins.property
  def input2(self):
    return self.operation.operands[1]

  @builtins.property
  def z(self):
    return self.operation.results[0]

def logical_xor(z, input1, input2, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(LogicalXorOp(z=z, input1=input1, input2=input2, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class MatMulOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.matmul"

  _ODS_REGIONS = (0, True)

  def __init__(self, c, a, b, *, quantization_info=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(a))
    operands.append(_get_op_result_or_value(b))
    _ods_context = _ods_get_default_loc_context(loc)
    if quantization_info is not None: attributes["quantization_info"] = (quantization_info if (
        isinstance(quantization_info, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tosa_MatMulOpQuantizationAttr')) else
          _ods_ir.AttrBuilder.get('Tosa_MatMulOpQuantizationAttr')(quantization_info, context=_ods_context))
    results.append(c)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def quantization_info(self):
    if "quantization_info" not in self.operation.attributes:
      return None
    return self.operation.attributes["quantization_info"]

  @quantization_info.setter
  def quantization_info(self, value):
    if value is not None:
      self.operation.attributes["quantization_info"] = value
    elif "quantization_info" in self.operation.attributes:
      del self.operation.attributes["quantization_info"]

  @quantization_info.deleter
  def quantization_info(self):
    del self.operation.attributes["quantization_info"]

  @builtins.property
  def c(self):
    return self.operation.results[0]

def matmul(c, a, b, *, quantization_info=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(MatMulOp(c=c, a=a, b=b, quantization_info=quantization_info, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class MaxPool2dOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.max_pool2d"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, kernel, stride, pad, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["kernel"] = (kernel if (
    isinstance(kernel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_IntArrayAttr2')) else
      _ods_ir.AttrBuilder.get('Tosa_IntArrayAttr2')(kernel, context=_ods_context))
    attributes["stride"] = (stride if (
    isinstance(stride, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_IntArrayAttr2')) else
      _ods_ir.AttrBuilder.get('Tosa_IntArrayAttr2')(stride, context=_ods_context))
    attributes["pad"] = (pad if (
    isinstance(pad, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_IntArrayAttr4')) else
      _ods_ir.AttrBuilder.get('Tosa_IntArrayAttr4')(pad, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def kernel(self):
    return self.operation.attributes["kernel"]

  @kernel.setter
  def kernel(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kernel"] = value

  @builtins.property
  def stride(self):
    return self.operation.attributes["stride"]

  @stride.setter
  def stride(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["stride"] = value

  @builtins.property
  def pad(self):
    return self.operation.attributes["pad"]

  @pad.setter
  def pad(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pad"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def max_pool2d(output, input, kernel, stride, pad, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(MaxPool2dOp(output=output, input=input, kernel=kernel, stride=stride, pad=pad, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class MaximumOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.maximum"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input1))
    operands.append(_get_op_result_or_value(input2))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input1(self):
    return self.operation.operands[0]

  @builtins.property
  def input2(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def maximum(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(MaximumOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class MinimumOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.minimum"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input1))
    operands.append(_get_op_result_or_value(input2))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input1(self):
    return self.operation.operands[0]

  @builtins.property
  def input2(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def minimum(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(MinimumOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class MulOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.mul"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, shift, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input1))
    operands.append(_get_op_result_or_value(input2))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["shift"] = (shift if (
    isinstance(shift, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I8Attr')) else
      _ods_ir.AttrBuilder.get('I8Attr')(shift, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input1(self):
    return self.operation.operands[0]

  @builtins.property
  def input2(self):
    return self.operation.operands[1]

  @builtins.property
  def shift(self):
    return self.operation.attributes["shift"]

  @shift.setter
  def shift(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["shift"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def mul(output, input1, input2, shift, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(MulOp(output=output, input1=input1, input2=input2, shift=shift, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class NegateOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.negate"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, *, quantization_info=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input1))
    _ods_context = _ods_get_default_loc_context(loc)
    if quantization_info is not None: attributes["quantization_info"] = (quantization_info if (
        isinstance(quantization_info, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tosa_UnaryOpQuantizationAttr')) else
          _ods_ir.AttrBuilder.get('Tosa_UnaryOpQuantizationAttr')(quantization_info, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input1(self):
    return self.operation.operands[0]

  @builtins.property
  def quantization_info(self):
    if "quantization_info" not in self.operation.attributes:
      return None
    return self.operation.attributes["quantization_info"]

  @quantization_info.setter
  def quantization_info(self, value):
    if value is not None:
      self.operation.attributes["quantization_info"] = value
    elif "quantization_info" in self.operation.attributes:
      del self.operation.attributes["quantization_info"]

  @quantization_info.deleter
  def quantization_info(self):
    del self.operation.attributes["quantization_info"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def negate(output, input1, *, quantization_info=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(NegateOp(output=output, input1=input1, quantization_info=quantization_info, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class PadOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.pad"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, padding, *, pad_const=None, quantization_info=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input1))
    operands.append(_get_op_result_or_value(padding))
    if pad_const is not None: operands.append(_get_op_result_or_value(pad_const))
    _ods_context = _ods_get_default_loc_context(loc)
    if quantization_info is not None: attributes["quantization_info"] = (quantization_info if (
        isinstance(quantization_info, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tosa_PadOpQuantizationAttr')) else
          _ods_ir.AttrBuilder.get('Tosa_PadOpQuantizationAttr')(quantization_info, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input1(self):
    return self.operation.operands[0]

  @builtins.property
  def padding(self):
    return self.operation.operands[1]

  @builtins.property
  def pad_const(self):
    return None if len(self.operation.operands) < 3 else self.operation.operands[2]

  @builtins.property
  def quantization_info(self):
    if "quantization_info" not in self.operation.attributes:
      return None
    return self.operation.attributes["quantization_info"]

  @quantization_info.setter
  def quantization_info(self, value):
    if value is not None:
      self.operation.attributes["quantization_info"] = value
    elif "quantization_info" in self.operation.attributes:
      del self.operation.attributes["quantization_info"]

  @quantization_info.deleter
  def quantization_info(self):
    del self.operation.attributes["quantization_info"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def pad(output, input1, padding, *, pad_const=None, quantization_info=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(PadOp(output=output, input1=input1, padding=padding, pad_const=pad_const, quantization_info=quantization_info, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class PowOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.pow"

  _ODS_REGIONS = (0, True)

  def __init__(self, z, input1, input2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input1))
    operands.append(_get_op_result_or_value(input2))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(z)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input1(self):
    return self.operation.operands[0]

  @builtins.property
  def input2(self):
    return self.operation.operands[1]

  @builtins.property
  def z(self):
    return self.operation.results[0]

def pow(z, input1, input2, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(PowOp(z=z, input1=input1, input2=input2, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class RFFT2dOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.rfft2d"

  _ODS_REGIONS = (0, True)

  def __init__(self, output_real, output_imag, input, *, local_bound=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if local_bound is not None: attributes["local_bound"] = (local_bound if (
        isinstance(local_bound, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(local_bound, context=_ods_context))
    results.append(output_real)
    results.append(output_imag)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def local_bound(self):
    if "local_bound" not in self.operation.attributes:
      return None
    return self.operation.attributes["local_bound"]

  @local_bound.setter
  def local_bound(self, value):
    if value is not None:
      self.operation.attributes["local_bound"] = value
    elif "local_bound" in self.operation.attributes:
      del self.operation.attributes["local_bound"]

  @local_bound.deleter
  def local_bound(self):
    del self.operation.attributes["local_bound"]

  @builtins.property
  def output_real(self):
    return self.operation.results[0]

  @builtins.property
  def output_imag(self):
    return self.operation.results[1]

def rfft2d(output_real, output_imag, input, *, local_bound=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return _get_op_result_or_op_results(RFFT2dOp(output_real=output_real, output_imag=output_imag, input=input, local_bound=local_bound, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ReciprocalOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.reciprocal"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input1))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input1(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def reciprocal(output, input1, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ReciprocalOp(output=output, input1=input1, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ReduceAllOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.reduce_all"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, axis, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    isinstance(axis, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(axis, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def reduce_all(input, axis, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ReduceAllOp(input=input, axis=axis, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ReduceAnyOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.reduce_any"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, axis, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    isinstance(axis, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(axis, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def reduce_any(input, axis, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ReduceAnyOp(input=input, axis=axis, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ReduceMaxOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.reduce_max"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, axis, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    isinstance(axis, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(axis, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def reduce_max(input, axis, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ReduceMaxOp(input=input, axis=axis, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ReduceMinOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.reduce_min"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, axis, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    isinstance(axis, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(axis, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def reduce_min(input, axis, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ReduceMinOp(input=input, axis=axis, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ReduceProdOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.reduce_prod"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, axis, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    isinstance(axis, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(axis, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def reduce_prod(input, axis, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ReduceProdOp(input=input, axis=axis, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ReduceSumOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.reduce_sum"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, axis, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    isinstance(axis, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(axis, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def reduce_sum(input, axis, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ReduceSumOp(input=input, axis=axis, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class RescaleOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.rescale"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, input_zp, output_zp, multiplier, shift, scale32, double_round, per_channel, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["input_zp"] = (input_zp if (
    isinstance(input_zp, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(input_zp, context=_ods_context))
    attributes["output_zp"] = (output_zp if (
    isinstance(output_zp, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(output_zp, context=_ods_context))
    attributes["multiplier"] = (multiplier if (
    isinstance(multiplier, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI32ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI32ArrayAttr')(multiplier, context=_ods_context))
    attributes["shift"] = (shift if (
    isinstance(shift, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI8ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI8ArrayAttr')(shift, context=_ods_context))
    attributes["scale32"] = (scale32 if (
    isinstance(scale32, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(scale32, context=_ods_context))
    attributes["double_round"] = (double_round if (
    isinstance(double_round, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(double_round, context=_ods_context))
    attributes["per_channel"] = (per_channel if (
    isinstance(per_channel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(per_channel, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def input_zp(self):
    return self.operation.attributes["input_zp"]

  @input_zp.setter
  def input_zp(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["input_zp"] = value

  @builtins.property
  def output_zp(self):
    return self.operation.attributes["output_zp"]

  @output_zp.setter
  def output_zp(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["output_zp"] = value

  @builtins.property
  def multiplier(self):
    return self.operation.attributes["multiplier"]

  @multiplier.setter
  def multiplier(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["multiplier"] = value

  @builtins.property
  def shift(self):
    return self.operation.attributes["shift"]

  @shift.setter
  def shift(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["shift"] = value

  @builtins.property
  def scale32(self):
    return self.operation.attributes["scale32"]

  @scale32.setter
  def scale32(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale32"] = value

  @builtins.property
  def double_round(self):
    return self.operation.attributes["double_round"]

  @double_round.setter
  def double_round(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["double_round"] = value

  @builtins.property
  def per_channel(self):
    return self.operation.attributes["per_channel"]

  @per_channel.setter
  def per_channel(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["per_channel"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def rescale(output, input, input_zp, output_zp, multiplier, shift, scale32, double_round, per_channel, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(RescaleOp(output=output, input=input, input_zp=input_zp, output_zp=output_zp, multiplier=multiplier, shift=shift, scale32=scale32, double_round=double_round, per_channel=per_channel, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ReshapeOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.reshape"

  _ODS_REGIONS = (0, True)

  def __init__(self, input1, new_shape, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input1))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["new_shape"] = (new_shape if (
    isinstance(new_shape, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(new_shape, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input1(self):
    return self.operation.operands[0]

  @builtins.property
  def new_shape(self):
    return self.operation.attributes["new_shape"]

  @new_shape.setter
  def new_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["new_shape"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def reshape(input1, new_shape, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ReshapeOp(input1=input1, new_shape=new_shape, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ResizeOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.resize"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, scale, offset, border, mode, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scale"] = (scale if (
    isinstance(scale, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_IntArrayAttr4')) else
      _ods_ir.AttrBuilder.get('Tosa_IntArrayAttr4')(scale, context=_ods_context))
    attributes["offset"] = (offset if (
    isinstance(offset, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_IntArrayAttr2')) else
      _ods_ir.AttrBuilder.get('Tosa_IntArrayAttr2')(offset, context=_ods_context))
    attributes["border"] = (border if (
    isinstance(border, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_IntArrayAttr2')) else
      _ods_ir.AttrBuilder.get('Tosa_IntArrayAttr2')(border, context=_ods_context))
    attributes["mode"] = (mode if (
    isinstance(mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_ResizeTypeAttr')) else
      _ods_ir.AttrBuilder.get('Tosa_ResizeTypeAttr')(mode, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def scale(self):
    return self.operation.attributes["scale"]

  @scale.setter
  def scale(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale"] = value

  @builtins.property
  def offset(self):
    return self.operation.attributes["offset"]

  @offset.setter
  def offset(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["offset"] = value

  @builtins.property
  def border(self):
    return self.operation.attributes["border"]

  @border.setter
  def border(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["border"] = value

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def resize(output, input, scale, offset, border, mode, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ResizeOp(output=output, input=input, scale=scale, offset=offset, border=border, mode=mode, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ReverseOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.reverse"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, axis, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    isinstance(axis, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(axis, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def reverse(output, input, axis, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ReverseOp(output=output, input=input, axis=axis, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class RsqrtOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.rsqrt"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input1))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input1(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def rsqrt(output, input1, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(RsqrtOp(output=output, input1=input1, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ScatterOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.scatter"

  _ODS_REGIONS = (0, True)

  def __init__(self, values_out, values_in, indices, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(values_in))
    operands.append(_get_op_result_or_value(indices))
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(values_out)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def values_in(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def input(self):
    return self.operation.operands[2]

  @builtins.property
  def values_out(self):
    return self.operation.results[0]

def scatter(values_out, values_in, indices, input, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ScatterOp(values_out=values_out, values_in=values_in, indices=indices, input=input, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class SelectOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.select"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, pred, on_true, on_false, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(pred))
    operands.append(_get_op_result_or_value(on_true))
    operands.append(_get_op_result_or_value(on_false))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def pred(self):
    return self.operation.operands[0]

  @builtins.property
  def on_true(self):
    return self.operation.operands[1]

  @builtins.property
  def on_false(self):
    return self.operation.operands[2]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def select(output, pred, on_true, on_false, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(SelectOp(output=output, pred=pred, on_true=on_true, on_false=on_false, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class SigmoidOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.sigmoid"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def sigmoid(output, input, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(SigmoidOp(output=output, input=input, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class SinOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.sin"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def sin(output, input, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(SinOp(output=output, input=input, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class SliceOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.slice"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, start, size, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["start"] = (start if (
    isinstance(start, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(start, context=_ods_context))
    attributes["size"] = (size if (
    isinstance(size, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(size, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def start(self):
    return self.operation.attributes["start"]

  @start.setter
  def start(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["start"] = value

  @builtins.property
  def size(self):
    return self.operation.attributes["size"]

  @size.setter
  def size(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["size"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def slice(output, input, start, size, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(SliceOp(output=output, input=input, start=start, size=size, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class SubOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.sub"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input1))
    operands.append(_get_op_result_or_value(input2))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input1(self):
    return self.operation.operands[0]

  @builtins.property
  def input2(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def sub(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(SubOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class TableOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.table"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, table, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(table))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def table(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def table(output, input, table, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(TableOp(output=output, input=input, table=table, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class TanhOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.tanh"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def tanh(output, input, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(TanhOp(output=output, input=input, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class TileOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.tile"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, multiples, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input1))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["multiples"] = (multiples if (
    isinstance(multiples, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(multiples, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input1(self):
    return self.operation.operands[0]

  @builtins.property
  def multiples(self):
    return self.operation.attributes["multiples"]

  @multiples.setter
  def multiples(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["multiples"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

def tile(output, input1, multiples, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(TileOp(output=output, input1=input1, multiples=multiples, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class TransposeConv2DOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.transpose_conv2d"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, filter, bias, out_pad, stride, out_shape, *, quantization_info=None, local_bound=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(filter))
    operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["out_pad"] = (out_pad if (
    isinstance(out_pad, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_IntArrayAttr4')) else
      _ods_ir.AttrBuilder.get('Tosa_IntArrayAttr4')(out_pad, context=_ods_context))
    attributes["stride"] = (stride if (
    isinstance(stride, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_IntArrayAttr2')) else
      _ods_ir.AttrBuilder.get('Tosa_IntArrayAttr2')(stride, context=_ods_context))
    attributes["out_shape"] = (out_shape if (
    isinstance(out_shape, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tosa_IntArrayAttrUpto4')) else
      _ods_ir.AttrBuilder.get('Tosa_IntArrayAttrUpto4')(out_shape, context=_ods_context))
    if quantization_info is not None: attributes["quantization_info"] = (quantization_info if (
        isinstance(quantization_info, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tosa_ConvOpQuantizationAttr')) else
          _ods_ir.AttrBuilder.get('Tosa_ConvOpQuantizationAttr')(quantization_info, context=_ods_context))
    if local_bound is not None: attributes["local_bound"] = (local_bound if (
        isinstance(local_bound, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(local_bound, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def filter(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def out_pad(self):
    return self.operation.attributes["out_pad"]

  @out_pad.setter
  def out_pad(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["out_pad"] = value

  @builtins.property
  def stride(self):
    return self.operation.attributes["stride"]

  @stride.setter
  def stride(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["stride"] = value

  @builtins.property
  def out_shape(self):
    return self.operation.attributes["out_shape"]

  @out_shape.setter
  def out_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["out_shape"] = value

  @builtins.property
  def quantization_info(self):
    if "quantization_info" not in self.operation.attributes:
      return None
    return self.operation.attributes["quantization_info"]

  @quantization_info.setter
  def quantization_info(self, value):
    if value is not None:
      self.operation.attributes["quantization_info"] = value
    elif "quantization_info" in self.operation.attributes:
      del self.operation.attributes["quantization_info"]

  @quantization_info.deleter
  def quantization_info(self):
    del self.operation.attributes["quantization_info"]

  @builtins.property
  def local_bound(self):
    if "local_bound" not in self.operation.attributes:
      return None
    return self.operation.attributes["local_bound"]

  @local_bound.setter
  def local_bound(self, value):
    if value is not None:
      self.operation.attributes["local_bound"] = value
    elif "local_bound" in self.operation.attributes:
      del self.operation.attributes["local_bound"]

  @local_bound.deleter
  def local_bound(self):
    del self.operation.attributes["local_bound"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def transpose_conv2d(output, input, filter, bias, out_pad, stride, out_shape, *, quantization_info=None, local_bound=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(TransposeConv2DOp(output=output, input=input, filter=filter, bias=bias, out_pad=out_pad, stride=stride, out_shape=out_shape, quantization_info=quantization_info, local_bound=local_bound, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class TransposeOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.transpose"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, perms, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input1))
    operands.append(_get_op_result_or_value(perms))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input1(self):
    return self.operation.operands[0]

  @builtins.property
  def perms(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

def transpose(output, input1, perms, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(TransposeOp(output=output, input1=input1, perms=perms, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class VariableOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.variable"

  _ODS_REGIONS = (0, True)

  def __init__(self, name, type_, *, initial_value=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["name"] = (name if (
    isinstance(name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(name, context=_ods_context))
    attributes["type"] = (type_ if (
    isinstance(type_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(type_, context=_ods_context))
    if initial_value is not None: attributes["initial_value"] = (initial_value if (
        isinstance(initial_value, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('AnyAttr')) else
          _ods_ir.AttrBuilder.get('AnyAttr')(initial_value, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def name(self):
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

  @builtins.property
  def type_(self):
    return self.operation.attributes["type"]

  @type_.setter
  def type_(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["type"] = value

  @builtins.property
  def initial_value(self):
    if "initial_value" not in self.operation.attributes:
      return None
    return self.operation.attributes["initial_value"]

  @initial_value.setter
  def initial_value(self, value):
    if value is not None:
      self.operation.attributes["initial_value"] = value
    elif "initial_value" in self.operation.attributes:
      del self.operation.attributes["initial_value"]

  @initial_value.deleter
  def initial_value(self):
    del self.operation.attributes["initial_value"]

def variable(name, type_, *, initial_value=None, loc=None, ip=None) -> _ods_ir.Operation:
  return _get_op_result_or_op_results(VariableOp(name=name, type_=type_, initial_value=initial_value, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class VariableReadOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.variable.read"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, name, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["name"] = (name if (
    isinstance(name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(name, context=_ods_context))
    results.append(value)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def name(self):
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

  @builtins.property
  def value(self):
    return self.operation.results[0]

def variable_read(value, name, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(VariableReadOp(value=value, name=name, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class VariableWriteOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.variable.write"

  _ODS_REGIONS = (0, True)

  def __init__(self, name, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(value))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["name"] = (name if (
    isinstance(name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(name, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def name(self):
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

def variable_write(name, value, *, loc=None, ip=None) -> _ods_ir.Operation:
  return _get_op_result_or_op_results(VariableWriteOp(name=name, value=value, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class WhileOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.while_loop"

  _ODS_REGIONS = (2, True)

  def __init__(self, output, inputs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def output(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def cond(self):
    return self.regions[0]

  @builtins.property
  def body(self):
    return self.regions[1]

def while_loop(output, inputs, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(WhileOp(output=output, inputs=inputs, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class YieldOp(_ods_ir.OpView):
  OPERATION_NAME = "tosa.yield"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def yield_(inputs, *, loc=None, ip=None) -> _ods_ir.Operation:
  return _get_op_result_or_op_results(YieldOp(inputs=inputs, loc=loc, ip=ip))
