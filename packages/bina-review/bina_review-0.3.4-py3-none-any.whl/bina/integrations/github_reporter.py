# Copyright 2025-2026 Bonyad-Labs
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
import json
import requests
from typing import List, Dict, Any
from ..core.models import Finding

class GitHubReporter:
    def __init__(self, token: str, repository: str, pr_number: int):
        self.token = token
        self.repository = repository
        self.pr_number = pr_number
        self.api_url = f"https://api.github.com/repos/{repository}/issues/{pr_number}/comments"
        self.headers = {
            "Authorization": f"token {token}",
            "Accept": "application/vnd.github.v3+json"
        }

    def post_summary(self, findings: List[Finding], baseline_findings: List[Finding] = None):
        """Post or update a summary comment on the PR."""
        if baseline_findings is None:
            baseline_findings = []
        body = self._generate_markdown_summary(findings, baseline_findings)
        
        # 1. Check for existing comment
        existing_comment_id = self._find_existing_comment()
        
        if existing_comment_id:
            # Update
            url = f"https://api.github.com/repos/{self.repository}/issues/comments/{existing_comment_id}"
            resp = requests.patch(url, headers=self.headers, json={"body": body})
            if resp.status_code not in (200, 201):
                print(f"Failed to update comment: {resp.text}")
            else:
                print("Updated existing PR comment.")
        else:
            # Create
            resp = requests.post(self.api_url, headers=self.headers, json={"body": body})
            if resp.status_code not in (200, 201):
                 print(f"Failed to post comment: {resp.text}")
            else:
                 print("Posted new PR comment.")

    def _find_existing_comment(self) -> int:
        """Find comment ID that contains our signature."""
        try:
            resp = requests.get(self.api_url, headers=self.headers)
            if resp.status_code == 200:
                comments = resp.json()
                for comment in comments:
                    if "<!-- bina-review-summary -->" in comment.get("body", ""):
                        return comment["id"]
        except Exception as e:
            print(f"Error fetching comments: {e}")
        return None

    def _generate_markdown_summary(self, findings: List[Finding], baseline_findings: List[Finding]) -> str:
        new_count = len(findings)
        baseline_count = len(baseline_findings)
        total = new_count + baseline_count # Assuming findings argument is filtered NEW findings
        
        # If findings includes ALL, we need to know separation.
        # Typically argument `findings` passed here are the ones we want to report as NEW.
        
        icon = "✅" if new_count == 0 else "⚠️"
        
        md = [
            "<!-- bina-review-summary -->",
            f"## {icon} Bina Static Analysis Report",
            "",
            f"**{new_count} New Issues** | {baseline_count} Baseline Issues (Hidden)",
            ""
        ]
        
        if new_count > 0:
            md.append("| Severity | Rule | Location | Message |")
            md.append("|---|---|---|---|")
            
            # Sort by severity
            sorted_findings = sorted(findings, key=lambda x: x.severity.value if hasattr(x.severity, 'value') else str(x.severity))
            # Actually enum sorting depends on definition order usually or value.
            # Severity HIGH > MEDIUM > LOW.
            
            for f in sorted_findings:
                # GitHub allows limited path linking
                # file_link = f"[{f.file}:{f.line}](...)"
                # Getting correct blob link is hard without SHA, but file path is usually enough for display
                md.append(f"| {f.severity.value} | {f.rule_id} | `{f.file}:{f.line}` | {f.message} |")
        
        else:
            md.append("Great job! No new issues found.")
            
        md.append("\n_Generated by Bina Review")
        return "\n".join(md)
