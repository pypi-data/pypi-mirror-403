{"guide": {"name": "using-gradio-in-other-programming-languages", "category": "other-tutorials", "pretty_category": "Other Tutorials", "guide_index": null, "absolute_index": 97, "pretty_name": "Using Gradio In Other Programming Languages", "content": "# Using Gradio in Other Programming Languages\n\nThe core `gradio` library is a Python library. But you can also use `gradio` to create UIs around programs written in other languages, thanks to Python's ability to interface with external processes. Using Python's `subprocess` module, you can call programs written in C++, Rust, or virtually any other language, allowing `gradio` to become a flexible UI layer for non-Python applications.\n\nIn this post, we'll walk through how to integrate `gradio` with C++ and Rust, using Python's `subprocess` module to invoke code written in these languages. We'll also discuss how to use Gradio with R, which is even easier, thanks to the [reticulate](https://rstudio.github.io/reticulate/) R package, which makes it possible to install and import Python modules in R.\n\n## Using Gradio with C++\n\nLet\u2019s start with a simple example of integrating a C++ program into a Gradio app. Suppose we have the following C++ program that adds two numbers:\n\n```cpp\n// add.cpp\n#include <iostream>\n\nint main() {\n    double a, b;\n    std::cin >> a >> b;\n    std::cout << a + b << std::endl;\n    return 0;\n}\n```\n\nThis program reads two numbers from standard input, adds them, and outputs the result.\n\nWe can build a Gradio interface around this C++ program using Python's `subprocess` module. Here\u2019s the corresponding Python code:\n\n```python\nimport gradio as gr\nimport subprocess\n\ndef add_numbers(a, b):\n    process = subprocess.Popen(\n        ['./add'], \n        stdin=subprocess.PIPE, \n        stdout=subprocess.PIPE, \n        stderr=subprocess.PIPE\n    )\n    output, error = process.communicate(input=f\"{a} {b}\\n\".encode())\n    \n    if error:\n        return f\"Error: {error.decode()}\"\n    return float(output.decode().strip())\n\ndemo = gr.Interface(\n    fn=add_numbers, \n    inputs=[gr.Number(label=\"Number 1\"), gr.Number(label=\"Number 2\")], \n    outputs=gr.Textbox(label=\"Result\")\n)\n\ndemo.launch()\n```\n\nHere, `subprocess.Popen` is used to execute the compiled C++ program (`add`), pass the input values, and capture the output. You can compile the C++ program by running:\n\n```bash\ng++ -o add add.cpp\n```\n\nThis example shows how easy it is to call C++ from Python using `subprocess` and build a Gradio interface around it.\n\n## Using Gradio with Rust\n\nNow, let\u2019s move to another example: calling a Rust program to apply a sepia filter to an image. The Rust code could look something like this:\n\n```rust\n// sepia.rs\nextern crate image;\n\nuse image::{GenericImageView, ImageBuffer, Rgba};\n\nfn sepia_filter(input: &str, output: &str) {\n    let img = image::open(input).unwrap();\n    let (width, height) = img.dimensions();\n    let mut img_buf = ImageBuffer::new(width, height);\n\n    for (x, y, pixel) in img.pixels() {\n        let (r, g, b, a) = (pixel[0] as f32, pixel[1] as f32, pixel[2] as f32, pixel[3]);\n        let tr = (0.393 * r + 0.769 * g + 0.189 * b).min(255.0);\n        let tg = (0.349 * r + 0.686 * g + 0.168 * b).min(255.0);\n        let tb = (0.272 * r + 0.534 * g + 0.131 * b).min(255.0);\n        img_buf.put_pixel(x, y, Rgba([tr as u8, tg as u8, tb as u8, a]));\n    }\n\n    img_buf.save(output).unwrap();\n}\n\nfn main() {\n    let args: Vec<String> = std::env::args().collect();\n    if args.len() != 3 {\n        eprintln!(\"Usage: sepia <input_file> <output_file>\");\n        return;\n    }\n    sepia_filter(&args[1], &args[2]);\n}\n```\n\nThis Rust program applies a sepia filter to an image. It takes two command-line arguments: the input image path and the output image path. You can compile this program using:\n\n```bash\ncargo build --release\n```\n\nNow, we can call this Rust program from Python and use Gradio to build the interface:\n\n```python\nimport gradio as gr\nimport subprocess\n\ndef apply_sepia(input_path):\n    output_path = \"output.png\"\n    \n    process = subprocess.Popen(\n        ['./target/release/sepia', input_path, output_path], \n        stdout=subprocess.PIPE, \n        stderr=subprocess.PIPE\n    )\n    process.wait()\n    \n    return output_path\n\ndemo = gr.Interface(\n    fn=apply_sepia, \n    inputs=gr.Image(type=\"filepath\", label=\"Input Image\"), \n    outputs=gr.Image(label=\"Sepia Image\")\n)\n\ndemo.launch()\n```\n\nHere, when a user uploads an image and clicks submit, Gradio calls the Rust binary (`sepia`) to process the image, and returns the sepia-filtered output to Gradio.\n\nThis setup showcases how you can integrate performance-critical or specialized code written in Rust into a Gradio interface.\n\n## Using Gradio with R (via `reticulate`)\n\nIntegrating Gradio with R is particularly straightforward thanks to the `reticulate` package, which allows you to run Python code directly in R. Let\u2019s walk through an example of using Gradio in R. \n\n**Installation**\n\nFirst, you need to install the `reticulate` package in R:\n\n```r\ninstall.packages(\"reticulate\")\n```\n\n\nOnce installed, you can use the package to run Gradio directly from within an R script.\n\n\n```r\nlibrary(reticulate)\n\npy_install(\"gradio\", pip = TRUE)\n\ngr <- import(\"gradio\") # import gradio as gr\n```\n\n**Building a Gradio Application**\n\nWith gradio installed and imported, we now have access to gradio's app building methods. Let's build a simple app for an R function that returns a greeting\n\n```r\ngreeting <- \\(name) paste(\"Hello\", name)\n\napp <- gr$Interface(\n  fn = greeting,\n  inputs = gr$Text(label = \"Name\"),\n  outputs = gr$Text(label = \"Greeting\"),\n  title = \"Hello! &#128515 &#128075\"\n)\n\napp$launch(server_name = \"localhost\", \n           server_port = as.integer(3000))\n```\n\nCredit to [@IfeanyiIdiaye](https://github.com/Ifeanyi55) for contributing this section. You can see more examples [here](https://github.com/Ifeanyi55/Gradio-in-R/tree/main/Code), including using Gradio Blocks to build a machine learning application in R.\n", "tags": [], "spaces": [], "url": "/guides/using-gradio-in-other-programming-languages/", "contributor": null}}