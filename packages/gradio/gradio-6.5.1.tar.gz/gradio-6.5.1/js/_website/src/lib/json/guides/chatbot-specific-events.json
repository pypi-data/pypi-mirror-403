{"guide": {"name": "chatbot-specific-events", "category": "chatbots", "pretty_category": "Chatbots", "guide_index": 5, "absolute_index": 35, "pretty_name": "Chatbot Specific Events", "content": "# Chatbot-Specific Events\n\n\n\nUsers expect modern chatbot UIs to let them easily interact with individual chat messages: for example, users might want to retry message generations, undo messages, or click on a like/dislike button to upvote or downvote a generated message.\n\nThankfully, the Gradio Chatbot exposes several events, such as `.retry`, `.undo`, `.like`, and `.clear`, to let you build this functionality into your application. As an application developer, you can attach functions to any of these event, allowing you to run arbitrary Python functions e.g. when a user interacts with a message.\n\nIn this demo, we'll build a UI that implements these events. You can see our finished demo deployed on Hugging Face spaces here:\n\n<gradio-app space='gradio/chatbot_retry_undo_like'></gradio-app>\n            <div class='tip'>\n                <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n                    <path d=\"M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .2 2.2 1.5 3.5.7.7 1.3 1.5 1.5 2.5\"/>\n                    <path d=\"M9 18h6\"/>\n                    <path d=\"M10 22h4\"/>\n                </svg>\n                <div><p><code>gr.ChatInterface</code> automatically uses the <code>retry</code> and <code>.undo</code> events so it's best to start there in order get a fully working application quickly.</p></div>\n            </div>\n                \n\n\n## The UI\n\nFirst, we'll build the UI without handling these events and build from there. \nWe'll use the Hugging Face InferenceClient in order to get started without setting up\nany API keys.\n\nThis is what the first draft of our application looks like:\n\n```python\nfrom huggingface_hub import InferenceClient\nimport gradio as gr\n\nclient = InferenceClient()\n\ndef respond(\n    prompt: str,\n    history,\n):\n    if not history:\n        history = [{\"role\": \"system\", \"content\": \"You are a friendly chatbot\"}]\n    history.append({\"role\": \"user\", \"content\": prompt})\n\n    yield history\n\n    response = {\"role\": \"assistant\", \"content\": \"\"}\n    for message in client.chat_completion( # type: ignore\n        history,\n        temperature=0.95,\n        top_p=0.9,\n        max_tokens=512,\n        stream=True,\n        model=\"openai/gpt-oss-20b\"\n    ):\n        response[\"content\"] += message.choices[0].delta.content or \"\" if message.choices else \"\"\n        yield history + [response]\n\n\nwith gr.Blocks() as demo:\n    gr.Markdown(\"# Chat with GPT-OSS 20b \ud83e\udd17\")\n    chatbot = gr.Chatbot(\n        label=\"Agent\",\n        avatar_images=(\n            None,\n            \"https://em-content.zobj.net/source/twitter/376/hugging-face_1f917.png\",\n        ),\n    )\n    prompt = gr.Textbox(max_lines=1, label=\"Chat Message\")\n    prompt.submit(respond, [prompt, chatbot], [chatbot])\n    prompt.submit(lambda: \"\", None, [prompt])\n\nif __name__ == \"__main__\":\n    demo.launch()\n```\n\n## The Undo Event\n\nOur undo event will populate the textbox with the previous user message and also remove all subsequent assistant responses.\n\nIn order to know the index of the last user message, we can pass `gr.UndoData` to our event handler function like so:\n\n```python\ndef handle_undo(history, undo_data: gr.UndoData):\n    return history[:undo_data.index], history[undo_data.index]['content'][0][\"text\"]\n```\n\nWe then pass this function to the `undo` event!\n\n```python\n    chatbot.undo(handle_undo, chatbot, [chatbot, prompt])\n```\n\nYou'll notice that every bot response will now have an \"undo icon\" you can use to undo the response - \n\n![undo_event](https://github.com/user-attachments/assets/180b5302-bc4a-4c3e-903c-f14ec2adcaa6)\n            <div class='tip'>\n                <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n                    <path d=\"M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .2 2.2 1.5 3.5.7.7 1.3 1.5 1.5 2.5\"/>\n                    <path d=\"M9 18h6\"/>\n                    <path d=\"M10 22h4\"/>\n                </svg>\n                <div><p>You can also access the content of the user message with <code>undo_data.value</code></p></div>\n            </div>\n                \n\n## The Retry Event\n\nThe retry event will work similarly. We'll use `gr.RetryData` to get the index of the previous user message and remove all the subsequent messages from the history. Then we'll use the `respond` function to generate a new response. We could also get the previous prompt via the `value` property of `gr.RetryData`.\n\n```python\ndef handle_retry(history, retry_data: gr.RetryData):\n    new_history = history[:retry_data.index]\n    previous_prompt = history[retry_data.index]['content'][0][\"text\"]\n    yield from respond(previous_prompt, new_history)\n...\n\nchatbot.retry(handle_retry, chatbot, chatbot)\n```\n\nYou'll see that the bot messages have a \"retry\" icon now -\n\n![retry_event](https://github.com/user-attachments/assets/cec386a7-c4cd-4fb3-a2d7-78fd806ceac6)\n            <div class='tip'>\n                <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n                    <path d=\"M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .2 2.2 1.5 3.5.7.7 1.3 1.5 1.5 2.5\"/>\n                    <path d=\"M9 18h6\"/>\n                    <path d=\"M10 22h4\"/>\n                </svg>\n                <div><p>The Hugging Face inference API caches responses, so in this demo, the retry button will not generate a new response.</p></div>\n            </div>\n                \n\n## The Like Event\n\nBy now you should hopefully be seeing the pattern!\nTo let users like a message, we'll add a `.like` event to our chatbot.\nWe'll pass it a function that accepts a `gr.LikeData` object.\nIn this case, we'll just print the message that was either liked or disliked.\n\n```python\ndef handle_like(data: gr.LikeData):\n    if data.liked:\n        print(\"You upvoted this response: \", data.value)\n    else:\n        print(\"You downvoted this response: \", data.value)\n\nchatbot.like(handle_like, None, None)\n```\n\n## The Edit Event\n\nSame idea with the edit listener! with `gr.Chatbot(editable=True)`, you can capture user edits. The `gr.EditData` object tells us the index of the message edited and the new text of the mssage. Below, we use this object to edit the history, and delete any subsequent messages. \n\n```python\ndef handle_edit(history, edit_data: gr.EditData):\n    new_history = history[:edit_data.index]\n    new_history[-1]['content'] = [{\"text\": edit_data.value, \"type\": \"text\"}]\n    return new_history\n\n...\n\nchatbot.edit(handle_edit, chatbot, chatbot)\n```\n\n## The Clear Event\n\nAs a bonus, we'll also cover the `.clear()` event, which is triggered when the user clicks the clear icon to clear all messages. As a developer, you can attach additional events that should happen when this icon is clicked, e.g. to handle clearing of additional chatbot state:\n\n```python\nfrom uuid import uuid4\nimport gradio as gr\n\n\ndef clear():\n    print(\"Cleared uuid\")\n    return uuid4()\n\n\ndef chat_fn(user_input, history, uuid):\n    return f\"{user_input} with uuid {uuid}\"\n\n\nwith gr.Blocks() as demo:\n    uuid_state = gr.State(\n        uuid4\n    )\n    chatbot = gr.Chatbot()\n    chatbot.clear(clear, outputs=[uuid_state])\n\n    gr.ChatInterface(\n        chat_fn,\n        additional_inputs=[uuid_state],\n        chatbot=chatbot,\n    )\n\ndemo.launch()\n```\n\nIn this example, the `clear` function, bound to the `chatbot.clear` event, returns a new UUID into our session state, when the chat history is cleared via the trash icon. This can be seen in the `chat_fn` function, which references the UUID saved in our session state.\n\nThis example also shows that you can use these events with `gr.ChatInterface` by passing in a custom `gr.Chatbot` object.\n\n## Conclusion\n\nThat's it! You now know how you can implement the retry, undo, like, and clear events for the Chatbot.\n\n\n\n", "tags": ["LLM", "CHAT"], "spaces": [], "url": "/guides/chatbot-specific-events/", "contributor": null}}