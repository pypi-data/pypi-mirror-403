{"guide": {"name": "creating-a-chatbot-fast", "category": "chatbots", "pretty_category": "Chatbots", "guide_index": 1, "absolute_index": 31, "pretty_name": "Creating A Chatbot Fast", "content": "# How to Create a Chatbot with Gradio\n\n\n\n## Introduction\n\nChatbots are a popular application of large language models (LLMs). Using Gradio, you can easily build a chat application and share that with your users, or try it yourself using an intuitive UI.\n\nThis tutorial uses `gr.ChatInterface()`, which is a high-level abstraction that allows you to create your chatbot UI fast, often with a _few lines of Python_. It can be easily adapted to support multimodal chatbots, or chatbots that require further customization.\n\n**Prerequisites**: please make sure you are using the latest version of Gradio:\n\n```bash\n$ pip install --upgrade gradio\n```\n\n## Note for OpenAI-API compatible endpoints\n\nIf you have a chat server serving an OpenAI-API compatible endpoint (such as Ollama), you can spin up a ChatInterface in a single line of Python. First, also run `pip install openai`. Then, with your own URL, model, and optional token:\n\n```python\nimport gradio as gr\n\ngr.load_chat(\"http://localhost:11434/v1/\", model=\"llama3.2\", token=\"***\").launch()\n```\n\nRead about `gr.load_chat` in [the docs](https://www.gradio.app/docs/gradio/load_chat). If you have your own model, keep reading to see how to create an application around any chat model in Python!\n\n## Defining a chat function\n\nTo create a chat application with `gr.ChatInterface()`, the first thing you should do is define your **chat function**. In the simplest case, your chat function should accept two arguments: `message` and `history` (the arguments can be named anything, but must be in this order).\n\n- `message`: a `str` representing the user's most recent message.\n- `history`: a list of openai-style dictionaries with `role` and `content` keys, representing the previous conversation history. May also include additional keys representing message metadata.\n\nThe `history` would look like this:\n\n```python\n[\n    {\"role\": \"user\", \"content\": [{\"type\": \"text\", \"text\": \"What is the capital of France?\"}]},\n    {\"role\": \"assistant\", \"content\": [{\"type\": \"text\", \"text\": \"Paris\"}]}\n]\n```\n\nwhile the next `message` would be:\n\n```py\n\"And what is its largest city?\"\n```\n\nYour chat function simply needs to return: \n\n* a `str` value, which is the chatbot's response based on the chat `history` and most recent `message`, for example, in this case:\n\n```\nParis is also the largest city.\n```\n\nLet's take a look at a few example chat functions:\n\n**Example: a chatbot that randomly responds with yes or no**\n\nLet's write a chat function that responds `Yes` or `No` randomly.\n\nHere's our chat function:\n\n```python\nimport random\n\ndef random_response(message, history):\n    return random.choice([\"Yes\", \"No\"])\n```\n\nNow, we can plug this into `gr.ChatInterface()` and call the `.launch()` method to create the web interface:\n\n```python\nimport gradio as gr\n\ngr.ChatInterface(\n    fn=random_response, \n).launch()\n```\n\nThat's it! Here's our running demo, try it out:\n\n<gradio-app space='gradio/chatinterface_random_response'></gradio-app>\n\n**Example: a chatbot that alternates between agreeing and disagreeing**\n\nOf course, the previous example was very simplistic, it didn't take user input or the previous history into account! Here's another simple example showing how to incorporate a user's input as well as the history.\n\n```python\nimport gradio as gr\n\ndef alternatingly_agree(message, history):\n    if len([h for h in history if h['role'] == \"assistant\"]) % 2 == 0:\n        return f\"Yes, I do think that: {message}\"\n    else:\n        return \"I don't think so\"\n\ngr.ChatInterface(\n    fn=alternatingly_agree, \n).launch()\n```\n\nWe'll look at more realistic examples of chat functions in our next Guide, which shows [examples of using `gr.ChatInterface` with popular LLMs](../guides/chatinterface-examples). \n\n## Streaming chatbots\n\nIn your chat function, you can use `yield` to generate a sequence of partial responses, each replacing the previous ones. This way, you'll end up with a streaming chatbot. It's that simple!\n\n```python\nimport time\nimport gradio as gr\n\ndef slow_echo(message, history):\n    for i in range(len(message)):\n        time.sleep(0.3)\n        yield \"You typed: \" + message[: i+1]\n\ngr.ChatInterface(\n    fn=slow_echo, \n).launch()\n```\n\nWhile the response is streaming, the \"Submit\" button turns into a \"Stop\" button that can be used to stop the generator function.\n            <div class='tip'>\n                <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n                    <path d=\"M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .2 2.2 1.5 3.5.7.7 1.3 1.5 1.5 2.5\"/>\n                    <path d=\"M9 18h6\"/>\n                    <path d=\"M10 22h4\"/>\n                </svg>\n                <div><p>Even though you are yielding the latest message at each iteration, Gradio only sends the \"diff\" of each message from the server to the frontend, which reduces latency and data consumption over your network.</p></div>\n            </div>\n                \n\n## Customizing the Chat UI\n\nIf you're familiar with Gradio's `gr.Interface` class, the `gr.ChatInterface` includes many of the same arguments that you can use to customize the look and feel of your Chatbot. For example, you can:\n\n- add a title and description above your chatbot using `title` and `description` arguments.\n- add a theme or custom css using `theme` and `css` arguments respectively in the `launch()` method.\n- add `examples` and even enable `cache_examples`, which make your Chatbot easier for users to try it out.\n- customize the chatbot (e.g. to change the height or add a placeholder) or textbox (e.g. to add a max number of characters or add a placeholder).\n\n**Adding examples**\n\nYou can add preset examples to your `gr.ChatInterface` with the `examples` parameter, which takes a list of string examples. Any examples will appear as \"buttons\" within the Chatbot before any messages are sent. If you'd like to include images or other files as part of your examples, you can do so by using this dictionary format for each example instead of a string: `{\"text\": \"What's in this image?\", \"files\": [\"cheetah.jpg\"]}`. Each file will be a separate message that is added to your Chatbot history.\n\nYou can change the displayed text for each example by using the `example_labels` argument. You can add icons to each example as well using the `example_icons` argument. Both of these arguments take a list of strings, which should be the same length as the `examples` list.\n\nIf you'd like to cache the examples so that they are pre-computed and the results appear instantly, set `cache_examples=True`.\n\n**Customizing the chatbot or textbox component**\n\nIf you want to customize the `gr.Chatbot` or `gr.Textbox` that compose the `ChatInterface`, then you can pass in your own chatbot or textbox components. Here's an example of how we to apply the parameters we've discussed in this section:\n\n```python\nimport gradio as gr\n\ndef yes_man(message, history):\n    if message.endswith(\"?\"):\n        return \"Yes\"\n    else:\n        return \"Ask me anything!\"\n\ngr.ChatInterface(\n    yes_man,\n    chatbot=gr.Chatbot(height=300),\n    textbox=gr.Textbox(placeholder=\"Ask me a yes or no question\", container=False, scale=7),\n    title=\"Yes Man\",\n    description=\"Ask Yes Man any question\",\n    examples=[\"Hello\", \"Am I cool?\", \"Are tomatoes vegetables?\"],\n    cache_examples=True,\n).launch(theme=\"ocean\")\n```\n\nHere's another example that adds a \"placeholder\" for your chat interface, which appears before the user has started chatting. The `placeholder` argument of `gr.Chatbot` accepts Markdown or HTML:\n\n```python\ngr.ChatInterface(\n    yes_man,\n    chatbot=gr.Chatbot(placeholder=\"<strong>Your Personal Yes-Man</strong><br>Ask Me Anything\"),\n...\n```\n\nThe placeholder appears vertically and horizontally centered in the chatbot.\n\n## Multimodal Chat Interface\n\nYou may want to add multimodal capabilities to your chat interface. For example, you may want users to be able to upload images or files to your chatbot and ask questions about them. You can make your chatbot \"multimodal\" by passing in a single parameter (`multimodal=True`) to the `gr.ChatInterface` class.\n\nWhen `multimodal=True`, the signature of your chat function changes slightly: the first parameter of your function (what we referred to as `message` above) should accept a dictionary consisting of the submitted text and uploaded files that looks like this: \n\n```py\n{\n    \"text\": \"user input\", \n    \"files\": [\n        \"updated_file_1_path.ext\",\n        \"updated_file_2_path.ext\", \n        ...\n    ]\n}\n```\n\nThis second parameter of your chat function, `history`, will be in the same openai-style dictionary format as before. However, if the history contains uploaded files, the `content` key will be a dictionary with a \"type\" key whose value is \"file\" and the file will be represented as a dictionary. All the files will be grouped in message in the history. So after uploading two files and asking a question, your history might look like this:\n\n```python\n[\n    {\"role\": \"user\", \"content\": [{\"type\": \"file\", \"file\": {\"path\": \"cat1.png\"}},\n                                 {\"type\": \"file\", \"file\": {\"path\": \"cat1.png\"}},\n                                 {\"type\": \"text\", \"text\": \"What's the difference between these two images?\"}]}\n]\n```\n\nThe return type of your chat function does *not change* when setting `multimodal=True` (i.e. in the simplest case, you should still return a string value). We discuss more complex cases, e.g. returning files [below](#returning-complex-responses).\n\nIf you are customizing a multimodal chat interface, you should pass in an instance of `gr.MultimodalTextbox` to the `textbox` parameter. You can customize the `MultimodalTextbox` further by passing in the `sources` parameter, which is a list of sources to enable. Here's an example that illustrates how to set up and customize and multimodal chat interface:\n \n\n```python\nimport gradio as gr\n\ndef count_images(message, history):\n    num_images = len(message[\"files\"])\n    total_images = 0\n    for message in history:\n        for content in message[\"content\"]:\n            if content[\"type\"] == \"file\":\n                total_images += 1\n    return f\"You just uploaded {num_images} images, total uploaded: {total_images+num_images}\"\n\ndemo = gr.ChatInterface(\n    fn=count_images, \n    examples=[\n        {\"text\": \"No files\", \"files\": []}\n    ], \n    multimodal=True,\n    textbox=gr.MultimodalTextbox(file_count=\"multiple\", file_types=[\"image\"], sources=[\"upload\", \"microphone\"])\n)\n\ndemo.launch()\n```\n\n## Additional Inputs\n\nYou may want to add additional inputs to your chat function and expose them to your users through the chat UI. For example, you could add a textbox for a system prompt, or a slider that sets the number of tokens in the chatbot's response. The `gr.ChatInterface` class supports an `additional_inputs` parameter which can be used to add additional input components.\n\nThe `additional_inputs` parameters accepts a component or a list of components. You can pass the component instances directly, or use their string shortcuts (e.g. `\"textbox\"` instead of `gr.Textbox()`). If you pass in component instances, and they have _not_ already been rendered, then the components will appear underneath the chatbot within a `gr.Accordion()`. \n\nHere's a complete example:\n\n```python\nimport gradio as gr\nimport time\n\ndef echo(message, history, system_prompt, tokens):\n    response = f\"System prompt: {system_prompt}\\n Message: {message}.\"\n    for i in range(min(len(response), int(tokens))):\n        time.sleep(0.05)\n        yield response[: i + 1]\n\ndemo = gr.ChatInterface(\n    echo,\n    additional_inputs=[\n        gr.Textbox(\"You are helpful AI.\", label=\"System Prompt\"),\n        gr.Slider(10, 100),\n    ],\n)\n\ndemo.launch()\n\n```\n\nIf the components you pass into the `additional_inputs` have already been rendered in a parent `gr.Blocks()`, then they will _not_ be re-rendered in the accordion. This provides flexibility in deciding where to lay out the input components. In the example below, we position the `gr.Textbox()` on top of the Chatbot UI, while keeping the slider underneath.\n\n```python\nimport gradio as gr\nimport time\n\ndef echo(message, history, system_prompt, tokens):\n    response = f\"System prompt: {system_prompt}\\n Message: {message}.\"\n    for i in range(min(len(response), int(tokens))):\n        time.sleep(0.05)\n        yield response[: i+1]\n\nwith gr.Blocks() as demo:\n    system_prompt = gr.Textbox(\"You are helpful AI.\", label=\"System Prompt\")\n    slider = gr.Slider(10, 100, render=False)\n\n    gr.ChatInterface(\n        echo, additional_inputs=[system_prompt, slider],\n    )\n\ndemo.launch()\n```\n\n**Examples with additional inputs**\n\nYou can also add example values for your additional inputs. Pass in a list of lists to the `examples` parameter, where each inner list represents one sample, and each inner list should be `1 + len(additional_inputs)` long. The first element in the inner list should be the example value for the chat message, and each subsequent element should be an example value for one of the additional inputs, in order. When additional inputs are provided, examples are rendered in a table underneath the chat interface.\n\nIf you need to create something even more custom, then its best to construct the chatbot UI using the low-level `gr.Blocks()` API. We have [a dedicated guide for that here](/guides/creating-a-custom-chatbot-with-blocks).\n\n## Additional Outputs\n\nIn the same way that you can accept additional inputs into your chat function, you can also return additional outputs. Simply pass in a list of components to the `additional_outputs` parameter in `gr.ChatInterface` and return additional values for each component from your chat function. Here's an example that extracts code and outputs it into a separate `gr.Code` component:\n\n```python\nimport gradio as gr\n\npython_code = \"\"\"\ndef fib(n):\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fib(n-1) + fib(n-2)\n\"\"\"\n\njs_code = \"\"\"\nfunction fib(n) {\n    if (n <= 0) return 0;\n    if (n === 1) return 1;\n    return fib(n - 1) + fib(n - 2);\n}\n\"\"\"\n\ndef chat(message, history):\n    if \"python\" in message.lower():\n        return \"Type Python or JavaScript to see the code.\", gr.Code(language=\"python\", value=python_code)\n    elif \"javascript\" in message.lower():\n        return \"Type Python or JavaScript to see the code.\", gr.Code(language=\"javascript\", value=js_code)\n    else:\n        return \"Please ask about Python or JavaScript.\", None\n\nwith gr.Blocks() as demo:\n    code = gr.Code(render=False)\n    with gr.Row():\n        with gr.Column():\n            gr.Markdown(\"<center><h1>Write Python or JavaScript</h1></center>\")\n            gr.ChatInterface(\n                chat,\n                examples=[\"Python\", \"JavaScript\"],\n                additional_outputs=[code],\n                api_name=\"chat\",\n            )\n        with gr.Column():\n            gr.Markdown(\"<center><h1>Code Artifacts</h1></center>\")\n            code.render()\n\ndemo.launch()\n\n```\n\n**Note:** unlike the case of additional inputs, the components passed in `additional_outputs` must be already defined in your `gr.Blocks` context -- they are not rendered automatically. If you need to render them after your `gr.ChatInterface`, you can set `render=False` when they are first defined and then `.render()` them in the appropriate section of your `gr.Blocks()` as we do in the example above.\n\n## Returning Complex Responses\n\nWe mentioned earlier that in the simplest case, your chat function should return a `str` response, which will be rendered as Markdown in the chatbot. However, you can also return more complex responses as we discuss below:\n\n\n**Returning files or Gradio components**\n\nCurrently, the following Gradio components can be displayed inside the chat interface:\n* `gr.Image`\n* `gr.Plot`\n* `gr.Audio`\n* `gr.HTML`\n* `gr.Video`\n* `gr.Gallery`\n* `gr.File`\n\nSimply return one of these components from your function to use it with `gr.ChatInterface`. Here's an example that returns an audio file:\n\n```py\nimport gradio as gr\n\ndef music(message, history):\n    if message.strip():\n        return gr.Audio(\"https://github.com/gradio-app/gradio/raw/main/test/test_files/audio_sample.wav\")\n    else:\n        return \"Please provide the name of an artist\"\n\ngr.ChatInterface(\n    music,\n    textbox=gr.Textbox(placeholder=\"Which artist's music do you want to listen to?\", scale=7),\n).launch()\n```\n\nSimilarly, you could return image files with `gr.Image`, video files with `gr.Video`, or arbitrary files with the `gr.File` component.\n\n**Returning Multiple Messages**\n\nYou can return multiple assistant messages from your chat function simply by returning a `list` of messages, each of which is a valid chat type. This lets you, for example, send a message along with files, as in the following example:\n\n```python\nimport gradio as gr\n\ndef echo_multimodal(message, history):\n    response = []\n    response.append(\"You wrote: '\" + message[\"text\"] + \"' and uploaded:\")\n    if message.get(\"files\"):\n        for file in message[\"files\"]:\n            response.append(gr.File(value=file))\n    return response\n\ndemo = gr.ChatInterface(\n    echo_multimodal,\n    multimodal=True,\n    textbox=gr.MultimodalTextbox(file_count=\"multiple\"),\n    api_name=\"chat\",\n)\n\ndemo.launch()\n\n```\n\n\n**Displaying intermediate thoughts or tool usage**\n\nThe `gr.ChatInterface` class supports displaying intermediate thoughts or tool usage direct in the chatbot.\n\n![](https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/gradio-guides/nested-thought.png)\n\n To do this, you will need to return a `gr.ChatMessage` object from your chat function. Here is the schema of the `gr.ChatMessage` data class as well as two internal typed dictionaries:\n \n ```py\nMessageContent = Union[str, FileDataDict, FileData, Component]\n\n@dataclass\nclass ChatMessage:\n    content: MessageContent | list[MessageContent]\n    metadata: MetadataDict = None\n    options: list[OptionDict] = None\n\nclass MetadataDict(TypedDict):\n    title: NotRequired[str]\n    id: NotRequired[int | str]\n    parent_id: NotRequired[int | str]\n    log: NotRequired[str]\n    duration: NotRequired[float]\n    status: NotRequired[Literal[\"pending\", \"done\"]]\n\nclass OptionDict(TypedDict):\n    label: NotRequired[str]\n    value: str\n ```\n \nAs you can see, the `gr.ChatMessage` dataclass is similar to the openai-style message format, e.g. it has a \"content\" key that refers to the chat message content. But it also includes a \"metadata\" key whose value is a dictionary. If this dictionary includes a \"title\" key, the resulting message is displayed as an intermediate thought with the title being displayed on top of the thought. Here's an example showing the usage:\n\n```python\nimport gradio as gr\nfrom gradio import ChatMessage\nimport time\n\nsleep_time = 0.5\n\ndef simulate_thinking_chat(message, history):\n    start_time = time.time()\n    response = ChatMessage(\n        content=\"\",\n        metadata={\"title\": \"_Thinking_ step-by-step\", \"id\": 0, \"status\": \"pending\"}\n    )\n    yield response\n\n    thoughts = [\n        \"First, I need to understand the core aspects of the query...\",\n        \"Now, considering the broader context and implications...\",\n        \"Analyzing potential approaches to formulate a comprehensive answer...\",\n        \"Finally, structuring the response for clarity and completeness...\"\n    ]\n\n    accumulated_thoughts = \"\"\n    for thought in thoughts:\n        time.sleep(sleep_time)\n        accumulated_thoughts += f\"- {thought}\\n\\n\"\n        response.content = accumulated_thoughts.strip()\n        yield response\n\n    response.metadata[\"status\"] = \"done\"\n    response.metadata[\"duration\"] = time.time() - start_time\n    yield response\n\n    response = [\n        response,\n        ChatMessage(\n            content=\"Based on my thoughts and analysis above, my response is: This dummy repro shows how thoughts of a thinking LLM can be progressively shown before providing its final answer.\"\n        )\n    ]\n    yield response\n\n\ndemo = gr.ChatInterface(\n    simulate_thinking_chat,\n    title=\"Thinking LLM Chat Interface \ud83e\udd14\",\n)\n\ndemo.launch()\n\n```\n\nYou can even show nested thoughts, which is useful for agent demos in which one tool may call other tools. To display nested thoughts, include \"id\" and \"parent_id\" keys in the \"metadata\" dictionary. Read our [dedicated guide on displaying intermediate thoughts and tool usage](/guides/agents-and-tool-usage) for more realistic examples.\n\n**Providing preset responses**\n\nWhen returning an assistant message, you may want to provide preset options that a user can choose in response. To do this, again, you will again return a `gr.ChatMessage` instance from your chat function. This time, make sure to set the `options` key specifying the preset responses.\n\nAs shown in the schema for `gr.ChatMessage` above, the value corresponding to the `options` key should be a list of dictionaries, each with a `value` (a string that is the value that should be sent to the chat function when this response is clicked) and an optional `label` (if provided, is the text displayed as the preset response instead of the `value`). \n\nThis example illustrates how to use preset responses:\n\n```python\nimport gradio as gr\nimport random\n\nexample_code = \"\"\"\nHere's an example Python lambda function:\n\nlambda x: x + {}\n\nIs this correct?\n\"\"\"\n\ndef chat(message, history):\n    if message == \"Yes, that's correct.\":\n        return \"Great!\"\n    else:\n        return gr.ChatMessage(\n            content=example_code.format(random.randint(1, 100)),\n            options=[\n                {\"value\": \"Yes, that's correct.\", \"label\": \"Yes\"},\n                {\"value\": \"No\"}\n            ]\n        )\n\ndemo = gr.ChatInterface(\n    chat,\n    examples=[\"Write an example Python lambda function.\"],\n    api_name=\"chat\",\n)\n\ndemo.launch()\n\n```\n\n## Modifying the Chatbot Value Directly\n\nYou may wish to modify the value of the chatbot with your own events, other than those prebuilt in the `gr.ChatInterface`. For example, you could create a dropdown that prefills the chat history with certain conversations or add a separate button to clear the conversation history. The `gr.ChatInterface` supports these events, but you need to use the `gr.ChatInterface.chatbot_value` as the input or output component in such events. In this example, we use a `gr.Radio` component to prefill the the chatbot with certain conversations:\n\n```python\nimport gradio as gr\nimport random\n\ndef prefill_chatbot(choice):\n    if choice == \"Greeting\":\n        return [\n            {\"role\": \"user\", \"content\": \"Hi there!\"},\n            {\"role\": \"assistant\", \"content\": \"Hello! How can I assist you today?\"}\n        ]\n    elif choice == \"Complaint\":\n        return [\n            {\"role\": \"user\", \"content\": \"I'm not happy with the service.\"},\n            {\"role\": \"assistant\", \"content\": \"I'm sorry to hear that. Can you please tell me more about the issue?\"}\n        ]\n    else:\n        return []\n\ndef random_response(message, history):\n    return random.choice([\"Yes\", \"No\"])\n\nwith gr.Blocks() as demo:\n    radio = gr.Radio([\"Greeting\", \"Complaint\", \"Blank\"])\n    chat = gr.ChatInterface(random_response, api_name=\"chat\")\n    radio.change(prefill_chatbot, radio, chat.chatbot_value)\n\ndemo.launch()\n\n```\n\n## Using Your Chatbot via API\n\nOnce you've built your Gradio chat interface and are hosting it on [Hugging Face Spaces](https://hf.space) or somewhere else, then you can query it with a simple API. The API route will be the name of the function you pass to the ChatInterface. So if `gr.ChatInterface(respond)`, then the API route is `/respond`. The endpoint just expects the user's message and will return the response, internally keeping track of the message history.\n\n![](https://github.com/gradio-app/gradio/assets/1778297/7b10d6db-6476-4e2e-bebd-ecda802c3b8f)\n\nTo use the endpoint, you should use either the [Gradio Python Client](/guides/getting-started-with-the-python-client) or the [Gradio JS client](/guides/getting-started-with-the-js-client). Or, you can deploy your Chat Interface to other platforms, such as a:\n\n* Slack bot [[tutorial]](../guides/creating-a-slack-bot-from-a-gradio-app)\n* Website widget [[tutorial]](../guides/creating-a-website-widget-from-a-gradio-chatbot)\n\n## Chat History\n\nYou can enable persistent chat history for your ChatInterface, allowing users to maintain multiple conversations and easily switch between them. When enabled, conversations are stored locally and privately in the user's browser using local storage. So if you deploy a ChatInterface e.g. on [Hugging Face Spaces](https://hf.space), each user will have their own separate chat history that won't interfere with other users' conversations. This means multiple users can interact with the same ChatInterface simultaneously while maintaining their own private conversation histories.\n\nTo enable this feature, simply set `gr.ChatInterface(save_history=True)` (as shown in the example in the next section). Users will then see their previous conversations in a side panel and can continue any previous chat or start a new one.\n\n## Collecting User Feedback\n\nTo gather feedback on your chat model, set `gr.ChatInterface(flagging_mode=\"manual\")` and users will be able to thumbs-up or thumbs-down assistant responses. Each flagged response, along with the entire chat history, will get saved in a CSV file in the app working directory (this can be configured via the `flagging_dir` parameter). \n\nYou can also change the feedback options via `flagging_options` parameter. The default options are \"Like\" and \"Dislike\", which appear as the thumbs-up and thumbs-down icons. Any other options appear under a dedicated flag icon. This example shows a ChatInterface that has both chat history (mentioned in the previous section) and user feedback enabled:\n\n```python\nimport time\nimport gradio as gr\n\ndef slow_echo(message, history):\n    for i in range(len(message)):\n        time.sleep(0.05)\n        yield \"You typed: \" + message[: i + 1]\n\ndemo = gr.ChatInterface(\n    slow_echo,\n    flagging_mode=\"manual\",\n    flagging_options=[\"Like\", \"Spam\", \"Inappropriate\", \"Other\"],\n    save_history=True,\n)\n\ndemo.launch()\n\n```\n\nNote that in this example, we set several flagging options: \"Like\", \"Spam\", \"Inappropriate\", \"Other\". Because the case-sensitive string \"Like\" is one of the flagging options, the user will see a thumbs-up icon next to each assistant message. The three other flagging options will appear in a dropdown under the flag icon.\n\n## What's Next?\n\nNow that you've learned about the `gr.ChatInterface` class and how it can be used to create chatbot UIs quickly, we recommend reading one of the following:\n\n* [Our next Guide](../guides/chatinterface-examples) shows examples of how to use `gr.ChatInterface` with popular LLM libraries.\n* If you'd like to build very custom chat applications from scratch, you can build them using the low-level Blocks API, as [discussed in this Guide](../guides/creating-a-custom-chatbot-with-blocks).\n* Once you've deployed your Gradio Chat Interface, its easy to use in other applications because of the built-in API. Here's a tutorial on [how to deploy a Gradio chat interface as a Discord bot](../guides/creating-a-discord-bot-from-a-gradio-app).\n\n\n", "tags": ["LLM", "CHATBOT", "NLP"], "spaces": [], "url": "/guides/creating-a-chatbot-fast/", "contributor": null}}