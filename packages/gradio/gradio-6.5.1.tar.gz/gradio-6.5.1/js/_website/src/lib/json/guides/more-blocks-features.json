{"guide": {"name": "more-blocks-features", "category": "building-with-blocks", "pretty_category": "Building With Blocks", "guide_index": 5, "absolute_index": 11, "pretty_name": "More Blocks Features", "content": "# More Blocks Features\n\n## Examples\n\nJust like with `gr.Interface`, you can also add examples for your functions when you are working with `gr.Blocks`. In this case, instantiate a `gr.Examples` similar to how you would instantiate any other component. The constructor of `gr.Examples` takes two required arguments:\n\n- `examples`: a nested list of examples, in which the outer list consists of examples and each inner list consists of an input corresponding to each input component\n- `inputs`: the component or list of components that should be populated when the examples are clicked\n\nYou can also set `cache_examples=True` or `cache_examples='lazy'`, similar to [the caching API in `gr.Interface`](https://www.gradio.app/guides/more-on-examples), in which case two additional arguments must be provided:\n\n- `outputs`: the component or list of components corresponding to the output of the examples\n- `fn`: the function to run to generate the outputs corresponding to the examples\n\nHere's an example showing how to use `gr.Examples` in a `gr.Blocks` app:\n\n```python\nimport gradio as gr\n\ndef calculator(num1, operation, num2):\n    if operation == \"add\":\n        return num1 + num2\n    elif operation == \"subtract\":\n        return num1 - num2\n    elif operation == \"multiply\":\n        return num1 * num2\n    elif operation == \"divide\":\n        return num1 / num2\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        with gr.Column():\n            num_1 = gr.Number(value=4)\n            operation = gr.Radio([\"add\", \"subtract\", \"multiply\", \"divide\"])\n            num_2 = gr.Number(value=0)\n            submit_btn = gr.Button(value=\"Calculate\")\n        with gr.Column():\n            result = gr.Number()\n\n    submit_btn.click(\n        calculator, inputs=[num_1, operation, num_2], outputs=[result], api_visibility=\"private\"\n    )\n    examples = gr.Examples(\n        examples=[\n            [5, \"add\", 3],\n            [4, \"divide\", 2],\n            [-4, \"multiply\", 2.5],\n            [0, \"subtract\", 1.2],\n        ],\n        inputs=[num_1, operation, num_2],\n    )\n\nif __name__ == \"__main__\":\n    demo.launch(footer_links=[\"gradio\"])\n\n```\n<gradio-app space='gradio/calculator_blocks'></gradio-app>\n\n**Note**: When you click on examples, not only does the value of the input component update to the example value, but the component's configuration also reverts to the properties with which you constructed the component. This ensures that the examples are compatible with the component even if its configuration has been changed.\n\n## Running Events Continuously\n\nYou can run events on a fixed schedule using `gr.Timer()` object. This will run the event when the timer's `tick` event fires. See the code below:\n\n```python\nwith gr.Blocks as demo:\n    timer = gr.Timer(5)\n    textbox = gr.Textbox()\n    textbox2 = gr.Textbox()\n    timer.tick(set_textbox_fn, textbox, textbox2)\n```\n\nThis can also be used directly with a Component's `every=` parameter, if the value of the Component is a function:\n\n```python\nwith gr.Blocks as demo:\n    timer = gr.Timer(5)\n    textbox = gr.Textbox()\n    textbox2 = gr.Textbox(set_textbox_fn, inputs=[textbox], every=timer)\n```\n\nHere is an example of a demo that print the current timestamp, and also prints random numbers regularly!\n\n```python\nimport gradio as gr\nimport random\nimport time\n\nwith gr.Blocks() as demo:\n  timer = gr.Timer(1)\n  timestamp = gr.Number(label=\"Time\")\n  timer.tick(lambda: round(time.time()), outputs=timestamp, api_name=\"timestamp\")\n\n  number = gr.Number(lambda: random.randint(1, 10), every=timer, label=\"Random Number\")\n  with gr.Row():\n    gr.Button(\"Start\").click(lambda: gr.Timer(active=True), None, timer)\n    gr.Button(\"Stop\").click(lambda: gr.Timer(active=False), None, timer)\n    gr.Button(\"Go Fast\").click(lambda: 0.2, None, timer)\n\nif __name__ == \"__main__\":\n  demo.launch()\n\n```\n<gradio-app space='gradio/timer_simple'></gradio-app>\n\n## Gathering Event Data\n\nYou can gather specific data about an event by adding the associated event data class as a type hint to an argument in the event listener function.\n\nFor example, event data for `.select()` can be type hinted by a `gradio.SelectData` argument. This event is triggered when a user selects some part of the triggering component, and the event data includes information about what the user specifically selected. For example, if a user selected a specific word in a `Textbox`, a specific pixel in an `Image`, a specific image in a `Gallery`, or a specific cell in a `DataFrame`, the event data argument would contain information about the specific selection.\n\nThe `SelectData` includes the value that was selected, and the index where the selection occurred. A simple example that shows what text was selected in a `Textbox`.\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    textbox = gr.Textbox(\"The quick brown fox jumped.\")\n    selection = gr.Textbox()\n\n    def get_selection(select_evt: gr.SelectData):\n        return select_evt.value\n\n    textbox.select(get_selection, None, selection)\n```\n\nIn the 2 player tic-tac-toe demo below, a user can select a cell in the `DataFrame` to make a move. The event data argument contains information about the specific cell that was selected. We can first check to see if the cell is empty, and then update the cell with the user's move.\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    turn = gr.Textbox(\"X\", interactive=False, label=\"Turn\")\n    board = gr.Dataframe(value=[[\"\", \"\", \"\"]] * 3, interactive=False, type=\"array\")\n\n    def place(board: list[list[int]], turn, evt: gr.SelectData):  \n        if evt.value:\n            return board, turn\n        board[evt.index[0]][evt.index[1]] = turn\n        turn = \"O\" if turn == \"X\" else \"X\"\n        return board, turn\n\n    board.select(place, [board, turn], [board, turn], show_progress=\"hidden\")\n\ndemo.launch()\n\n```\n<gradio-app space='gradio/tictactoe'></gradio-app>\n\n## Validation\n\nFor certain apps, it is important to validate inputs prior to using them. While this can be done in the main event function, events also support a `validator` function dedicated to this task.\n\nThis feature allows for a far better user experience than placing this logic in your main function for the following reasons:\n\n- Input validation is performed immediately, bypassing the queue, giving the end user almost instant feedback.\n- Validation errors returned from the `validator` function are displayed differently in the UI.\n- The validator function allows for greater granularity. Rather than raising a generic exception, you can return a validation message and status for each input individually.\n\nThe `validator` kwarg should be a function that returns a `gr.validate` object for each input. `gr.validate` takes two arguments:\n\n- `is_valid` - whether or not the input is valid\n- `message` - the message to display if validation fails.\n\nIn the demo below you can see that by returning a validation status for each input, we have more granular information that we can display to the user.\n\n```python\nimport gradio as gr\n\n\ndef validate_input(age, location):\n    return [\n        gr.validate(not age or age > 3, \"Age must be at least 3\"),\n        gr.validate(\"london\" not in location.lower(), \"Location must not be in London\"),\n    ]\n\n\ndef process_text(age, location):\n    return f\"Processed: {age} -- {location.upper()}\"\n\n\nwith gr.Blocks() as demo:\n    gr.Markdown(\"# Validator Parameter Test Demo\")\n\n    with gr.Row():\n        with gr.Column():\n            age = gr.Number(\n                label=\"Enter age\",\n                placeholder=\"Enter age\",\n            )\n            location = gr.Textbox(\n                max_lines=3,\n                label=\"Enter location\",\n                placeholder=\"Enter location\",\n            )\n\n    validate_btn = gr.Button(\"Process with Validation\", variant=\"primary\")\n\n    output_with_validation = gr.Textbox(\n        label=\"Output (with validation)\", interactive=False\n    )\n\n    validate_btn.click(\n        fn=process_text,\n        validator=validate_input,\n        inputs=[age, location],\n        outputs=output_with_validation,\n    )\n\n\ndemo.launch()\n\n```\n<gradio-app space='gradio/validator_simple'></gradio-app>\n", "tags": [], "spaces": [], "url": "/guides/more-blocks-features/", "contributor": null}}