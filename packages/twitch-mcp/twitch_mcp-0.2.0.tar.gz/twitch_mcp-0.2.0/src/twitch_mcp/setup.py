"""Interactive setup for Twitch MCP credentials using Device Code Flow."""

import os
import sys
import time
import json
import urllib.request
import urllib.error
from urllib.parse import urlencode
from pathlib import Path

REQUIRED_VARS = [
    "TWITCH_CLIENT_ID",
    "TWITCH_CLIENT_SECRET",
    "TWITCH_ACCESS_TOKEN",
    "TWITCH_REFRESH_TOKEN",
]

# Scopes needed for full twitch-mcp functionality
SCOPES = [
    # Channel management
    "channel:manage:broadcast",
    "channel:read:subscriptions",
    "channel:manage:polls",
    "channel:read:polls",
    "channel:manage:predictions",
    "channel:read:predictions",
    "channel:manage:raids",
    "channel:read:goals",
    # Channel points
    "channel:read:redemptions",
    "channel:manage:redemptions",
    # VIP management
    "channel:read:vips",
    "channel:manage:vips",
    # Channel editors
    "channel:read:editors",
    # Moderation
    "moderation:read",
    "moderator:manage:announcements",
    "moderator:read:chatters",
    "moderator:manage:chat_messages",
    "moderator:manage:banned_users",
    "moderator:read:followers",
    "moderator:read:blocked_terms",
    "moderator:manage:blocked_terms",
    "moderator:read:automod_settings",
    "moderator:manage:automod_settings",
    "moderator:read:shield_mode",
    "moderator:manage:shield_mode",
    # Bits
    "bits:read",
    # User
    "user:write:chat",
    "user:read:chat",
    "user:read:email",
    "user:read:follows",
    # Clips
    "clips:edit",
]

ENV_TEMPLATE = """# Twitch MCP Credentials
# Generated by: twitch-mcp-setup

TWITCH_CLIENT_ID={client_id}
TWITCH_CLIENT_SECRET={client_secret}
TWITCH_ACCESS_TOKEN={access_token}
TWITCH_REFRESH_TOKEN={refresh_token}
"""


def post_request(url: str, data: dict) -> dict:
    """Make a POST request and return JSON response."""
    encoded = urlencode(data).encode()
    req = urllib.request.Request(url, data=encoded, method="POST")
    try:
        with urllib.request.urlopen(req) as resp:
            return json.loads(resp.read().decode())
    except urllib.error.HTTPError as e:
        return json.loads(e.read().decode())


def get_device_code(client_id: str) -> dict:
    """Request a device code from Twitch."""
    return post_request(
        "https://id.twitch.tv/oauth2/device",
        {"client_id": client_id, "scopes": " ".join(SCOPES)}
    )


def poll_for_token(client_id: str, client_secret: str, device_code: str, interval: int) -> dict:
    """Poll Twitch until user authorizes or times out."""
    while True:
        time.sleep(interval)
        result = post_request(
            "https://id.twitch.tv/oauth2/token",
            {
                "client_id": client_id,
                "client_secret": client_secret,
                "device_code": device_code,
                "grant_type": "urn:ietf:params:oauth:grant-type:device_code",
            }
        )

        if "access_token" in result:
            return result

        status = result.get("status")
        if status == 400:  # authorization_pending
            print(".", end="", flush=True)
            continue
        elif status == 403:  # access_denied
            return {"error": "User denied authorization"}
        elif status == 429:  # slow_down
            interval += 5
            continue
        else:
            return result


def run_device_flow(client_id: str, client_secret: str) -> dict | None:
    """Run device code OAuth flow."""

    print("\nRequesting device code...")
    device = get_device_code(client_id)

    if "device_code" not in device:
        print(f"❌ Error: {device}")
        return None

    print(f"""
╔══════════════════════════════════════════════════════════════════╗
║  Go to: {device['verification_uri']:<52} ║
║  Enter code: {device['user_code']:<47} ║
╚══════════════════════════════════════════════════════════════════╝
""")

    print("Waiting for authorization", end="", flush=True)

    tokens = poll_for_token(
        client_id,
        client_secret,
        device["device_code"],
        device.get("interval", 5)
    )

    print()  # newline after dots

    if "error" in tokens:
        print(f"❌ {tokens['error']}")
        return None

    if "access_token" not in tokens:
        print(f"❌ Failed: {tokens}")
        return None

    return tokens


def save_credentials(client_id: str, client_secret: str, access_token: str, refresh_token: str, path: Path):
    """Save credentials to env file."""
    content = ENV_TEMPLATE.format(
        client_id=client_id,
        client_secret=client_secret,
        access_token=access_token,
        refresh_token=refresh_token,
    )
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(content)
    path.chmod(0o600)


def interactive_setup():
    """Run interactive OAuth setup."""
    print("""
╔══════════════════════════════════════════════════════════════════╗
║                    TWITCH MCP SETUP                              ║
╚══════════════════════════════════════════════════════════════════╝

STEP 1: Create a Twitch App (if you haven't already)
─────────────────────────────────────────────────────
  1. Go to: https://dev.twitch.tv/console/apps
  2. Click "Register Your Application"
  3. Name: anything (e.g., "twitch-mcp")
  4. OAuth Redirect URL: http://localhost:3000/callback
  5. Category: Application Integration
  6. Click "Create", copy CLIENT_ID
  7. Click "New Secret", copy CLIENT_SECRET
""")

    client_id = input("TWITCH_CLIENT_ID: ").strip()
    if not client_id:
        print("Client ID required.")
        return False

    client_secret = input("TWITCH_CLIENT_SECRET: ").strip()
    if not client_secret:
        print("Client Secret required.")
        return False

    tokens = run_device_flow(client_id, client_secret)
    if not tokens:
        return False

    print(f"✅ Authorized! Token expires in {tokens.get('expires_in', '?')} seconds")

    # Save
    env_path = Path.home() / ".config" / "twitch-mcp" / ".env"
    save_credentials(client_id, client_secret, tokens["access_token"], tokens["refresh_token"], env_path)

    print(f"✅ Saved to: {env_path}")
    print(f"\nSet in your shell:")
    print(f"  export TWITCH_ENV_FILE={env_path}")

    return True


def check_credentials() -> dict[str, str | None]:
    """Check which credentials are set."""
    return {var: os.environ.get(var) for var in REQUIRED_VARS}


def main():
    """Entry point for twitch-mcp-setup command."""
    import argparse
    parser = argparse.ArgumentParser(description="Setup Twitch MCP credentials")
    parser.add_argument("--check", action="store_true", help="Check current credentials")
    parser.add_argument("--test", action="store_true", help="Test credentials with API")
    args = parser.parse_args()

    if args.check:
        creds = check_credentials()
        for k, v in creds.items():
            print(f"  {k}: {'✅' if v else '❌'}")
        sys.exit(0 if all(creds.values()) else 1)

    if args.test:
        missing = [k for k, v in check_credentials().items() if not v]
        if missing:
            print(f"❌ Missing: {', '.join(missing)}")
            sys.exit(1)
        try:
            from twitch_sdk import TwitchSDK
            from twitch_sdk.endpoints import users
            import asyncio
            async def test():
                sdk = TwitchSDK()
                r = await users.get_users(sdk.http, None)
                await sdk.close()
                return r
            r = asyncio.run(test())
            print(f"✅ Authenticated as: {r.data[0].display_name}")
        except Exception as e:
            print(f"❌ {e}")
            sys.exit(1)
        sys.exit(0)

    interactive_setup()


if __name__ == "__main__":
    main()
