Metadata-Version: 2.4
Name: nirfmxlte
Version: 26.0.0b0
Summary: Python APIs for interacting with NI RFmx LTE Product
License: MIT
License-File: LICENSE
Keywords: rfmx,nirfmx,nirfmxlte
Author: NI
Author-email: opensource@ni.com
Maintainer: Thangam V
Maintainer-email: thangam.v@emerson.com
Requires-Python: >=3.9,<4.0
Classifier: Development Status :: 4 - Beta
Classifier: Intended Audience :: Developers
Classifier: Intended Audience :: Manufacturing
Classifier: Intended Audience :: Science/Research
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: Microsoft :: Windows
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Classifier: Programming Language :: Python :: 3.13
Classifier: Programming Language :: Python :: 3.14
Classifier: Programming Language :: Python :: Implementation :: CPython
Classifier: Programming Language :: Python :: Implementation :: PyPy
Classifier: Topic :: Scientific/Engineering :: Instrument Drivers
Provides-Extra: dev
Requires-Dist: fasteners (>=0.19)
Requires-Dist: hightime (>=0.2.2)
Requires-Dist: nirfmxinstr (==26.0.0b0)
Requires-Dist: numpy (>=1.22) ; python_version >= "3.9" and python_version < "3.12" and implementation_name != "pypy"
Requires-Dist: numpy (>=1.26) ; implementation_name != "pypy" and python_version == "3.12"
Requires-Dist: numpy (>=2.1) ; implementation_name == "pypy" and python_version == "3.10"
Requires-Dist: numpy (>=2.1) ; python_version >= "3.13" and python_version < "4.0" and implementation_name != "pypy"
Requires-Dist: numpy (>=2.3) ; python_version >= "3.11" and python_version < "4.0" and implementation_name == "pypy"
Project-URL: Documentation, https://nirfmx-python-nirfmxlte.readthedocs-hosted.com/
Project-URL: Repository, https://github.com/ni/nirfmx-python
Description-Content-Type: text/markdown

| **Info**      | Contains Python APIs for interacting with NI RFmx LTE Product. |
| :------------ | :-------------------------------------------------------------- |
| **Author**    | National Instruments                                            |

# Table of Contents

- [Table of Contents](#table-of-contents)
- [About](#about)
  - [Documentation](#documentation)
  - [Operating System Support](#operating-system-support)
- [Installation](#installation)
- [License](#license)
- [Support and Feedback](#support-and-feedback)
- [Example](#example)


# About

The **nirfmx-python** repository generates Python bindings (Application Programming Interface)
for interacting with the NI RFmx Products.

**nirfmx-python** follows [Python Software Foundation](https://devguide.python.org/#status-of-python-branches)
support policy for different versions.


## RFmx Instr Python API Status

| Item                         | Details                      |
|------------------------------|-------------------------------|
| **Driver Version Tested**    | [2026 Q1](http://www.ni.com/downloads/)                      |
| **PyPI Package Version**     | v19.1                        |
| **Supported Python Versions**| Python 3.9+ (64-bit)    |
| **Documentation**            | [RFmx Instr Docs](https://nirfmx-python-nirfmxinstr.readthedocs-hosted.com/en/latest/) |


## RFmx LTE Python API Status

| Item                         | Details                      |
|------------------------------|-------------------------------|
| **Driver Version Tested**    | [2026 Q1](http://www.ni.com/downloads/)                      |
| **PyPI Package Version**     | v26.0                        |
| **Supported Python Versions**| Python 3.9+ (64-bit)    |
| **Documentation**            | [RFmx LTE Docs](https://nirfmx-python-nirfmxlte.readthedocs-hosted.com/en/latest/) |


## Documentation

You can find the latest API documentation for the **nirfmx-python** package
on [Read the Docs](https://nirfmx-python-nirfmxinstr.readthedocs-hosted.com/en/latest/)

Refer to the [NI RFmx User Manual](https://www.ni.com/docs/en-US/bundle/rfmx/page/user-manual-welcome.html)
for an overview of NI RFmx, system requirements, troubleshooting, key concepts, etc.


## Operating System Support

**nirfmx-python** supports Windows systems where the supported drivers are 
installed. Refer to [NI Hardware and Operating System Compatibility](https://www.ni.com/r/hw-support) for 
which versions of the driver support your hardware on a given operating system.


## Installation

You can use [pip](http://pypi.python.org/pypi/pip) to download [nirfmxlte](https://pypi.org/project/nirfmxlte/) and install it.
    
    $ python -m pip install nirfmxlte

## Upgrade

You can use [pip](http://pypi.python.org/pypi/pip) to upgrade [nirfmxlte](https://pypi.org/project/nirfmxlte/) package using following command:

    $ python -m pip install nirfmxlte --upgrade

## License

This project is licensed under the MIT License. While the source code is not publicly released,
the license permits binary distribution with attribution.

**Note:** This Python driver depends on several third-party components that are subject to separate
commercial licenses. Users are responsible for ensuring they have the appropriate rights and licenses
to use those dependencies in their environments.


# gRPC Features

For driver APIs that support it, passing a GrpcSessionOptions instance as a parameter to nirfmxinstr.Session.__init__() is subject to the NI General Purpose EULA.


# SSL/TLS Support

The server supports both server-side TLS and mutual TLS. Security configuration is accomplished by setting the `server_cert`, `server_key` and `root_cert` values in the server's configuration file. The server expects the certificate files specified in the configuration file to exist in a `certs` folder that is located in the same directory as the configuration file being used by the server. For more detailed information on SSL/TLS support refer to the [Server Security Support wiki page](https://github.com/ni/grpc-device/wiki/Server-Security-Support).


## Support and Feedback

For support with Python API, hardware, the driver runtime or any other questions,
please visit [NI Community Forums](https://forums.ni.com/).

## RFmxLTE Example

```python
import nirfmxinstr
import nirfmxlte

instr_session = None
lte_signal = None

try:
    # Create a new RFmx Session
    instr_session = nirfmxinstr.Session(resource_name="RFSA", option_string="")

    # Get LTE signal configuration
    lte_signal = instr_session.get_lte_signal_configuration()

    # Configure frequency reference
    instr_session.configure_frequency_reference(
        selector_string="", frequency_reference_source="OnboardClock", frequency_reference_frequency=10e6
    )

    # Configure RF settings
    lte_signal.configure_frequency(selector_string="", center_frequency=1.95e9)
    lte_signal.configure_reference_level(selector_string="", reference_level=0.0)
    lte_signal.configure_external_attenuation(selector_string="", external_attenuation=0.0)

    # Configure trigger
    lte_signal.configure_digital_edge_trigger(
        selector_string="",
        digital_edge_trigger_source="PFI0",
        digital_edge_trigger_edge=nirfmxlte.DigitalEdgeTriggerEdge.RISING_EDGE,
        trigger_delay=0.0,
        enable_trigger=False,
    )

    # Configure component carrier
    lte_signal.component_carrier.configure(
        selector_string="", component_carrier_bandwidth=10e6, component_carrier_frequency=0.0, cell_id=0
    )

    # Configure band and duplex scheme
    lte_signal.configure_band(selector_string="", band=1)
    lte_signal.configure_duplex_scheme(
        selector_string="",
        duplex_scheme=nirfmxlte.DuplexScheme.FDD,
        uplink_downlink_configuration=nirfmxlte.UplinkDownlinkConfiguration.CONFIGURATION_0,
    )

    # Configure auto DMRS detection
    lte_signal.configure_auto_dmrs_detection_enabled(
        selector_string="", auto_dmrs_detection_enabled=nirfmxlte.AutoDmrsDetectionEnabled.TRUE
    )

    # Select ModAcc measurement
    lte_signal.select_measurements(
        selector_string="", measurements=nirfmxlte.MeasurementTypes.MODACC, enable_all_traces=True
    )

    # Configure ModAcc measurement
    lte_signal.modacc.configuration.configure_synchronization_mode_and_interval(
        selector_string="",
        synchronization_mode=nirfmxlte.ModAccSynchronizationMode.SLOT,
        measurement_offset=0,
        measurement_length=1,
    )

    lte_signal.modacc.configuration.configure_evm_unit(
        selector_string="", evm_unit=nirfmxlte.ModAccEvmUnit.PERCENTAGE
    )

    lte_signal.modacc.configuration.configure_in_band_emission_mask_type(
        selector_string="", in_band_emission_mask_type=nirfmxlte.ModAccInBandEmissionMaskType.RELEASE_11_ONWARDS
    )

    lte_signal.modacc.configuration.configure_averaging(
        selector_string="", averaging_enabled=nirfmxlte.ModAccAveragingEnabled.FALSE, averaging_count=10
    )

    # Initiate measurement
    error_code = lte_signal.initiate(selector_string="", result_name="")

    # Retrieve results
    (
        mean_rms_composite_evm,
        max_peak_composite_evm,
        mean_frequency_error,
        peak_composite_evm_symbol_index,
        peak_composite_evm_subcarrier_index,
        peak_composite_evm_slot_index,
        error_code,
    ) = lte_signal.modacc.results.fetch_composite_evm(selector_string="", timeout=10.0)

    (
        mean_iq_origin_offset,
        mean_iq_gain_imbalance,
        mean_iq_quadrature_error,
        error_code,
    ) = lte_signal.modacc.results.fetch_iq_impairments(selector_string="", timeout=10.0)

    in_band_emission_margin, error_code = lte_signal.modacc.results.fetch_in_band_emission_margin(
        selector_string="", timeout=10.0
    )

    # Print Results
    print("------------------Measurements------------------")
    print(f"Mean RMS Composite EVM (% or dB)        : {mean_rms_composite_evm}")
    print(f"Max Peak Composite EVM (% or dB)        : {max_peak_composite_evm}")
    print(f"Peak Composite EVM Slot Index           : {peak_composite_evm_slot_index}")
    print(f"Peak Composite EVM Symbol Index         : {peak_composite_evm_symbol_index}")
    print(f"Peak Composite EVM Subcarrier Index     : {peak_composite_evm_subcarrier_index}")
    print(f"Mean Frequency Error (Hz)               : {mean_frequency_error}")
    print(f"Mean IQ Origin Offset (dBc)             : {mean_iq_origin_offset}")
    print(f"Mean IQ Gain Imbalance (dB)             : {mean_iq_gain_imbalance}")
    print(f"Mean IQ Quadrature Error (deg)          : {mean_iq_quadrature_error}")
    print(f"In-Band Emission Margin (dB)            : {in_band_emission_margin}")

except Exception as e:
    print("ERROR: " + str(e))

finally:
    # Close Session
    if lte_signal is not None:
        lte_signal.dispose()
        lte_signal = None
    if instr_session is not None:
        instr_session.close()
        instr_session = None
```

