/* tslint:disable */
/* eslint-disable */
/**
 * {{ api_title }}
 * {{ api_description | replace("\n", " ") | replace("\\", "\\\\") | replace("'", "\\'") }}
 *
 * The version of the OpenAPI document: {{ api_version }}
{% if contact_email %} * Contact: {{ contact_email }}
{% else %} * 
{% endif %} *
 * NOTE: This file is auto generated by openapi-ts-client.
 * https://github.com/fa-krug/openapi-ts-client
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
{% if model_imports %}
import type {
{% for import_name in model_imports | sort %}
  {{ import_name }},
{% endfor %}
} from '../models/index';
import {
{% for import_name in model_imports | sort %}
    {{ import_name }}FromJSON,
    {{ import_name }}ToJSON,
{% endfor %}
} from '../models/index';
{% endif %}

{% for request in request_interfaces %}
export interface {{ request.name }} {
{% for param in request.params %}
    {{ param.name }}{{ '?' if not param.required else '' }}: {{ param.type }};
{% endfor %}
}

{% endfor %}
/**
 * {{ class_description }}
 */
export class {{ class_name }} extends runtime.BaseAPI {

{% for method in methods %}
    /**
{% if method.description %}
     * {{ method.description }}
{% endif %}
     * {{ method.summary }}
     */
{% if method.has_request_params %}
    async {{ method.method_name }}Raw(requestParameters: {{ method.request_interface }}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<{{ method.return_type }}>> {
{% else %}
    async {{ method.method_name }}Raw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<{{ method.return_type }}>> {
{% endif %}
{% for validation in method.validations %}
        if (requestParameters['{{ validation.param }}'] == null) {
            throw new runtime.RequiredError(
                '{{ validation.param }}',
                'Required parameter "{{ validation.param }}" was null or undefined when calling {{ method.method_name }}().'
            );
        }

{% endfor %}
        const queryParameters: any = {};

{% for query_param in method.query_params %}
        if (requestParameters['{{ query_param.ts_name }}'] != null) {
            queryParameters['{{ query_param.original_name }}'] = requestParameters['{{ query_param.ts_name }}'];
        }

{% endfor %}
        const headerParameters: runtime.HTTPHeaders = {};

{% if method.has_body %}
        headerParameters['Content-Type'] = '{{ method.body_content_type | default("application/json") }}';

{% endif %}
{% for header_param in method.header_params %}
        if (requestParameters['{{ header_param.ts_name }}'] != null) {
            headerParameters['{{ header_param.original_name }}'] = String(requestParameters['{{ header_param.ts_name }}']);
        }

{% endfor %}
{% for sec in method.security %}
{% if sec.type == 'http' and sec.scheme == 'bearer' %}
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("{{ sec.name }}", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
{% elif sec.type == 'oauth2' %}
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("{{ sec.name }}", [{{ sec.scopes | map('tojson') | join(', ') }}]);
        }

{% elif sec.type == 'apiKey' %}
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["{{ sec.header_name }}"] = await this.configuration.apiKey("{{ sec.header_name }}"); // {{ sec.name }} authentication
        }

{% endif %}
{% endfor %}

        let urlPath = `{{ method.path }}`;
{% for path_param in method.path_params %}
        urlPath = urlPath.replace(`{${"{{ path_param.name }}"}}`, encodeURIComponent(String(requestParameters['{{ path_param.name }}'])));
{% endfor %}

        const response = await this.request({
            path: urlPath,
            method: '{{ method.http_method }}',
            headers: headerParameters,
            query: queryParameters,
{% if method.has_body %}
            body: {{ method.body_serializer }},
{% endif %}
        }, initOverrides);

{% if method.return_type == 'void' %}
        return new runtime.VoidApiResponse(response);
{% elif method.is_blob_return %}
        return new runtime.BlobApiResponse(response);
{% elif method.is_primitive_return %}
        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<{{ method.return_type }}>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
{% elif method.is_any_return %}
        return new runtime.JSONApiResponse<any>(response);
{% elif method.is_array_return %}
        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map({{ method.item_deserializer }}));
{% else %}
        return new runtime.JSONApiResponse(response, (jsonValue) => {{ method.return_deserializer }}(jsonValue));
{% endif %}
    }

    /**
{% if method.description %}
     * {{ method.description }}
{% endif %}
     * {{ method.summary }}
     */
{% if method.has_request_params %}
{% if method.has_all_optional_params %}
    async {{ method.method_name }}(requestParameters: {{ method.request_interface }} = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{{ method.return_type }}> {
{% else %}
    async {{ method.method_name }}(requestParameters: {{ method.request_interface }}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{{ method.return_type }}> {
{% endif %}
{% else %}
    async {{ method.method_name }}(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{{ method.return_type }}> {
{% endif %}
{% if method.return_type == 'void' %}
        await this.{{ method.method_name }}Raw({% if method.has_request_params %}requestParameters, {% endif %}initOverrides);
{% else %}
        const response = await this.{{ method.method_name }}Raw({% if method.has_request_params %}requestParameters, {% endif %}initOverrides);
        return await response.value();
{% endif %}
    }

{% endfor %}
}
{% for method in methods %}
{% for enum_def in method.enum_defs %}

/**
 * @export
 */
export const {{ enum_def.name }} = {
{% for value in enum_def.enum_values %}
    {{ value | title | replace('-', '') | replace('_', '') }}: '{{ value }}'{{ ',' if not loop.last else '' }}
{% endfor %}
} as const;
export type {{ enum_def.name }} = typeof {{ enum_def.name }}[keyof typeof {{ enum_def.name }}];
{% endfor %}
{% endfor %}
