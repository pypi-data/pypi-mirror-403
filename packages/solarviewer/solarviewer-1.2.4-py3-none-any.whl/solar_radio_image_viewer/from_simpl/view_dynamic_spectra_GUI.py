"""
Dynamic Spectrum Viewer & RFI Cleaning Tool
=============================================

Description:
    This graphical user interface (GUI) application is designed for viewing,
    cleaning, and processing dynamic spectra generated by the pipeline or
    'make_dynamic_spectra.py'. Specially tested with LOFAR data, the tool
    provides users with the ability to:
        1. View the dynamic spectrum.
        2. Flag and mask regions within the dynamic spectrum.
        3. Perform bandpass normalization.
        4. Extract active solar radio emissions from the dynamic spectrum.
        5. Save the cleaned dynamic spectrum as a FITS file.

Features:
    - Interactive visualization using Matplotlib integrated with PyQt5.
    - ROI (Region of Interest) selection for RFI (Radio Frequency Interference) flagging.
    - Cross-section mode for extracting and analyzing time and frequency slices.
    - Auto-scaling and adjustable visualization parameters.
    - Undo/Redo support for modification steps.
    - Option to view FITS file metadata via a menu command.

Dependencies:
    - Python 3.x
    - NumPy, SciPy, OpenCV (cv2)
    - Astropy
    - Matplotlib
    - PyQt5

Tested Environment:
    - This tool has been specifically tested with LOFAR data.

Usage:
    - Launch the application to view dynamic spectra.
    - Use the provided controls to mask unwanted regions, normalize the bandpass,
      and extract specific source features.
    - Use Undo (Ctrl+Z) and Redo (Ctrl+Y) to revert modifications.
    - Select "View Metadata" from the menu to see the FITS file header.
    - Save the processed dynamic spectrum as a FITS file for further analysis.

Authors:
    Soham Dey, Deepan Patra

Version:
    1.0

Date:
    6th February 2025

Notes:
    - Ensure that all required dependencies are installed.
    - For any queries or issues, please refer to the documentation.
"""

import sys
import os
import numpy as np
import numpy.ma as ma
try:
    import cv2
except ImportError:
    cv2 = None

from astropy.io import fits
from astropy.time import Time

import threading
from PyQt5.QtWidgets import (
    QMainWindow,
    QApplication,
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QSplitter,
    QAction,
    QFileDialog,
    QMessageBox,
    QStatusBar,
    QMenuBar,
    QLabel,
    QSlider,
    QComboBox,
    QFormLayout,
    QPushButton,
    QDockWidget,
    QDoubleSpinBox,
    QSpinBox,
    QCheckBox,
    QInputDialog,
    QGroupBox,
    QDialog,
    QTextEdit,
    QVBoxLayout as QVBoxLayoutDialog,
    QScrollArea,
    QFrame,
    QGridLayout,
    QLineEdit,
    QTableWidget,
    QTableWidgetItem,
    QHeaderView,
    QAbstractItemView,
    QTabWidget,
)
from PyQt5 import QtWidgets
from PyQt5.QtCore import Qt, pyqtSlot, QThread, pyqtSignal, QTimer
from PyQt5.QtGui import QFont, QColor

import matplotlib
import matplotlib.pyplot as plt
from matplotlib.colors import LogNorm, Normalize, PowerNorm
from matplotlib.dates import DateFormatter, date2num
from .simpl_theme import apply_theme, get_matplotlib_params, get_palette
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar,
)
from matplotlib.widgets import RectangleSelector


###############################################################################
#                           RFI CLEANING UTILITIES                            #
###############################################################################


def create_binary(data, thresh):
    """Create a binary DS: 0 where data < thresh, 1 where data >= thresh."""
    return np.where(data < thresh, 0.0, 1.0)


def region_detection(original_image, binary_image, min_width=1, min_height=5):
    """
    Finds closed contours in the binary image.
    Returns (closed_image, valid_contours, overlay_image).
    """
    binary_image_uint8 = np.uint8(binary_image * 255)
    kernel = np.ones((2, 2), np.uint8)
    closed_image = cv2.morphologyEx(binary_image_uint8, cv2.MORPH_CLOSE, kernel)
    contours, _ = cv2.findContours(
        closed_image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE
    )

    if len(original_image.shape) == 2:
        overlay_image = cv2.cvtColor(
            original_image.astype(np.float32), cv2.COLOR_GRAY2BGR
        )
    else:
        overlay_image = original_image.copy()

    valid_contours = []
    for contour in contours:
        x, y, w, h = cv2.boundingRect(contour)
        if w >= min_width and h >= min_height:
            valid_contours.append(contour)
            cv2.rectangle(overlay_image, (x, y), (x + w, y + h), (255, 0, 0), 3)
    return closed_image, valid_contours, overlay_image


def create_mask(original_binary, contours):
    """
    Create a mask with detected contours filled.
    """
    mask = np.zeros(original_binary.shape, dtype=np.uint8)
    for contour in contours:
        cv2.drawContours(mask, [contour], -1, 255, thickness=cv2.FILLED)
    return mask


def subtract_contours(original_image, mask):
    """
    Zero out the flagged (RFI) region in original_image.
    """
    result_image = original_image.copy()
    result_image[mask > 0] = 0
    return result_image


###############################################################################
#              MATPLOTLIB CANVAS FOR DYNAMIC SPECTRUM DISPLAY                 #
###############################################################################


class DynamicSpectrumCanvas(FigureCanvas):
    """
    A Matplotlib canvas for displaying a dynamic spectrum (time vs freq).
    """

    def __init__(self, parent=None):
        self.main_window = parent
        # Setup logging
        import logging

        self.logger = logging.getLogger("DynamicSpectrumCanvas")
        self.logger.setLevel(logging.DEBUG)

        # Apply initial theme settings to matplotlib
        self._apply_initial_theme()

        # Create figure with better DPI
        self.fig = plt.figure(figsize=(9, 6), dpi=100)
        self.ax = self.fig.add_subplot(111)
        super().__init__(self.fig)
        self.setParent(parent)
        
        # Ensure canvas background matches theme to avoid white gaps when scaling
        self.setStyleSheet("background-color: transparent;")

        # Set minimum size to avoid layout issues
        self.setMinimumSize(400, 300)

        self.ax.set_title("Dynamic Spectrum Viewer", fontsize=14)
        self.ax.set_xlabel("Time (UTC)", fontsize=12)
        self.ax.set_ylabel("Frequency (MHz)", fontsize=12)

        # Apply theme to the newly created canvas
        self._apply_canvas_theme_colors()

        # Internal references
        self._data = None  # Float array with NaNs
        self._time_axis = None
        self._freq_axis = None
        self._extent = None

        self._colorbar = None
        self._im = None
        self._date_cache = {} # Cache for time_axis -> utc_num mapping
        self._filename = "" 

        # Visualization parameters
        self._scale_mode = "Linear"  # Options: "Linear", "Log", "Sqrt", "Gamma"
        self._gamma = 1.0
        self._vmin = None
        self._vmax = None
        self._vmin_manual = None
        self._vmax_manual = None
        self._cmap = "inferno"
        self._smart_scale = (
            "0.5-99.5%"  # Options: "0-100%", "0.1-99.9%", "0.5-99.5%", "1-99%"
        )

        # Interactive ROI
        self.rect_selector = None
        self.roi_active = False
        self.roi_callback = None

        # Cross-section mode
        self.cross_section_active = False

        # Mouse hover info control
        self.hover_info_enabled = False  # Default disabled
        self._last_hover_text = ""  # Cache last hover text to avoid unnecessary redraws
        self._hover_throttle_counter = 0  # Throttle hover updates
        self._hover_throttle_limit = 3  # Update every N mouse events

        # Store event connection IDs for reconnection
        self._event_connections = {}
        self._connect_events()

        self._hover_text = self.ax.text(
            1.0,
            1.05,
            "",
            transform=self.ax.transAxes,
            ha="right",
            va="top",
            fontsize=10,
        )

        # Mode indicator overlay: centered at the top
        self._mode_text = self.ax.text(
            0.5,
            1.05,
            "",
            transform=self.ax.transAxes,
            ha="center",
            va="top",
            fontsize=11,
            fontweight="bold",
            visible=False
        )

        #self.fig.tight_layout()

    def _apply_initial_theme(self):
        """Apply dark theme as default for matplotlib."""
        # Use centralized params from simpl_theme
        params = get_matplotlib_params("dark")
        plt.rcParams.update(params)
        # Ensure grid is enabled
        plt.rcParams["axes.grid"] = True
        plt.rcParams["grid.alpha"] = 0.3

    def _apply_canvas_theme_colors(self):
        """Apply theme colors to the canvas elements."""
        # Get parent window to access theme information
        parent = self.parent()
        while parent is not None and not hasattr(parent, "current_theme"):
            parent = parent.parent()

        # Default to dark theme if no parent found
        theme_name = getattr(parent, "current_theme", "dark")
        
        # Get centralized params and palette
        params = get_matplotlib_params(theme_name)
        palette = get_palette(theme_name)

        # Set figure and axes background
        self.fig.patch.set_facecolor(params["figure.facecolor"])
        self.ax.set_facecolor(params["axes.facecolor"])

        # Set text and spine colors
        text_color = params["text.color"]
        self.ax.tick_params(colors=text_color)
        self.ax.xaxis.label.set_color(text_color)
        self.ax.yaxis.label.set_color(text_color)
        self.ax.title.set_color(text_color)

        for spine in self.ax.spines.values():
            spine.set_edgecolor(params["axes.edgecolor"])
            spine.set_linewidth(params.get("axes.linewidth", 1.4))

        # Update tick label sizes
        self.ax.tick_params(labelsize=params.get("font.size", 12))

        # Enable grid with theme colors
        self.ax.grid(True, color=params["grid.color"], alpha=0.3)

        # Update hover text colors
        if hasattr(self, "_hover_text"):
            bg_color = palette["window"]
            self._hover_text.set_color(text_color)
            self._hover_text.set_bbox(dict(facecolor=bg_color, alpha=0.8, edgecolor=palette["border"]))

        # Update mode text colors
        if hasattr(self, "_mode_text"):
            self._mode_text.set_color(palette.get("highlight", text_color))
            self._mode_text.set_bbox(dict(facecolor=palette["window"], alpha=0.9, edgecolor=palette["highlight"], pad=5))



    def _connect_events(self):
        """Connect all necessary event handlers"""
        # Disconnect existing connections if they exist
        self._disconnect_events()

        # Connect mouse events
        self._event_connections["button_press"] = self.mpl_connect(
            "button_press_event", self.on_mouse_click
        )
        self._event_connections["motion_notify"] = self.mpl_connect(
            "motion_notify_event", self.on_mouse_move
        )

        # If ROI selector is active, reconnect it
        if self.roi_active and self.roi_callback:
            self.enable_roi_selector(True, self.roi_callback)

    def _disconnect_events(self):
        """Disconnect all matplotlib event connections"""
        for event_id in self._event_connections.values():
            try:
                self.mpl_disconnect(event_id)
            except:
                pass
        self._event_connections = {}

    def clear_plot(self):
        """Clear the axes and remove the colorbar."""
        # Store current states before clearing
        roi_was_active = self.roi_active
        roi_callback = self.roi_callback
        cross_was_active = self.cross_section_active

        # Turn off rectangle selector before clearing
        if self.rect_selector is not None:
            try:
                self.rect_selector.set_active(False)
                self.rect_selector.set_visible(False)
                # For Matplotlib 3.x, disconnect events
                if hasattr(self.rect_selector, "disconnect_events"):
                    self.rect_selector.disconnect_events()
                # Invalidate the selector
                self.rect_selector = None
            except Exception as e:
                print(f"Error disabling selector: {e}")

        # Disconnect existing events before clearing
        self._disconnect_events()

        # Clear the axis
        self.ax.clear()

        # Reset basic axis properties
        self.ax.set_title(os.path.basename(self._filename) if self._filename else " ", fontsize=14)
        self.ax.set_xlabel("Time (UTC)", fontsize=12)
        self.ax.set_ylabel("Frequency (MHz)", fontsize=12)

        # Handle colorbar removal
        if self._colorbar is not None:
            try:
                self._colorbar.remove()
            except (AttributeError, ValueError):
                # Handle case where colorbar removal fails - recreate the figure
                self.fig.clf()
                self.ax = self.fig.add_subplot(111)

                # Reset basic axis properties
                self.ax.set_title(os.path.basename(self._filename) if self._filename else " ", fontsize=14)
                self.ax.set_xlabel("Time (UTC)", fontsize=12)
                self.ax.set_ylabel("Frequency (MHz)", fontsize=12)
            self._colorbar = None

        self._im = None
        self._extent = None

        # Recreate hover text after clearing with theme-aware colors
        parent = self.parent()
        while parent is not None and not hasattr(parent, "current_theme"):
            parent = parent.parent()

        # Set colors based on current theme
        if (
            parent
            and hasattr(parent, "current_theme")
            and parent.current_theme == "light"
        ):
            text_color = "black"
            bg_color = "white"
        else:
            text_color = "white"
            bg_color = "black"

        self._hover_text = self.ax.text(
            1.0,
            1.05,
            "",
            transform=self.ax.transAxes,
            ha="right",
            va="top",
            fontsize=10,
            color=text_color,
            bbox=dict(facecolor=bg_color, alpha=0.8),
        )

        # Reconnect event handlers
        self._connect_events()

        # Restore interactive features if they were active
        if roi_was_active and roi_callback:
            self.enable_roi_selector(True, roi_callback)

        self.cross_section_active = cross_was_active

    def set_data(self, data, time_axis=None, freq_axis=None, filename=""):
        """Set data and optional time and frequency axes."""
        self._data = data
        self._time_axis = time_axis
        self._freq_axis = freq_axis
        if filename:
            self._filename = filename

    def draw_spectrum(self, fast=False):
        """Plot the dynamic spectrum using the current visualization parameters.
        Set fast=True to skip expensive layout/colorbar updates for fluid navigation.
        """
        if fast and hasattr(self, '_im') and self._im is not None:
            # Fast update: we expect self._data to be (Time, Freq), 
            # so we always transpose for imshow(Freq, Time)
            data_ma = ma.masked_invalid(self._data)
            self._im.set_data(data_ma.T)
            
            if self._time_axis is not None and self._freq_axis is not None:
                # Use cached dates if possible to avoid expensive processing
                t_hash = hash(self._time_axis.tobytes())
                if t_hash in self._date_cache:
                    utc_num = self._date_cache[t_hash]
                else:
                    time_mjd = self._time_axis / 86400.0
                    utc_dt = Time(time_mjd, format="mjd", scale="utc").to_datetime()
                    utc_num = np.array([date2num(dt) for dt in utc_dt])
                    self._date_cache[t_hash] = utc_num

                self._extent = [utc_num[0], utc_num[-1], self._freq_axis[0], self._freq_axis[-1]]
                self._im.set_extent(self._extent)
                self.ax.set_xlim(self._extent[0], self._extent[1])
            
            self.draw_idle()
            return

        self.clear_plot()
        if self._data is None:
            self.draw()
            return

        # Reset axis limits before plotting
        self.ax.set_xlim(auto=True)
        self.ax.set_ylim(auto=True)

        data_ma = ma.masked_invalid(self._data)
        data_flat = data_ma.compressed()
        if len(data_flat) == 0:
            self._vmin, self._vmax = 0, 1
        else:
            if self._smart_scale == "0-100%":
                self._vmin, self._vmax = np.nanmin(data_flat), np.nanmax(data_flat)
            elif self._smart_scale == "0.1-99.9%":
                p01 = np.percentile(data_flat, 0.1)
                p999 = np.percentile(data_flat, 99.9)
                self._vmin, self._vmax = p01, p999
            elif self._smart_scale == "0.5-99.5%":
                p05 = np.percentile(data_flat, 0.5)
                p995 = np.percentile(data_flat, 99.5)
                self._vmin, self._vmax = p05, p995
            elif self._smart_scale == "1-99%":
                p1 = np.percentile(data_flat, 1)
                p99 = np.percentile(data_flat, 99)
                self._vmin, self._vmax = p1, p99
            elif self._smart_scale == "5-95%":
                p5 = np.percentile(data_flat, 5)
                p95 = np.percentile(data_flat, 95)
                self._vmin, self._vmax = p5, p95
            elif self._smart_scale == "Manual":
                if self._vmin_manual is not None and self._vmax_manual is not None:
                    self._vmin, self._vmax = self._vmin_manual, self._vmax_manual
                else:
                    # Fallback if manual not set yet
                    self._vmin, self._vmax = np.nanmin(data_flat), np.nanmax(data_flat)

        # Push limits to UI if in auto mode or just loaded
        if hasattr(self.main_window, "vminEntry") and not self.main_window.vminEntry.hasFocus():
             self.main_window.vminEntry.setText(f"{self._vmin:.4g}")
        if hasattr(self.main_window, "vmaxEntry") and not self.main_window.vmaxEntry.hasFocus():
             self.main_window.vmaxEntry.setText(f"{self._vmax:.4g}")

        if self._vmin == self._vmax:
            self._vmin -= 1e-9
            self._vmax += 1e-9

        if self._scale_mode == "Log":
            norm = LogNorm(vmin=max(self._vmin, 1e-12), vmax=self._vmax)
        elif self._scale_mode == "Sqrt":
            norm = PowerNorm(gamma=0.5, vmin=self._vmin, vmax=self._vmax)
        elif self._scale_mode == "Gamma":
            norm = PowerNorm(gamma=self._gamma, vmin=self._vmin, vmax=self._vmax)
        else:
            norm = Normalize(vmin=self._vmin, vmax=self._vmax)

        if (self._time_axis is None) or (self._freq_axis is None):
            self._im = self.ax.imshow(
                data_ma.T, aspect="auto", origin="lower", cmap=self._cmap, norm=norm
            )
            self.ax.set_xlabel("Time index")
            self.ax.set_ylabel("Frequency index")
        else:
            time_mjd = self._time_axis / 86400.0
            utc_dt = Time(time_mjd, format="mjd", scale="utc").to_datetime()
            utc_num = np.array([date2num(dt) for dt in utc_dt])
            self._extent = [
                utc_num[0],
                utc_num[-1],
                self._freq_axis[0],
                self._freq_axis[-1],
            ]
            
            # Internal normalized orientation is always (Time, Freq)
            # We transpose for imshow to get (Freq on Y, Time on X)
            self._im = self.ax.imshow(
                data_ma.T,
                aspect="auto",
                origin="lower",
                extent=self._extent,
                cmap=self._cmap,
                norm=norm,
            )
            
            #date_formatter = DateFormatter("%Y-%m-%d\n%H:%M:%S")
            date_formatter = DateFormatter("%H:%M:%S")
            self.ax.xaxis.set_major_formatter(date_formatter)
            self.fig.autofmt_xdate()
            
            # Add date to the label 
            start_date = utc_dt[0].strftime("%Y-%m-%d")
            self.ax.set_xlabel(f"Time (UTC) [{start_date}]")
            self.ax.set_ylabel("Frequency (MHz)")
            
            title = os.path.basename(self._filename) if self._filename else "Dynamic Spectrum"
            self.ax.set_title(title)

        #self._colorbar = self.fig.colorbar(self._im, ax=self.ax, label="Amplitude")
        self._colorbar = self.fig.colorbar(self._im, ax=self.ax)

        # Apply theme colors to the newly created colorbar
        self._apply_colorbar_theme()

        # Ensure the figure layout is updated
        self.fig.tight_layout()
        self.draw()

    def _apply_colorbar_theme(self):
        """Apply theme colors to the colorbar."""
        if self._colorbar is None:
            return

        # Get parent window to access theme information
        parent = self.parent()
        while parent is not None and not hasattr(parent, "current_theme"):
            parent = parent.parent()

        if parent is None or not hasattr(parent, "current_theme"):
            theme_name = "dark"
        else:
            theme_name = parent.current_theme

        # Define themes locally for matplotlib elements
        themes = {
            "dark": {
                "plot_bg": "#2b2b2b",
                "plot_text": "white",
                "plot_grid": "#505050",
            },
            "light": {
                "plot_bg": "#f0f0f0",
                "plot_text": "black",
                "plot_grid": "#cccccc",
            },
        }
        theme = themes.get(theme_name, themes["dark"])

        # Update colorbar text colors
        self._colorbar.ax.tick_params(colors=theme["plot_text"])
        self._colorbar.ax.yaxis.label.set_color(theme["plot_text"])

        # Update colorbar outline
        for spine in self._colorbar.ax.spines.values():
            spine.set_edgecolor(theme["plot_text"])

    def set_scale_mode(self, mode):
        self._scale_mode = mode
        self.draw_spectrum()

    def set_gamma(self, gamma):
        self._gamma = gamma
        if self._scale_mode == "Gamma":
            if hasattr(self, "_im") and self._im is not None:
                from matplotlib.colors import PowerNorm

                self._im.set_norm(
                    PowerNorm(gamma=self._gamma, vmin=self._vmin, vmax=self._vmax)
                )
                self.draw_idle()
            else:
                self.draw_spectrum()

    def set_cmap(self, cmap_name):
        self._cmap = cmap_name
        self.draw_spectrum()

    def set_smart_scale(self, scale_option):
        """Set the percentile scale option for auto scaling."""
        self._smart_scale = scale_option
        self.draw_spectrum()

    def set_manual_range(self, vmin, vmax):
        """Set manual vmin/vmax values."""
        self._vmin_manual = vmin
        self._vmax_manual = vmax
        if self._smart_scale == "Manual":
            self.draw_spectrum()

    def get_normalization(self, vmin, vmax):
        if self._scale_mode == "Log":
            return LogNorm(vmin=max(vmin, 1e-12), vmax=vmax)
        elif self._scale_mode == "Sqrt":
            return PowerNorm(gamma=0.5, vmin=vmin, vmax=vmax)
        elif self._scale_mode == "Gamma":
            return PowerNorm(gamma=self._gamma, vmin=vmin, vmax=vmax)
        else:
            return Normalize(vmin=vmin, vmax=vmax)

    # -------------------------- ROI Selector ------------------------------------
    def enable_roi_selector(self, enable, callback=None):
        """
        Enable or disable the ROI selection mode.
        When enabled, allows the user to draw a rectangle to select a region of interest.
        """
        self.roi_active = enable
        self.roi_callback = callback
        
        # Update cursor and overlay
        if enable:
            self.setCursor(Qt.CrossCursor)
            self._update_mode_overlay("MODE: MASK REGION (ROI)")
        else:
            self.setCursor(Qt.ArrowCursor)
            self._update_mode_overlay("")
        
        # Force immediate update of cursor if mouse is over canvas
        self._force_cursor_update()

        if enable:
            # Re-init RectangleSelector
            self.rect_selector = RectangleSelector(
                self.ax,
                self._roi_on_select,
                useblit=True,
                button=[1],
                interactive=True,
                props=dict(facecolor="#ff4d4d", edgecolor="#ff4d4d", alpha=0.4, fill=True, linewidth=1.5),
                handle_props=dict(marker='o', markersize=6, markerfacecolor="white", markeredgecolor="#ff4d4d", markeredgewidth=1.5)
            )

            self.draw_idle()
        else:
            # Disable RectangleSelector
            if self.rect_selector is not None:
                self.rect_selector.set_active(False)
                self.rect_selector.disconnect_events()
                self.rect_selector = None


            self._roi_start_point = None
            self._roi_current_rect = None

            self.draw_idle()



    def _roi_on_select(self, eclick, erelease):
        """Callback for RectangleSelector."""
        if self._data is None:
            return

        try:
            # Get Selection bounds
            start_x, start_y = eclick.xdata, eclick.ydata
            end_x, end_y = erelease.xdata, erelease.ydata
            
            # Edge case handling: Ensure we have data
            if None in [start_x, start_y, end_x, end_y]:
                return

            nt, nf = self._data.shape
            
            # Logic for data coordinate calculation based on extent
            if self._extent is not None:
                x0, x1_, y0, y1_ = self._extent
                
                # Selection bounds safely clipped to extent
                xmin, xmax = sorted([start_x, end_x])
                ymin, ymax = sorted([start_y, end_y])
                
                # Clip to plot boundaries
                xmin = max(x0, min(x1_, xmin))
                xmax = max(x0, min(x1_, xmax))
                ymin = max(y0, min(y1_, ymin))
                ymax = max(y0, min(y1_, ymax))
                
                if x1_ == x0 or y1_ == y0: return

                frac_xmin = (xmin - x0) / (x1_ - x0)
                frac_xmax = (xmax - x0) / (x1_ - x0)
                frac_ymin = (ymin - y0) / (y1_ - y0)
                frac_ymax = (ymax - y0) / (y1_ - y0)

            # nt, nf should be aligned with X, Y
            # In our normalized (Time, Freq) data:
            # Axis 0 (nt) is Time (X), Axis 1 (nf) is Freq (Y)
            # Internal data is normalized to (Time, Freq)
            # Axis 0 is Time (mapped to X), Axis 1 is Freq (mapped to Y)
            n_time, n_freq = self._data.shape
            
            idx_time_min = max(0, min(int(frac_xmin * (n_time - 1)), n_time - 1))
            idx_time_max = max(0, min(int(frac_xmax * (n_time - 1)), n_time - 1))
            idx_freq_min = max(0, min(int(frac_ymin * (n_freq - 1)), n_freq - 1))
            idx_freq_max = max(0, min(int(frac_ymax * (n_freq - 1)), n_freq - 1))

            # Trigger the actual masking with (Axis 0 [Time], Axis 1 [Freq]) indices
            if self.roi_callback and idx_time_min <= idx_time_max and idx_freq_min <= idx_freq_max:
                self.roi_callback(idx_time_min, idx_time_max, idx_freq_min, idx_freq_max)
                
            # Clear selector for next use
            if self.rect_selector:
                self.rect_selector.set_visible(False)
            
            self.draw_idle()

        except Exception as e:
            self.logger.error(f"Error in ROI selection: {e}")

    # --------------------- Cross-Section Mode -----------------------------------
    def enable_cross_section(self, enable):
        """Enable or disable the cross-section interactive mode."""
        self.cross_section_active = enable
        
        # Update cursor and overlay
        if enable:
            self.setCursor(Qt.CrossCursor)
            self._update_mode_overlay("MODE: CROSS SECTION")
        else:
            self.setCursor(Qt.ArrowCursor)
            self._update_mode_overlay("")
            
        self.draw_idle()
        
        # Force immediate update of cursor if mouse is over canvas
        self._force_cursor_update()

    def set_cursor(self, cursor):
        """Override Matplotlib's internal cursor setting to respect active modes."""
        if self.roi_active or self.cross_section_active:
            # While our custom interactive modes are on, we force the crosshair
            super().setCursor(Qt.CrossCursor)
        else:
            # Fallback to standard behavior (converting if it's an int from backend)
            if isinstance(cursor, int):
                # Matplotlib might pass an int, but super().setCursor expects QCursor
                super().setCursor(Qt.ArrowCursor)
            else:
                super().setCursor(cursor)

    def _force_cursor_update(self):
        """Force Qt to refresh the cursor under the mouse immediately."""
        try:
            from PyQt5.QtWidgets import QApplication
            app = QApplication.instance()
            if app:
                # Momentarily override and restore to force recalculation
                curr = self.cursor()
                app.setOverrideCursor(curr)
                app.restoreOverrideCursor()
        except:
            pass

    def _update_mode_overlay(self, text):
        """Update the on-canvas mode indicator text."""
        if not hasattr(self, "_mode_text"):
            return
            
        if text:
            self._mode_text.set_text(text)
            self._mode_text.set_visible(True)
        else:
            self._mode_text.set_visible(False)
        self.draw_idle()

    def on_mouse_click(self, event):
        if not self.cross_section_active or self._data is None:
            return
        if event.inaxes != self.ax or event.button != 1:
            return

        try:
            nt, nf = self._data.shape
            if self._extent is not None:
                x0, x1, y0, y1 = self._extent
                # Ensure valid division
                if x1 == x0 or y1 == y0:
                    return

                frac_x = (event.xdata - x0) / (x1 - x0)
                frac_y = (event.ydata - y0) / (y1 - y0)

                # Check if click is within valid data range
                if not (0 <= frac_x <= 1) or not (0 <= frac_y <= 1):
                    return

                time_idx = int(frac_x * (nt - 1))
                freq_idx = int(frac_y * (nf - 1))
            else:
                # Handle integer indices case
                if event.xdata is None or event.ydata is None:
                    return
                time_idx = int(event.xdata)
                freq_idx = int(event.ydata)

            # Ensure indices are within valid range
            time_idx = max(0, min(time_idx, nt - 1))
            freq_idx = max(0, min(freq_idx, nf - 1))

            options = [
                f"Time slice at freq_idx = {freq_idx}",
                f"Freq slice at time_idx = {time_idx}",
            ]
            choice, ok = QInputDialog.getItem(
                None, "Cross Section", "Which slice to plot?", options, 0, False
            )
            if not ok:
                return

            if choice.startswith("Time slice"):
                data_slice = self._data[:, freq_idx]
                self._plot_1d_time(data_slice, freq_idx)
            else:
                data_slice = self._data[time_idx, :]
                self._plot_1d_freq(data_slice, time_idx)
        except (ValueError, TypeError, IndexError) as e:
            # Handle any errors in coordinate conversion
            QMessageBox.warning(
                None,
                "Cross Section Error",
                f"Could not extract cross-section: {str(e)}",
            )

    def _plot_1d_time(self, data_slice, freq_idx):
        nt = data_slice.shape[0]

        # Get theme colors from parent window
        parent = self.parent()
        while parent is not None and not hasattr(parent, "current_theme"):
            parent = parent.parent()

        theme_name = getattr(parent, "current_theme", "dark")
        params = get_matplotlib_params(theme_name)
        text_color = params["text.color"]

        fig, ax = plt.subplots(facecolor=params["figure.facecolor"])
        ax.set_facecolor(params["axes.facecolor"])
        yvals = np.ma.masked_invalid(data_slice)

        if self._time_axis is not None:
            time_mjd = self._time_axis / 86400.0
            utc_dt = Time(time_mjd, format="mjd", scale="utc").to_datetime()
            xvals = np.array([date2num(dt) for dt in utc_dt])
            if np.any(np.diff(xvals) <= 0):
                xvals = np.linspace(xvals[0], xvals[-1], nt)
            ax.plot_date(xvals, yvals, "-", lw=1.5, color=text_color)
            date_formatter = DateFormatter("%H:%M:%S")
            ax.xaxis.set_major_formatter(date_formatter)
            fig.autofmt_xdate()
            xlabel = "Time (UTC)"
        else:
            xvals = np.linspace(0, nt - 1, nt)
            ax.plot(xvals, yvals, "-", lw=1.5, color=text_color)
            xlabel = "Time index"

        # Apply theme colors to all text elements
        ax.set_title(f"Time Slice @ freq_idx={freq_idx}", color=text_color)
        ax.set_xlabel(xlabel, color=text_color)
        #ax.set_ylabel("Amplitude", color=text_color)
        ax.tick_params(colors=text_color)

        # Set spine colors
        for spine in ax.spines.values():
            spine.set_edgecolor(params["axes.edgecolor"])
            spine.set_linewidth(params.get("axes.linewidth", 1.4))

        ax.tick_params(labelsize=params.get("font.size", 12))
        ax.tick_params(colors=text_color)

        fig.tight_layout()
        fig.show()

    def _plot_1d_freq(self, data_slice, time_idx):
        nf = data_slice.shape[0]

        # Get theme colors from parent window
        parent = self.parent()
        while parent is not None and not hasattr(parent, "current_theme"):
            parent = parent.parent()

        # Determine colors based on theme
        if parent and hasattr(parent, "current_theme"):
            theme_name = parent.current_theme
        else:
            theme_name = "dark"

        theme_name = getattr(parent, "current_theme", "dark")
        params = get_matplotlib_params(theme_name)
        text_color = params["text.color"]

        fig, ax = plt.subplots(facecolor=params["figure.facecolor"])
        ax.set_facecolor(params["axes.facecolor"])
        yvals = np.ma.masked_invalid(data_slice)

        if self._freq_axis is not None:
            xvals = self._freq_axis
            ax.plot(xvals, yvals, "-", lw=1.5, color=text_color)
            xlabel = "Frequency (MHz)"
        else:
            xvals = np.linspace(0, nf - 1, nf)
            ax.plot(xvals, yvals, "-", lw=1.5, color=text_color)
            xlabel = "Frequency index"

        # Apply theme colors to all text elements
        ax.set_title(f"Freq Slice @ time_idx={time_idx}", color=text_color)
        ax.set_xlabel(xlabel, color=text_color)
        #ax.set_ylabel("Amplitude", color=text_color)
        ax.tick_params(colors=text_color)

        # Set spine colors
        for spine in ax.spines.values():
            spine.set_edgecolor(params["axes.edgecolor"])
            spine.set_linewidth(params.get("axes.linewidth", 1.4))

        ax.tick_params(labelsize=params.get("font.size", 12))
        ax.tick_params(colors=text_color)

        fig.tight_layout()
        fig.show()

    # ------------------ Mouse Hover: Display Amplitude --------------------------
    def on_mouse_move(self, event):
        # Return immediately if in an interactive mode to ensure zero latency for tools
        if self.roi_active or self.cross_section_active:
            return

        # Check if hover info is enabled
        if not self.hover_info_enabled:
            # Only clear text and redraw if text was previously showing
            if self._last_hover_text:
                self._hover_text.set_text("")
                self._last_hover_text = ""
                self.draw_idle()
            return

        if event.inaxes != self.ax or self._data is None:
            # Only clear text and redraw if text was previously showing
            if self._last_hover_text:
                self._hover_text.set_text("")
                self._last_hover_text = ""
                self.draw_idle()
            return

        # Throttle hover updates to reduce CPU usage
        self._hover_throttle_counter += 1
        if self._hover_throttle_counter < self._hover_throttle_limit:
            return
        self._hover_throttle_counter = 0

        try:
            nt, nf = self._data.shape
            if self._extent is not None:
                x0, x1, y0, y1 = self._extent
                frac_x = (event.xdata - x0) / (x1 - x0)
                time_idx = round(frac_x * (nt - 1))
                frac_y = (event.ydata - y0) / (y1 - y0)
                freq_idx = round(frac_y * (nf - 1))
            else:
                time_idx = round(event.xdata)
                freq_idx = round(event.ydata)

            time_idx = max(0, min(time_idx, nt - 1))
            freq_idx = max(0, min(freq_idx, nf - 1))

            val = self._data[time_idx, freq_idx]
            if np.isnan(val):
                msg = f"Time={time_idx}, Freq={freq_idx}, Amp=NaN"
            else:
                msg = f"Time={time_idx}, Freq={freq_idx}, Amp={val:.3f}"

            # Only update and redraw if the text has changed
            if msg != self._last_hover_text:
                self._hover_text.set_text(msg)
                self._last_hover_text = msg
                self.draw_idle()

        except (TypeError, ValueError, IndexError) as e:
            # Handle any errors in coordinate conversion - only clear if needed
            if self._last_hover_text:
                self._hover_text.set_text("")
                self._last_hover_text = ""
                self.draw_idle()



###############################################################################
#                           MINIMAP CANVAS                                    #
###############################################################################

class MinimapCanvas(FigureCanvas):
    """A thin Matplotlib canvas for displaying the full-spectrum overview."""
    
    seekRequested = pyqtSignal(float) # Emits the target MJD offset / index

    def __init__(self, parent=None):
        self.fig, self.ax = plt.subplots(figsize=(10, 0.8))
        super(MinimapCanvas, self).__init__(self.fig)
        self.setParent(parent)
        
        # Ensure canvas background matches theme to avoid white gaps when scaling
        self.setStyleSheet("background-color: transparent;")
        
        self.ax.set_axis_off()
        self.fig.subplots_adjust(left=0.01, right=0.99, top=0.9, bottom=0.1)
        
        # Apply initial theme
        self._apply_theme()
        
        self._current_rect = None
        self._total_samples = 0
        self._view_width_pct = 1.0 # Current width of the highlight in percent
        self._bg_cache = None # Background cache for blitting
        self._last_cursor_is_hand = False 
        self._page_markers = [] # Store dashed line markers
        
        # Connect events
        self.mpl_connect('button_press_event', self._on_click)
        self.mpl_connect('motion_notify_event', self._on_drag)
        self.mpl_connect('button_release_event', self._on_release)
        self.mpl_connect('draw_event', self._on_draw)

    def _apply_theme(self):
        """Apply theme colors to the minimap."""
        parent = self.parent()
        while parent is not None and not hasattr(parent, "current_theme"):
            parent = parent.parent()

        theme_name = getattr(parent, "current_theme", "dark")
        params = get_matplotlib_params(theme_name)
        palette = get_palette(theme_name)
        
        # Use figure facecolor for background consistency
        bg_color = palette.get('base', '#2d2d4a')
        #bg_color = params["figure.facecolor"]
        self.fig.patch.set_facecolor(bg_color)
        self.ax.set_facecolor(bg_color)

    def set_full_data(self, data_downsampled):
        """Render the downsampled full spectrum with linear scale, 1-99 percentile, and bandpass normalization."""
        self.ax.clear()
        self.ax.set_axis_off()
        
        if data_downsampled is not None:
            # 1. Bandpass normalization (normalize by median of each channel across time)
            # data_downsampled is typically (freq, time)
            med = np.nanmedian(data_downsampled, axis=1, keepdims=True)
            med[np.isnan(med)] = 1e-20
            med[med == 0] = 1e-20
            data_normed = data_downsampled / med

            # 2. 1-99 percentile scaling on normalized data
            data_ma = ma.masked_invalid(data_normed)
            data_flat = data_ma.compressed()
            if len(data_flat) > 0:
                vmin = np.percentile(data_flat, 1)
                vmax = np.percentile(data_flat, 99)
            else:
                vmin, vmax = 0, 1
            
            # 3. Always use Linear Scale for minimap
            norm = Normalize(vmin=vmin, vmax=vmax)
            
            self.ax.imshow(data_normed, aspect='auto', cmap='inferno', 
                           interpolation='nearest', origin='lower', norm=norm)
            self._total_samples = data_downsampled.shape[1]
            
        self._current_rect = matplotlib.patches.Rectangle(
            (0, 0), 0, 1, transform=self.ax.get_xaxis_transform(),
            facecolor='red', alpha=0.3, edgecolor='red', animated=True
        )
        self.ax.add_patch(self._current_rect)
        
        # Clear existing markers on data reset
        self._page_markers = []

    def draw_page_markers(self, total_samples, window_samples):
        """Draw vertical dashed lines at page boundaries using absolute sample indices."""
        # 1. Clear existing marker artists
        for line in self._page_markers:
            try: line.remove()
            except Exception: pass
        self._page_markers = []
        
        # 2. Don't draw if mode is Full or data not loaded
        if window_samples >= total_samples or total_samples == 0:
            self.draw_idle()
            return
            
        # 3. Calculate boundary positions
        xlim = self.ax.get_xlim()
        width = xlim[1] - xlim[0]
        
        total_pages = int(np.ceil(total_samples / window_samples))
        max_markers = 80
        step_pages = 1
        if total_pages > max_markers:
            step_pages = int(np.ceil(total_pages / max_markers))

        # Start from first boundary
        for i in range(step_pages, total_pages, step_pages):
            sample_idx = i * window_samples
            if sample_idx >= total_samples: break
            
            x = xlim[0] + (sample_idx / total_samples) * width
            line = self.ax.axvline(x=x, color='white', linestyle='--', alpha=0.4, linewidth=0.8)
            self._page_markers.append(line)
        
        self.draw_idle()
        self.draw()
        # Capture background after initial draw
        self._bg_cache = self.fig.canvas.copy_from_bbox(self.ax.bbox)

    def update_view_window(self, start_idx, end_idx):
        """Update the position of the highlight rectangle."""
        if self._current_rect is None or self._total_samples == 0:
            return
            
        pass

    def update_view_percent(self, start_pct, end_pct):
        """Update highlight using 0.0-1.0 range."""
        if self._current_rect is None:
            return
        
        xlim = self.ax.get_xlim()
        width = xlim[1] - xlim[0]
        x = xlim[0] + start_pct * width
        w = (end_pct - start_pct) * width
        
        self._view_width_pct = (end_pct - start_pct)
        self._current_rect.set_xy((x, 0))
        self._current_rect.set_width(w)
        
        # Trigger a full redraw which will call _on_draw and refresh the cache
        self.draw_idle()

    def _on_draw(self, event):
        """Handle standard redraws by refreshing bg cache and manually drawing animated artist."""
        if self._current_rect is None: return
        
        # 1. Capture background BEFORE drawing the animated artist
        self._bg_cache = self.fig.canvas.copy_from_bbox(self.ax.bbox)
        
        # 2. Manually draw the animated artist so it appears in standard draws
        self.ax.draw_artist(self._current_rect)

    def _on_click(self, event):
        if event.inaxes != self.ax: return
        # Move rectangle immediately
        self._on_drag(event)

    def _on_release(self, event):
        if event.button == 1 and event.inaxes == self.ax:
            # Emit seek signal ONLY on release for final update
            self.seekRequested.emit(event.xdata)

    def _on_drag(self, event):
        if event.inaxes != self.ax or event.xdata is None:
            if self._last_cursor_is_hand:
                self.setCursor(Qt.ArrowCursor)
                self._last_cursor_is_hand = False
            return

        # Show hand cursor over the draggable rectangle (efficiently)
        rect_x = self._current_rect.get_x()
        rect_w = self._current_rect.get_width()
        is_over_rect = rect_x <= event.xdata <= rect_x + rect_w
        
        if is_over_rect != self._last_cursor_is_hand:
            self.setCursor(Qt.PointingHandCursor if is_over_rect else Qt.ArrowCursor)
            self._last_cursor_is_hand = is_over_rect

        if event.button == 1:
            if self._bg_cache is None: return
            
            # Move the rectangle locally for instant visual feedback
            xlim = self.ax.get_xlim()
            width = xlim[1] - xlim[0]
            
            # Center the window on the mouse
            center_pct = (event.xdata - xlim[0]) / width
            start_pct = max(0, min(1.0 - self._view_width_pct, center_pct - self._view_width_pct/2))
            
            x = xlim[0] + start_pct * width
            w = self._view_width_pct * width
            
            self._current_rect.set_xy((x, 0))
            self._current_rect.set_width(w)
            
            # BLITTING: Restore bg, redraw artist only, blit to screen
            self.fig.canvas.restore_region(self._bg_cache)
            self.ax.draw_artist(self._current_rect)
            self.fig.canvas.blit(self.ax.bbox)


class MainWindow(QMainWindow):
    def __init__(self, theme="dark"):
        super(MainWindow, self).__init__()
        self.setWindowTitle("Dynamic Spectra Viewer")
        self.resize(1500, 850)

        # Store theme from parameter (allows external theme override)
        self._external_theme = theme

        # Data placeholders
        self.hdul = None  # Store FITS handle to keep memmap alive
        self._original_unmodified = None  # For revert
        self._original_data = None  # Working data (float array with NaNs)
        self._time_axis = None
        self._freq_axis = None

        # Navigation / Paging state
        self._nav_mode = "Full" # "Full" or "Windowed"
        self._current_page = 0
        self._total_pages = 1
        self._window_duration_min = 20.0
        self._full_time_axis = None # Store the full time axis for indexing
        self._full_freq_axis = None # Store the full freq axis
        self._is_large_file = False

        # Performance / Smoothness state
        self._data_cache = {} # cache of {page_index: (data, time_axis)}
        self._cache_limit = 10 # Number of windows to keep in RAM
        self._pending_page = -1 # Track page undergoing full-res load
        self._full_lowres_data = None # Downsampled full spectrum in RAM
        self._lowres_skip = 1 # Skip factor for lowres data
        
        # Mask persistence
        self._pending_user_mask = None # Temporary storage for user mask during bandpass toggle
        self._global_masked_freq_indices = set() # Set of freq indices to be masked globally (Extend Mask)

        # Metadata storage (list of (name, header) for all HDUs)
        self._all_headers = []
        self._metadata = "" # Keep for compatibility, but _all_headers is primary
        self._metadata_dialog = None # Track the non-modal metadata window

        # Undo/Redo stacks (store copies of working data)
        self.undo_stack = []
        self.redo_stack = []

        # Theme management
        self.current_theme = (
            self._external_theme
            if self._external_theme in ["dark", "light"]
            else "dark"
        )

        self._is_bandpass_enabled = False # Persistent bandpass toggle

        self._setupLogger()
        self._createActions()
        self._createMenuBar()
        self._createMainWidgets()
        self._createStatusBar()

        self._applyStyle()
        self._updateNavigationStats() # Ensure initial navigation state is correct

        # Gamma debouncer
        self._gamma_timer = QTimer()
        self._gamma_timer.setSingleShot(True)
        self._gamma_timer.timeout.connect(self._apply_gamma_change)
        self._pending_gamma = 1.0

        # Connect resize event
        self.resizeTimer = None

    from contextlib import contextmanager

    @contextmanager
    def wait_cursor(self):
        """Context manager to show a wait cursor during long operations."""
        QApplication.setOverrideCursor(Qt.WaitCursor)
        try:
            yield
        finally:
            QApplication.restoreOverrideCursor()

    def _setupLogger(self):
        import logging

        self.logger = logging.getLogger("DynamicSpectrumViewer")
        self.logger.setLevel(logging.DEBUG)
        if not self.logger.handlers:
            ch = logging.StreamHandler()
            ch.setLevel(logging.DEBUG)
            formatter = logging.Formatter("%(asctime)s - %(levelname)s - %(message)s")
            ch.setFormatter(formatter)
            self.logger.addHandler(ch)

    # ------------------------- Actions and Menu -------------------------------
    def _createActions(self):
        self.openAct = QAction("&Open FITS...", self)
        self.openAct.setShortcut("Ctrl+O")
        self.openAct.triggered.connect(self.openFile)

        self.saveAct = QAction("&Save FITS...", self)
        self.saveAct.setShortcut("Ctrl+S")
        self.saveAct.triggered.connect(self.saveCleanedData)

        self.exitAct = QAction("E&xit", self)
        self.exitAct.setShortcut("Ctrl+Q")
        self.exitAct.triggered.connect(self.close)

        self.compareAct = QAction("Compare &Original vs Cleaned", self)
        self.compareAct.setShortcut("Ctrl+C")
        self.compareAct.triggered.connect(self.compareOriginalCleaned)

        self.revertAct = QAction("&Revert to Original", self)
        self.revertAct.setShortcut("Ctrl+R")
        self.revertAct.triggered.connect(self.revertToOriginal)

        # New Undo/Redo actions
        self.undoAct = QAction("&Undo", self)
        self.undoAct.setShortcut("Ctrl+Z")
        self.undoAct.triggered.connect(self.undo)

        self.redoAct = QAction("&Redo", self)
        self.redoAct.setShortcut("Ctrl+Y")
        self.redoAct.triggered.connect(self.redo)

        # New action for viewing metadata
        self.viewMetaAct = QAction("View &Metadata", self)
        self.viewMetaAct.triggered.connect(self.viewMetadata)

        # Theme toggle action
        #self.toggleThemeAct = QAction("Toggle &Dark/Light Theme", self)
        #self.toggleThemeAct.setShortcut("Ctrl+T")
        #self.toggleThemeAct.triggered.connect(self.toggleTheme)

    def _createMenuBar(self):
        menubar = QMenuBar(self)
        self.setMenuBar(menubar)

        fileMenu = menubar.addMenu("&File")
        fileMenu.addAction(self.openAct)
        fileMenu.addAction(self.saveAct)
        fileMenu.addSeparator()
        fileMenu.addAction(self.exitAct)

        editMenu = menubar.addMenu("&Edit")
        editMenu.addAction(self.undoAct)
        editMenu.addAction(self.redoAct)

        viewMenu = menubar.addMenu("&View")
        viewMenu.addAction(self.viewMetaAct)
        #viewMenu.addSeparator()
        #viewMenu.addAction(self.toggleThemeAct)

        toolsMenu = menubar.addMenu("&Tools")
        toolsMenu.addAction(self.compareAct)
        toolsMenu.addAction(self.revertAct)

    # -------------------------- Central Widgets ---------------------------------
    def _createMainWidgets(self):
        centralWidget = QWidget()
        self.setCentralWidget(centralWidget)
        mainLayout = QVBoxLayout(centralWidget)
        mainLayout.setContentsMargins(10, 10, 10, 10)
        mainLayout.setSpacing(10)

        # Use a splitter for a responsive left/right layout
        self.mainSplitter = QSplitter(Qt.Horizontal)
        self.mainSplitter.setHandleWidth(5)
        
        # --- LEFT SIDE: CANVAS AND NAVIGATION ---
        leftWidget = QWidget()
        leftLayout = QVBoxLayout(leftWidget)
        leftLayout.setContentsMargins(0, 0, 0, 0)
        leftLayout.setSpacing(10)

        self.canvas = DynamicSpectrumCanvas(self)
        self.current_filename = ""
        
        # Minimap Container
        self.minimap_container = QFrame()
        self.minimap_container.setObjectName("MinimapContainer")
        self.minimap_layout = QVBoxLayout(self.minimap_container)
        self.minimap_layout.setContentsMargins(0, 0, 0, 0)
        self.minimap_layout.setSpacing(0)
        
        self.minimap = MinimapCanvas(self)
        self.minimap.setFixedHeight(80)
        self.minimap.seekRequested.connect(self.onMinimapSeek)
        
        self.minimap_layout.addWidget(self.minimap)
        
        # Navigation Toolbar
        self.navbar = NavigationToolbar(self.canvas, self)
        
        # Add canvas components
        leftLayout.addWidget(self.canvas, 1)
        leftLayout.addWidget(self.minimap_container)
        leftLayout.addWidget(self.navbar)

        # --- RIGHT SIDE: CONTROL PANEL ---
        rightScroll = QScrollArea()
        rightScroll.setWidgetResizable(True)
        rightScroll.setFrameShape(QFrame.NoFrame)
        rightScroll.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        rightScroll.setMinimumWidth(320)
        
        controlPanel = QWidget()
        rightLayout = QVBoxLayout(controlPanel)
        rightLayout.setContentsMargins(10, 0, 5, 0)
        rightLayout.setSpacing(15)
        
        # 1. Visualization Settings Group
        visGroup = QGroupBox("Visualization")
        visLayout = QVBoxLayout(visGroup)
        visLayout.setSpacing(12)

        scaleForm = QFormLayout()
        scaleForm.setSpacing(10)
        
        self.scaleCombo = QComboBox()
        self.scaleCombo.addItems(["Linear", "Log", "Sqrt", "Gamma"])
        self.scaleCombo.setCurrentText("Linear")
        self.scaleCombo.currentTextChanged.connect(self.onScaleModeChanged)
        scaleForm.addRow("Intensity Scale:", self.scaleCombo)

        self.cmapCombo = QComboBox()
        cmaps = ["inferno", "viridis", "plasma", "magma", "cividis", "turbo", "jet", "gray", "bone", "afmhot", "cubehelix", "Greens", "gist_heat"]
        self.cmapCombo.addItems(cmaps)
        self.cmapCombo.setCurrentText("inferno")
        self.cmapCombo.currentTextChanged.connect(self.onCmapChanged)
        scaleForm.addRow("Colormap:", self.cmapCombo)

        self.scaleRangeCombo = QComboBox()
        self.scaleRangeCombo.addItems(["0-100%", "0.1-99.9%", "0.5-99.5%", "1-99%", "5-95%", "Manual"])
        self.scaleRangeCombo.setCurrentText("0.5-99.5%")
        self.scaleRangeCombo.currentTextChanged.connect(self.onScaleRangeChanged)
        scaleForm.addRow("Intensity Range:", self.scaleRangeCombo)
        
        # Min/Max Manual Controls
        self.vminEntry = QLineEdit()
        #self.vminEntry.setFixedWidth(60)
        self.vminEntry.setMinimumWidth(50)
        self.vminEntry.setPlaceholderText("Min")
        self.vminEntry.editingFinished.connect(self.onManualRangeChanged)
        
        self.vmaxEntry = QLineEdit()
        #self.vmaxEntry.setFixedWidth(60)
        self.vmaxEntry.setMinimumWidth(50)
        self.vmaxEntry.setPlaceholderText("Max")
        self.vmaxEntry.editingFinished.connect(self.onManualRangeChanged)
        
        rangeInputLayout = QHBoxLayout()
        rangeInputLayout.addStretch()
        rangeInputLayout.addWidget(self.vminEntry)
        rangeInputLayout.addWidget(QLabel("-"))
        rangeInputLayout.addWidget(self.vmaxEntry)
        rangeInputLayout.addStretch()
        self.manualLimitsLabel = QLabel("Manual Limits:")
        scaleForm.addRow(self.manualLimitsLabel, rangeInputLayout)

        
        self.vminEntry.setEnabled(False)
        self.vmaxEntry.setEnabled(False)
        self.manualLimitsLabel.setEnabled(False)
        
        visLayout.addLayout(scaleForm)
        
        self.gammaLabel = QLabel("Gamma:")
        self.gammaSlider = QSlider(Qt.Horizontal)
        self.gammaSlider.setObjectName("GammaSlider")
        self.gammaSlider.setRange(1, 300)
        self.gammaSlider.setValue(100)
        self.gammaSlider.valueChanged.connect(self.onGammaChanged)
        self.gammaSlider.sliderReleased.connect(self._apply_gamma_change)
        self.gammaLabel.setEnabled(False)
        self.gammaSlider.setEnabled(False)

        # Gamma section wrapped in its own layout for tight spacing
        gammaControlLayout = QVBoxLayout()
        gammaControlLayout.setSpacing(4) 
        gammaControlLayout.setContentsMargins(0, 0, 0, 0)
        gammaControlLayout.addWidget(self.gammaLabel)
        gammaControlLayout.addWidget(self.gammaSlider)
        
        visLayout.addLayout(gammaControlLayout)
        
        rightLayout.addWidget(visGroup)

        # 2. Tools Group
        toolsGroup = QGroupBox("Processing")
        toolsLayout = QVBoxLayout(toolsGroup)
        toolsLayout.setSpacing(10)
        
        # --- RFI Masking Section ---
        maskLabel = QLabel("RFI Masking")
        maskLabel.setStyleSheet("color: #a0a0b0; font-size: 9pt; font-weight: bold; text-transform: uppercase; letter-spacing: 0.5px;")
        toolsLayout.addWidget(maskLabel)
        
        self.roiButton = QPushButton(" Draw Mask Region")
        self.roiButton.setCheckable(True)
        self.roiButton.setToolTip("Click and drag to mask a region (time & frequency).")
        self.roiButton.toggled.connect(self.onRoiToggled)
        toolsLayout.addWidget(self.roiButton)
        
        # Mask Extensions
        maskToolsLayout = QHBoxLayout()
        maskToolsLayout.setSpacing(10)
        
        self.extendMaskBtn = QPushButton(" Extend")
        self.extendMaskBtn.setToolTip("Mask the currently flagged frequencies across all time.")
        self.extendMaskBtn.clicked.connect(self.onExtendMask)
        
        self.clearMaskBtn = QPushButton(" Clear")
        self.clearMaskBtn.setToolTip("Clear all manual masks and global frequency masks.")
        self.clearMaskBtn.clicked.connect(self.onClearMasks)
        
        maskToolsLayout.addWidget(self.extendMaskBtn)
        maskToolsLayout.addWidget(self.clearMaskBtn)
        toolsLayout.addLayout(maskToolsLayout)

        '''self.detectBtn = QPushButton(" Auto-Detect RFI")
        self.detectBtn.setToolTip("Auto-detect RFI.")
        self.detectBtn.clicked.connect(self.onCleanRFIRegionDetect)
        toolsLayout.addWidget(self.detectBtn)'''
        
        # Separator
        sep = QFrame()
        sep.setFrameShape(QFrame.HLine)
        sep.setFrameShadow(QFrame.Sunken)
        #sep.setStyleSheet("background-color: rgba(128, 128, 128, 0.2); margin-top: 5px; margin-bottom: 5px;")
        sep.setStyleSheet("background-color: transparent; margin-top: 5px; margin-bottom: 5px;")
        toolsLayout.addWidget(sep)

        # --- Analysis Section ---
        analysisLabel = QLabel("Analysis")
        analysisLabel.setStyleSheet("color: #a0a0b0; font-size: 9pt; font-weight: bold; text-transform: uppercase; letter-spacing: 0.5px;")
        toolsLayout.addWidget(analysisLabel)
         
        self.crossBtn = QPushButton("  Cross Section")
        self.crossBtn.setCheckable(True)
        self.crossBtn.setToolTip("Click on the plot to view 1D time or frequency profiles.")
        self.crossBtn.toggled.connect(self.onCrossSectionToggled)
        toolsLayout.addWidget(self.crossBtn)
       
        self.normBtn = QPushButton(" Bandpass Norm")
        self.normBtn.setCheckable(True)
        self.normBtn.setToolTip("Normalize spectrum by time-averaged frequency profile.")
        self.normBtn.toggled.connect(self.onBandpassNorm)
        toolsLayout.addWidget(self.normBtn)
        
        '''self.hoverCheck = QCheckBox("Show Hover Info")
        self.hoverCheck.setChecked(True)
        self.hoverCheck.toggled.connect(self.onHoverInfoToggled)
        toolsLayout.addWidget(self.hoverCheck)'''
        
        rightLayout.addWidget(toolsGroup)

        # 3. Navigation Group
        self.navGroup = QGroupBox("Time Navigation")
        navLayout = QVBoxLayout(self.navGroup)
        navLayout.setSpacing(10)
        
        modeForm = QFormLayout()
        self.navModeCombo = QComboBox()
        self.navModeCombo.addItems(["Full Spectrum", "Windowed"])
        self.navModeCombo.currentTextChanged.connect(self.onNavModeChanged)
        modeForm.addRow("View Mode:", self.navModeCombo)
        
        self.navDurationSpin = QDoubleSpinBox()
        self.navDurationSpin.setRange(1.0, 1440.0)
        self.navDurationSpin.setValue(20.0)
        self.navDurationSpin.setSuffix(" min")
        self.navDurationSpin.valueChanged.connect(self.onNavDurationChanged)
        self.navDurationLabel = QLabel("Window Size:")
        modeForm.addRow(self.navDurationLabel, self.navDurationSpin)
        
        navLayout.addLayout(modeForm)
        
        navBtnLayout = QHBoxLayout()
        navBtnLayout.setSpacing(8)
        navBtnLayout.setAlignment(Qt.AlignCenter)
        
        # Get palette for consistent styling
        palette = get_palette(self.current_theme)
        disabled_color = palette["disabled"]
        highlight = palette["highlight"]
        
        # Premium style for navigation buttons
        nav_btn_style = f"""
            QPushButton {{
                background-color: transparent;
                border: 1px solid rgba(120, 120, 150, 0.3);
                border-radius: 6px;
                padding: 2px;
                font-size: 13pt;
                font-weight: bold;
                min-width: 32px;
                max-width: 32px;
                min-height: 28px;
            }}
            QPushButton:hover {{
                background-color: rgba(99, 102, 241, 0.15);
                border-color: {highlight};
            }}
            QPushButton:pressed {{
                background-color: rgba(99, 102, 241, 0.25);
            }}
            QPushButton:disabled {{
                border-color: transparent;
                color: {disabled_color};
                opacity: 0.5;
            }}
        """

        self.firstBtn = QPushButton("")
        self.firstBtn.setToolTip("First Page")
        self.firstBtn.setStyleSheet(nav_btn_style)
        self.firstBtn.clicked.connect(self.onFirstPage)
        
        self.prevBtn = QPushButton("")
        self.prevBtn.setToolTip("Previous Page")
        self.prevBtn.setStyleSheet(nav_btn_style)
        self.prevBtn.clicked.connect(self.onPrevPage)
        
        self.nextBtn = QPushButton("")
        self.nextBtn.setToolTip("Next Page")
        self.nextBtn.setStyleSheet(nav_btn_style)
        self.nextBtn.clicked.connect(self.onNextPage)
        
        self.lastBtn = QPushButton("")
        self.lastBtn.setToolTip("Last Page")
        self.lastBtn.setStyleSheet(nav_btn_style)
        self.lastBtn.clicked.connect(self.onLastPage)
        
        # Arrange in a single row: [First] [Prev]  Page X of Y  [Next] [Last]
        self.pageLabel = QLabel("1/1")
        self.pageLabel.setAlignment(Qt.AlignCenter)
        self.pageLabel.setStyleSheet(f"""
            QLabel {{
                font-size: 10pt;
                font-weight: 500;
                min-width: 25px;
                color: {palette['text']};
            }}
            QLabel:disabled {{
                color: {disabled_color};
            }}
        """)
        
        navBtnLayout.addWidget(self.firstBtn)
        navBtnLayout.addWidget(self.prevBtn)
        navBtnLayout.addSpacing(10)
        navBtnLayout.addWidget(self.pageLabel)
        navBtnLayout.addSpacing(10)
        navBtnLayout.addWidget(self.nextBtn)
        navBtnLayout.addWidget(self.lastBtn)
        
        navLayout.addLayout(navBtnLayout)
        
        rightLayout.addWidget(self.navGroup)
        #self.navGroup.hide() # Hidden until data loaded

        rightLayout.addStretch()
        
        rightScroll.setWidget(controlPanel)
        
        # Add widgets to splitter
        self.mainSplitter.addWidget(leftWidget)
        self.mainSplitter.addWidget(rightScroll)
        
        # Initial proportions
        self.mainSplitter.setStretchFactor(0, 4)
        self.mainSplitter.setStretchFactor(1, 1)
        
        mainLayout.addWidget(self.mainSplitter)

    # ---------------------------- Status Bar ------------------------------------
    def _createStatusBar(self):
        self.amplitudeLabel = QLabel("")
        self.statusBar().addPermanentWidget(self.amplitudeLabel)

    # --------------------- View Metadata Dialog ---------------------------------
    def viewMetadata(self):
        """Show all FITS HDU metadata."""
        if not self._all_headers:
            QMessageBox.information(self, "Metadata", "No metadata available.")
            return

        # If a dialog is already open, raise it and return
        if self._metadata_dialog is not None:
            self._metadata_dialog.raise_()
            self._metadata_dialog.activateWindow()
            return

        # Fetch authoritative palette from simpl_theme
        palette = get_palette(self.current_theme)
        
        # Create a non-modal dialog 
        dlg = QDialog(self, Qt.Window)
        self._metadata_dialog = dlg
        dlg.setAttribute(Qt.WA_DeleteOnClose)
        
        def on_close():
            self._metadata_dialog = None
        dlg.finished.connect(on_close)
        dlg.setWindowTitle("FITS File Metadata")
        dlg.setMinimumSize(750, 750)
        
        # We rely on the global stylesheet applied in __init__ via apply_theme.
        # Minimal dialog-specific tweaks for layout spacing
        dlg.setStyleSheet(dlg.styleSheet() + f"""
            QDialog {{ background-color: {palette['window']}; }}
            QTableWidget {{ border: none; }}
        """)

        main_layout = QVBoxLayout(dlg)
        main_layout.setSpacing(0)
        main_layout.setContentsMargins(0, 0, 0, 0)
        
        # Compact Aesthetic Source Info
        source_container = QWidget()
        source_layout = QHBoxLayout(source_container)
        source_layout.setContentsMargins(35, 20, 35, 0)
        
        source_label = QLabel(f" {os.path.basename(self.current_filename)}")
        source_label.setStyleSheet(f"""
            font-size: 11pt; 
            font-weight: 600; 
            color: {palette['text_secondary']};
            background: {palette['button']};
            padding: 4px 12px;
            border-radius: 6px;
        """)
        source_layout.addWidget(source_label)
        source_layout.addStretch()
        main_layout.addWidget(source_container)
        
        # Search area - Styled precisely like SolarViewer
        search_widget = QWidget()
        search_layout = QHBoxLayout(search_widget)
        search_layout.setContentsMargins(35, 15, 35, 20) 
        search_layout.setSpacing(15)
        
        search_label = QLabel(" Search:")
        search_label.setStyleSheet(f"font-weight: 600; font-size: 11.5pt; color: {palette['text_secondary']};")
        search_layout.addWidget(search_label)
        
        search_input = QLineEdit()
        search_input.setPlaceholderText("Filter headers across all columns...")
        search_layout.addWidget(search_input)
        main_layout.addWidget(search_widget)
        
        # Tab Widget Container
        tab_container = QWidget()
        tab_container_layout = QVBoxLayout(tab_container)
        tab_container_layout.setContentsMargins(35, 0, 35, 20)
        
        tab_widget = QTabWidget()
        tab_container_layout.addWidget(tab_widget)
        main_layout.addWidget(tab_container)
        
        # Typography for technical data
        mono_font = QFont("Monospace", 11)
        mono_font.setStyleHint(QFont.TypeWriter)
        bold_mono = QFont(mono_font)
        bold_mono.setBold(True)
        
        for hdu_name, hdu_header in self._all_headers:
            table = QTableWidget()
            table.setColumnCount(3)
            table.setHorizontalHeaderLabels(["Keyword", "Value", "Comment"])
            table.verticalHeader().setVisible(False)
            table.setSelectionBehavior(QAbstractItemView.SelectRows)
            table.setEditTriggers(QAbstractItemView.NoEditTriggers)
            table.setAlternatingRowColors(True)
            table.setShowGrid(False)
            
            h_header = table.horizontalHeader()
            h_header.setSectionResizeMode(0, QHeaderView.ResizeToContents)
            h_header.setSectionResizeMode(1, QHeaderView.ResizeToContents)
            h_header.setSectionResizeMode(2, QHeaderView.ResizeToContents)
            h_header.setDefaultAlignment(Qt.AlignLeft | Qt.AlignVCenter)
            
            cards = hdu_header.cards
            table.setRowCount(len(cards))
            for i, card in enumerate(cards):
                k = QTableWidgetItem(str(card.keyword))
                k.setFont(bold_mono)
                
                v = QTableWidgetItem(str(card.value) if card.value is not None else "")
                v.setFont(mono_font)
                
                c = QTableWidgetItem(str(card.comment) if card.comment else "")
                c.setFont(mono_font)
                c.setForeground(QColor(palette['text_secondary']))
                
                table.setItem(i, 0, k)
                table.setItem(i, 1, v)
                table.setItem(i, 2, c)
            
            table.setViewportMargins(5, 5, 5, 5)
            tab_widget.addTab(table, hdu_name)
        
        def filter_active_tab(text):
            text = text.lower()
            tbl = tab_widget.currentWidget()
            if not tbl: return
            for i in range(tbl.rowCount()):
                match = any(text in (tbl.item(i, j).text().lower() if tbl.item(i, j) else "") 
                           for j in range(tbl.columnCount()))
                tbl.setRowHidden(i, not match)
        
        search_input.textChanged.connect(filter_active_tab)
        tab_widget.currentChanged.connect(lambda: filter_active_tab(search_input.text()))
        
        # Bottom Bar
        bottom_bar = QFrame()
        bottom_bar.setFixedHeight(95)
        bottom_bar.setStyleSheet(f"border-top: 1px solid {palette['border']};")
        b_layout = QHBoxLayout(bottom_bar)
        b_layout.setContentsMargins(35, 0, 35, 0)
        b_layout.setSpacing(20)
        
        copy_btn = QPushButton(" Copy to Clipboard")
        copy_btn.clicked.connect(self._copy_metadata_to_clipboard)
        b_layout.addWidget(copy_btn)
        
        b_layout.addStretch()
        
        close_btn = QPushButton("Close")
        close_btn.setFixedWidth(140)
        close_btn.setStyleSheet("font-weight: bold;")
        close_btn.clicked.connect(dlg.close)
        b_layout.addWidget(close_btn)
        
        main_layout.addWidget(bottom_bar)
        dlg.show()

    def _copy_metadata_to_clipboard(self):
        """Format and copy all metadata to clipboard."""
        if not self._all_headers: return
        
        lines = []
        for hdu_name, hdu_header in self._all_headers:
            lines.append(f"=== HDU: {hdu_name} ===")
            lines.append(str(hdu_header))
            lines.append("\n")
            
        text = "\n".join(lines)
        QApplication.clipboard().setText(text)
        self.statusBar().showMessage("Metadata copied to clipboard", 3000)

    def _applyStyle(self):
        """Apply the global application theme."""
        app = QApplication.instance()
        if app:
            apply_theme(app, self.current_theme)
        
        # Redraw canvas if it exists to pick up matplotlib theme changes
        if hasattr(self, "canvas"):
            self.canvas._apply_canvas_theme_colors()
            self.canvas.draw()
        
        # Also update minimap theme
        if hasattr(self, "minimap"):
            self.minimap._apply_theme()
            
            # Apply border to the container
            palette = get_palette(self.current_theme)
            if self.current_theme == "dark":
                border_color = palette.get('border_light', palette['border'])
            else:
                border_color = palette.get('border', palette['border'])
            self.minimap_container.setStyleSheet(f"""
                QFrame#MinimapContainer {{
                    border: 1px solid {border_color};
                    border-radius: 6px;
                    background-color: transparent;
                }}
            """)
            self.minimap.draw()

        # Set hand cursor for all interactive elements programmatically
        self._setHandCursorRecursive(self)

        # Update status message
        self.statusBar().showMessage(f"Switched to {self.current_theme} theme", 3000)

    def _setHandCursorRecursive(self, widget):
        """Recursively set PointingHandCursor for all buttons and interactive widgets."""
        from PyQt5.QtWidgets import QAbstractButton, QComboBox, QTabBar, QMenu, QMenuBar
        
        # Check if this widget should have a hand cursor
        if isinstance(widget, (QAbstractButton, QComboBox, QMenu, QMenuBar)):
            widget.setCursor(Qt.PointingHandCursor)
        
        # For QTabWidget, we need to set it on the bar
        if isinstance(widget, QTabBar):
            widget.setCursor(Qt.PointingHandCursor)
            
        # Recurse into children
        for child in widget.children():
            if isinstance(child, QtWidgets.QWidget):
                self._setHandCursorRecursive(child)

    # ---------------------------- File Operations -------------------------------
    def openFile(self):
        fileName, _ = QFileDialog.getOpenFileName(
            self, "Open FITS File", "", "FITS Files (*.fits *.fts);;All Files (*)"
        )
        if not fileName:
            return
        
        with self.wait_cursor():
            self.current_filename = fileName
                
            try:
                # Close previous file handle if any
                if hasattr(self, "hdul") and self.hdul:
                    self.hdul.close()
                self._data_cache.clear()

                self.logger.info(f"Opening FITS file: {fileName}")
                self.hdul = fits.open(fileName, memmap=True)
                header = self.hdul[0].header
                data_ref = self.hdul[0].data
                
                # Capture metadata from all HDUs
                self._all_headers = []
                for i, hdu in enumerate(self.hdul):
                    name = hdu.name if hdu.name else f"HDU {i}"
                    self._all_headers.append((name, hdu.header))
                
                self._metadata = str(header)
                
                # Detect if large (e.g., > 10^7 pixels)
                num_pixels = data_ref.size
                self._is_large_file = num_pixels > 1e7 or data_ref.shape[0] > 10000
                
                time_axis = None
                freq_axis = None

                # Robust axis extraction (using the logic we built)
                for hdu in self.hdul:
                    if hdu.name.upper() == "TIME_AXIS":
                        time_axis = hdu.data["TIME_MJD"] * 86400.0
                    if hdu.name.upper() == "FREQ_AXIS":
                        freq_axis = hdu.data["FREQ_MHz"]

                if time_axis is None or freq_axis is None:
                    try:
                        naxis1 = header.get("NAXIS1", data_ref.shape[1] if len(data_ref.shape) > 1 else 0)
                        naxis2 = header.get("NAXIS2", data_ref.shape[0])
                        for ax_idx in [1, 2]:
                            ctype = str(header.get(f"CTYPE{ax_idx}", "")).upper()
                            cunit = str(header.get(f"CUNIT{ax_idx}", "")).lower()
                            crval = header.get(f"CRVAL{ax_idx}", 0)
                            cdelt = header.get(f"CDELT{ax_idx}", 1)
                            crpix = header.get(f"CRPIX{ax_idx}", 1)
                            naxis = naxis1 if ax_idx == 1 else naxis2
                            if "FREQ" in ctype:
                                freqs = crval + (np.arange(naxis) - (crpix - 1)) * cdelt
                                if cunit == "hz": freqs /= 1e6
                                elif cunit == "khz": freqs /= 1000.0
                                elif cunit == "ghz": freqs *= 1000.0
                                freq_axis = freqs
                            elif "TIME" in ctype:
                                start_mjd = 0
                                if crval > 2400000.5: start_mjd = crval - 2400000.5
                                elif 30000 < crval < 100000: start_mjd = crval
                                else:
                                    date_obs = header.get("DATE-OBS", None)
                                    if date_obs:
                                        from astropy.time import Time as AstroTime
                                        start_mjd = AstroTime(date_obs).mjd
                                cdelt_s = cdelt * (86400.0 if cunit == "d" else 3600.0 if cunit == "h" else 60.0 if cunit == "min" else 0.001 if cunit == "ms" else 1.0)
                                time_axis = (start_mjd * 86400.0) + (np.arange(naxis) - (crpix - 1)) * cdelt_s
                    except Exception as wcs_err:
                        self.logger.warning(f"Axis extraction error: {wcs_err}")

                self._full_time_axis = time_axis
                self._full_freq_axis = freq_axis
                
                # Feature 2: Load Minimap (Full spectrum overview) - Always load for all files
                # Downsample significantly (e.g., 2000 points wide)
                total_samples = len(self._full_time_axis)
                self._lowres_skip = max(1, total_samples // 2000)
                skip = self._lowres_skip
                
                # Slicing the memmapped data carefully
                if data_ref.shape[0] == total_samples:
                    # (time, freq)
                    mini_data = data_ref[::skip, :]
                    mini_data_for_display = mini_data.T
                    # RAM overview normalized to (time, freq)
                    self._full_lowres_data = np.array(mini_data, dtype=np.float32)
                else:
                    # (freq, time)
                    mini_data = data_ref[:, ::skip]
                    mini_data_for_display = mini_data
                    # RAM overview normalized to (time, freq)
                    self._full_lowres_data = np.array(mini_data.T, dtype=np.float32)
                
                # Convert to RAM for minimap and instant preview
                self._full_lowres_data[np.isnan(self._full_lowres_data)] = np.nan
                self._full_lowres_data[np.isinf(self._full_lowres_data)] = np.nan
                
                self.minimap.set_full_data(np.array(mini_data_for_display, dtype=np.float32))
                
                # Initialize Navigation
                if self._is_large_file:
                    self._nav_mode = "Windowed"
                    self.navModeCombo.blockSignals(True)
                    self.navModeCombo.setCurrentText("Windowed")
                    self.navModeCombo.blockSignals(False)
                else:
                    self._nav_mode = "Full"
                    self.navModeCombo.blockSignals(True)
                    self.navModeCombo.setCurrentText("Full Spectrum")
                    self.navModeCombo.blockSignals(False)

                self._current_page = 0
                self._updateNavigationStats()

                if self._nav_mode == "Windowed":
                    self.loadSlice() # Initial load
                else:
                    # Load everything (copy to RAM)
                    data = np.array(data_ref, dtype=np.float32)
                    data[np.isnan(data)] = np.nan
                    data[np.isinf(data)] = np.nan
                    
                    # Use centralized display logic to honor persistent toggles (Bandpass, etc.)
                    self._display_data(data, self._full_time_axis, self._full_freq_axis)

                self.undo_stack.clear()
                self.redo_stack.clear()
                self.statusBar().showMessage(f"Loaded {os.path.basename(fileName)}", 5000)

            except Exception as e:
                self.logger.exception(f"Failed to open or plot FITS file: {e}")
                QMessageBox.critical(self, "Error", f"Failed to open FITS file:\n{e}")

    # -------------------------- Paging & Navigation -----------------------------
    def _updateNavigationStats(self):
        """Calculate total pages and update UI labels."""
        if self._full_time_axis is None:
            self.navGroup.setEnabled(True)
            self.pageLabel.setText("1/1")
            self.firstBtn.setEnabled(False)
            self.prevBtn.setEnabled(False)
            self.nextBtn.setEnabled(False)
            self.lastBtn.setEnabled(False)
            
            # Initial disabling based on default "Full" mode
            is_windowed = (self._nav_mode == "Windowed")
            self.navDurationSpin.setEnabled(is_windowed)
            self.navDurationLabel.setEnabled(is_windowed)
            self.pageLabel.setEnabled(is_windowed)
            return
            
        total_samples = len(self._full_time_axis)
        dt = abs(self._full_time_axis[1] - self._full_time_axis[0])
        window_samples = int((self._window_duration_min * 60.0) / dt)
        
        if self._nav_mode == "Full":
            self._total_pages = 1
        else:
            self._total_pages = max(1, int(np.ceil(total_samples / window_samples)))
        
        if self._current_page >= self._total_pages:
            self._current_page = self._total_pages - 1
        
        self.pageLabel.setText(f"{self._current_page + 1}/{self._total_pages}")
        
        # Keep navGroup enabled even for 1 page, so user can switch View Mode
        self.navGroup.setEnabled(True)
        
        self.firstBtn.setEnabled(self._current_page > 0)
        self.prevBtn.setEnabled(self._current_page > 0)
        self.nextBtn.setEnabled(self._current_page < self._total_pages - 1)
        self.lastBtn.setEnabled(self._current_page < self._total_pages - 1)
        
        # Visually disable "Window Size" and "Page Number" in Full mode
        is_windowed = (self._nav_mode == "Windowed")
        self.navDurationSpin.setEnabled(is_windowed)
        self.navDurationLabel.setEnabled(is_windowed)
        self.pageLabel.setEnabled(is_windowed)
        
        # Feature 2: Update Minimap Highlight & Markers
        if self._full_time_axis is not None:
            total_samples = len(self._full_time_axis)
            dt = abs(self._full_time_axis[1] - self._full_time_axis[0])
            window_samples = int((self._window_duration_min * 60.0) / dt)
            
            if self._nav_mode == "Windowed":
                start_idx = self._current_page * window_samples
                end_idx = min(start_idx + window_samples, total_samples)
                
                start_pct = start_idx / total_samples
                end_pct = end_idx / total_samples
                self.minimap.update_view_percent(start_pct, end_pct)
                self.minimap.draw_page_markers(total_samples, window_samples)
            else:
                self.minimap.update_view_percent(0, 1)
                self.minimap.draw_page_markers(total_samples, total_samples)

    def _get_slice_data(self, page_idx, downsample=1):
        """Helper to extract a data slice from the FITS handle."""
        if not self.hdul or self._full_time_axis is None:
            return None, None, None
            
        total_samples = len(self._full_time_axis)
        dt = abs(self._full_time_axis[1] - self._full_time_axis[0])
        window_samples = int((self._window_duration_min * 60.0) / dt)
        
        start_idx = page_idx * window_samples
        end_idx = min(start_idx + window_samples, total_samples)
        
        if start_idx >= total_samples or start_idx < 0:
            return None, None, None

        raw_data = self.hdul[0].data
        
        # Apply downsampling for fast preview if requested
        step = max(1, downsample)
        
        try:
            if raw_data.shape[0] == total_samples:
                # (time, freq)
                data_slice = raw_data[start_idx:end_idx:step, :]
            else:
                # (freq, time) -> (time, freq)
                data_slice = raw_data[:, start_idx:end_idx:step].T
            
            time_slice = self._full_time_axis[start_idx:end_idx:step]
            
            # Convert to RAM and handle NaNs/Infs
            data = np.array(data_slice, dtype=np.float32)
            data[np.isnan(data)] = np.nan
            data[np.isinf(data)] = np.nan
            return data, time_slice, self._full_freq_axis

        except Exception as e:
            self.logger.error(f"Error extracting slice at page {page_idx}: {e}")
            return None, None, None

    def _get_fast_slice_data(self, page_idx):
        """Ultra-fast extraction of low-res data from RAM-cached overview."""
        if self._full_lowres_data is None or self._full_time_axis is None:
            return None, None, None
            
        total_samples = len(self._full_time_axis)
        dt = abs(self._full_time_axis[1] - self._full_time_axis[0])
        window_samples = int((self._window_duration_min * 60.0) / dt)
        
        start_idx = page_idx * window_samples
        end_idx = min(start_idx + window_samples, total_samples)
        
        # Map to low-res indices
        low_start = start_idx // self._lowres_skip
        low_end = end_idx // self._lowres_skip
        
        if low_start >= self._full_lowres_data.shape[0 if self._full_lowres_data.ndim == 2 and self._full_lowres_data.shape[0] == (total_samples//self._lowres_skip) else 1] or low_start < 0:
            # Re-check shape logic based on orientation in openFile
            pass

        # Robust slicing: _full_lowres_data is now guaranteed to be (time, freq)
        try:
            data_slice = self._full_lowres_data[low_start:low_end, :]
            time_slice = self._full_time_axis[start_idx:end_idx:self._lowres_skip]
            return data_slice.copy(), time_slice, self._full_freq_axis

        except Exception as e:
            self.logger.error(f"Fast slice error: {e}")
            return None, None, None

    def loadSlice(self):
        """Extract and load the current data slice into the canvas with progressive rendering."""
        if not self.hdul:
            return

        page_to_load = self._current_page
        
        # 1. Instant Preview from RAM (Feature 5 Optimized)
        # We do this FIRST even if cached, to provide instantaneous visual feedback of the button press.
        if self._is_large_file and self._full_lowres_data is not None:
            data_fast, time_fast, freq_fast = self._get_fast_slice_data(page_to_load)
            if data_fast is not None:
                self._display_data(data_fast, time_fast, freq_fast, fast=True)
                # Force Qt to repaint the fast preview BEFORE we schedule the high-res update
                # QtWidgets.QApplication.processEvents()

        # 2. Check Cache
        if page_to_load in self._data_cache:
            data, time_axis, freq_axis = self._data_cache[page_to_load]
            self.logger.info(f"Loaded page {page_to_load} from cache")
            # Schedule the high-res update to allow the fast-preview to be drawn first
            self._pending_page = page_to_load
            QTimer.singleShot(10, lambda: self._completeLoad(page_to_load, data, time_axis, freq_axis))
            return

        # 3. Schedule Full-res Data (Async Load from file)
        self._pending_page = page_to_load
        QTimer.singleShot(10, lambda: self._loadFullRes(page_to_load))

    def _completeLoad(self, page_idx, data, time_axis, freq_axis):
        """Final display of high-res data for both cache hits and file loads."""
        if not self.hdul or page_idx != self._current_page or page_idx != self._pending_page:
            return
        with self.wait_cursor():
            self._display_data(data, time_axis, freq_axis)
            self._pending_page = -1 # Completed

    def _loadFullRes(self, page_idx):
        """Perform the actual high-resolution load scheduled by loadSlice."""
        # Ensure we are still on the same page and not cleared
        if not self.hdul or page_idx != self._current_page or page_idx != self._pending_page:
            return
            
        with self.wait_cursor():
            self.logger.info(f"Performing full-res load for page {page_idx}")
            data, time_axis, freq_axis = self._get_slice_data(page_idx, downsample=1)
            
            if data is not None:
                # Update cache
                self._data_cache[page_idx] = (data, time_axis, freq_axis)
                if len(self._data_cache) > self._cache_limit:
                    keys = sorted(self._data_cache.keys())
                    furthest = keys[0] if abs(keys[0] - page_idx) > abs(keys[-1] - page_idx) else keys[-1]
                    del self._data_cache[furthest]
                
                # Use shared completion logic (handles page check and _pending_page)
                self._completeLoad(page_idx, data, time_axis, freq_axis)

    def _apply_bandpass_to_data(self, data):
        """Helper to apply bandpass normalization to a 2D data array."""
        if data is None: return None
        # normalize by median of each channel (freq) across time
        freq_profile = np.nanmedian(data, axis=0) # Axis 0 is time
        freq_profile[freq_profile == 0] = 1e-20
        freq_profile[np.isnan(freq_profile)] = 1e-20
        normed = data / freq_profile
        normed[np.isnan(normed)] = np.nan
        return normed

    def _display_data(self, data, time_axis, freq_axis, fast=False):
        """Shared logic to update canvas and stats."""
        # Keep raw for revert
        self._original_unmodified = data.copy()
        
        # Apply persistent bandpass if enabled
        if self._is_bandpass_enabled:
            data_to_show = self._apply_bandpass_to_data(data)
        else:
            data_to_show = data.copy()
            
        self._original_data = data_to_show
        
        # Apply pending user mask if it exists (e.g. from bandpass toggle)
        if hasattr(self, '_pending_user_mask') and self._pending_user_mask is not None:
             # Ensure shapes match (e.g. skip if fast preview has different shape)
             if self._original_data.shape == self._pending_user_mask.shape:
                 self._original_data[self._pending_user_mask] = np.nan
             
             # Clear the pending mask only after the full load (not fast preview)
             if not fast:
                 self._pending_user_mask = None



        # Apply Global Frequency Mask (Extend Mask feature)
        if self._global_masked_freq_indices and self._original_data is not None:
             # Standardized: self._original_data is always (Time, Freq)
             bad_freqs = list(self._global_masked_freq_indices)
             self._original_data[:, bad_freqs] = np.nan
             
        self._time_axis = time_axis
        self._freq_axis = freq_axis
        
        self.canvas.set_data(self._original_data, self._time_axis, self._freq_axis, filename=self.current_filename)
        self.canvas.draw_spectrum(fast=fast)
        self._updateNavigationStats()

    def onNavModeChanged(self, mode):
        if not self.hdul: return
        self._nav_mode = "Windowed" if "Windowed" in mode else "Full"
        
        if self._nav_mode == "Full":
            # Warning for very large files
            if self._is_large_file:
                reply = QMessageBox.warning(self, "Large Data Warning", 
                    "Loading the full spectrum for a very large file may consume significant memory. Continue?",
                    QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
                if reply == QMessageBox.No:
                    self.navModeCombo.blockSignals(True)
                    self.navModeCombo.setCurrentText("Windowed")
                    self.navModeCombo.blockSignals(False)
                    self._nav_mode = "Windowed"
                    return
            
            # Load full data into RAM (subject to memory limits)
            with self.wait_cursor():
                raw_data = self.hdul[0].data
                if raw_data.shape[0] == len(self._full_time_axis):
                    data = np.array(raw_data, dtype=np.float32)
                else:
                    data = np.array(raw_data.T, dtype=np.float32)
                self._display_data(data, self._full_time_axis, self._full_freq_axis)
            return

        # Switching/Returning to Windowed mode
        self._data_cache.clear()
        self._current_page = 0
        with self.wait_cursor():
            self.loadSlice()

    def onNavDurationChanged(self, val):
        if not self.hdul: return
        self._window_duration_min = val
        self._current_page = 0 # Reset to start when duration changes
        
        # Invalidate cache
        with self.wait_cursor():
            self._data_cache.clear()
        
            # Recalculate total pages based on new duration
            if self._full_time_axis is not None:
                total_samples = len(self._full_time_axis)
                dt = abs(self._full_time_axis[1] - self._full_time_axis[0])
                window_samples = int((self._window_duration_min * 60.0) / dt)
                if window_samples > 0:
                    self._total_pages = (total_samples + window_samples - 1) // window_samples
                else:
                    self._total_pages = 1
        
            self.loadSlice()
            self._updateNavigationStats() # Ensure button states and minimap rectangle update

    def onPrevPage(self):
        if self._current_page > 0:
            self._current_page -= 1
            with self.wait_cursor():
                self.loadSlice()

    def onNextPage(self):
        if self._current_page < self._total_pages - 1:
            self._current_page += 1
            with self.wait_cursor():
                self.loadSlice()

    def onFirstPage(self):
        if self._current_page != 0:
            self._current_page = 0
            with self.wait_cursor():
                self.loadSlice()

    def onLastPage(self):
        if self._current_page != self._total_pages - 1:
            self._current_page = self._total_pages - 1
            with self.wait_cursor():
                self.loadSlice()

    def onMinimapSeek(self, x_data):
        """Handle seek request from minimap click/drag."""
        if self._full_time_axis is None: return
        
        with self.wait_cursor():
            total_samples = len(self._full_time_axis)
            
            # x_data is coordinate in the axes
            xlim = self.minimap.ax.get_xlim()
            pct = (x_data - xlim[0]) / (xlim[1] - xlim[0])
            pct = max(0, min(0.999, pct))
            
            # Map percentage directly to sample index
            target_idx = int(pct * total_samples)
            
            # Determine which page contains this sample
            dt = abs(self._full_time_axis[1] - self._full_time_axis[0])
            window_samples = int((self._window_duration_min * 60.0) / dt)
            
            new_page = target_idx // window_samples
            if new_page >= self._total_pages:
                new_page = self._total_pages - 1
                
            if new_page != self._current_page:
                self._current_page = new_page
                self.loadSlice()

    def saveCleanedData(self):
        if self._original_data is None:
            QMessageBox.information(self, "Info", "No data to save.")
            return
        fileName, _ = QFileDialog.getSaveFileName(
            self, "Save Cleaned FITS", "", "FITS Files (*.fits)"
        )
        if not fileName:
            return
        with self.wait_cursor():
            try:
                hdu = fits.PrimaryHDU(self._original_data)
                hdul = fits.HDUList([hdu])
                if self._time_axis is not None:
                    from astropy.table import Table

                    t = Table()
                    t["TIME_MJD"] = self._time_axis / 86400.0
                    time_hdu = fits.BinTableHDU(t, name="TIME_AXIS")
                    hdul.append(time_hdu)
                if self._freq_axis is not None:
                    from astropy.table import Table

                    t = Table()
                    t["FREQ_MHz"] = self._freq_axis
                    freq_hdu = fits.BinTableHDU(t, name="FREQ_AXIS")
                    hdul.append(freq_hdu)
                hdu.header.add_history(
                    "Cleaned/processed with SolarViewer Dynamic Spectrum Viewer"
                )
                hdul.writeto(fileName, overwrite=True)
                self.statusBar().showMessage(f"Saved cleaned data to {fileName}", 5000)
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to save FITS:\n{e}")

    def compareOriginalCleaned(self):
        if self._original_unmodified is None or self._original_data is None:
            QMessageBox.information(self, "Info", "No data loaded.")
            return
        with self.wait_cursor():
            fig, axes = plt.subplots(1, 2, figsize=(12, 5), sharey=True)
        axes[0].set_title("Original Unmodified")
        axes[1].set_title("Current Cleaned")
        orig_ma = ma.masked_invalid(self._original_unmodified)
        cle_ma = ma.masked_invalid(self._original_data)

        # Apply the same scaling as the current view
        if self.canvas._smart_scale == "0-100%":
            orig_vals = orig_ma.compressed()
            cle_vals = cle_ma.compressed()
            orig_vmin, orig_vmax = orig_vals.min(), orig_vals.max()
            cle_vmin, cle_vmax = cle_vals.min(), cle_vals.max()
        elif self.canvas._smart_scale == "0.1-99.9%":
            orig_vals = orig_ma.compressed()
            cle_vals = cle_ma.compressed()
            orig_vmin = np.percentile(orig_vals, 0.1)
            orig_vmax = np.percentile(orig_vals, 99.9)
            cle_vmin = np.percentile(cle_vals, 0.1)
            cle_vmax = np.percentile(cle_vals, 99.9)
        elif self.canvas._smart_scale == "0.5-99.5%":
            orig_vals = orig_ma.compressed()
            cle_vals = cle_ma.compressed()
            orig_vmin = np.percentile(orig_vals, 0.5)
            orig_vmax = np.percentile(orig_vals, 99.5)
            cle_vmin = np.percentile(cle_vals, 0.5)
            cle_vmax = np.percentile(cle_vals, 99.5)
        else:  # "1-99%"
            orig_vals = orig_ma.compressed()
            cle_vals = cle_ma.compressed()
            orig_vmin = np.percentile(orig_vals, 1)
            orig_vmax = np.percentile(orig_vals, 99)
            cle_vmin = np.percentile(cle_vals, 1)
            cle_vmax = np.percentile(cle_vals, 99)

        norm1 = self.canvas.get_normalization(orig_vmin, orig_vmax)
        norm2 = self.canvas.get_normalization(cle_vmin, cle_vmax)
        im1 = axes[0].imshow(
            orig_ma.T, origin="lower", aspect="auto", norm=norm1, cmap=self.canvas._cmap
        )
        fig.colorbar(im1, ax=axes[0], label="")
        im2 = axes[1].imshow(
            cle_ma.T, origin="lower", aspect="auto", norm=norm2, cmap=self.canvas._cmap
        )
        fig.colorbar(im2, ax=axes[1], label="")
        axes[0].set_xlabel("Time Index")
        axes[1].set_xlabel("Time Index")
        axes[0].set_ylabel("Frequency Index")
        axes[1].set_ylabel("Frequency Index")
        fig.suptitle("Original vs Cleaned")
        fig.tight_layout()
        fig.show()

    def revertToOriginal(self):
        if self._original_unmodified is None:
            QMessageBox.warning(self, "Warning", "No original data to revert to.")
            return
        self._original_data = self._original_unmodified.copy()
        self.canvas.set_data(self._original_data, self._time_axis, self._freq_axis)
        self.canvas.draw_spectrum()
        self.statusBar().showMessage("Reverted to original data.", 5000)

    # ----------------------- Undo/Redo Functionality ----------------------------
    def undo(self):
        if self.undo_stack:
            self.redo_stack.append(self._original_data.copy())
            self._original_data = self.undo_stack.pop()
            self.canvas.set_data(self._original_data, self._time_axis, self._freq_axis)
            self.canvas.draw_spectrum()
        else:
            QMessageBox.information(self, "Undo", "No more actions to undo.")

    def redo(self):
        if self.redo_stack:
            self.undo_stack.append(self._original_data.copy())
            self._original_data = self.redo_stack.pop()
            self.canvas.set_data(self._original_data, self._time_axis, self._freq_axis)
            self.canvas.draw_spectrum()
        else:
            QMessageBox.information(self, "Redo", "No more actions to redo.")

    # In each modifying operation, push current state to undo stack and clear redo stack.
    def onCleanRFIRegionDetect(self):
        if self._original_data is None:
            QMessageBox.information(self, "Info", "No data loaded.")
            return
        
        with self.wait_cursor():
            self.undo_stack.append(self._original_data.copy())
            self.redo_stack.clear()
            thresh = self.threshSpin.value()
            min_w = self.minWidthSpin.value()
            min_h = self.minHeightSpin.value()
            data_2d = self._original_data.copy()
            data_2d[np.isnan(data_2d)] = 0
            data_T = data_2d.T
            med_band = np.nanmedian(data_T, axis=1, keepdims=True)
            normed_data = data_T / (med_band + 1e-20)
            binary_image = create_binary(normed_data, thresh=thresh)
            _, valid_contours, _ = region_detection(
                normed_data, binary_image, min_width=min_w, min_height=min_h
            )
            mask = create_mask(binary_image, valid_contours)
            rfi_map = subtract_contours(normed_data, mask=~mask)
            cleaned_data = rfi_map.T
            cleaned_data[np.isnan(cleaned_data)] = np.nan
            self._original_data = cleaned_data
            self.canvas.set_data(self._original_data, self._time_axis, self._freq_axis)
            self.canvas.draw_spectrum()
            self.statusBar().showMessage("Region detection done.", 5000)

    def onBandpassNorm(self, checked):
        """Toggle persistent bandpass normalization."""
        if self._original_unmodified is None:
            if checked:
                self.normBtn.blockSignals(True)
                self.normBtn.setChecked(False)
                self.normBtn.blockSignals(False)
            return

        # Capture user mask before changing state
        # The mask is the difference between current data and what the data SHOULD be (baseline)
        # We need to compute baseline based on the CURRENT state (before toggle)
        if self._is_bandpass_enabled:
             baseline = self._apply_bandpass_to_data(self._original_unmodified)
        else:
             baseline = self._original_unmodified
        
        # Identify manual edits: where data is NaN but baseline is NOT NaN
        if self._original_data is not None and baseline is not None and self._original_data.shape == baseline.shape:
             user_mask = np.isnan(self._original_data) & (~np.isnan(baseline))
        else:
             user_mask = None

        self._is_bandpass_enabled = checked
        self.logger.info(f"Bandpass Normalization toggled to: {checked}")
        
        # Clear cache to force re-processing of all pages
        self._data_cache.clear()
        
        # Store mask for re-application
        self._pending_user_mask = user_mask
        
        with self.wait_cursor():
            if self._is_large_file:
                # Reload from file (async)
                self.loadSlice() 
            else:
                # For small files, just refresh the view using the immutable data
                self._display_data(self._original_unmodified, self._time_axis, self._freq_axis)
            
        self.statusBar().showMessage(f"Bandpass normalization {'enabled' if checked else 'disabled'}.", 5000)

    def _mask_roi_values(self, ixmin, ixmax, iymin, iymax):
        """Mask a region of interest with NaN values."""
        with self.wait_cursor():
            try:
                self.logger.info(
                    f"Masking ROI: time=[{ixmin},{ixmax}], freq=[{iymin},{iymax}]"
                )

                # Validate indices
                if ixmax < ixmin or iymax < iymin:
                    self.logger.warning("Invalid ROI coordinates: Empty region")
                    return

                # Validate against data dimensions
                if self._original_data is None:
                    self.logger.error("No data loaded")
                    return

                # Save current state for undo
                self.undo_stack.append(self._original_data.copy())
                self.redo_stack.clear()

                # Apply the mask
                self._original_data[ixmin : ixmax + 1, iymin : iymax + 1] = np.nan

                # Update the display
                self.canvas.set_data(self._original_data, self._time_axis, self._freq_axis)
                self.canvas.draw_spectrum()

                # Update status
                self.statusBar().showMessage(
                    f"ROI masked: time=[{ixmin},{ixmax}], freq=[{iymin},{iymax}] => NaN",
                    5000,
                )
                self.logger.info("ROI masked successfully")
            except Exception as e:
                self.logger.exception(f"Error masking ROI: {e}")
                QMessageBox.warning(self, "Error", f"Failed to mask region: {str(e)}")
                # Disable ROI selector on error
                self.roiButton.setChecked(False)
                self.canvas.enable_roi_selector(False)
                self.statusBar().showMessage("ROI masking failed", 5000)

    # ----------------------- Scale / Colormap Controls --------------------------
    @pyqtSlot(str)
    def onScaleModeChanged(self, mode):
        self.canvas.set_scale_mode(mode)
        if mode == "Gamma":
            self.gammaLabel.setEnabled(True)
            self.gammaSlider.setEnabled(True)
        else:
            self.gammaLabel.setEnabled(False)
            self.gammaSlider.setEnabled(False)

    @pyqtSlot(int)
    def onGammaChanged(self, sliderValue):
        """Update gamma value - continuous label, deferred plot update on drag."""
        self._pending_gamma = sliderValue / 100.0
        
        # Immediate UI feedback for the label
        self.gammaLabel.setText(f"Gamma: {self._pending_gamma:.2f}")
        
        # Only update the plot immediately if NOT dragging (e.g. keyboard or track click)
        # If dragging, we wait for sliderReleased
        if not self.gammaSlider.isSliderDown():
            # Still use a tiny debounce for keyboard "repeat" events
            self._gamma_timer.start(30)

    def _apply_gamma_change(self):
        """Actually apply the gamma change to the canvas."""
        self.canvas.set_gamma(self._pending_gamma)

    @pyqtSlot(str)
    def onCmapChanged(self, cmap_name):
        self.canvas.set_cmap(cmap_name)

    @pyqtSlot(str)
    def onScaleRangeChanged(self, scale_option):
        """Handle changes to the scale range dropdown."""
        is_manual = (scale_option == "Manual")
        self.vminEntry.setEnabled(is_manual)
        self.vmaxEntry.setEnabled(is_manual)
        self.manualLimitsLabel.setEnabled(is_manual)
        self.canvas.set_smart_scale(scale_option)

    @pyqtSlot()
    def onManualRangeChanged(self):
        """Handle manual min/max changes."""
        try:
            vmin = float(self.vminEntry.text())
            vmax = float(self.vmaxEntry.text())
            if vmin >= vmax:
                # Basic validation
                return
            self.canvas.set_manual_range(vmin, vmax)
        except ValueError:
            pass

    # ------------------------- ROI / Cross-Section -----------------------------
    def onRoiToggled(self, checked):
        if self._original_data is None:
            QMessageBox.information(self, "Info", "No data loaded.")
            self.roiButton.setChecked(False)
            return

        try:
            if checked:
                # Mutual exclusivity: disable cross section if active
                if self.crossBtn.isChecked():
                    self.crossBtn.setChecked(False)
                
                # Deactivate Pan/Zoom in toolbar to avoid cursor conflicts
                if hasattr(self, "navbar"):
                    if self.navbar.mode == 'zoom':
                        self.navbar.zoom()
                    elif self.navbar.mode == 'pan':
                        self.navbar.pan()
                        
                self.logger.info("Enabling ROI selector...")
                self.canvas.enable_roi_selector(True, self._mask_roi_values)
                self.statusBar().showMessage(
                    "Mask Region ON: Click and drag to select an area to mask."
                )
                self.logger.info("ROI selector enabled successfully")
            else:
                self.logger.info("Disabling ROI selector...")
                self.canvas.enable_roi_selector(False)
                self.statusBar().clearMessage()
                self.logger.info("ROI selector disabled")
        except Exception as e:
            # Handle any exceptions and inform the user
            error_msg = f"There was an error with the ROI selector: {str(e)}"
            self.logger.exception(error_msg)
            QMessageBox.warning(
                self,
                "ROI Selection Error",
                f"{error_msg}\n\n"
                "This may be due to compatibility issues with your Matplotlib version.\n"
                "Please try updating Matplotlib or using a different selection method.",
            )

            # Reset button state
            self.roiButton.setChecked(False)

            # Disable the selector and clean up
            try:
                self.canvas.roi_active = False
                if (
                    hasattr(self.canvas, "rect_selector")
                    and self.canvas.rect_selector is not None
                ):
                    self.canvas.rect_selector.set_active(False)
                    if hasattr(self.canvas.rect_selector, "disconnect_events"):
                        self.canvas.rect_selector.disconnect_events()
                    self.canvas.rect_selector = None
            except Exception as cleanup_error:
                self.logger.error(f"Error during cleanup: {cleanup_error}")

            # Update the status bar
            self.statusBar().showMessage("ROI selection disabled due to an error", 5000)

    def onHoverInfoToggled(self, checked):
        """Toggle the mouse hover info display on/off."""
        if hasattr(self.canvas, "hover_info_enabled"):
            self.canvas.hover_info_enabled = checked
        else:
            # For backwards compatibility, set the attribute
            self.canvas.hover_info_enabled = checked

        # Clear hover text and reset cache if disabled
        if not checked and hasattr(self.canvas, "_hover_text"):
            self.canvas._hover_text.set_text("")
            if hasattr(self.canvas, "_last_hover_text"):
                self.canvas._last_hover_text = ""
            self.canvas.draw_idle()

    def onHoverFrequencyChanged(self, value):
        """Update the hover throttle limit for performance tuning."""
        if hasattr(self.canvas, "_hover_throttle_limit"):
            self.canvas._hover_throttle_limit = value
            # Reset counter to apply change immediately
            if hasattr(self.canvas, "_hover_throttle_counter"):
                self.canvas._hover_throttle_counter = 0

    def onCrossSectionToggled(self, checked):
        if self._original_data is None:
            QMessageBox.information(self, "Info", "No data loaded.")
            self.crossBtn.setChecked(False)
            return
            
        if checked:
            # Mutual exclusivity: disable ROI if active
            if self.roiButton.isChecked():
                self.roiButton.setChecked(False)
            
            # Deactivate Pan/Zoom in toolbar to avoid cursor conflicts
            if hasattr(self, "navbar"):
                if self.navbar.mode == 'zoom':
                    self.navbar.zoom()
                elif self.navbar.mode == 'pan':
                    self.navbar.pan()
                
        self.canvas.enable_cross_section(checked)
        if checked:
            self.statusBar().showMessage("Cross-section mode ON. Click on data.")
        else:
            self.statusBar().clearMessage()

    def onExtendMask(self):
        """Extend the current mask across frequency (i.e. Global Frequency Masking)."""
        if self._original_data is None: return
        
        with self.wait_cursor():
            # Identify frequencies that have ANY masking in the current view
            # self._original_data is usually (time, freq) but checked via axis lengths
            
            data = self._original_data
            mask = np.isnan(data)
            # Identify frequencies that have ANY masking in the current view
            # Standardized orientation is always (Time, Freq)
            # Axis 1 is Frequency
            masked_freqs = np.where(np.any(mask, axis=0))[0]
            self._global_masked_freq_indices.update(masked_freqs)
            
            # Apply immediately to current view
            self._display_data(self._original_unmodified, self._time_axis, self._freq_axis)
            self.statusBar().showMessage(f"Extended mask to {len(self._global_masked_freq_indices)} channels globally.", 5000)

    def onClearMasks(self):
        """Clear all masks: local manual masks, global extended masks, and undo history."""
        reply = QMessageBox.question(self, "Clear Masks", 
                                     "Clear ALL masks (including extended frequency masks)?",
                                     QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
        
        if reply == QMessageBox.Yes:
            self._global_masked_freq_indices.clear()
            self._pending_user_mask = None
            
            # Revert current view to raw
            if self._original_unmodified is not None:
                self._original_data = self._original_unmodified.copy()
                self._display_data(self._original_unmodified, self._time_axis, self._freq_axis)
            
            self.statusBar().showMessage("All masks cleared.", 5000)

    def resizeEvent(self, event):
        """Handle window resize events to ensure canvas redraws properly"""
        super().resizeEvent(event)
        # Use a timer to avoid excessive redrawing during resize
        if self.resizeTimer is not None:
            self.resizeTimer.stop()

        # Wait for resize to complete before redrawing
        from PyQt5.QtCore import QTimer

        self.resizeTimer = QTimer()
        self.resizeTimer.setSingleShot(True)
        self.resizeTimer.timeout.connect(self._delayed_redraw)
        self.resizeTimer.start(200)  # 200ms delay

    def _delayed_redraw(self):
        """Redraw the canvas after resize is complete"""
        if hasattr(self, "canvas") and self.canvas._data is not None:
            self.canvas.draw_idle()


###############################################################################
#                                  MAIN                                       #
###############################################################################


def main():
    """Entry point for viewds command."""
    # Apply high DPI scaling
    from solar_radio_image_viewer.from_simpl.simpl_theme import setup_high_dpi
    setup_high_dpi()

    app = QApplication(sys.argv)

    # Apply dark theme from solarviewer
    from solar_radio_image_viewer.from_simpl.simpl_theme import apply_theme

    apply_theme(app, "dark")

    w = MainWindow(theme="dark")
    w.show()
    sys.exit(app.exec_())


if __name__ == "__main__":
    main()
