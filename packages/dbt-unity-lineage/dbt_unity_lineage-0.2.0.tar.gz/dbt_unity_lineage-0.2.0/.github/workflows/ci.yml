name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ["3.9", "3.10", "3.11", "3.12"]

    steps:
      - uses: actions/checkout@v4

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -e ".[dev]"

      - name: Lint with ruff
        run: ruff check src/ tests/

      - name: Type check with mypy
        run: mypy src/
        continue-on-error: true  # TODO: Fix type errors

      - name: Run unit tests with coverage
        run: pytest tests/ -v -m "not integration" --cov=src/dbt_unity_lineage --cov-branch --cov-report=xml

      - name: Upload coverage to Codecov
        if: matrix.python-version == '3.11'
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          slug: dbt-conceptual/dbt-unity-lineage
          files: ./coverage.xml
          fail_ci_if_error: false
          verbose: true

  integration:
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'pull_request'
    permissions:
      contents: read
      pull-requests: write

    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -e ".[dev]"

      - name: Run integration tests
        id: integration_tests
        env:
          DATABRICKS_HOST: ${{ secrets.DATABRICKS_HOST }}
          DATABRICKS_TOKEN: ${{ secrets.DATABRICKS_TOKEN }}
          DATABRICKS_CATALOG: ${{ secrets.DATABRICKS_CATALOG }}
          DATABRICKS_HTTP_PATH: ${{ secrets.DATABRICKS_HTTP_PATH }}
        run: |
          pytest tests/ -v -m "integration" --tb=short 2>&1 | tee integration-results.txt
          echo "exit_code=${PIPESTATUS[0]}" >> $GITHUB_OUTPUT
        continue-on-error: true

      - name: Generate test results markdown
        if: always()
        run: |
          echo "## Integration Test Results" > integration-report.md
          echo "" >> integration-report.md
          if [ -f integration-results.txt ]; then
            # Extract summary line
            if grep -q "passed" integration-results.txt; then
              echo "### Summary" >> integration-report.md
              grep -E "^(PASSED|FAILED|ERROR|=.*(passed|failed|error))" integration-results.txt | tail -1 >> integration-report.md
              echo "" >> integration-report.md
            fi
            echo "<details>" >> integration-report.md
            echo "<summary>Full Test Output</summary>" >> integration-report.md
            echo "" >> integration-report.md
            echo '```' >> integration-report.md
            cat integration-results.txt >> integration-report.md
            echo '```' >> integration-report.md
            echo "</details>" >> integration-report.md
          else
            echo "No test results found." >> integration-report.md
          fi

      - name: Comment on PR with test results
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const report = fs.readFileSync('integration-report.md', 'utf8');

            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(c =>
              c.user.type === 'Bot' &&
              c.body.includes('## Integration Test Results')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: report,
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: report,
              });
            }
