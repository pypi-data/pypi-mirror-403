"""Lifecycle hooks for the FastAPI Standard kit."""

from __future__ import annotations

import getpass
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, Optional


def pre_generate(variables: Dict[str, Any]) -> None:
    """Normalize variables prior to project scaffolding."""
    variables.setdefault("author", getpass.getuser())
    variables.setdefault("app_version", "0.1.0")
    variables.setdefault("description", "FastAPI service generated with RapidKit")
    variables.setdefault("year", str(datetime.now().year))


def post_generate(
    output_path: Optional[Path] = None, variables: Optional[Dict[str, Any]] = None
) -> None:
    """Display next steps after project generation."""
    if not output_path:
        return

    project_name = (
        variables.get("project_name", "fastapi-service") if variables else "fastapi-service"
    )

    print("\n" + "=" * 60)
    print("üéâ FastAPI Standard project scaffolded!")
    print("=" * 60)

    # Optionally generate a lockfile for reproducible installs. Controlled by
    # environment variable RAPIDKIT_GENERATE_LOCKS=1 or variables['generate_lock']=True
    try:
        import os
        import subprocess  # nosec - safe use for lock generation

        def _is_truthy(value: object) -> bool:
            return str(value).lower() in {"1", "true", "yes", "on"}

        should_lock: bool
        env_toggle = os.environ.get("RAPIDKIT_GENERATE_LOCKS")
        if env_toggle is not None:
            should_lock = _is_truthy(env_toggle)
        elif _is_truthy(os.environ.get("RAPIDKIT_SKIP_LOCKS", "0")):
            should_lock = False
        elif variables and "generate_lock" in variables:
            should_lock = bool(variables.get("generate_lock", True))
        else:
            should_lock = True

        if should_lock:
            print("\n‚ÑπÔ∏è Generating poetry.lock (automatic lockfiles enabled)")
            subprocess.run(
                ["poetry", "lock"], cwd=str(output_path), check=False
            )  # nosec - safe, static tool invocation
            print("‚ÑπÔ∏è poetry.lock generation attempted (check output above).")
    except (subprocess.SubprocessError, FileNotFoundError, OSError):
        # non-fatal - don't break generation for users who lack poetry or network
        print("WARN: Lockfile generation attempted and failed. Continuing without locking.")
    print(f"üìÅ Project: {project_name}")
    print(f"üìÇ Location: {output_path}")
    print("\nNext steps:")
    print(f"  1. cd {project_name}")
    print("  2. source .rapidkit/activate")
    print("  3. rapidkit init")
    print("  4. ./bootstrap.sh")
    print("  5. rapidkit dev")
    print(
        "\nRapidKit manages dependencies with Poetry. A requirements.txt file is not generated by default."
    )
    print(
        "Use `poetry export --format requirements.txt --output requirements.txt` if tooling needs one."
    )

    if variables:
        module_toggles = [
            ("install_logging", "logging", True),
            ("install_settings", "settings", True),
            ("install_deployment", "deployment", True),
            ("enable_postgres", "db_postgres", False),
            ("enable_sqlite", "db_sqlite", True),
            ("enable_redis", "redis", False),
            ("enable_monitoring", "monitoring", False),
            ("enable_tracing", "tracing", False),
            ("enable_docs", "openapi_docs", True),
        ]

        missing_modules = [
            module_name
            for flag, module_name, default in module_toggles
            if not variables.get(flag, default)
        ]

        if missing_modules:
            print("\nExplore additional RapidKit modules whenever you need them:")
            for module_name in dict.fromkeys(missing_modules):
                print(f"  ‚Ä¢ rapidkit add module {module_name}")

    print("=" * 60)
