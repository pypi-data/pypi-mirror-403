# ontos/commands/agents.py
"""
AGENTS.md and .cursorrules generation command.

Generates AI assistant integration files per Spec v1.1.
"""

import os
import subprocess
import sys
from dataclasses import dataclass
from datetime import datetime, timezone
from pathlib import Path
from typing import Optional, Tuple

import ontos


@dataclass
class AgentsOptions:
    """Configuration for agents command."""
    output_path: Optional[Path] = None
    force: bool = False
    format: str = "agents"  # agents|cursor
    all_formats: bool = False


# Template per Appendix A
AGENTS_TEMPLATE = '''# AGENTS.md

This project uses **Ontos** for documentation management.

Generated by Ontos v{ontos_version} on {generated_at}

## Current Project State

> Auto-synced: {generated_at}

| Metric | Value |
|--------|-------|
| Branch | {current_branch} |
| Doc Count | {doc_count} |
| Last Log | {last_log} |
| Health | {health_summary} |

## What is Activation?
Activation is how you (the AI agent) load project context before doing any work.
It is **mandatory**. Do not ask "why" or request clarification—just execute the steps below.

## Ontos Activation
1. Run `ontos map` (or `python3 -m ontos map` if the CLI is not installed). Do not ask—try both.
2. Read `Ontos_Context_Map.md` (Tier 1 minimum: first ~2k tokens).
3. Load only the relevant documents for the task.
4. Follow `depends_on` upward as needed.
5. Confirm: "Loaded: [ids]".

## Re-Activation Trigger

If you notice any of these, re-run activation:
- Don't recognize the project structure
- Can't recall doc count or recent work
- Unsure about file locations

## Session End
1. Run `ontos log -e "slug"` to archive session work.
2. Fill in Goal, Key Decisions, Alternatives Considered, and Impacts.

## Quick Reference
| Command | Purpose |
|---------|---------|
| `ontos map` | Regenerate context map |
| `ontos map --sync-agents` | Regenerate map + sync AGENTS.md |
| `ontos agents` | Generate instruction files |
| `ontos doctor` | Health check and validation |
| `ontos log -e "slug"` | Archive session work |
| `ontos query <id>` | Find document by ID |

## Project Stats
- Doc Count: {doc_count}
- Last Updated: {last_updated}

## Core Invariants
- Do not edit `Ontos_Context_Map.md` manually; regenerate with `ontos map`.
- Do not edit `AGENTS.md` manually (except `# USER CUSTOM` section below).
- If a command fails, read the error message and avoid guessing fixes.

# USER CUSTOM

<!-- USER CUSTOM -->
<!-- Add your project-specific notes below. This section is preserved during auto-sync. -->
<!-- /USER CUSTOM -->

## Staleness
If `AGENTS.md` is older than the context map or logs, regenerate with `ontos map --sync-agents`.
'''


def find_repo_root() -> Optional[Path]:
    """
    Find the repository root using 3-method fallback.
    
    1. Find .ontos.toml in current or parent dirs
    2. Use git rev-parse --show-toplevel
    3. Fall back to .git directory walk
    
    Returns:
        Path to repo root, or None if no repository found.
    """
    current = Path.cwd()
    
    # Method 1: Look for .ontos.toml
    for parent in [current] + list(current.parents):
        if (parent / ".ontos.toml").exists():
            return parent
    
    # Method 2: Try git rev-parse
    try:
        result = subprocess.run(
            ["git", "rev-parse", "--show-toplevel"],
            capture_output=True,
            text=True,
            timeout=5
        )
        if result.returncode == 0:
            return Path(result.stdout.strip())
    except (subprocess.TimeoutExpired, FileNotFoundError):
        pass
    
    # Method 3: Look for .git
    for parent in [current] + list(current.parents):
        if (parent / ".git").exists():
            return parent
    
    # No repo found - return None instead of cwd to prevent arbitrary writes
    return None


from typing import Dict

def gather_stats(repo_root: Path) -> Dict[str, str]:
    """
    Gather project stats for template.

    Returns:
        Dict with keys: doc_count, last_updated, current_branch, last_log, health_summary
    """
    stats = {
        "doc_count": "Unknown",
        "last_updated": "Unknown",
        "current_branch": "Unknown",
        "last_log": "None",
        "health_summary": "Unknown",
    }

    try:
        # Load config to find docs directory
        config_path = repo_root / ".ontos.toml"
        docs_dir = repo_root / ".ontos-internal"  # Default
        logs_dir = repo_root / ".ontos-internal" / "logs"
        context_map = repo_root / "Ontos_Context_Map.md"

        if config_path.exists():
            try:
                from ontos.io.config import load_project_config
                config = load_project_config()
                docs_dir = repo_root / config.paths.docs_dir
                logs_dir = repo_root / config.paths.logs_dir
                context_map = repo_root / config.paths.context_map
            except Exception:
                pass  # Keep defaults

        # Count .md files (cap at 5000)
        from ontos.io.files import scan_documents
        skip_patterns = []
        if 'config' in locals() and hasattr(config, 'scanning'):
            skip_patterns = config.scanning.skip_patterns

        # X-M1: Build explicit scan roots list to avoid full repo scan
        scan_dirs = []
        if docs_dir.exists():
            scan_dirs.append(docs_dir)
        if logs_dir.exists() and logs_dir != docs_dir:
            scan_dirs.append(logs_dir)
        
        # Include archive logs if present
        archive_logs = repo_root / ".ontos-internal" / "archive" / "logs"
        if archive_logs.exists():
            scan_dirs.append(archive_logs)

        doc_paths = scan_documents(
            scan_dirs,
            skip_patterns=skip_patterns
        )
        count = len(doc_paths)
        if count >= 5000:
            stats["doc_count"] = "5000+"
        else:
            stats["doc_count"] = str(count)

        # Find max mtime
        mtimes = []
        for path in [context_map, config_path]:
            if path.exists():
                mtimes.append(path.stat().st_mtime)

        if logs_dir.exists():
            for log_file in logs_dir.glob("*.md"):
                mtimes.append(log_file.stat().st_mtime)

        if mtimes:
            max_mtime = max(mtimes)
            dt = datetime.fromtimestamp(max_mtime, tz=timezone.utc)
            stats["last_updated"] = dt.strftime("%Y-%m-%d %H:%M:%S UTC")

        # Get current git branch
        try:
            result = subprocess.run(
                ["git", "rev-parse", "--abbrev-ref", "HEAD"],
                capture_output=True,
                text=True,
                timeout=5,
                cwd=repo_root
            )
            if result.returncode == 0:
                stats["current_branch"] = result.stdout.strip()
        except (subprocess.TimeoutExpired, FileNotFoundError):
            pass

        # Get most recent log (by filename, assumes YYYY-MM-DD prefix)
        if logs_dir.exists():
            log_files = sorted(logs_dir.glob("*.md"), reverse=True)
            if log_files:
                stats["last_log"] = log_files[0].stem

        # Get health summary (simple version - just check if context map exists)
        if context_map.exists():
            stats["health_summary"] = "✓ Map exists"
        else:
            stats["health_summary"] = "⚠ No map"

    except Exception:
        pass  # Keep defaults on any error

    return stats


def generate_agents_content(existing_content: Optional[str] = None) -> str:
    """Generate AGENTS.md content with stats."""
    repo_root = find_repo_root()
    stats = gather_stats(repo_root)

    generated_at = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")

    content = AGENTS_TEMPLATE.format(
        ontos_version=ontos.__version__,
        generated_at=generated_at,
        doc_count=stats["doc_count"],
        last_updated=stats["last_updated"],
        current_branch=stats["current_branch"],
        last_log=stats["last_log"],
        health_summary=stats["health_summary"],
    )
    
    # Preserve USER CUSTOM section if it exists
    if existing_content and "<!-- USER CUSTOM -->" in existing_content:
        import re
        pattern = r"<!-- USER CUSTOM -->(.*?)<!-- /USER CUSTOM -->"
        match = re.search(pattern, existing_content, re.DOTALL)
        if match:
            custom_content = match.group(1).strip()
            if custom_content:
                # Replace the placeholder in the new content
                placeholder_pattern = r"(<!-- USER CUSTOM -->).*?(<!-- /USER CUSTOM -->)"
                content = re.sub(
                    placeholder_pattern,
                    f"\\1\n{custom_content}\n\\2",
                    content,
                    flags=re.DOTALL
                )
    
    return content


def transform_to_cursorrules(agents_content: str) -> str:
    """
    Transform AGENTS.md content to .cursorrules format.
    
    Per Appendix B transform rules.
    """
    lines = agents_content.split('\n')
    result = []
    
    in_section = None
    skip_until_next_section = False
    
    for line in lines:
        # Title replacement
        if line.startswith('# AGENTS.md'):
            result.append('# Ontos Protocol for Cursor')
            continue
        
        # Section detection
        if line.startswith('## '):
            section_name = line[3:].strip()
            skip_until_next_section = False
            
            if section_name == 'Ontos Activation':
                result.append('')
                result.append('When the user says "Ontos" or "Activate Ontos":')
                result.append('')
                result.append('## Activation')
                in_section = 'activation'
                continue
            elif section_name == 'Session End':
                result.append('')
                result.append('When ending a session:')
                result.append('')
                result.append('## Session End')
                in_section = 'session_end'
                continue
            elif section_name in ('Quick Reference', 'Project Stats', 'Core Invariants', 'Staleness'):
                result.append(line)
                in_section = section_name.lower().replace(' ', '_')
                continue
            else:
                # Remove unknown sections
                skip_until_next_section = True
                in_section = None
                continue
        
        if skip_until_next_section:
            continue
        
        result.append(line)
    
    return '\n'.join(result)


def create_backup(path: Path) -> None:
    """Create .bak backup of existing file."""
    if path.exists():
        backup_path = path.with_suffix(path.suffix + '.bak')
        backup_path.write_text(path.read_text(encoding='utf-8'), encoding='utf-8')


def agents_command(options: AgentsOptions) -> Tuple[int, str]:
    """
    Generate AGENTS.md and/or .cursorrules files.
    
    Returns:
        Tuple of (exit_code, message)
    
    Exit Codes:
        0: Success
        1: File exists (use --force)
        2: Configuration error
    """
    repo_root = find_repo_root()
    if repo_root is None:
        return 2, "Error: No repository found. Run from within a git repository or Ontos project."
    
    messages = []
    
    # Determine what to generate
    generate_agents = options.format == "agents" or options.all_formats
    generate_cursor = options.format == "cursor" or options.all_formats
    
    # Generate AGENTS.md
    if generate_agents:
        agents_path = options.output_path or repo_root / "AGENTS.md"
        
        # Path safety validation
        try:
            resolved_output = agents_path.resolve()
            resolved_root = repo_root.resolve()
            resolved_output.relative_to(resolved_root)
        except ValueError:
            return 2, f"Error: Output path must be within repository root ({repo_root})"
        
        if agents_path.exists() and not options.force:
            return 1, f"AGENTS.md already exists at {agents_path}. Use --force to overwrite."
        
        try:
            if options.force and agents_path.exists():
                create_backup(agents_path)
            
            existing_content = None
            if agents_path.exists():
                existing_content = agents_path.read_text(encoding='utf-8')
                
            agents_path.parent.mkdir(parents=True, exist_ok=True)
            content = generate_agents_content(existing_content)
            agents_path.write_text(content, encoding='utf-8')
            messages.append(f"Created {agents_path}")
        except Exception as e:
            return 2, f"Error writing AGENTS.md: {e}"
    
    # Generate .cursorrules
    if generate_cursor:
        cursor_path = repo_root / ".cursorrules"
        
        if cursor_path.exists() and not options.force:
            if generate_agents:
                # Already created AGENTS, warn about cursor
                messages.append(f".cursorrules already exists. Use --force to overwrite.")
            else:
                return 1, f".cursorrules already exists at {cursor_path}. Use --force to overwrite."
        else:
            try:
                if options.force and cursor_path.exists():
                    create_backup(cursor_path)
                
                # Check for existing AGENTS.md content to pass through
                existing_agents_path = repo_root / "AGENTS.md"
                existing_content = None
                if existing_agents_path.exists():
                    existing_content = existing_agents_path.read_text(encoding='utf-8')
                
                agents_content = generate_agents_content(existing_content)
                cursor_content = transform_to_cursorrules(agents_content)
                cursor_path.write_text(cursor_content, encoding='utf-8')
                messages.append(f"Created {cursor_path}")
            except Exception as e:
                return 2, f"Error writing .cursorrules: {e}"
    
    return 0, '\n'.join(messages) if messages else "No files generated"
