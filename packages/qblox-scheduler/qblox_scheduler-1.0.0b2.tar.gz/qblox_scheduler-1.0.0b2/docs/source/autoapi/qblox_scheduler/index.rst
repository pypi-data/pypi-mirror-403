qblox_scheduler
===============

.. py:module:: qblox_scheduler 

.. autoapi-nested-parse::

   .. list-table::
       :header-rows: 1
       :widths: auto

       * - Import alias
         - Target
       * - :class:`.QuantumDevice`
         - :class:`!qblox_scheduler.QuantumDevice`
       * - :class:`.TimeableSchedule`
         - :class:`!qblox_scheduler.TimeableSchedule`
       * - :class:`.Resource`
         - :class:`!qblox_scheduler.Resource`
       * - :class:`.ClockResource`
         - :class:`!qblox_scheduler.ClockResource`
       * - :class:`.BasebandClockResource`
         - :class:`!qblox_scheduler.BasebandClockResource`
       * - :class:`.DigitalClockResource`
         - :class:`!qblox_scheduler.DigitalClockResource`
       * - :class:`.Operation`
         - :class:`!qblox_scheduler.Operation`
       * - :obj:`.structure`
         - :obj:`!qblox_scheduler.structure`
       * - :class:`.ScheduleGettable`
         - :class:`!qblox_scheduler.ScheduleGettable`
       * - :class:`.BasicElectronicNVElement`
         - :class:`!qblox_scheduler.BasicElectronicNVElement`
       * - :class:`.BasicSpinElement`
         - :class:`!qblox_scheduler.BasicSpinElement`
       * - :class:`.BasicTransmonElement`
         - :class:`!qblox_scheduler.BasicTransmonElement`
       * - :class:`.CompositeSquareEdge`
         - :class:`!qblox_scheduler.CompositeSquareEdge`
       * - :class:`.InstrumentCoordinator`
         - :class:`!qblox_scheduler.InstrumentCoordinator`
       * - :class:`.GenericInstrumentCoordinatorComponent`
         - :class:`!qblox_scheduler.GenericInstrumentCoordinatorComponent`
       * - :class:`.SerialCompiler`
         - :class:`!qblox_scheduler.SerialCompiler`
       * - :class:`.MockLocalOscillator`
         - :class:`!qblox_scheduler.MockLocalOscillator`
       * - :class:`.SpinEdge`
         - :class:`!qblox_scheduler.SpinEdge`



Subpackages
-----------
.. toctree::
   :titlesonly:
   :maxdepth: 3

   analysis/index.rst
   backends/index.rst
   device_under_test/index.rst
   experiments/index.rst
   helpers/index.rst
   instrument_coordinator/index.rst
   operations/index.rst
   qblox/index.rst
   schedules/index.rst
   schemas/index.rst
   structure/index.rst


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   _check_unsupported_expression/index.rst
   _static_version/index.rst
   _version/index.rst
   compilation/index.rst
   enums/index.rst
   gettables/index.rst
   json_utils/index.rst
   math/index.rst
   pulse_compensation/index.rst
   resources/index.rst
   schedule/index.rst
   waveforms/index.rst
   yaml_utils/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   qblox_scheduler.HardwareAgent
   qblox_scheduler.SerialCompiler
   qblox_scheduler.BasicElectronicNVElement
   qblox_scheduler.BasicSpinElement
   qblox_scheduler.BasicTransmonElement
   qblox_scheduler.ChargeSensor
   qblox_scheduler.CompositeSquareEdge
   qblox_scheduler.QuantumDevice
   qblox_scheduler.SpinEdge
   qblox_scheduler.Step
   qblox_scheduler.ScheduleGettable
   qblox_scheduler.MockLocalOscillator
   qblox_scheduler.InstrumentCoordinator
   qblox_scheduler.GenericInstrumentCoordinatorComponent
   qblox_scheduler.Operation
   qblox_scheduler.BasebandClockResource
   qblox_scheduler.ClockResource
   qblox_scheduler.DigitalClockResource
   qblox_scheduler.Resource
   qblox_scheduler.Schedule
   qblox_scheduler.TimeableSchedule




Attributes
~~~~~~~~~~

.. autoapisummary::

   qblox_scheduler.__version__


.. py:class:: HardwareAgent(hardware_configuration: qblox_scheduler.backends.qblox_backend.QbloxHardwareCompilationConfig | dict | str | pathlib.Path, quantum_device_configuration: dict | str | pathlib.Path | qblox_scheduler.device_under_test.quantum_device.QuantumDevice | None = None, *, debug: qblox_instruments.types.DebugLevel = DebugLevel.MINIMAL_CHECK, output_dir: pathlib.Path | str | None = None)

   Hardware definition of qblox backend.
   Contains definitions for the cluster, the hardware configuration,
   and related classes to manage the instruments.

   :param hardware_configuration: The hardware configuration.
                                  Either
                                  - a QbloxHardwareCompilationConfig instance
                                  - a dictionary as pydantic model of the QbloxHardwareCompilationConfig
                                  - a json file that stores the above dictionary

                                  The cluster fields in "hardware_description" will have its `modules` field autogenerated,
                                  based on its `ip` field when they are not defined.
                                  This `ip` field is mandatory.
   :param quantum_device_configuration: The quantum device configuration.
                                        Either
                                        - a json dictionary of the QuantumDevice
                                        - a path to the file that stores the json dictionary
   :param debug: Debug level of the cluster. By default, it is set to `DebugLevel.MINIMAL_CHECK`.
                 Available debug levels are:
                 - `DebugLevel.MINIMAL_CHECK`: Check compatibility between the hardware firmware version and qblox-instruments version, and check for errors when starting and stopping sequencers.
                 - `DebugLevel.ERROR_CHECK`: Check for errors after every low-level cluster command.
                 - `DebugLevel.NO_CHECK`: Do not check for errors.
                 - `DebugLevel.VERSION_AND_ERROR_CHECK`: Combination of `DebugLEVEL.MINIMAL_CHECK` and `DebugLevel.ERROR_CHECK`.
   :param default_output_dir: Default output directory where the data will be stored.


   .. py:attribute:: _ElementType


   .. py:attribute:: _num_instances_initiated
      :value: 0



   .. py:attribute:: _hardware_configuration


   .. py:attribute:: _clusters
      :type:  dict[str, qblox_scheduler.instrument_coordinator.components.qblox.ClusterComponent]


   .. py:attribute:: _noncluster_instruments
      :type:  dict[str, qcodes.instrument.instrument.Instrument]


   .. py:attribute:: _instrument_coordinator


   .. py:attribute:: _measurement_control


   .. py:attribute:: _debug


   .. py:attribute:: _latest_compiled_schedule
      :type:  qblox_scheduler.schedules.schedule.CompiledSchedule | None
      :value: None



   .. py:property:: hardware_configuration
      :type: qblox_scheduler.backends.qblox_backend.QbloxHardwareCompilationConfig


      The (validated) hardware configuration of this hardware.
      Only available after the connections with the clusters
      have been established using `connect_clusters` if initially given as a file/dictionary.
      Note that this is **not** in json/dictionary format.


   .. py:method:: add_device_elements(device_elements: collections.abc.Sequence[qblox_scheduler.device_under_test.device_element.DeviceElement]) -> None

      Add multiple device elements to the quantum device.

      :param device_elements: list of device elements to be added



   .. py:method:: add_edges(edges: list[qblox_scheduler.device_under_test.edge.Edge]) -> None

      Add multiple edges to the quantum device.

      :param edges: list of edges to be added



   .. py:method:: connect_clusters() -> None

      Connect the defined clusters to the hardware given their identifiers.

      Will also supplement the modules to the given hardware description and/or verify them.



   .. py:property:: quantum_device
      :type: qblox_scheduler.device_under_test.quantum_device.QuantumDevice


      The quantum device active in this hardware.

      The quantum device contains the device elements
      and how the connectivity between them is defined.


   .. py:property:: instrument_coordinator
      :type: qblox_scheduler.instrument_coordinator.instrument_coordinator.InstrumentCoordinator


      The instrument coordinator active in this hardware.

      The instrument coordinator is responsible for executing
      the (compiled) schedule on the instruments in this backend.


   .. py:property:: measurement_control
      :type: quantify_core.measurement.control.MeasurementControl


      The instrument coordinator active in this hardware.

      The instrument coordinator is responsible for executing
      the (compiled) schedule on the instruments in this backend.


   .. py:method:: get_clusters() -> dict[str, qblox_instruments.Cluster]

      Get all the instantiated clusters.

      :returns: A dictionary mapping cluster names to Cluster objects.




   .. py:property:: latest_compiled_schedule
      :type: qblox_scheduler.schedules.schedule.CompiledSchedule | None


      Get the latest compiled schedule, if one exists.


   .. py:method:: run(schedule: qblox_scheduler.schedule.Schedule | qblox_scheduler.schedules.schedule.TimeableSchedule | qblox_scheduler.schedules.schedule.CompiledSchedule, *, timeout: int = 10, save_to_experiment: bool = True, save_snapshot: bool = True) -> xarray.Dataset

      Run a schedule on the hardware.

      :param schedule: The schedule to run.
      :param timeout: The timeout for retrieving the results, in seconds
      :param save_to_experiment: Whether to save the dataset to an experiment directory. The dataset and (optionally)
                                 snapshot will be saved in <datadir>/<tuid>/dataset.hdf5 and
                                 <datadir>/<tuid>/snapshot.json, where datadir is specified by
                                 :func:`~qblox_scheduler.analysis.data_handling.OutputDirectoryManager.set_datadir` and
                                 :func:`~qblox_scheduler.analysis.data_handling.OutputDirectoryManager.get_datadir`
      :param save_snapshot: Whether to save a snapshot of the experiment

      :returns: Acquisition result dataset if any acquisitions are used in the schedule.
                Empty dataset otherwise.

      :raises TimeoutError: When hardware doesn't return results in the given timeout.



   .. py:method:: compile(schedule: qblox_scheduler.schedule.Schedule | qblox_scheduler.schedules.schedule.TimeableSchedule) -> qblox_scheduler.schedules.schedule.CompiledSchedule

      Compile the schedule to the hardware.
      Compilation is already done in the `run` method,
      so run this method only if the compiled schedule requires to be investigated.

      :param schedule: The TimeableSchedule to compile for this hardware

      :returns: The compiled schedule




   .. py:method:: set_output_data_dir(datadir: pathlib.Path | str | None = None) -> None
      :staticmethod:


      Sets the output data directory.

      :param datadir: Path of the data directory. If set to ``None``, resets the datadir to the
                      default datadir (``<top_level>/data``).



   .. py:method:: _verify_hardware_configuration() -> None

      Verifies if the given hardware configuration can be run on the cluster.

      :raises TypeError: When the hardware_configuration has not been correctly initialized yet.
      :raises ValueError: When the hardware configuration does not match the modules installed on the cluster.



   .. py:method:: _create_cluster(cluster_name: str, cluster_description: dict | qblox_scheduler.backends.types.qblox.ClusterDescription) -> qblox_instruments.Cluster


   .. py:method:: _create_dummy_cluster(cluster_name: str, cluster_description: dict | qblox_scheduler.backends.types.qblox.ClusterDescription) -> qblox_instruments.Cluster



.. py:class:: SerialCompiler(name: str = 'compiler', quantum_device: qblox_scheduler.device_under_test.quantum_device.QuantumDevice | None = None)

   Bases: :py:obj:`ScheduleCompiler`


   A compiler that executes compilation passes sequentially.


   .. py:method:: construct_graph(config: SerialCompilationConfig) -> None

      Construct the compilation graph based on a provided config.

      For a serial backend, it is just a list of compilation passes.



   .. py:method:: _compilation_func(schedule: qblox_scheduler.schedules.schedule.TimeableSchedule, config: SerialCompilationConfig) -> qblox_scheduler.schedules.schedule.CompiledSchedule

      Compile a schedule using the backend and the information provided in the config.

      :param schedule: The schedule to compile.
      :param config: A dictionary containing the information needed to compile the schedule.
                     Nodes in this compiler specify what key they need information from in this
                     dictionary.



.. py:class:: BasicElectronicNVElement(/, name, **data: Any)

   Bases: :py:obj:`qblox_scheduler.device_under_test.device_element.DeviceElement`


   A device element representing an electronic qubit in an NV center.

   The submodules contain the necessary device element parameters to translate higher-level
   operations into pulses. Please see the documentation of these classes.

   .. admonition:: Examples

       Qubit parameters can be set through submodule attributes

       .. jupyter-execute::

           from qblox_scheduler import BasicElectronicNVElement

           device_element = BasicElectronicNVElement("q2")

           device_element.rxy.amp180 = 0.1
           device_element.measure.pulse_amplitude = 0.25
           device_element.measure.pulse_duration = 300e-9
           device_element.measure.acq_delay = 430e-9
           device_element.measure.acq_duration = 1e-6
           ...



   .. py:attribute:: element_type
      :type:  Literal['BasicElectronicNVElement']
      :value: 'BasicElectronicNVElement'



   .. py:attribute:: spectroscopy_operation
      :type:  SpectroscopyOperationNV


   .. py:attribute:: ports
      :type:  Ports


   .. py:attribute:: clock_freqs
      :type:  ClockFrequencies


   .. py:attribute:: reset
      :type:  ResetSpinpump


   .. py:attribute:: charge_reset
      :type:  ChargeReset


   .. py:attribute:: measure
      :type:  Measure


   .. py:attribute:: pulse_compensation
      :type:  qblox_scheduler.device_under_test.transmon_element.PulseCompensationModule


   .. py:attribute:: cr_count
      :type:  CRCount


   .. py:attribute:: rxy
      :type:  RxyNV


   .. py:method:: _generate_config() -> dict[str, dict[str, qblox_scheduler.backends.graph_compilation.OperationCompilationConfig]]

      Generate part of the device configuration specific to a single qubit.

      This method is intended to be used when this object is part of a
      device object containing multiple elements.



   .. py:method:: generate_device_config() -> qblox_scheduler.backends.graph_compilation.DeviceCompilationConfig

      Generate a valid device config for the qblox-scheduler.

      This makes use of the
      :func:`~.circuit_to_device.compile_circuit_to_device_with_config_validation` function.

      This enables the settings of this qubit to be used in isolation.

      .. note:

          This config is only valid for single qubit experiments.



.. py:class:: BasicSpinElement(/, name, **data: Any)

   Bases: :py:obj:`qblox_scheduler.device_under_test.device_element.DeviceElement`


   A device element representing a Loss-DiVincenzo Spin qubit.
   The element refers to the intrinsic spin-1/2 degree of freedom of
   individual electrons/holes trapped in quantum dots.
   The charge of the particle is coupled to a resonator.

   .. admonition:: Examples

       Qubit parameters can be set through submodule attributes

       .. jupyter-execute::

           from qblox_scheduler import BasicSpinElement

           device_element = BasicSpinElement("q1")

           device_element.rxy.amp180 = 0.1
           device_element.measure.pulse_amp = 0.25
           device_element.measure.pulse_duration = 300e-9
           device_element.measure.acq_delay = 430e-9
           device_element.measure.integration_time = 1e-6
           ...


   :param name: The name of the spin element.
   :param kwargs: Can be used to pass submodule initialization data by using submodule name
                  as keyword and as argument a dictionary containing the submodule parameter
                  names and their value.


   .. py:attribute:: element_type
      :type:  Literal['BasicSpinElement']
      :value: 'BasicSpinElement'



   .. py:attribute:: reset
      :type:  qblox_scheduler.device_under_test.transmon_element.IdlingReset


   .. py:attribute:: rxy
      :type:  RxyGaussian


   .. py:attribute:: measure
      :type:  DispersiveMeasurementSpin


   .. py:attribute:: pulse_compensation
      :type:  qblox_scheduler.device_under_test.transmon_element.PulseCompensationModule


   .. py:attribute:: ports
      :type:  PortsSpin


   .. py:attribute:: clock_freqs
      :type:  ClocksFrequenciesSpin


   .. py:method:: _generate_config() -> dict[str, dict[str, qblox_scheduler.backends.graph_compilation.OperationCompilationConfig]]

      Generate part of the device configuration specific to a single qubit trapped in a quantum
      dot. A resonator to perform dispersive readout is attached to the gate to perform charge
      sensing.

      This method is intended to be used when this object is part of a
      device object containing multiple elements.



   .. py:method:: generate_device_config() -> qblox_scheduler.backends.graph_compilation.DeviceCompilationConfig

      Generate a valid device config.

      The config will be used for the qblox-scheduler making use of the
      :func:`~.circuit_to_device.compile_circuit_to_device_with_config_validation` function.

      This enables the settings of this qubit to be used in isolation.

      .. note:

          This config is only valid for single qubit experiments.



.. py:class:: BasicTransmonElement(/, name, **data: Any)

   Bases: :py:obj:`qblox_scheduler.device_under_test.device_element.DeviceElement`


   A device element representing a single fixed-frequency transmon qubit.

   The qubit is coupled to a readout resonator.


   .. admonition:: Examples

       Qubit parameters can be set through submodule attributes

       .. jupyter-execute::

           from qblox_scheduler import BasicTransmonElement

           device_element = BasicTransmonElement("q3")

           device_element.rxy.amp180 = 0.1
           device_element.measure.pulse_amp = 0.25
           device_element.measure.pulse_duration = 300e-9
           device_element.measure.acq_delay = 430e-9
           device_element.measure.integration_time = 1e-6
           ...

   :param name: The name of the transmon element.
   :param kwargs: Can be used to pass submodule initialization data by using submodule name
                  as keyword and as argument a dictionary containing the submodule parameter
                  names and their value.


   .. py:attribute:: element_type
      :type:  Literal['BasicTransmonElement']
      :value: 'BasicTransmonElement'



   .. py:attribute:: reset
      :type:  IdlingReset


   .. py:attribute:: rxy
      :type:  RxyDRAG


   .. py:attribute:: measure
      :type:  DispersiveMeasurement


   .. py:attribute:: pulse_compensation
      :type:  PulseCompensationModule


   .. py:attribute:: ports
      :type:  Ports


   .. py:attribute:: clock_freqs
      :type:  ClocksFrequencies


   .. py:method:: _generate_config() -> dict[str, dict[str, qblox_scheduler.backends.graph_compilation.OperationCompilationConfig]]

      Generate part of the device configuration specific to a single qubit.

      This method is intended to be used when this object is part of a
      device object containing multiple elements.



   .. py:method:: generate_device_config() -> qblox_scheduler.backends.graph_compilation.DeviceCompilationConfig

      Generate a valid device config.

      The config will be used for the qblox-scheduler making use of the
      :func:`~.circuit_to_device.compile_circuit_to_device_with_config_validation` function.

      This enables the settings of this device element to be used in isolation.

      .. note:

          This config is only valid for single qubit experiments.



.. py:class:: ChargeSensor(/, name, **data: Any)

   Bases: :py:obj:`qblox_scheduler.device_under_test.device_element.DeviceElement`


   A device element representing a Charge Sensor connected to a tank circuit to perform
   dispersive readout.

   .. admonition:: Examples

       Sensor parameters can be set through submodule attributes

       .. jupyter-execute::

           from qblox_scheduler import ChargeSensor

           sensor = ChargeSensor("s1")

           sensor.measure.pulse_amp = 0.25
           sensor.measure.pulse_duration = 300e-9
           sensor.measure.acq_delay = 430e-9
           sensor.measure.integration_time = 1e-6
           ...

   :param name: The name of the spin element.
   :param kwargs: Can be used to pass submodule initialization data by using submodule name
                  as keyword and as argument a dictionary containing the submodule parameter
                  names and their value.


   .. py:attribute:: element_type
      :type:  Literal['ChargeSensor']
      :value: 'ChargeSensor'



   .. py:attribute:: measure
      :type:  DispersiveMeasurementSpin


   .. py:attribute:: pulse_compensation
      :type:  qblox_scheduler.device_under_test.transmon_element.PulseCompensationModule


   .. py:attribute:: ports
      :type:  PortsChargeSensor


   .. py:attribute:: clock_freqs
      :type:  ClocksFrequenciesSensor


   .. py:method:: _generate_config() -> dict[str, dict[str, qblox_scheduler.backends.graph_compilation.OperationCompilationConfig]]

      Generate part of the device configuration specific to a single qubit.

      This method is intended to be used when this object is part of a
      device object containing multiple elements.



   .. py:method:: generate_device_config() -> qblox_scheduler.backends.graph_compilation.DeviceCompilationConfig

      Generate a valid device config.

      The config will be used for the qblox-scheduler making use of the
      :func:`~.circuit_to_device.compile_circuit_to_device_with_config_validation` function.

      This enables the settings of this qubit to be used in isolation.

      .. note:

          This config is only valid for single qubit experiments.



.. py:class:: CompositeSquareEdge(parent_element: qblox_scheduler.device_under_test.device_element.DeviceElement | str | None = None, child_element: qblox_scheduler.device_under_test.device_element.DeviceElement | str | None = None, **data: Any)

   Bases: :py:obj:`qblox_scheduler.device_under_test.edge.Edge`


   An example Edge implementation which connects two BasicTransmonElements.

   This edge implements a square flux pulse and two virtual z
   phase corrections for the CZ operation between the two BasicTransmonElements.


   .. py:attribute:: edge_type
      :type:  Literal['CompositeSquareEdge']
      :value: 'CompositeSquareEdge'



   .. py:attribute:: _parent_device_element
      :type:  qblox_scheduler.device_under_test.transmon_element.BasicTransmonElement | None
      :value: None



   .. py:attribute:: _child_device_element
      :type:  qblox_scheduler.device_under_test.transmon_element.BasicTransmonElement | None
      :value: None



   .. py:attribute:: cz
      :type:  CZ


   .. py:method:: generate_edge_config() -> dict[str, dict[str, qblox_scheduler.backends.graph_compilation.OperationCompilationConfig]]

      Generate valid device config.

      Fills in the edges information to produce a valid device config for the
      qblox-scheduler making use of the
      :func:`~.circuit_to_device.compile_circuit_to_device_with_config_validation` function.



.. py:class:: QuantumDevice(/, name, **data: Any)

   Bases: :py:obj:`qblox_scheduler.structure.model.SchedulerBaseModel`


   The QuantumDevice directly represents the device under test (DUT).

   This contains a description of the connectivity to the control hardware as
   well as parameters specifying quantities like cross talk, attenuation and
   calibrated cable-delays. The QuantumDevice also contains references to
   individual DeviceElements, representations of elements on a device (e.g, a
   transmon qubit) containing the (calibrated) control-pulse parameters.

   This object can be used to generate configuration files for the compilation step
   from the gate-level to the pulse level description.
   These configuration files should be compatible with the
   :meth:`~qblox_scheduler.backends.graph_compilation.ScheduleCompiler.compile`
   function.


   .. py:attribute:: model_config

      Configuration for the model, should be a dictionary conforming to [`ConfigDict`][pydantic.config.ConfigDict].


   .. py:attribute:: elements
      :type:  dict[str, ConcreteDeviceElement]
      :value: None



   .. py:attribute:: edges
      :type:  dict[str, ConcreteEdge]
      :value: None



   .. py:attribute:: instr_instrument_coordinator
      :type:  qblox_scheduler.instrument_coordinator.InstrumentCoordinator | None
      :value: None



   .. py:attribute:: cfg_sched_repetitions
      :type:  pydantic.PositiveInt
      :value: None



   .. py:attribute:: keep_original_schedule
      :type:  bool
      :value: None



   .. py:attribute:: hardware_config
      :type:  qblox_scheduler.backends.types.common.HardwareCompilationConfig | dict | None
      :value: None



   .. py:attribute:: scheduling_strategy
      :type:  qblox_scheduler.enums.SchedulingStrategy
      :value: None



   .. py:method:: validate_instrument_coordinator(value: str | qblox_scheduler.instrument_coordinator.InstrumentCoordinator | None) -> qcodes.instrument.Instrument | None
      :classmethod:


      Load InstrumentCoordinator instance from its name.

      Pydantic doesn't know how to handle a QCoDeS instrument; thus, we have to allow
      arbitrary types and manually fetch them with `find_or_create_instrument`.



   .. py:method:: validate_scheduling_strategy(value: str | qblox_scheduler.enums.SchedulingStrategy) -> qblox_scheduler.enums.SchedulingStrategy
      :classmethod:


      Force `scheduling_strategy` into its proper enum value.



   .. py:method:: validate_elements_and_edges(data: Any, handler: pydantic.ModelWrapValidatorHandler[typing_extensions.Self]) -> typing_extensions.Self
      :classmethod:


      Add elements and edges to the model by calling `add_element` and `add_edge`
      respectively to force our consistency checks.



   .. py:method:: generate_compilation_config() -> qblox_scheduler.backends.graph_compilation.SerialCompilationConfig

      Generate a config for use with a :class:`~.graph_compilation.ScheduleCompiler`.



   .. py:method:: generate_hardware_config() -> dict[str, Any]

      Generate a valid hardware configuration describing the quantum device.

      :returns: The hardware configuration file used for compiling from the quantum-device
                layer to a hardware backend.

      .. warning:

          The config currently has to be specified by the user using the
          :code:`hardware_config` parameter.




   .. py:method:: generate_device_config() -> qblox_scheduler.backends.graph_compilation.DeviceCompilationConfig

      Generate a device config.

      This config is used to compile from the quantum-circuit to the
      quantum-device layer.



   .. py:method:: generate_hardware_compilation_config() -> qblox_scheduler.backends.types.common.HardwareCompilationConfig | None

      Generate a hardware compilation config.

      The compilation config is used to compile from the quantum-device to the
      control-hardware layer.



   .. py:method:: get_element(name: str) -> qblox_scheduler.device_under_test.device_element.DeviceElement

      Return a :class:`~qblox_scheduler.device_under_test.device_element.DeviceElement`
      by name.

      :param name: The element name.

      :returns: :
                    The element.

      :raises KeyError: If key ``name`` is not present in `self.elements`.



   .. py:method:: add_element(element: qblox_scheduler.device_under_test.device_element.DeviceElement) -> None

      Add an element to the elements collection.

      :param element: The element to add.

      :raises ValueError: If an element with a duplicated name is added to the collection.
      :raises TypeError: If :code:`element` is not an instance of the base element.



   .. py:method:: remove_element(name: str) -> None

      Removes an element by name.

      :param name: The element name.
                   Has to follow the convention ``"{element_0}_{element_1}"``.



   .. py:method:: get_edge(name: str) -> qblox_scheduler.device_under_test.edge.Edge

      Returns an edge by name.

      :param name: The edge name.
                   Has to follow the convention ``"{element_0}_{element_1}"``.

      :returns: :
                    The edge.

      :raises KeyError: If key ``name`` is not present in ``self.edges``.



   .. py:method:: add_edge(edge: qblox_scheduler.device_under_test.edge.Edge) -> None

      Add the edges.

      :param edge: The edge to add.



   .. py:method:: remove_edge(name: str) -> None

      Remove an edge by name.

      :param name: The edge name connecting the elements.
                   Has to follow the convention ``"{element_0}_{element_1}"``.



   .. py:method:: from_json_file(filename: str | pathlib.Path) -> typing_extensions.Self
      :classmethod:


      Read JSON data from a file and convert it to an instance of the attached class.



.. py:class:: SpinEdge(parent_element: qblox_scheduler.device_under_test.device_element.DeviceElement | str | None = None, child_element: qblox_scheduler.device_under_test.device_element.DeviceElement | str | None = None, **data: Any)

   Bases: :py:obj:`qblox_scheduler.device_under_test.edge.Edge`


   Spin edge implementation which connects two BasicSpinElements.

   This edge implements some operations between the two BasicSpinElements.


   .. py:attribute:: edge_type
      :type:  Literal['SpinEdge']
      :value: 'SpinEdge'



   .. py:attribute:: _parent_device_element
      :type:  qblox_scheduler.device_under_test.spin_element.BasicSpinElement | None
      :value: None



   .. py:attribute:: _child_device_element
      :type:  qblox_scheduler.device_under_test.spin_element.BasicSpinElement | None
      :value: None



   .. py:attribute:: spin_init
      :type:  SpinInit


   .. py:attribute:: cz
      :type:  CZ


   .. py:attribute:: cnot
      :type:  CNOT


   .. py:attribute:: ports
      :type:  PortSpinEdge


   .. py:method:: generate_edge_config() -> dict[str, dict[str, qblox_scheduler.backends.graph_compilation.OperationCompilationConfig]]

      Generate valid device config.

      Fills in the edges information to produce a valid device config for the
      qblox-scheduler making use of the
      :func:`~.circuit_to_device.compile_circuit_to_device_with_config_validation` function.



.. py:class:: Step(name: str)

   Bases: :py:obj:`qblox_scheduler.json_utils.JSONSchemaValMixin`, :py:obj:`collections.UserDict`, :py:obj:`abc.ABC`


   A step containing a single (possibly) near-time operation to be performed in an experiment.

   An `Experiment` consists of steps, each of which performs a specific operation
   (usually on hardware). There is no real-time guarantee between steps, as opposed to `Operation`.


   .. py:attribute:: schema_filename
      :value: 'step.json'



   .. py:attribute:: _class_signature
      :value: None



   .. py:method:: _update() -> None

      Update the Step's internals.



   .. py:method:: clone() -> Step

      Clone this operation into a new independent operation.



   .. py:method:: substitute(substitutions: dict[qblox_scheduler.operations.expressions.Expression, qblox_scheduler.operations.expressions.Expression | int | float | complex]) -> Step

      Substitute matching expressions in operand, possibly evaluating a result.



   .. py:property:: name
      :type: str


      Return the name of the step.


   .. py:method:: _get_signature(parameters: dict) -> str
      :classmethod:


      Returns the constructor call signature of this instance for serialization.

      The string constructor representation can be used to recreate the object
      using eval(signature).

      :param parameters: The current data dictionary.
      :type parameters: dict

      :returns: :




   .. py:method:: run(device: qblox_scheduler.device_under_test.QuantumDevice, timeout: int) -> xarray.Dataset | None
      :abstractmethod:


      Execute step on quantum device.



.. py:class:: ScheduleGettable(quantum_device: qblox_scheduler.device_under_test.quantum_device.QuantumDevice, schedule_function: collections.abc.Callable[Ellipsis, qblox_scheduler.schedule.Schedule | qblox_scheduler.schedule.TimeableSchedule], schedule_kwargs: dict[str, Any], num_channels: int = 1, data_labels: list[str] | None = None, real_imag: bool = True, batched: bool = False, max_batch_size: int = 1024, always_initialize: bool = True, return_xarray: bool = False)

   Generic gettable for a quantify schedule using vector (I,Q) acquisition.

   The gettable evaluates the parameters passed as ``schedule_kwargs``, then generates
   the :class:`qblox_scheduler.schedules.schedule.TimeableSchedule` using the
   ``schedule_function``, this is then compiled and finally executed by the
   :class:`~.InstrumentCoordinator`.

   ``ScheduleGettable`` can be set to return either static (demodulated) I and Q
   values or magnitude and phase.

   :param quantum_device: The qcodes instrument representing the quantum device under test (DUT)
                          containing quantum device properties and setup configuration information.
   :param schedule_function: A function which returns a :class:`qblox_scheduler.schedule.Schedule` or
                             :class:`qblox_scheduler.schedules.schedule.TimeableSchedule`. The
                             function is required to have the ``repetitions`` keyword argument.
   :param schedule_kwargs: The schedule function keyword arguments, when a value in this dictionary is
                           a :class:`~qcodes.parameters.parameter.Parameter`, this parameter will be
                           evaluated every time :code:`.get()` is called before being passed to the
                           :code:`schedule_function`.
   :param num_channels: The number of channels to expect in the acquisition data.
   :param data_labels: Allows to specify custom labels. Needs to be precisely 2*num_channels if
                       specified. The order is [Voltage I 0, Voltage Q 0, Voltage I 1, Voltage Q 1,
                       ...], in case real_imag==True, otherwise [Magnitude 0, Phase 0, Magnitude 1,
                       Phase 1, ...].
   :param real_imag: If true, the gettable returns I, Q values. Otherwise, magnitude and phase
                     (degrees) are returned.
   :param batched: Used to indicate if the experiment is performed in batches or in an
                   iterative fashion.
   :param max_batch_size: Determines the maximum number of points to acquire when acquiring in batched
                          mode. Can be used to split up a program in parts if required due to hardware
                          constraints.
   :param always_initialize: If True, then reinitialize the schedule on each invocation of ``get``. If
                             False, then only initialize the first invocation of ``get``.


   .. py:attribute:: _data_labels_specified


   .. py:attribute:: always_initialize
      :value: True



   .. py:attribute:: is_initialized
      :value: False



   .. py:attribute:: _compiled_schedule
      :type:  qblox_scheduler.schedules.schedule.CompiledSchedule | None
      :value: None



   .. py:attribute:: real_imag
      :value: True



   .. py:attribute:: batched
      :value: False



   .. py:attribute:: batch_size
      :value: 1024



   .. py:attribute:: _return_xarray
      :value: False



   .. py:attribute:: schedule_function


   .. py:attribute:: schedule_kwargs


   .. py:attribute:: _evaluated_sched_kwargs


   .. py:attribute:: quantum_device


   .. py:attribute:: _backend
      :value: None



   .. py:attribute:: _debug_mode
      :type:  bool
      :value: False



   .. py:method:: compile() -> qblox_scheduler.schedules.schedule.CompiledSchedule

      Compile the schedule without preparing and running it.
      The returned compiled schedule can be used to
      plot the circuit or pulse diagrams for example.

      :returns: :
                    The compiled schedule.




   .. py:method:: initialize() -> None

      Generates the schedule and uploads the compiled instructions to the
      hardware using the instrument coordinator.



   .. py:property:: compiled_schedule
      :type: qblox_scheduler.schedules.schedule.CompiledSchedule | None


      Get the latest compiled schedule, or None if nothing has been compiled yet.


   .. py:method:: get() -> tuple[numpy.ndarray, Ellipsis]

      Start the experimental sequence and retrieve acquisition data.

      The data format returned is dependent on the type of acquisitions used
      in the schedule. These data formats can be found in the :ref:`user guide
      <sec-user-guide-acquisition-data-schedulegettable>`.

      :returns: :
                    A tuple of acquisition data per acquisition channel as specified above.




   .. py:method:: initialize_and_get_with_report() -> str

      Create a report that saves all information from this experiment in a zipfile.

      Run :meth:`~.ScheduleGettable.initialize` and :meth:`~.ScheduleGettable.get`
      and capture all information from the experiment in a zipfile in the quantify
      datadir.
      The basic information in the report includes the schedule, device config and
      hardware config. The method attempts to compile the schedule, and if it
      succeeds, it runs the experiment and adds the compiled schedule, a snapshot of
      the instruments, and logs from the actual hardware (only Qblox instruments
      supported currently) to the zipfile.
      A full error trace is also included if any of these steps fail.

      :returns: :
                    A path to the generated report. Directory name includes a flag indicating at
                    which state the experiment and report retrieval stopped.

                    Flags (defined in :func: `~._generate_diagnostics_report`):

                    - ``failed_initialization``: The experiment failed during             :meth:`~.ScheduleGettable.initialize`.
                    - ``failed_exp``: The experiment initialized failed during             :meth:`~.ScheduleGettable.get`.
                    - ``failed_connection_to_hw``: The experiment initialized but both             :meth:`~.ScheduleGettable.get` and             :meth:`~.InstrumentCoordinator.retrieve_hardware_logs` failed. Connection             to hardware was likely interrupted during runtime.
                    - ``failed_hw_log_retrieval``: The experiment succeeded but             :meth:`~.InstrumentCoordinator.retrieve_hardware_logs` failed.
                    - ``completed_exp``: The experiment succeeded.




.. py:class:: MockLocalOscillator(name: str)

   Bases: :py:obj:`qcodes.instrument.instrument.Instrument`


   A class representing a dummy Local Oscillator.

   :param name: QCoDeS name of the instrument.


   .. py:method:: _add_qcodes_parameters_dummy() -> None

      Use to fake communications.



.. py:class:: InstrumentCoordinator(name: str, add_default_generic_icc: bool = True)

   Bases: :py:obj:`qcodes.instrument.instrument.Instrument`


   The :class:`~.InstrumentCoordinator` serves as
   the central interface of the hardware abstraction layer.

   It provides a standardized interface to execute Schedules on
   control hardware.

   The :class:`~.InstrumentCoordinator` has two main functionalities exposed to the
   user, the ability to configure its
   :mod:`~.instrument_coordinator.components`
   representing physical instruments, and the ability to execute experiments.


   .. admonition:: Executing a schedule using the instrument coordinator
       :class: dropdown

       To execute a :class:`~.TimeableSchedule` , one needs to first
       compile a schedule and then configure all the instrument coordinator components
       using :meth:`~.InstrumentCoordinator.prepare`.
       After starting the experiment, the results can be retrieved using
       :meth:`~.InstrumentCoordinator.retrieve_acquisition`.

       .. code-block::

           from qblox_scheduler.backends.graph_compilation import SerialCompiler

           my_sched: TimeableSchedule = ...  # a schedule describing the experiment to perform
           quantum_device: QuantumDevice = ...  # the device under test
           hardware_config: dict = ...  # a config file describing the connection to the hardware

           quantum_device.hardware_config = hardware_config

           compiler = SerialCompiler(name="compiler")
           compiled_sched = compiler.compile(
               schedule=sched, config=quantum_device.generate_compilation_config()
           )

           instrument_coordinator.prepare(compiled_sched)
           instrument_coordinator.start()
           dataset = instrument_coordinator.retrieve_acquisition()

   .. admonition:: Adding components to the instrument coordinator
       :class: dropdown

       In order to distribute compiled instructions and execute an experiment,
       the instrument coordinator needs to have references to the individual
       instrument coordinator components. They can be added using
       :meth:`~.InstrumentCoordinator.add_component`.

       .. code-block::

           instrument_coordinator.add_component(qcm_component)

   :param name: The name for the instrument coordinator instance.
   :param add_default_generic_icc: If True, automatically adds a GenericInstrumentCoordinatorComponent to this
                                   instrument coordinator with the default name.


   .. py:attribute:: components


   .. py:attribute:: timeout


   .. py:attribute:: _last_schedule
      :value: None



   .. py:attribute:: _compiled_schedule
      :value: None



   .. py:property:: last_schedule
      :type: qblox_scheduler.schedules.schedule.CompiledSchedule


      Returns the last schedule used to prepare the instrument coordinator.

      This feature is intended to aid users in debugging.


   .. py:property:: is_running
      :type: bool


      Returns if any of the :class:`.InstrumentCoordinator` components is running.

      :returns: :
                    The :class:`.InstrumentCoordinator`'s running state.


   .. py:method:: get_component(full_name: str) -> qblox_scheduler.instrument_coordinator.components.base.InstrumentCoordinatorComponentBase

      Returns the InstrumentCoordinator component by name.

      :param full_name: The component name.

      :returns: :
                    The component.

      :raises KeyError: If key ``name`` is not present in ``self.components``.



   .. py:method:: add_component(component: qblox_scheduler.instrument_coordinator.components.base.InstrumentCoordinatorComponentBase) -> None

      Adds a component to the components collection.

      :param component: The component to add.

      :raises ValueError: If a component with a duplicated name is added to the collection.
      :raises TypeError: If :code:`component` is not an instance of the base component.



   .. py:method:: remove_component(name: str) -> None

      Removes a component by name.

      :param name: The component name.



   .. py:method:: prepare(compiled_schedule: qblox_scheduler.schedules.schedule.CompiledSchedule) -> None

      Prepares each component for execution of a schedule.

      It attempts to configure all instrument coordinator components for which
      compiled instructions, typically consisting of a combination of sequence
      programs, waveforms and other instrument settings, are available in the
      compiled schedule.


      :param compiled_schedule: A schedule containing the information required to execute the program.

      :raises KeyError: If the compiled schedule contains instructions for a component
          absent in the instrument coordinator.
      :raises TypeError: If the schedule provided is not a valid :class:`.CompiledSchedule`.



   .. py:method:: start() -> None

      Start all of the components that appear in the compiled instructions.

      The instruments will be started in the order in which they were added to the
      instrument coordinator.



   .. py:method:: stop(allow_failure: bool = False) -> None

      Stops all components.

      The components are stopped in the order in which they were added.

      :param allow_failure: By default it is set to `False`. When set to `True`, the AttributeErrors
                            raised by a component are demoted to warnings to allow other
                            components to stop.



   .. py:method:: retrieve_acquisition() -> xarray.Dataset

      Retrieves the latest acquisition results of the components with acquisition capabilities.

      :returns: :
                    The acquisition data in an :code:`xarray.Dataset`.
                    For each acquisition channel it contains an :code:`xarray.DataArray`.




   .. py:method:: wait_done(timeout_sec: int = 10) -> None

      Awaits each component until it is done.

      The timeout in seconds specifies the allowed amount of time to run before
      it times out.

      :param timeout_sec: The maximum amount of time in seconds before a timeout.



   .. py:method:: retrieve_hardware_logs() -> dict[str, dict]

      Return the hardware logs of the instruments of each component.

      The instruments must be referenced in the :class:`.CompiledSchedule`.

      :returns: :
                    A nested dict containing the components hardware logs




.. py:class:: GenericInstrumentCoordinatorComponent(instrument_reference: str | qcodes.instrument.instrument_base.InstrumentBase = DEFAULT_NAME)

   Bases: :py:obj:`qblox_scheduler.instrument_coordinator.components.base.InstrumentCoordinatorComponentBase`


   A Generic class which can be used for interaction with the InstrumentCoordinator.

   The GenericInstrumentCoordinatorComponent should be able to accept any type of
   qcodes instrument. The component is meant to serve as an interface for simple
   access to instruments such as the local oscillator, or current source which needs to
   only set parameters. For now this component is not being used in any of the hardware
   backends' compilation step. This will be fixed in the next official release.


   .. py:attribute:: _no_gc_instances
      :type:  ClassVar[dict[str, qcodes.instrument.instrument_base.InstrumentBase]]


   .. py:property:: is_running
      :type: bool


      A state whether an instrument is capable of running in a program.

      Not to be confused with the on/off state of an
      instrument.


   .. py:method:: start() -> None

      Start the instrument.



   .. py:method:: stop() -> None

      Stop the instrument.



   .. py:method:: prepare(params_config: dict[str, Any]) -> None

      Prepare the instrument.

      params_config has keys which should correspond to parameter names of the
      instrument and the corresponding values to be set. Always ensure that the
      key to the params_config is in the format 'instrument_name.parameter_name'
      See example below.

      .. code-block:: python

          params_config = {
                           "lo_mw_q0.frequency": 6e9,
                           "lo_mw_q0.power": 13, "lo_mw_q0.status": True,
                           "lo_ro_q0.frequency": 8.3e9, "lo_ro_q0.power": 16,
                           "lo_ro_q0.status": True,
                           "lo_spec_q0.status": False,
                          }




   .. py:method:: _set_params_to_devices(params_config: dict) -> None

      Set the parameters in the params_config dict
      to the generic devices set in the hardware_config.

      The bool force_set_parameters is used to
      change the lazy_set behavior.



   .. py:method:: retrieve_acquisition() -> xarray.Dataset | None

      Retrieve acquisition.



   .. py:method:: get_hardware_log(compiled_schedule: qblox_scheduler.schedules.schedule.CompiledSchedule) -> dict | None

      Get the hardware log.



   .. py:method:: wait_done(timeout_sec: int = 10) -> None

      Wait till done.



.. py:class:: Operation(name: str)

   Bases: :py:obj:`qblox_scheduler.json_utils.JSONSchemaValMixin`, :py:obj:`collections.UserDict`


   A representation of quantum circuit operations.

   The :class:`~Operation` class is a JSON-compatible data structure that contains information
   on how to represent the operation on the quantum-circuit and/or the quantum-device
   layer. It also contains information on where the operation should be applied: the
   :class:`~qblox_scheduler.resources.Resource` s used.

   An operation always has the following attributes:

   - duration (float): duration of the operation in seconds (can be 0).
   - hash (str): an auto generated unique identifier.
   - name (str): a readable identifier, does not have to be unique.



   An Operation can contain information  on several levels of abstraction.
   This information is used when different representations are required. Note that when
   initializing an operation  not all of this information needs to be available
   as operations are typically modified during the compilation steps.

   .. tip::

       :mod:`qblox_scheduler` comes with a
       :mod:`~qblox_scheduler.operations.gate_library` and a
       :mod:`~qblox_scheduler.operations.pulse_library` , both containing common
       operations.


   **JSON schema of a valid Operation**

   .. jsonschema:: https://gitlab.com/qblox/packages/software/qblox-scheduler/-/raw/main/src/qblox_scheduler/schemas/operation.json


   .. note::

       Two different Operations containing the same information generate the
       same hash and are considered identical.


   .. py:attribute:: schema_filename
      :value: 'operation.json'



   .. py:attribute:: _class_signature
      :value: None



   .. py:attribute:: _duration
      :type:  float
      :value: 0



   .. py:method:: clone() -> Operation

      Clone this operation into a new independent operation.



   .. py:method:: substitute(substitutions: dict[qblox_scheduler.operations.expressions.Expression, qblox_scheduler.operations.expressions.Expression | int | float | complex]) -> Operation

      Substitute matching expressions in operand, possibly evaluating a result.



   .. py:property:: name
      :type: str


      Return the name of the operation.


   .. py:property:: duration
      :type: float


      Determine operation duration from pulse_info.

      If the operation contains no pulse info, it is assumed to be ideal and
      have zero duration.


   .. py:property:: hash
      :type: str


      A hash based on the contents of the Operation.

      Needs to be a str for easy compatibility with json.


   .. py:method:: _get_signature(parameters: dict) -> str
      :classmethod:


      Returns the constructor call signature of this instance for serialization.

      The string constructor representation can be used to recreate the object
      using eval(signature).

      :param parameters: The current data dictionary.
      :type parameters: dict

      :returns: :




   .. py:method:: add_gate_info(gate_operation: Operation) -> None

      Updates self.data['gate_info'] with contents of gate_operation.

      :param gate_operation: an operation containing gate_info.



   .. py:method:: add_device_representation(device_operation: Operation) -> None

      Adds device-level representation details to the current operation.

      :param device_operation: an operation containing the pulse_info and/or acquisition info describing
                               how to represent the current operation at the quantum-device layer.



   .. py:method:: get_used_port_clocks() -> set[tuple[str, str]]

      Extracts which port-clock combinations are used in this operation.

      :returns: :
                    All (port, clock) combinations this operation uses.




   .. py:method:: is_valid(object_to_be_validated: Operation) -> bool
      :classmethod:


      Validates the object's contents against the schema.

      Additionally, checks if the hash property of the object evaluates correctly.



   .. py:property:: valid_gate
      :type: bool


      An operation is a valid gate if it has gate-level representation details.


   .. py:property:: valid_pulse
      :type: bool


      An operation is a valid pulse if it has pulse-level representation details.


   .. py:property:: valid_acquisition
      :type: bool


      An operation is a valid acquisition
      if it has pulse-level acquisition representation details.


   .. py:property:: is_conditional_acquisition
      :type: bool


      An operation is conditional if one of the following holds, ``self`` is an
      an acquisition with a ``feedback_trigger_label`` assigned to it.


   .. py:property:: is_control_flow
      :type: bool


      Determine if operation is a control flow operation.

      :returns: bool
                    Whether the operation is a control flow operation.


   .. py:property:: has_voltage_offset
      :type: bool


      Checks if the operation contains information for a voltage offset.


.. py:class:: BasebandClockResource(name: str)

   Bases: :py:obj:`Resource`


   Global identity for a virtual baseband clock.

   Baseband signals are assumed to be real-valued and will not be modulated.

   :param name: the name of this clock


   .. py:attribute:: IDENTITY
      :value: 'cl0.baseband'



   .. py:attribute:: data


.. py:class:: ClockResource(name: str, freq: float, phase: float = 0)

   Bases: :py:obj:`Resource`


   The ClockResource corresponds to a physical clock used to modulate pulses.

   :param name: the name of this clock
   :param freq: the frequency of the clock in Hz
   :param phase: the starting phase of the clock in deg


   .. py:attribute:: data


.. py:class:: DigitalClockResource(name: str)

   Bases: :py:obj:`Resource`


   Global identity for a virtual digital clock.

   Digital clocks can only be associated with digital channels.

   :param name: the name of this clock


   .. py:attribute:: IDENTITY
      :value: 'digital'



   .. py:attribute:: data


.. py:class:: Resource(name: str)

   Bases: :py:obj:`collections.UserDict`


   A resource corresponds to a physical resource such as a port or a clock.

   :param name: The resource name.


   .. py:property:: name
      :type: str


      Returns the name of the Resource.

      :returns: :


   .. py:property:: hash
      :type: str


      A hash based on the contents of the Operation.


.. py:class:: Schedule(name: str, repetitions: int = 1)

   High-level hybrid schedule.


   .. py:attribute:: _experiments


   .. py:attribute:: _resources
      :value: []



   .. py:attribute:: _schedule_count
      :value: None



   .. py:attribute:: _repetitions
      :value: 1



   .. py:attribute:: _uses_timeable_repetitions
      :value: False



   .. py:attribute:: _duration
      :value: None



   .. py:method:: clone() -> Schedule

      Clone this schedule into a separate independent schedule.



   .. py:method:: substitute(substitutions: dict[qblox_scheduler.operations.expressions.Expression, qblox_scheduler.operations.expressions.Expression | int | float | complex]) -> Schedule

      Substitute matching expressions of operations in this schedule.



   .. py:property:: repetitions
      :type: int


      Returns the amount of times this schedule should be repeated.


   .. py:property:: _experiment
      :type: qblox_scheduler.experiments.experiment.Experiment


      Returns the current experiment.


   .. py:property:: name
      :type: str


      Returns the name of the schedule.


   .. py:property:: _timeable_schedules
      :type: list[qblox_scheduler.schedules.schedule.TimeableSchedule]


      Returns a list of timeable schedules in this schedule.


   .. py:property:: _last_timeable_schedule
      :type: qblox_scheduler.schedules.schedule.TimeableSchedule | None


      Returns the last timeable schedule in this schedule.


   .. py:property:: _last_compiled_timeable_schedule
      :type: qblox_scheduler.schedules.schedule.CompiledSchedule | None


      Returns the last compiled timeable schedule in this schedule.


   .. py:property:: _timeable_schedule
      :type: qblox_scheduler.schedules.schedule.TimeableScheduleBase | None


      Returns the single timeable schedule in this schedule, or None.


   .. py:method:: get_schedule_duration() -> float

      Return total duration of all timeable schedules.

      :returns: schedule_duration : float
                    Duration of current schedule




   .. py:property:: duration
      :type: float | None


      Determine the cached duration of the schedule.

      Will return None if get_schedule_duration() has not been called before.


   .. py:property:: data
      :type: dict


      The dictionary data of a single contained timeable schedule.


   .. py:property:: operations
      :type: dict[str, qblox_scheduler.operations.operation.Operation | qblox_scheduler.schedules.schedule.TimeableSchedule]


      A dictionary of all unique operations used in the schedule.

      This specifies information on *what* operation to apply *where*.

      The keys correspond to the :attr:`~.Operation.hash` and values are instances
      of :class:`qblox_scheduler.operations.operation.Operation`.


   .. py:property:: schedulables
      :type: dict[str, qblox_scheduler.schedules.schedule.Schedulable]


      Ordered dictionary of schedulables describing timing and order of operations.

      A schedulable uses timing constraints to constrain the operation in time by
      specifying the time (:code:`"rel_time"`) between a reference operation and the
      added operation. The time can be specified with respect to a reference point
      (:code:`"ref_pt"') on the reference operation (:code:`"ref_op"`) and a reference
      point on the next added operation (:code:`"ref_pt_new"').
      A reference point can be either the "start", "center", or "end" of an
      operation. The reference operation (:code:`"ref_op"`) is specified using its
      label property.

      Each item in the list represents a timing constraint and is a dictionary with
      the following keys:

      .. code-block::

          ['label', 'rel_time', 'ref_op', 'ref_pt_new', 'ref_pt', 'operation_id']

      The label is used as a unique identifier that can be used as a reference for
      other operations, the operation_id refers to the hash of an
      operation in :attr:`~.TimeableScheduleBase.operations`.

      .. note::

          timing constraints are not intended to be modified directly.
          Instead use the :meth:`~.Schedule.add`


   .. py:method:: plot_circuit_diagram(figsize: tuple[int, int] | None = None, ax: matplotlib.axes.Axes | None = None, plot_backend: Literal['mpl'] = 'mpl', timeable_schedule_index: int | None = None) -> tuple[matplotlib.figure.Figure | None, matplotlib.axes.Axes | list[matplotlib.axes.Axes]]

      Create a circuit diagram visualization of the schedule using the specified plotting backend.

      The circuit diagram visualization depicts the schedule at the quantum circuit
      layer. Because qblox-scheduler uses a hybrid gate-pulse paradigm, operations
      for which no information is specified at the gate level are visualized using an
      icon (e.g., a stylized wavy pulse) depending on the information specified at
      the quantum device layer.

      Alias of :func:`qblox_scheduler.schedules._visualization.circuit_diagram.circuit_diagram_matplotlib`.

      :param figsize: matplotlib figsize.
      :param ax: Axis handle to use for plotting.
      :param plot_backend: Plotting backend to use, currently only 'mpl' is supported
      :param timeable_schedule_index: Index of timeable schedule in schedule to plot. If None (the default),
                                      will only plot if the schedule contains a single timeable schedule.

      :returns: fig
                    matplotlib figure object.
                ax
                    matplotlib axis object.



      Each gate, pulse, measurement, and any other operation are plotted in the order
      of execution, but no timing information is provided.

      .. admonition:: Example
          :class: tip

          .. jupyter-execute::

              from qblox_scheduler import Schedule
              from qblox_scheduler.operations.gate_library import Reset, X90, CZ, Rxy, Measure

              sched = Schedule(f"Bell experiment on q0-q1")

              sched.add(Reset("q0", "q1"))
              sched.add(X90("q0"))
              sched.add(X90("q1"), ref_pt="start", rel_time=0)
              sched.add(CZ(qC="q0", qT="q1"))
              sched.add(Rxy(theta=45, phi=0, qubit="q0") )
              sched.add(Measure("q0", acq_index=0))
              sched.add(Measure("q1", acq_index=0), ref_pt="start")

              sched.plot_circuit_diagram()

      .. note::

          Gates that are started simultaneously on the same qubit will overlap.

          .. jupyter-execute::

              from qblox_scheduler import Schedule
              from qblox_scheduler.operations.gate_library import X90, Measure

              sched = Schedule(f"overlapping gates")

              sched.add(X90("q0"))
              sched.add(Measure("q0"), ref_pt="start", rel_time=0)
              sched.plot_circuit_diagram();

      .. note::

          If the pulse's port address was not found then the pulse will be plotted on the
          'other' timeline.




   .. py:method:: plot_pulse_diagram(port_list: list[str] | None = None, sampling_rate: float = 1000000000.0, modulation: Literal['off', 'if', 'clock'] = 'off', modulation_if: float = 0.0, plot_backend: Literal['mpl', 'plotly'] = 'mpl', x_range: tuple[float, float] = (-np.inf, np.inf), combine_waveforms_on_same_port: bool = True, timeable_schedule_index: int | None = None, **backend_kwargs) -> tuple[matplotlib.figure.Figure, matplotlib.axes.Axes] | plotly.graph_objects.Figure

      Create a visualization of all the pulses in a schedule using the specified plotting backend.

      The pulse diagram visualizes the schedule at the quantum device layer.
      For this visualization to work, all operations need to have the information
      present (e.g., pulse info) to represent these on the quantum-circuit level and
      requires the absolute timing to have been determined.
      This information is typically added when the quantum-device level compilation is
      performed.

      Alias of
      :func:`qblox_scheduler.schedules._visualization.pulse_diagram.pulse_diagram_matplotlib`
      and
      :func:`qblox_scheduler.schedules._visualization.pulse_diagram.pulse_diagram_plotly`.

      :param port_list: A list of ports to show. If ``None`` (default) the first 8 ports encountered in the sequence are used.
      :param modulation: Determines if modulation is included in the visualization.
      :param modulation_if: Modulation frequency used when modulation is set to "if".
      :param sampling_rate: The time resolution used to sample the schedule in Hz.
      :param plot_backend: Plotting library to use, can either be 'mpl' or 'plotly'.
      :param x_range: The range of the x-axis that is plotted, given as a tuple (left limit, right
                      limit). This can be used to reduce memory usage when plotting a small section of
                      a long pulse sequence. By default (-np.inf, np.inf).
      :param combine_waveforms_on_same_port: By default True. If True, combines all waveforms on the same port into one
                                             single waveform. The resulting waveform is the sum of all waveforms on that
                                             port (small inaccuracies may occur due to floating point approximation). If
                                             False, the waveforms are shown individually.
      :param timeable_schedule_index: Index of timeable schedule in schedule to plot. If None (the default),
                                      will only plot if the schedule contains a single timeable schedule.
      :param backend_kwargs: Keyword arguments to be passed on to the plotting backend. The arguments
                             that can be used for either backend can be found in the documentation of
                             :func:`qblox_scheduler.schedules._visualization.pulse_diagram.pulse_diagram_matplotlib`
                             and
                             :func:`qblox_scheduler.schedules._visualization.pulse_diagram.pulse_diagram_plotly`.

      :returns: Union[tuple[Figure, Axes], :class:`!plotly.graph_objects.Figure`]
                    the plot


      .. admonition:: Example
          :class: tip

          A simple plot with matplotlib can be created as follows:

          .. jupyter-execute::

              from qblox_scheduler.backends.graph_compilation import SerialCompiler
              from qblox_scheduler.device_under_test.quantum_device import QuantumDevice
              from qblox_scheduler.operations.pulse_library import (
                  DRAGPulse, SquarePulse, RampPulse, VoltageOffset,
              )
              from qblox_scheduler.resources import ClockResource

              schedule = Schedule("Multiple waveforms")
              schedule.add(DRAGPulse(amplitude=0.2, beta=2e-9, phase=0, duration=4e-6, port="P", clock="C"))
              schedule.add(RampPulse(amp=0.2, offset=0.0, duration=6e-6, port="P"))
              schedule.add(SquarePulse(amp=0.1, duration=4e-6, port="Q"), ref_pt='start')
              schedule.add_resource(ClockResource(name="C", freq=4e9))

              quantum_device = QuantumDevice("quantum_device")
              device_compiler = SerialCompiler("Device compiler", quantum_device)
              compiled_schedule = device_compiler.compile(schedule)

              _ = compiled_schedule.plot_pulse_diagram(sampling_rate=20e6)

          The backend can be changed to the plotly backend by specifying the
          ``plot_backend=plotly`` argument. With the plotly backend, pulse
          diagrams include a separate plot for each port/clock
          combination:

          .. jupyter-execute::

              _ = compiled_schedule.plot_pulse_diagram(sampling_rate=20e6, plot_backend='plotly')

          The same can be achieved in the default ``plot_backend`` (``matplotlib``)
          by passing the keyword argument ``multiple_subplots=True``:

          .. jupyter-execute::

              _ = compiled_schedule.plot_pulse_diagram(sampling_rate=20e6, multiple_subplots=True)

          By default, waveforms overlapping in time on the same port are shown separately:

          .. jupyter-execute::

              schedule = Schedule("Overlapping waveforms")
              schedule.add(VoltageOffset(offset_path_I=0.25, offset_path_Q=0.0, port="Q"))
              schedule.add(SquarePulse(amp=0.1, duration=4e-6, port="Q"), rel_time=2e-6)
              schedule.add(VoltageOffset(offset_path_I=0.0, offset_path_Q=0.0, port="Q"), ref_pt="start", rel_time=2e-6)

              compiled_schedule = device_compiler.compile(schedule)

              _ = compiled_schedule.plot_pulse_diagram(sampling_rate=20e6)

          This behaviour can be changed with the parameter ``combine_waveforms_on_same_port``:

          .. jupyter-execute::

              _ = compiled_schedule.plot_pulse_diagram(sampling_rate=20e6, combine_waveforms_on_same_port=True)




   .. py:property:: timing_table
      :type: pandas.io.formats.style.Styler


      A styled pandas dataframe containing the absolute timing of pulses and acquisitions in a schedule.

      This table is constructed based on the ``abs_time`` key in the
      :attr:`~qblox_scheduler.schedules.schedule.TimeableScheduleBase.schedulables`.
      This requires the timing to have been determined.

      The table consists of the following columns:

      - `operation`: a ``repr`` of :class:`~qblox_scheduler.operations.operation.Operation` corresponding to the pulse/acquisition.
      - `waveform_op_id`: an id corresponding to each pulse/acquisition inside an :class:`~qblox_scheduler.operations.operation.Operation`.
      - `port`: the port the pulse/acquisition is to be played/acquired on.
      - `clock`: the clock used to (de)modulate the pulse/acquisition.
      - `abs_time`: the absolute time the pulse/acquisition is scheduled to start.
      - `duration`: the duration of the pulse/acquisition that is scheduled.
      - `is_acquisition`: whether the pulse/acquisition is an acquisition or not (type ``numpy.bool_``).
      - `wf_idx`: the waveform index of the pulse/acquisition belonging to the Operation.
      - `operation_hash`: the unique hash corresponding to the :class:`~.Schedulable` that the pulse/acquisition belongs to.

      .. admonition:: Example

          .. jupyter-execute::
              :hide-code:

              from qblox_scheduler.backends import SerialCompiler
              from qblox_scheduler.device_under_test.quantum_device import QuantumDevice
              from qblox_scheduler.device_under_test.transmon_element import BasicTransmonElement
              from qblox_scheduler.operations.gate_library import (
                  Measure,
                  Reset,
                  X,
                  Y,
              )
              from qblox_scheduler import Schedule
              from qblox_scheduler.schemas.examples import utils

              compiler = SerialCompiler("compiler")
              q0 = BasicTransmonElement("q0")
              q4 = BasicTransmonElement("q4")

              for device_element in [q0, q4]:
                  device_element.rxy.amp180 = 0.115
                  device_element.rxy.beta = 2.5e-10
                  device_element.clock_freqs.f01 = 7.3e9
                  device_element.clock_freqs.f12 = 7.0e9
                  device_element.clock_freqs.readout = 8.0e9
                  device_element.measure.acq_delay = 100e-9

              quantum_device = QuantumDevice(name="quantum_device0")
              quantum_device.add_element(q0)
              quantum_device.add_element(q4)

              device_config = quantum_device.generate_device_config()
              hardware_config = utils.load_json_example_scheme(
                  "qblox_hardware_config_transmon.json"
              )
              hardware_config["hardware_options"].pop("distortion_corrections")
              quantum_device.hardware_config = hardware_config

              compiler = SerialCompiler("compiler")
              compiler.quantum_device = quantum_device

          .. jupyter-execute::

              schedule = Schedule("demo timing table")
              schedule.add(Reset("q0", "q4"))
              schedule.add(X("q0"))
              schedule.add(Y("q4"))
              schedule.add(Measure("q0", acq_channel=0))
              schedule.add(Measure("q4", acq_channel=1))

              compiled_schedule = compiler.compile(schedule)
              compiled_schedule.timing_table

      :returns: :
                    styled_timing_table, a pandas Styler containing a dataframe with
                    an overview of the timing of the pulses and acquisitions present in the
                    schedule. The dataframe can be accessed through the .data attribute of
                    the Styler.

      :raises ValueError: When the absolute timing has not been determined during compilation.


   .. py:method:: _add_timeable_schedule(timeable_schedule: qblox_scheduler.schedules.schedule.TimeableSchedule) -> None


   .. py:method:: _get_current_timeable_schedule() -> qblox_scheduler.schedules.schedule.TimeableSchedule | None


   .. py:method:: _get_timeable_schedule() -> qblox_scheduler.schedules.schedule.TimeableSchedule


   .. py:method:: get_used_port_clocks() -> set[tuple[str, str]]

      Extracts which port-clock combinations are used in this schedule.

      :returns: :
                    All (port, clock) combinations that operations in this schedule uses




   .. py:method:: add_resources(resources_list: list) -> None

      Add wrapper for adding multiple resources.



   .. py:method:: add_resource(resource: qblox_scheduler.resources.Resource) -> None

      Add a resource such as a channel or device element to the schedule.



   .. py:method:: declare(dtype: qblox_scheduler.operations.expressions.DType) -> qblox_scheduler.operations.variables.Variable

      Declare a new variable.

      :param dtype: The data type of the variable.



   .. py:method:: add(operation: Schedule | qblox_scheduler.operations.operation.Operation | qblox_scheduler.schedules.schedule.TimeableSchedule | qblox_scheduler.experiments.experiment.Step, rel_time: float | qblox_scheduler.operations.expressions.Expression = 0, ref_op: qblox_scheduler.schedules.schedule.Schedulable | str | None = None, ref_pt: qblox_scheduler.schedules.schedule.OperationReferencePoint | None = None, ref_pt_new: qblox_scheduler.schedules.schedule.OperationReferencePoint | None = None, label: str | None = None) -> qblox_scheduler.schedules.schedule.Schedulable | None

      Add step, operation or timeable schedule to this schedule.



   .. py:method:: _add_schedule(schedule: Schedule, rel_time: float | qblox_scheduler.operations.expressions.Expression = 0, ref_op: qblox_scheduler.schedules.schedule.Schedulable | str | None = None, ref_pt: qblox_scheduler.schedules.schedule.OperationReferencePoint | None = None, ref_pt_new: qblox_scheduler.schedules.schedule.OperationReferencePoint | None = None, label: str | None = None) -> qblox_scheduler.schedules.schedule.Schedulable | None


   .. py:method:: loop(domain: qblox_scheduler.operations.loop_domains.LinearDomain, rel_time: float = 0, ref_op: qblox_scheduler.schedules.schedule.Schedulable | str | None = None, ref_pt: qblox_scheduler.schedules.schedule.OperationReferencePoint | None = None, ref_pt_new: qblox_scheduler.schedules.schedule.OperationReferencePoint | None = None, strategy: qblox_scheduler.operations.control_flow_library.LoopStrategy | None = None) -> collections.abc.Iterator[qblox_scheduler.operations.variables.Variable]
                  loop(*domains: qblox_scheduler.operations.loop_domains.LinearDomain, rel_time: float = 0, ref_op: qblox_scheduler.schedules.schedule.Schedulable | str | None = None, ref_pt: qblox_scheduler.schedules.schedule.OperationReferencePoint | None = None, ref_pt_new: qblox_scheduler.schedules.schedule.OperationReferencePoint | None = None, strategy: qblox_scheduler.operations.control_flow_library.LoopStrategy | None = None) -> collections.abc.Iterator[list[qblox_scheduler.operations.variables.Variable]]

      Add a loop operation to the schedule, using a with-statement.

      Every operation added while the context manager is active, will be added to the loop body.

      Example:

      .. code-block::

          sched = Schedule()
          with sched.loop(linspace(start_amp, start_amp + 1.0, 11, dtype=DType.AMP)) as amp:
              sched.add(SquarePulse(amp=amp, duration=100e-9, port="q0:mw", clock="q0.01"))

      :param domain: The object that describes the domain to be looped over.
      :param domains: Optional extra domains that will be looped over in parallel, in a zip-like fashion.
      :param rel_time: relative time between the reference operation and the added operation.
                       the time is the time between the "ref_pt" in the reference operation and
                       "ref_pt_new" of the operation that is added.
      :param ref_op: reference schedulable. If set to :code:`None`, will default
                     to the last added operation.
      :param ref_pt: reference point in reference operation must be one of
                     :code:`"start"`, :code:`"center"`, :code:`"end"`, or :code:`None`; in case
                     of :code:`None`,
                     :func:`~qblox_scheduler.compilation._determine_absolute_timing` assumes
                     :code:`"end"`.
      :param ref_pt_new: reference point in added operation must be one of
                         :code:`"start"`, :code:`"center"`, :code:`"end"`, or :code:`None`; in case
                         of :code:`None`,
                         :func:`~qblox_scheduler.compilation._determine_absolute_timing` assumes
                         :code:`"start"`.
      :param strategy: Strategy to use for implementing this loop, will default to
                       :code:`None` indicating no preference.

      :Yields: *variables* -- The Variable objects that are created for each domain.



   .. py:method:: repeat(n: int) -> collections.abc.Iterator[None]

      Add a loop operation to the schedule for a given amount of iterations,
      using a with-statement.

      Example:

      .. code-block::

          sched = Schedule()
          with sched.repeat(5):
              sched.add(SquarePulse(amp=some_amp, duration=100e-9, port="q0:mw", clock="q0.01"))

      :param n: The amount of times to repeat the loop body.



.. py:class:: TimeableSchedule(name: str = 'schedule', repetitions: int = 1, data: dict | None = None)

   Bases: :py:obj:`TimeableScheduleBase`


   A modifiable schedule.

   Operations :class:`qblox_scheduler.operations.operation.Operation` can be added
   using the :meth:`~.Schedule.add` method, allowing precise
   specification *when* to perform an operation using timing constraints.

   When adding an operation, it is not required to specify how to represent this
   :class:`qblox_scheduler.operations.operation.Operation` on all layers.
   Instead, this information can be added later during
   :ref:`compilation <sec-compilation>`.
   This allows the user to effortlessly mix the gate- and pulse-level descriptions as
   required for many (calibration) experiments.

   :param name: The name of the schedule, by default "schedule"
   :param repetitions: The amount of times the schedule will be repeated, by default 1
   :param data: A dictionary containing a pre-existing schedule, by default None


   .. py:attribute:: schema_filename
      :value: 'schedule.json'



   .. py:property:: _scope_stack
      :type: list[TimeableSchedule]



   .. py:method:: add_resources(resources_list: list) -> None

      Add wrapper for adding multiple resources.



   .. py:method:: add_resource(resource: qblox_scheduler.resources.Resource) -> None

      Add a resource such as a channel or device element to the schedule.



   .. py:method:: add(operation: qblox_scheduler.operations.operation.Operation | TimeableSchedule, rel_time: float | qblox_scheduler.operations.expressions.Expression = 0, ref_op: Schedulable | str | None = None, ref_pt: OperationReferencePoint | None = None, ref_pt_new: OperationReferencePoint | None = None, label: str | None = None) -> Schedulable

      Add an operation or a subschedule to the schedule.

      :param operation: The operation to add to the schedule, or another schedule to add
                        as a subschedule.
      :param rel_time: relative time between the reference operation and the added operation.
                       the time is the time between the "ref_pt" in the reference operation and
                       "ref_pt_new" of the operation that is added.
      :param ref_op: reference schedulable. If set to :code:`None`, will default
                     based on the chosen :code:`SchedulingStrategy`. If ASAP is chosen, the
                     previously added schedulable is the reference schedulable. If ALAP is chose,
                     the reference schedulable is the schedulable added immediately after this
                     schedulable.
      :param ref_pt: reference point in reference operation must be one of
                     :code:`"start"`, :code:`"center"`, :code:`"end"`, or :code:`None`; in case
                     of :code:`None`,
                     :func:`~qblox_scheduler.compilation._determine_absolute_timing` assumes
                     :code:`"end"`.
      :param ref_pt_new: reference point in added operation must be one of
                         :code:`"start"`, :code:`"center"`, :code:`"end"`, or :code:`None`; in case
                         of :code:`None`,
                         :func:`~qblox_scheduler.compilation._determine_absolute_timing` assumes
                         :code:`"start"`.
      :param label: a unique string that can be used as an identifier when adding operations.
                    if set to `None`, a random hash will be generated instead.

      :returns: :
                    Returns the schedulable created in the schedule.




   .. py:method:: _add(operation: qblox_scheduler.operations.operation.Operation | TimeableSchedule, rel_time: float | qblox_scheduler.operations.expressions.Expression = 0, ref_op: Schedulable | str | None = None, ref_pt: OperationReferencePoint | None = None, ref_pt_new: OperationReferencePoint | None = None, label: str | None = None) -> Schedulable


   .. py:method:: _validate_add_arguments(operation: qblox_scheduler.operations.operation.Operation | TimeableSchedule, label: str) -> None


   .. py:method:: declare(dtype: qblox_scheduler.operations.expressions.DType) -> qblox_scheduler.operations.variables.Variable

      Declare a new variable.

      :param dtype: The data type of the variable.



   .. py:method:: define(var: qblox_scheduler.operations.variables.Variable) -> None

      Add a declared variable.

      :param var: The variable.



   .. py:method:: clone() -> TimeableSchedule

      Clone this schedule into a separate independent schedule.



   .. py:method:: substitute(substitutions: dict[qblox_scheduler.operations.expressions.Expression, qblox_scheduler.operations.expressions.Expression | int | float | complex]) -> TimeableSchedule

      Substitute matching expressions in this schedule.



   .. py:method:: loop(domain: dict[qblox_scheduler.operations.variables.Variable, qblox_scheduler.operations.loop_domains.LinearDomain], rel_time: float = 0, ref_op: Schedulable | str | None = None, ref_pt: OperationReferencePoint | None = None, ref_pt_new: OperationReferencePoint | None = None, strategy: qblox_scheduler.operations.control_flow_library.LoopStrategy | None = None) -> collections.abc.Iterator[qblox_scheduler.operations.variables.Variable]
                  loop(domain: qblox_scheduler.operations.loop_domains.LinearDomain, rel_time: float = 0, ref_op: Schedulable | str | None = None, ref_pt: OperationReferencePoint | None = None, ref_pt_new: OperationReferencePoint | None = None, strategy: qblox_scheduler.operations.control_flow_library.LoopStrategy | None = None) -> collections.abc.Iterator[qblox_scheduler.operations.variables.Variable]
                  loop(*domains: qblox_scheduler.operations.loop_domains.LinearDomain, rel_time: float = 0, ref_op: Schedulable | str | None = None, ref_pt: OperationReferencePoint | None = None, ref_pt_new: OperationReferencePoint | None = None, strategy: qblox_scheduler.operations.control_flow_library.LoopStrategy | None = None) -> collections.abc.Iterator[list[qblox_scheduler.operations.variables.Variable]]

      Add a loop operation to the schedule, using a with-statement.

      Every operation added while the context manager is active, will be added to the loop body.

      Example:

      .. code-block::

          sched = TimeableSchedule()
          with sched.loop(linspace(start_amp, start_amp + 1.0, 11, dtype=DType.AMPLITUDE)) as amp:
              sched.add(SquarePulse(amp=amp, duration=100e-9, port="q0:mw", clock="q0.01"))

      :param domain: The object that describes the domain to be looped over.
      :param domains: Optional extra domains that will be looped over in parallel, in a zip-like fashion.
      :param rel_time: relative time between the reference operation and the added operation.
                       the time is the time between the "ref_pt" in the reference operation and
                       "ref_pt_new" of the operation that is added.
      :param ref_op: reference schedulable. If set to :code:`None`, will default
                     to the last added operation.
      :param ref_pt: reference point in reference operation must be one of
                     :code:`"start"`, :code:`"center"`, :code:`"end"`, or :code:`None`; in case
                     of :code:`None`,
                     :func:`~qblox_scheduler.compilation._determine_absolute_timing` assumes
                     :code:`"end"`.
      :param ref_pt_new: reference point in added operation must be one of
                         :code:`"start"`, :code:`"center"`, :code:`"end"`, or :code:`None`; in case
                         of :code:`None`,
                         :func:`~qblox_scheduler.compilation._determine_absolute_timing` assumes
                         :code:`"start"`.
      :param strategy: Strategy to use for implementing this loop, will default to
                       :code:`None` indicating no preference.

      :Yields: *variables* -- The Variable objects that are created for each domain.



   .. py:method:: repeat(n: int) -> collections.abc.Iterator[None]

      Add a loop operation to the schedule for a given amount of iterations,
      using a with-statement.

      Example:

      .. code-block::

          sched = Schedule()
          with sched.repeat(5):
              sched.add(SquarePulse(amp=some_amp, duration=100e-9, port="q0:mw", clock="q0.01"))

      :param n: The amount of times to repeat the loop body.



