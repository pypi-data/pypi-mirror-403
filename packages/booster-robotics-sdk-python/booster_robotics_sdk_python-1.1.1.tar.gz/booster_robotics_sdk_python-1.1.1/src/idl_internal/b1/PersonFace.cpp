// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file PersonFace.cpp
 * This source file contains the implementation of the described types in the
 * IDL file.
 *
 * This file was generated by the tool fastddsgen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
} // namespace
#endif // _WIN32

#include <booster_internal/idl/b1/PersonFace.h>

#include <fastcdr/Cdr.h>
#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

namespace detection {

namespace msg {

PersonFace::PersonFace(const PersonFace &x) :
    PersonFace() {
    m_xmin = x.m_xmin;
    m_ymin = x.m_ymin;
    m_xmax = x.m_xmax;
    m_ymax = x.m_ymax;
    m_position = x.m_position;
    m_tag = x.m_tag;
}

PersonFace::PersonFace(PersonFace &&x) noexcept :
    PersonFace() {
    m_xmin = x.m_xmin;
    m_ymin = x.m_ymin;
    m_xmax = x.m_xmax;
    m_ymax = x.m_ymax;
    m_position = std::move(x.m_position);
    m_tag = std::move(x.m_tag);
}

PersonFace &PersonFace::operator=(const PersonFace &x) {
    m_xmin = x.m_xmin;
    m_ymin = x.m_ymin;
    m_xmax = x.m_xmax;
    m_ymax = x.m_ymax;
    m_position = x.m_position;
    m_tag = x.m_tag;
    return *this;
}

PersonFace &PersonFace::operator=(PersonFace &&x) noexcept {
    m_xmin = x.m_xmin;
    m_ymin = x.m_ymin;
    m_xmax = x.m_xmax;
    m_ymax = x.m_ymax;
    m_position = std::move(x.m_position);
    m_tag = std::move(x.m_tag);
    return *this;
}

bool PersonFace::operator==(const PersonFace &x) const {
    return (m_xmin == x.m_xmin && m_ymin == x.m_ymin && m_xmax == x.m_xmax && m_ymax == x.m_ymax && m_position == x.m_position && m_tag == x.m_tag);
}

bool PersonFace::operator!=(const PersonFace &x) const {
    return !(*this == x);
}

/*!
 * @brief This function sets a value in member xmin
 * @param _xmin New value for member xmin
 */
void PersonFace::xmin(int64_t _xmin) {
    m_xmin = _xmin;
}

/*!
 * @brief This function returns the value of member xmin
 * @return Value of member xmin
 */
int64_t PersonFace::xmin() const {
    return m_xmin;
}

/*!
 * @brief This function returns a reference to member xmin
 * @return Reference to member xmin
 */
int64_t &PersonFace::xmin() {
    return m_xmin;
}

/*!
 * @brief This function sets a value in member ymin
 * @param _ymin New value for member ymin
 */
void PersonFace::ymin(int64_t _ymin) {
    m_ymin = _ymin;
}

/*!
 * @brief This function returns the value of member ymin
 * @return Value of member ymin
 */
int64_t PersonFace::ymin() const {
    return m_ymin;
}

/*!
 * @brief This function returns a reference to member ymin
 * @return Reference to member ymin
 */
int64_t &PersonFace::ymin() {
    return m_ymin;
}

/*!
 * @brief This function sets a value in member xmax
 * @param _xmax New value for member xmax
 */
void PersonFace::xmax(int64_t _xmax) {
    m_xmax = _xmax;
}

/*!
 * @brief This function returns the value of member xmax
 * @return Value of member xmax
 */
int64_t PersonFace::xmax() const {
    return m_xmax;
}

/*!
 * @brief This function returns a reference to member xmax
 * @return Reference to member xmax
 */
int64_t &PersonFace::xmax() {
    return m_xmax;
}

/*!
 * @brief This function sets a value in member ymax
 * @param _ymax New value for member ymax
 */
void PersonFace::ymax(int64_t _ymax) {
    m_ymax = _ymax;
}

/*!
 * @brief This function returns the value of member ymax
 * @return Value of member ymax
 */
int64_t PersonFace::ymax() const {
    return m_ymax;
}

/*!
 * @brief This function returns a reference to member ymax
 * @return Reference to member ymax
 */
int64_t &PersonFace::ymax() {
    return m_ymax;
}

/*!
 * @brief This function copies the value in member position
 * @param _position New value to be copied in member position
 */
void PersonFace::position(const std::vector<float> &_position) {
    m_position = _position;
}

/*!
 * @brief This function moves the value in member position
 * @param _position New value to be moved in member position
 */
void PersonFace::position(std::vector<float> &&_position) {
    m_position = std::move(_position);
}

/*!
 * @brief This function returns a constant reference to member position
 * @return Constant reference to member position
 */
const std::vector<float> &PersonFace::position() const {
    return m_position;
}

/*!
 * @brief This function returns a reference to member position
 * @return Reference to member position
 */
std::vector<float> &PersonFace::position() {
    return m_position;
}

/*!
 * @brief This function copies the value in member tag
 * @param _tag New value to be copied in member tag
 */
void PersonFace::tag(const std::string &_tag) {
    m_tag = _tag;
}

/*!
 * @brief This function moves the value in member tag
 * @param _tag New value to be moved in member tag
 */
void PersonFace::tag(std::string &&_tag) {
    m_tag = std::move(_tag);
}

/*!
 * @brief This function returns a constant reference to member tag
 * @return Constant reference to member tag
 */
const std::string &PersonFace::tag() const {
    return m_tag;
}

/*!
 * @brief This function returns a reference to member tag
 * @return Reference to member tag
 */
std::string &PersonFace::tag() {
    return m_tag;
}

}

} // namespace detection::msg
// Include auxiliary functions like for serializing/deserializing.
constexpr uint32_t detection_msg_PersonFace_max_cdr_typesize{704UL};
constexpr uint32_t detection_msg_PersonFace_max_key_cdr_typesize{
    0UL};
#include <fastcdr/Cdr.h>
#include <fastcdr/exceptions/BadParamException.h>

#include <fastcdr/CdrSizeCalculator.hpp>
using namespace eprosima::fastcdr::exception;

namespace eprosima {
namespace fastcdr {

template <>
eProsima_user_DllExport size_t
calculate_serialized_size(eprosima::fastcdr::CdrSizeCalculator &calculator,
                          const detection::msg::PersonFace &data,
                          size_t &current_alignment) {
    using namespace detection::msg;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding =
        calculator.get_encoding();
    size_t calculated_size{calculator.begin_calculate_type_serialized_size(
        eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ? eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 : eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
        current_alignment)};

    calculated_size += calculator.calculate_member_serialized_size(
        eprosima::fastcdr::MemberId(0), data.xmin(), current_alignment);

    calculated_size += calculator.calculate_member_serialized_size(
        eprosima::fastcdr::MemberId(1), data.ymin(), current_alignment);

    calculated_size += calculator.calculate_member_serialized_size(
        eprosima::fastcdr::MemberId(2), data.xmax(), current_alignment);

    calculated_size += calculator.calculate_member_serialized_size(
        eprosima::fastcdr::MemberId(3), data.ymax(), current_alignment);

    calculated_size += calculator.calculate_member_serialized_size(
        eprosima::fastcdr::MemberId(4), data.position(), current_alignment);

    calculated_size += calculator.calculate_member_serialized_size(
        eprosima::fastcdr::MemberId(5), data.tag(), current_alignment);

    calculated_size += calculator.end_calculate_type_serialized_size(
        previous_encoding, current_alignment);

    return calculated_size;
}

template <>
eProsima_user_DllExport void serialize(
    eprosima::fastcdr::Cdr &scdr,
    const detection::msg::PersonFace &data) {
    using namespace detection::msg;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(
        current_state,
        eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ? eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 : eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr << eprosima::fastcdr::MemberId(0) << data.xmin()
         << eprosima::fastcdr::MemberId(1) << data.ymin()
         << eprosima::fastcdr::MemberId(2) << data.xmax()
         << eprosima::fastcdr::MemberId(3) << data.ymax()
         << eprosima::fastcdr::MemberId(4) << data.position()
         << eprosima::fastcdr::MemberId(5) << data.tag();
    scdr.end_serialize_type(current_state);
}

template <>
eProsima_user_DllExport void deserialize(
    eprosima::fastcdr::Cdr &cdr, detection::msg::PersonFace &data) {
    using namespace detection::msg;

    cdr.deserialize_type(
        eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ? eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 : eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
        [&data](eprosima::fastcdr::Cdr &dcdr,
                const eprosima::fastcdr::MemberId &mid) -> bool {
            bool ret_value = true;
            switch (mid.id) {
            case 0:
                dcdr >> data.xmin();
                break;

            case 1:
                dcdr >> data.ymin();
                break;

            case 2:
                dcdr >> data.xmax();
                break;

            case 3:
                dcdr >> data.ymax();
                break;

            case 4:
                dcdr >> data.position();
                break;

            case 5:
                dcdr >> data.tag();
                break;

            default:
                ret_value = false;
                break;
            }
            return ret_value;
        });
}

void serialize_key(eprosima::fastcdr::Cdr &scdr,
                   const detection::msg::PersonFace &data) {
    using namespace detection::msg;

    static_cast<void>(scdr);
    static_cast<void>(data);
}

}
} // namespace eprosima::fastcdr

// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file PersonFaces.cpp
 * This header file contains the implementation of the serialization functions.
 *
 * This file was generated by the tool fastddsgen.
 */

#include <fastdds/rtps/common/CdrSerialization.hpp>

using SerializedPayload_t = eprosima::fastrtps::rtps::SerializedPayload_t;
using InstanceHandle_t = eprosima::fastrtps::rtps::InstanceHandle_t;
using DataRepresentationId_t = eprosima::fastdds::dds::DataRepresentationId_t;

namespace detection {
namespace msg {

PersonFace::PersonFace() {
    setName("detection::msg::dds_::PersonFace_");
    uint32_t type_size =
#if FASTCDR_VERSION_MAJOR == 1
        static_cast<uint32_t>(PersonFace::getMaxCdrSerializedSize());
#else
        detection_msg_PersonFace_max_cdr_typesize;
#endif
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(
        type_size, 4));         /* possible submessage alignment */
    m_typeSize = type_size + 4; /*encapsulation*/
    m_isGetKeyDefined = false;
    uint32_t keyLength =
        detection_msg_PersonFace_max_key_cdr_typesize > 16 ? detection_msg_PersonFace_max_key_cdr_typesize : 16;
    m_keyBuffer = reinterpret_cast<unsigned char *>(malloc(keyLength));
    memset(m_keyBuffer, 0, keyLength);
}

PersonFace::~PersonFace() {
    if (m_keyBuffer != nullptr) {
        free(m_keyBuffer);
    }
}

bool PersonFace::serialize(void *data, SerializedPayload_t *payload,
                           DataRepresentationId_t data_representation) {
    PersonFace *p_type = static_cast<PersonFace *>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(
        reinterpret_cast<char *>(payload->data), payload->max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ? eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload->encapsulation =
        ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
#if FASTCDR_VERSION_MAJOR > 1
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ? eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR : eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
#endif // FASTCDR_VERSION_MAJOR > 1

    try {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
    } catch (eprosima::fastcdr::exception::Exception & /*exception*/) {
        return false;
    }

    // Get the serialized length
#if FASTCDR_VERSION_MAJOR == 1
    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
#else
    payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
#endif // FASTCDR_VERSION_MAJOR == 1
    return true;
}

bool PersonFace::deserialize(SerializedPayload_t *payload, void *data) {
    try {
        // Convert DATA to pointer of your type
        PersonFace *p_type = static_cast<PersonFace *>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(
            reinterpret_cast<char *>(payload->data), payload->length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer,
                                     eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
#if FASTCDR_VERSION_MAJOR == 1
                                     ,
                                     eprosima::fastcdr::Cdr::CdrType::DDS_CDR
#endif // FASTCDR_VERSION_MAJOR == 1
        );

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation =
            deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    } catch (eprosima::fastcdr::exception::Exception & /*exception*/) {
        return false;
    }

    return true;
}

std::function<uint32_t()> PersonFace::getSerializedSizeProvider(
    void *data, DataRepresentationId_t data_representation) {
    return [data, data_representation]() -> uint32_t {
#if FASTCDR_VERSION_MAJOR == 1
        static_cast<void>(data_representation);
        return static_cast<uint32_t>(
                   type::getCdrSerializedSize(*static_cast<PersonFace *>(data)))
               + 4u /*encapsulation*/;
#else
        try {
            eprosima::fastcdr::CdrSizeCalculator calculator(
                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ? eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
            size_t current_alignment{0};
            return static_cast<uint32_t>(calculator.calculate_serialized_size(
                       *static_cast<PersonFace *>(data), current_alignment))
                   + 4u /*encapsulation*/;
        } catch (eprosima::fastcdr::exception::Exception & /*exception*/) {
            return 0;
        }
#endif // FASTCDR_VERSION_MAJOR == 1
    };
}

void *PersonFace::createData() {
    return reinterpret_cast<void *>(new PersonFace());
}

void PersonFace::deleteData(void *data) {
    delete (reinterpret_cast<PersonFace *>(data));
}

bool PersonFace::getKey(void *data, InstanceHandle_t *handle, bool force_md5) {
    if (!m_isGetKeyDefined) {
        return false;
    }

    PersonFace *p_type = static_cast<PersonFace *>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(
        reinterpret_cast<char *>(m_keyBuffer),
        detection_msg_PersonFace_max_key_cdr_typesize);

    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS,
                               eprosima::fastcdr::CdrVersion::XCDRv1);
#if FASTCDR_VERSION_MAJOR == 1
    p_type->serializeKey(ser);
#else
    eprosima::fastcdr::serialize_key(ser, *p_type);
#endif // FASTCDR_VERSION_MAJOR == 1
    if (force_md5 || detection_msg_PersonFace_max_key_cdr_typesize > 16) {
        m_md5.init();
#if FASTCDR_VERSION_MAJOR == 1
        m_md5.update(m_keyBuffer,
                     static_cast<unsigned int>(ser.getSerializedDataLength()));
#else
        m_md5.update(m_keyBuffer,
                     static_cast<unsigned int>(ser.get_serialized_data_length()));
#endif // FASTCDR_VERSION_MAJOR == 1
        m_md5.finalize();
        for (uint8_t i = 0; i < 16; ++i) {
            handle->value[i] = m_md5.digest[i];
        }
    } else {
        for (uint8_t i = 0; i < 16; ++i) {
            handle->value[i] = m_keyBuffer[i];
        }
    }
    return true;
}

}

} // namespace detection::msg
