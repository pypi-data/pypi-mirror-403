// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file RemoteControllerState.cpp
 * This source file contains the implementation of the described types in the
 * IDL file.
 *
 * This file was generated by the tool fastddsgen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include "RemoteControllerState.h"

#include <fastcdr/Cdr.h>
#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

namespace booster_interface {

namespace msg {

RemoteControllerState::RemoteControllerState(const RemoteControllerState& x)
    : RemoteControllerState() {
  m_event = x.m_event;
  m_lx = x.m_lx;
  m_ly = x.m_ly;
  m_rx = x.m_rx;
  m_ry = x.m_ry;
  m_a = x.m_a;
  m_b = x.m_b;
  m_x = x.m_x;
  m_y = x.m_y;
  m_lb = x.m_lb;
  m_rb = x.m_rb;
  m_lt = x.m_lt;
  m_rt = x.m_rt;
  m_ls = x.m_ls;
  m_rs = x.m_rs;
  m_back = x.m_back;
  m_start = x.m_start;
  m_hat_c = x.m_hat_c;
  m_hat_u = x.m_hat_u;
  m_hat_d = x.m_hat_d;
  m_hat_l = x.m_hat_l;
  m_hat_r = x.m_hat_r;
  m_hat_lu = x.m_hat_lu;
  m_hat_ld = x.m_hat_ld;
  m_hat_ru = x.m_hat_ru;
  m_hat_rd = x.m_hat_rd;
  m_reserved = x.m_reserved;
}

RemoteControllerState::RemoteControllerState(RemoteControllerState&& x) noexcept
    : RemoteControllerState() {
  m_event = x.m_event;
  m_lx = x.m_lx;
  m_ly = x.m_ly;
  m_rx = x.m_rx;
  m_ry = x.m_ry;
  m_a = x.m_a;
  m_b = x.m_b;
  m_x = x.m_x;
  m_y = x.m_y;
  m_lb = x.m_lb;
  m_rb = x.m_rb;
  m_lt = x.m_lt;
  m_rt = x.m_rt;
  m_ls = x.m_ls;
  m_rs = x.m_rs;
  m_back = x.m_back;
  m_start = x.m_start;
  m_hat_c = x.m_hat_c;
  m_hat_u = x.m_hat_u;
  m_hat_d = x.m_hat_d;
  m_hat_l = x.m_hat_l;
  m_hat_r = x.m_hat_r;
  m_hat_lu = x.m_hat_lu;
  m_hat_ld = x.m_hat_ld;
  m_hat_ru = x.m_hat_ru;
  m_hat_rd = x.m_hat_rd;
  m_reserved = x.m_reserved;
}

RemoteControllerState& RemoteControllerState::operator=(
    const RemoteControllerState& x) {
  m_event = x.m_event;
  m_lx = x.m_lx;
  m_ly = x.m_ly;
  m_rx = x.m_rx;
  m_ry = x.m_ry;
  m_a = x.m_a;
  m_b = x.m_b;
  m_x = x.m_x;
  m_y = x.m_y;
  m_lb = x.m_lb;
  m_rb = x.m_rb;
  m_lt = x.m_lt;
  m_rt = x.m_rt;
  m_ls = x.m_ls;
  m_rs = x.m_rs;
  m_back = x.m_back;
  m_start = x.m_start;
  m_hat_c = x.m_hat_c;
  m_hat_u = x.m_hat_u;
  m_hat_d = x.m_hat_d;
  m_hat_l = x.m_hat_l;
  m_hat_r = x.m_hat_r;
  m_hat_lu = x.m_hat_lu;
  m_hat_ld = x.m_hat_ld;
  m_hat_ru = x.m_hat_ru;
  m_hat_rd = x.m_hat_rd;
  m_reserved = x.m_reserved;
  return *this;
}

RemoteControllerState& RemoteControllerState::operator=(
    RemoteControllerState&& x) noexcept {
  m_event = x.m_event;
  m_lx = x.m_lx;
  m_ly = x.m_ly;
  m_rx = x.m_rx;
  m_ry = x.m_ry;
  m_a = x.m_a;
  m_b = x.m_b;
  m_x = x.m_x;
  m_y = x.m_y;
  m_lb = x.m_lb;
  m_rb = x.m_rb;
  m_lt = x.m_lt;
  m_rt = x.m_rt;
  m_ls = x.m_ls;
  m_rs = x.m_rs;
  m_back = x.m_back;
  m_start = x.m_start;
  m_hat_c = x.m_hat_c;
  m_hat_u = x.m_hat_u;
  m_hat_d = x.m_hat_d;
  m_hat_l = x.m_hat_l;
  m_hat_r = x.m_hat_r;
  m_hat_lu = x.m_hat_lu;
  m_hat_ld = x.m_hat_ld;
  m_hat_ru = x.m_hat_ru;
  m_hat_rd = x.m_hat_rd;
  m_reserved = x.m_reserved;
  return *this;
}

bool RemoteControllerState::operator==(const RemoteControllerState& x) const {
  return (m_event == x.m_event && m_lx == x.m_lx && m_ly == x.m_ly &&
          m_rx == x.m_rx && m_ry == x.m_ry && m_a == x.m_a && m_b == x.m_b &&
          m_x == x.m_x && m_y == x.m_y && m_lb == x.m_lb && m_rb == x.m_rb &&
          m_lt == x.m_lt && m_rt == x.m_rt && m_ls == x.m_ls &&
          m_rs == x.m_rs && m_back == x.m_back && m_start == x.m_start &&
          m_hat_c == x.m_hat_c && m_hat_u == x.m_hat_u &&
          m_hat_d == x.m_hat_d && m_hat_l == x.m_hat_l &&
          m_hat_r == x.m_hat_r && m_hat_lu == x.m_hat_lu &&
          m_hat_ld == x.m_hat_ld && m_hat_ru == x.m_hat_ru &&
          m_hat_rd == x.m_hat_rd && m_reserved == x.m_reserved);
}

bool RemoteControllerState::operator!=(const RemoteControllerState& x) const {
  return !(*this == x);
}

/*!
 * @brief This function sets a value in member event
 * @param _event New value for member event
 */
void RemoteControllerState::event(uint32_t _event) { m_event = _event; }

/*!
 * @brief This function returns the value of member event
 * @return Value of member event
 */
uint32_t RemoteControllerState::event() const { return m_event; }

/*!
 * @brief This function returns a reference to member event
 * @return Reference to member event
 */
uint32_t& RemoteControllerState::event() { return m_event; }

/*!
 * @brief This function sets a value in member lx
 * @param _lx New value for member lx
 */
void RemoteControllerState::lx(float _lx) { m_lx = _lx; }

/*!
 * @brief This function returns the value of member lx
 * @return Value of member lx
 */
float RemoteControllerState::lx() const { return m_lx; }

/*!
 * @brief This function returns a reference to member lx
 * @return Reference to member lx
 */
float& RemoteControllerState::lx() { return m_lx; }

/*!
 * @brief This function sets a value in member ly
 * @param _ly New value for member ly
 */
void RemoteControllerState::ly(float _ly) { m_ly = _ly; }

/*!
 * @brief This function returns the value of member ly
 * @return Value of member ly
 */
float RemoteControllerState::ly() const { return m_ly; }

/*!
 * @brief This function returns a reference to member ly
 * @return Reference to member ly
 */
float& RemoteControllerState::ly() { return m_ly; }

/*!
 * @brief This function sets a value in member rx
 * @param _rx New value for member rx
 */
void RemoteControllerState::rx(float _rx) { m_rx = _rx; }

/*!
 * @brief This function returns the value of member rx
 * @return Value of member rx
 */
float RemoteControllerState::rx() const { return m_rx; }

/*!
 * @brief This function returns a reference to member rx
 * @return Reference to member rx
 */
float& RemoteControllerState::rx() { return m_rx; }

/*!
 * @brief This function sets a value in member ry
 * @param _ry New value for member ry
 */
void RemoteControllerState::ry(float _ry) { m_ry = _ry; }

/*!
 * @brief This function returns the value of member ry
 * @return Value of member ry
 */
float RemoteControllerState::ry() const { return m_ry; }

/*!
 * @brief This function returns a reference to member ry
 * @return Reference to member ry
 */
float& RemoteControllerState::ry() { return m_ry; }

/*!
 * @brief This function sets a value in member a
 * @param _a New value for member a
 */
void RemoteControllerState::a(bool _a) { m_a = _a; }

/*!
 * @brief This function returns the value of member a
 * @return Value of member a
 */
bool RemoteControllerState::a() const { return m_a; }

/*!
 * @brief This function returns a reference to member a
 * @return Reference to member a
 */
bool& RemoteControllerState::a() { return m_a; }

/*!
 * @brief This function sets a value in member b
 * @param _b New value for member b
 */
void RemoteControllerState::b(bool _b) { m_b = _b; }

/*!
 * @brief This function returns the value of member b
 * @return Value of member b
 */
bool RemoteControllerState::b() const { return m_b; }

/*!
 * @brief This function returns a reference to member b
 * @return Reference to member b
 */
bool& RemoteControllerState::b() { return m_b; }

/*!
 * @brief This function sets a value in member x
 * @param _x New value for member x
 */
void RemoteControllerState::x(bool _x) { m_x = _x; }

/*!
 * @brief This function returns the value of member x
 * @return Value of member x
 */
bool RemoteControllerState::x() const { return m_x; }

/*!
 * @brief This function returns a reference to member x
 * @return Reference to member x
 */
bool& RemoteControllerState::x() { return m_x; }

/*!
 * @brief This function sets a value in member y
 * @param _y New value for member y
 */
void RemoteControllerState::y(bool _y) { m_y = _y; }

/*!
 * @brief This function returns the value of member y
 * @return Value of member y
 */
bool RemoteControllerState::y() const { return m_y; }

/*!
 * @brief This function returns a reference to member y
 * @return Reference to member y
 */
bool& RemoteControllerState::y() { return m_y; }

/*!
 * @brief This function sets a value in member lb
 * @param _lb New value for member lb
 */
void RemoteControllerState::lb(bool _lb) { m_lb = _lb; }

/*!
 * @brief This function returns the value of member lb
 * @return Value of member lb
 */
bool RemoteControllerState::lb() const { return m_lb; }

/*!
 * @brief This function returns a reference to member lb
 * @return Reference to member lb
 */
bool& RemoteControllerState::lb() { return m_lb; }

/*!
 * @brief This function sets a value in member rb
 * @param _rb New value for member rb
 */
void RemoteControllerState::rb(bool _rb) { m_rb = _rb; }

/*!
 * @brief This function returns the value of member rb
 * @return Value of member rb
 */
bool RemoteControllerState::rb() const { return m_rb; }

/*!
 * @brief This function returns a reference to member rb
 * @return Reference to member rb
 */
bool& RemoteControllerState::rb() { return m_rb; }

/*!
 * @brief This function sets a value in member lt
 * @param _lt New value for member lt
 */
void RemoteControllerState::lt(bool _lt) { m_lt = _lt; }

/*!
 * @brief This function returns the value of member lt
 * @return Value of member lt
 */
bool RemoteControllerState::lt() const { return m_lt; }

/*!
 * @brief This function returns a reference to member lt
 * @return Reference to member lt
 */
bool& RemoteControllerState::lt() { return m_lt; }

/*!
 * @brief This function sets a value in member rt
 * @param _rt New value for member rt
 */
void RemoteControllerState::rt(bool _rt) { m_rt = _rt; }

/*!
 * @brief This function returns the value of member rt
 * @return Value of member rt
 */
bool RemoteControllerState::rt() const { return m_rt; }

/*!
 * @brief This function returns a reference to member rt
 * @return Reference to member rt
 */
bool& RemoteControllerState::rt() { return m_rt; }

/*!
 * @brief This function sets a value in member ls
 * @param _ls New value for member ls
 */
void RemoteControllerState::ls(bool _ls) { m_ls = _ls; }

/*!
 * @brief This function returns the value of member ls
 * @return Value of member ls
 */
bool RemoteControllerState::ls() const { return m_ls; }

/*!
 * @brief This function returns a reference to member ls
 * @return Reference to member ls
 */
bool& RemoteControllerState::ls() { return m_ls; }

/*!
 * @brief This function sets a value in member rs
 * @param _rs New value for member rs
 */
void RemoteControllerState::rs(bool _rs) { m_rs = _rs; }

/*!
 * @brief This function returns the value of member rs
 * @return Value of member rs
 */
bool RemoteControllerState::rs() const { return m_rs; }

/*!
 * @brief This function returns a reference to member rs
 * @return Reference to member rs
 */
bool& RemoteControllerState::rs() { return m_rs; }

/*!
 * @brief This function sets a value in member back
 * @param _back New value for member back
 */
void RemoteControllerState::back(bool _back) { m_back = _back; }

/*!
 * @brief This function returns the value of member back
 * @return Value of member back
 */
bool RemoteControllerState::back() const { return m_back; }

/*!
 * @brief This function returns a reference to member back
 * @return Reference to member back
 */
bool& RemoteControllerState::back() { return m_back; }

/*!
 * @brief This function sets a value in member start
 * @param _start New value for member start
 */
void RemoteControllerState::start(bool _start) { m_start = _start; }

/*!
 * @brief This function returns the value of member start
 * @return Value of member start
 */
bool RemoteControllerState::start() const { return m_start; }

/*!
 * @brief This function returns a reference to member start
 * @return Reference to member start
 */
bool& RemoteControllerState::start() { return m_start; }

/*!
 * @brief This function sets a value in member hat_c
 * @param _hat_c New value for member hat_c
 */
void RemoteControllerState::hat_c(bool _hat_c) { m_hat_c = _hat_c; }

/*!
 * @brief This function returns the value of member hat_c
 * @return Value of member hat_c
 */
bool RemoteControllerState::hat_c() const { return m_hat_c; }

/*!
 * @brief This function returns a reference to member hat_c
 * @return Reference to member hat_c
 */
bool& RemoteControllerState::hat_c() { return m_hat_c; }

/*!
 * @brief This function sets a value in member hat_u
 * @param _hat_u New value for member hat_u
 */
void RemoteControllerState::hat_u(bool _hat_u) { m_hat_u = _hat_u; }

/*!
 * @brief This function returns the value of member hat_u
 * @return Value of member hat_u
 */
bool RemoteControllerState::hat_u() const { return m_hat_u; }

/*!
 * @brief This function returns a reference to member hat_u
 * @return Reference to member hat_u
 */
bool& RemoteControllerState::hat_u() { return m_hat_u; }

/*!
 * @brief This function sets a value in member hat_d
 * @param _hat_d New value for member hat_d
 */
void RemoteControllerState::hat_d(bool _hat_d) { m_hat_d = _hat_d; }

/*!
 * @brief This function returns the value of member hat_d
 * @return Value of member hat_d
 */
bool RemoteControllerState::hat_d() const { return m_hat_d; }

/*!
 * @brief This function returns a reference to member hat_d
 * @return Reference to member hat_d
 */
bool& RemoteControllerState::hat_d() { return m_hat_d; }

/*!
 * @brief This function sets a value in member hat_l
 * @param _hat_l New value for member hat_l
 */
void RemoteControllerState::hat_l(bool _hat_l) { m_hat_l = _hat_l; }

/*!
 * @brief This function returns the value of member hat_l
 * @return Value of member hat_l
 */
bool RemoteControllerState::hat_l() const { return m_hat_l; }

/*!
 * @brief This function returns a reference to member hat_l
 * @return Reference to member hat_l
 */
bool& RemoteControllerState::hat_l() { return m_hat_l; }

/*!
 * @brief This function sets a value in member hat_r
 * @param _hat_r New value for member hat_r
 */
void RemoteControllerState::hat_r(bool _hat_r) { m_hat_r = _hat_r; }

/*!
 * @brief This function returns the value of member hat_r
 * @return Value of member hat_r
 */
bool RemoteControllerState::hat_r() const { return m_hat_r; }

/*!
 * @brief This function returns a reference to member hat_r
 * @return Reference to member hat_r
 */
bool& RemoteControllerState::hat_r() { return m_hat_r; }

/*!
 * @brief This function sets a value in member hat_lu
 * @param _hat_lu New value for member hat_lu
 */
void RemoteControllerState::hat_lu(bool _hat_lu) { m_hat_lu = _hat_lu; }

/*!
 * @brief This function returns the value of member hat_lu
 * @return Value of member hat_lu
 */
bool RemoteControllerState::hat_lu() const { return m_hat_lu; }

/*!
 * @brief This function returns a reference to member hat_lu
 * @return Reference to member hat_lu
 */
bool& RemoteControllerState::hat_lu() { return m_hat_lu; }

/*!
 * @brief This function sets a value in member hat_ld
 * @param _hat_ld New value for member hat_ld
 */
void RemoteControllerState::hat_ld(bool _hat_ld) { m_hat_ld = _hat_ld; }

/*!
 * @brief This function returns the value of member hat_ld
 * @return Value of member hat_ld
 */
bool RemoteControllerState::hat_ld() const { return m_hat_ld; }

/*!
 * @brief This function returns a reference to member hat_ld
 * @return Reference to member hat_ld
 */
bool& RemoteControllerState::hat_ld() { return m_hat_ld; }

/*!
 * @brief This function sets a value in member hat_ru
 * @param _hat_ru New value for member hat_ru
 */
void RemoteControllerState::hat_ru(bool _hat_ru) { m_hat_ru = _hat_ru; }

/*!
 * @brief This function returns the value of member hat_ru
 * @return Value of member hat_ru
 */
bool RemoteControllerState::hat_ru() const { return m_hat_ru; }

/*!
 * @brief This function returns a reference to member hat_ru
 * @return Reference to member hat_ru
 */
bool& RemoteControllerState::hat_ru() { return m_hat_ru; }

/*!
 * @brief This function sets a value in member hat_rd
 * @param _hat_rd New value for member hat_rd
 */
void RemoteControllerState::hat_rd(bool _hat_rd) { m_hat_rd = _hat_rd; }

/*!
 * @brief This function returns the value of member hat_rd
 * @return Value of member hat_rd
 */
bool RemoteControllerState::hat_rd() const { return m_hat_rd; }

/*!
 * @brief This function returns a reference to member hat_rd
 * @return Reference to member hat_rd
 */
bool& RemoteControllerState::hat_rd() { return m_hat_rd; }

/*!
 * @brief This function sets a value in member reserved
 * @param _reserved New value for member reserved
 */
void RemoteControllerState::reserved(uint8_t _reserved) {
  m_reserved = _reserved;
}

/*!
 * @brief This function returns the value of member reserved
 * @return Value of member reserved
 */
uint8_t RemoteControllerState::reserved() const { return m_reserved; }

/*!
 * @brief This function returns a reference to member reserved
 * @return Reference to member reserved
 */
uint8_t& RemoteControllerState::reserved() { return m_reserved; }

}  // namespace msg

}  // namespace booster_interface
// Include auxiliary functions like for serializing/deserializing.
constexpr uint32_t booster_interface_msg_RemoteControllerState_max_cdr_typesize{
    46UL};
constexpr uint32_t
    booster_interface_msg_RemoteControllerState_max_key_cdr_typesize{0UL};
#include <fastcdr/Cdr.h>
#include <fastcdr/exceptions/BadParamException.h>

#include <fastcdr/CdrSizeCalculator.hpp>
using namespace eprosima::fastcdr::exception;

namespace eprosima {
namespace fastcdr {

template <>
eProsima_user_DllExport size_t calculate_serialized_size(
    eprosima::fastcdr::CdrSizeCalculator& calculator,
    const booster_interface::msg::RemoteControllerState& data,
    size_t& current_alignment) {
  using namespace booster_interface::msg;

  static_cast<void>(data);

  eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding =
      calculator.get_encoding();
  size_t calculated_size{calculator.begin_calculate_type_serialized_size(
      eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version()
          ? eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
          : eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
      current_alignment)};

  calculated_size += calculator.calculate_member_serialized_size(
      eprosima::fastcdr::MemberId(0), data.event(), current_alignment);

  calculated_size += calculator.calculate_member_serialized_size(
      eprosima::fastcdr::MemberId(1), data.lx(), current_alignment);

  calculated_size += calculator.calculate_member_serialized_size(
      eprosima::fastcdr::MemberId(2), data.ly(), current_alignment);

  calculated_size += calculator.calculate_member_serialized_size(
      eprosima::fastcdr::MemberId(3), data.rx(), current_alignment);

  calculated_size += calculator.calculate_member_serialized_size(
      eprosima::fastcdr::MemberId(4), data.ry(), current_alignment);

  calculated_size += calculator.calculate_member_serialized_size(
      eprosima::fastcdr::MemberId(5), data.a(), current_alignment);

  calculated_size += calculator.calculate_member_serialized_size(
      eprosima::fastcdr::MemberId(6), data.b(), current_alignment);

  calculated_size += calculator.calculate_member_serialized_size(
      eprosima::fastcdr::MemberId(7), data.x(), current_alignment);

  calculated_size += calculator.calculate_member_serialized_size(
      eprosima::fastcdr::MemberId(8), data.y(), current_alignment);

  calculated_size += calculator.calculate_member_serialized_size(
      eprosima::fastcdr::MemberId(9), data.lb(), current_alignment);

  calculated_size += calculator.calculate_member_serialized_size(
      eprosima::fastcdr::MemberId(10), data.rb(), current_alignment);

  calculated_size += calculator.calculate_member_serialized_size(
      eprosima::fastcdr::MemberId(11), data.lt(), current_alignment);

  calculated_size += calculator.calculate_member_serialized_size(
      eprosima::fastcdr::MemberId(12), data.rt(), current_alignment);

  calculated_size += calculator.calculate_member_serialized_size(
      eprosima::fastcdr::MemberId(13), data.ls(), current_alignment);

  calculated_size += calculator.calculate_member_serialized_size(
      eprosima::fastcdr::MemberId(14), data.rs(), current_alignment);

  calculated_size += calculator.calculate_member_serialized_size(
      eprosima::fastcdr::MemberId(15), data.back(), current_alignment);

  calculated_size += calculator.calculate_member_serialized_size(
      eprosima::fastcdr::MemberId(16), data.start(), current_alignment);

  calculated_size += calculator.calculate_member_serialized_size(
      eprosima::fastcdr::MemberId(17), data.hat_c(), current_alignment);

  calculated_size += calculator.calculate_member_serialized_size(
      eprosima::fastcdr::MemberId(18), data.hat_u(), current_alignment);

  calculated_size += calculator.calculate_member_serialized_size(
      eprosima::fastcdr::MemberId(19), data.hat_d(), current_alignment);

  calculated_size += calculator.calculate_member_serialized_size(
      eprosima::fastcdr::MemberId(20), data.hat_l(), current_alignment);

  calculated_size += calculator.calculate_member_serialized_size(
      eprosima::fastcdr::MemberId(21), data.hat_r(), current_alignment);

  calculated_size += calculator.calculate_member_serialized_size(
      eprosima::fastcdr::MemberId(22), data.hat_lu(), current_alignment);

  calculated_size += calculator.calculate_member_serialized_size(
      eprosima::fastcdr::MemberId(23), data.hat_ld(), current_alignment);

  calculated_size += calculator.calculate_member_serialized_size(
      eprosima::fastcdr::MemberId(24), data.hat_ru(), current_alignment);

  calculated_size += calculator.calculate_member_serialized_size(
      eprosima::fastcdr::MemberId(25), data.hat_rd(), current_alignment);

  calculated_size += calculator.calculate_member_serialized_size(
      eprosima::fastcdr::MemberId(26), data.reserved(), current_alignment);

  calculated_size += calculator.end_calculate_type_serialized_size(
      previous_encoding, current_alignment);

  return calculated_size;
}

template <>
eProsima_user_DllExport void serialize(
    eprosima::fastcdr::Cdr& scdr,
    const booster_interface::msg::RemoteControllerState& data) {
  using namespace booster_interface::msg;

  eprosima::fastcdr::Cdr::state current_state(scdr);
  scdr.begin_serialize_type(
      current_state,
      eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version()
          ? eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
          : eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

  scdr << eprosima::fastcdr::MemberId(0) << data.event()
       << eprosima::fastcdr::MemberId(1) << data.lx()
       << eprosima::fastcdr::MemberId(2) << data.ly()
       << eprosima::fastcdr::MemberId(3) << data.rx()
       << eprosima::fastcdr::MemberId(4) << data.ry()
       << eprosima::fastcdr::MemberId(5) << data.a()
       << eprosima::fastcdr::MemberId(6) << data.b()
       << eprosima::fastcdr::MemberId(7) << data.x()
       << eprosima::fastcdr::MemberId(8) << data.y()
       << eprosima::fastcdr::MemberId(9) << data.lb()
       << eprosima::fastcdr::MemberId(10) << data.rb()
       << eprosima::fastcdr::MemberId(11) << data.lt()
       << eprosima::fastcdr::MemberId(12) << data.rt()
       << eprosima::fastcdr::MemberId(13) << data.ls()
       << eprosima::fastcdr::MemberId(14) << data.rs()
       << eprosima::fastcdr::MemberId(15) << data.back()
       << eprosima::fastcdr::MemberId(16) << data.start()
       << eprosima::fastcdr::MemberId(17) << data.hat_c()
       << eprosima::fastcdr::MemberId(18) << data.hat_u()
       << eprosima::fastcdr::MemberId(19) << data.hat_d()
       << eprosima::fastcdr::MemberId(20) << data.hat_l()
       << eprosima::fastcdr::MemberId(21) << data.hat_r()
       << eprosima::fastcdr::MemberId(22) << data.hat_lu()
       << eprosima::fastcdr::MemberId(23) << data.hat_ld()
       << eprosima::fastcdr::MemberId(24) << data.hat_ru()
       << eprosima::fastcdr::MemberId(25) << data.hat_rd()
       << eprosima::fastcdr::MemberId(26) << data.reserved();
  scdr.end_serialize_type(current_state);
}

template <>
eProsima_user_DllExport void deserialize(
    eprosima::fastcdr::Cdr& cdr,
    booster_interface::msg::RemoteControllerState& data) {
  using namespace booster_interface::msg;

  cdr.deserialize_type(
      eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version()
          ? eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
          : eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
      [&data](eprosima::fastcdr::Cdr& dcdr,
              const eprosima::fastcdr::MemberId& mid) -> bool {
        bool ret_value = true;
        switch (mid.id) {
          case 0:
            dcdr >> data.event();
            break;

          case 1:
            dcdr >> data.lx();
            break;

          case 2:
            dcdr >> data.ly();
            break;

          case 3:
            dcdr >> data.rx();
            break;

          case 4:
            dcdr >> data.ry();
            break;

          case 5:
            dcdr >> data.a();
            break;

          case 6:
            dcdr >> data.b();
            break;

          case 7:
            dcdr >> data.x();
            break;

          case 8:
            dcdr >> data.y();
            break;

          case 9:
            dcdr >> data.lb();
            break;

          case 10:
            dcdr >> data.rb();
            break;

          case 11:
            dcdr >> data.lt();
            break;

          case 12:
            dcdr >> data.rt();
            break;

          case 13:
            dcdr >> data.ls();
            break;

          case 14:
            dcdr >> data.rs();
            break;

          case 15:
            dcdr >> data.back();
            break;

          case 16:
            dcdr >> data.start();
            break;

          case 17:
            dcdr >> data.hat_c();
            break;

          case 18:
            dcdr >> data.hat_u();
            break;

          case 19:
            dcdr >> data.hat_d();
            break;

          case 20:
            dcdr >> data.hat_l();
            break;

          case 21:
            dcdr >> data.hat_r();
            break;

          case 22:
            dcdr >> data.hat_lu();
            break;

          case 23:
            dcdr >> data.hat_ld();
            break;

          case 24:
            dcdr >> data.hat_ru();
            break;

          case 25:
            dcdr >> data.hat_rd();
            break;

          case 26:
            dcdr >> data.reserved();
            break;

          default:
            ret_value = false;
            break;
        }
        return ret_value;
      });
}

void serialize_key(eprosima::fastcdr::Cdr& scdr,
                   const booster_interface::msg::RemoteControllerState& data) {
  using namespace booster_interface::msg;

  static_cast<void>(scdr);
  static_cast<void>(data);
}

}  // namespace fastcdr
}  // namespace eprosima

// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file RemoteControllerStates.cpp
 * This header file contains the implementation of the serialization functions.
 *
 * This file was generated by the tool fastddsgen.
 */

#include <fastdds/rtps/common/CdrSerialization.hpp>

using SerializedPayload_t = eprosima::fastrtps::rtps::SerializedPayload_t;
using InstanceHandle_t = eprosima::fastrtps::rtps::InstanceHandle_t;
using DataRepresentationId_t = eprosima::fastdds::dds::DataRepresentationId_t;

namespace booster_interface {
namespace msg {

RemoteControllerState::RemoteControllerState() {
  setName("booster_interface::msg::dds_::RemoteControllerState_");
  uint32_t type_size =
#if FASTCDR_VERSION_MAJOR == 1
      static_cast<uint32_t>(RemoteControllerState::getMaxCdrSerializedSize());
#else
      booster_interface_msg_RemoteControllerState_max_cdr_typesize;
#endif
  type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(
      type_size, 4));         /* possible submessage alignment */
  m_typeSize = type_size + 4; /*encapsulation*/
  m_isGetKeyDefined = false;
  uint32_t keyLength =
      booster_interface_msg_RemoteControllerState_max_key_cdr_typesize > 16
          ? booster_interface_msg_RemoteControllerState_max_key_cdr_typesize
          : 16;
  m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
  memset(m_keyBuffer, 0, keyLength);
}

RemoteControllerState::~RemoteControllerState() {
  if (m_keyBuffer != nullptr) {
    free(m_keyBuffer);
  }
}

bool RemoteControllerState::serialize(
    void* data, SerializedPayload_t* payload,
    DataRepresentationId_t data_representation) {
  RemoteControllerState* p_type = static_cast<RemoteControllerState*>(data);

  // Object that manages the raw buffer.
  eprosima::fastcdr::FastBuffer fastbuffer(
      reinterpret_cast<char*>(payload->data), payload->max_size);
  // Object that serializes the data.
  eprosima::fastcdr::Cdr ser(
      fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
      data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION
          ? eprosima::fastcdr::CdrVersion::XCDRv1
          : eprosima::fastcdr::CdrVersion::XCDRv2);
  payload->encapsulation =
      ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE
                                                                 : CDR_LE;
#if FASTCDR_VERSION_MAJOR > 1
  ser.set_encoding_flag(
      data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION
          ? eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
          : eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
#endif  // FASTCDR_VERSION_MAJOR > 1

  try {
    // Serialize encapsulation
    ser.serialize_encapsulation();
    // Serialize the object.
    ser << *p_type;
  } catch (eprosima::fastcdr::exception::Exception& /*exception*/) {
    return false;
  }

  // Get the serialized length
#if FASTCDR_VERSION_MAJOR == 1
  payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
#else
  payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
#endif  // FASTCDR_VERSION_MAJOR == 1
  return true;
}

bool RemoteControllerState::deserialize(SerializedPayload_t* payload,
                                        void* data) {
  try {
    // Convert DATA to pointer of your type
    RemoteControllerState* p_type = static_cast<RemoteControllerState*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(
        reinterpret_cast<char*>(payload->data), payload->length);

    // Object that deserializes the data.
    eprosima::fastcdr::Cdr deser(fastbuffer,
                                 eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
#if FASTCDR_VERSION_MAJOR == 1
                                 ,
                                 eprosima::fastcdr::Cdr::CdrType::DDS_CDR
#endif  // FASTCDR_VERSION_MAJOR == 1
    );

    // Deserialize encapsulation.
    deser.read_encapsulation();
    payload->encapsulation =
        deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE
                                                                     : CDR_LE;

    // Deserialize the object.
    deser >> *p_type;
  } catch (eprosima::fastcdr::exception::Exception& /*exception*/) {
    return false;
  }

  return true;
}

std::function<uint32_t()> RemoteControllerState::getSerializedSizeProvider(
    void* data, DataRepresentationId_t data_representation) {
  return [data, data_representation]() -> uint32_t {
#if FASTCDR_VERSION_MAJOR == 1
    static_cast<void>(data_representation);
    return static_cast<uint32_t>(type::getCdrSerializedSize(
               *static_cast<RemoteControllerState*>(data))) +
           4u /*encapsulation*/;
#else
    try {
      eprosima::fastcdr::CdrSizeCalculator calculator(
          data_representation ==
                  DataRepresentationId_t::XCDR_DATA_REPRESENTATION
              ? eprosima::fastcdr::CdrVersion::XCDRv1
              : eprosima::fastcdr::CdrVersion::XCDRv2);
      size_t current_alignment{0};
      return static_cast<uint32_t>(calculator.calculate_serialized_size(
                 *static_cast<RemoteControllerState*>(data),
                 current_alignment)) +
             4u /*encapsulation*/;
    } catch (eprosima::fastcdr::exception::Exception& /*exception*/) {
      return 0;
    }
#endif  // FASTCDR_VERSION_MAJOR == 1
  };
}

void* RemoteControllerState::createData() {
  return reinterpret_cast<void*>(new RemoteControllerState());
}

void RemoteControllerState::deleteData(void* data) {
  delete (reinterpret_cast<RemoteControllerState*>(data));
}

bool RemoteControllerState::getKey(void* data, InstanceHandle_t* handle,
                                   bool force_md5) {
  if (!m_isGetKeyDefined) {
    return false;
  }

  RemoteControllerState* p_type = static_cast<RemoteControllerState*>(data);

  // Object that manages the raw buffer.
  eprosima::fastcdr::FastBuffer fastbuffer(
      reinterpret_cast<char*>(m_keyBuffer),
      booster_interface_msg_RemoteControllerState_max_key_cdr_typesize);

  // Object that serializes the data.
  eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS,
                             eprosima::fastcdr::CdrVersion::XCDRv1);
#if FASTCDR_VERSION_MAJOR == 1
  p_type->serializeKey(ser);
#else
  eprosima::fastcdr::serialize_key(ser, *p_type);
#endif  // FASTCDR_VERSION_MAJOR == 1
  if (force_md5 ||
      booster_interface_msg_RemoteControllerState_max_key_cdr_typesize > 16) {
    m_md5.init();
#if FASTCDR_VERSION_MAJOR == 1
    m_md5.update(m_keyBuffer,
                 static_cast<unsigned int>(ser.getSerializedDataLength()));
#else
    m_md5.update(m_keyBuffer,
                 static_cast<unsigned int>(ser.get_serialized_data_length()));
#endif  // FASTCDR_VERSION_MAJOR == 1
    m_md5.finalize();
    for (uint8_t i = 0; i < 16; ++i) {
      handle->value[i] = m_md5.digest[i];
    }
  } else {
    for (uint8_t i = 0; i < 16; ++i) {
      handle->value[i] = m_keyBuffer[i];
    }
  }
  return true;
}

}  // End of namespace msg

}  // End of namespace booster_interface
