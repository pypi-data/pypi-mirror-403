// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file CameraInfo.cpp
 * This source file contains the implementation of the described types in the
 * IDL file.
 *
 * This file was generated by the tool fastddsgen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include <booster/idl/sensor_msgs/CameraInfo.h>

#include <fastcdr/Cdr.h>
#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

namespace sensor_msgs {

namespace msg {

CameraInfo::CameraInfo(const CameraInfo& x) : CameraInfo() {
  m_header = x.m_header;
  m_height = x.m_height;
  m_width = x.m_width;
  m_distortion_model = x.m_distortion_model;
  m_d = x.m_d;
  m_k = x.m_k;
  m_r = x.m_r;
  m_p = x.m_p;
  m_binning_x = x.m_binning_x;
  m_binning_y = x.m_binning_y;
  m_roi = x.m_roi;
}

CameraInfo::CameraInfo(CameraInfo&& x) noexcept : CameraInfo() {
  m_header = std::move(x.m_header);
  m_height = x.m_height;
  m_width = x.m_width;
  m_distortion_model = std::move(x.m_distortion_model);
  m_d = std::move(x.m_d);
  m_k = std::move(x.m_k);
  m_r = std::move(x.m_r);
  m_p = std::move(x.m_p);
  m_binning_x = x.m_binning_x;
  m_binning_y = x.m_binning_y;
  m_roi = std::move(x.m_roi);
}

CameraInfo& CameraInfo::operator=(const CameraInfo& x) {
  m_header = x.m_header;
  m_height = x.m_height;
  m_width = x.m_width;
  m_distortion_model = x.m_distortion_model;
  m_d = x.m_d;
  m_k = x.m_k;
  m_r = x.m_r;
  m_p = x.m_p;
  m_binning_x = x.m_binning_x;
  m_binning_y = x.m_binning_y;
  m_roi = x.m_roi;
  return *this;
}

CameraInfo& CameraInfo::operator=(CameraInfo&& x) noexcept {
  m_header = std::move(x.m_header);
  m_height = x.m_height;
  m_width = x.m_width;
  m_distortion_model = std::move(x.m_distortion_model);
  m_d = std::move(x.m_d);
  m_k = std::move(x.m_k);
  m_r = std::move(x.m_r);
  m_p = std::move(x.m_p);
  m_binning_x = x.m_binning_x;
  m_binning_y = x.m_binning_y;
  m_roi = std::move(x.m_roi);
  return *this;
}

bool CameraInfo::operator==(const CameraInfo& x) const {
  return (m_header == x.m_header && m_height == x.m_height &&
          m_width == x.m_width && m_distortion_model == x.m_distortion_model &&
          m_d == x.m_d && m_k == x.m_k && m_r == x.m_r && m_p == x.m_p &&
          m_binning_x == x.m_binning_x && m_binning_y == x.m_binning_y &&
          m_roi == x.m_roi);
}

bool CameraInfo::operator!=(const CameraInfo& x) const { return !(*this == x); }

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void CameraInfo::header(const std_msgs::msg::Header& _header) {
  m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void CameraInfo::header(std_msgs::msg::Header&& _header) {
  m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const std_msgs::msg::Header& CameraInfo::header() const { return m_header; }

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
std_msgs::msg::Header& CameraInfo::header() { return m_header; }

/*!
 * @brief This function sets a value in member height
 * @param _height New value for member height
 */
void CameraInfo::height(uint32_t _height) { m_height = _height; }

/*!
 * @brief This function returns the value of member height
 * @return Value of member height
 */
uint32_t CameraInfo::height() const { return m_height; }

/*!
 * @brief This function returns a reference to member height
 * @return Reference to member height
 */
uint32_t& CameraInfo::height() { return m_height; }

/*!
 * @brief This function sets a value in member width
 * @param _width New value for member width
 */
void CameraInfo::width(uint32_t _width) { m_width = _width; }

/*!
 * @brief This function returns the value of member width
 * @return Value of member width
 */
uint32_t CameraInfo::width() const { return m_width; }

/*!
 * @brief This function returns a reference to member width
 * @return Reference to member width
 */
uint32_t& CameraInfo::width() { return m_width; }

/*!
 * @brief This function copies the value in member distortion_model
 * @param _distortion_model New value to be copied in member distortion_model
 */
void CameraInfo::distortion_model(const std::string& _distortion_model) {
  m_distortion_model = _distortion_model;
}

/*!
 * @brief This function moves the value in member distortion_model
 * @param _distortion_model New value to be moved in member distortion_model
 */
void CameraInfo::distortion_model(std::string&& _distortion_model) {
  m_distortion_model = std::move(_distortion_model);
}

/*!
 * @brief This function returns a constant reference to member distortion_model
 * @return Constant reference to member distortion_model
 */
const std::string& CameraInfo::distortion_model() const {
  return m_distortion_model;
}

/*!
 * @brief This function returns a reference to member distortion_model
 * @return Reference to member distortion_model
 */
std::string& CameraInfo::distortion_model() { return m_distortion_model; }

/*!
 * @brief This function copies the value in member d
 * @param _d New value to be copied in member d
 */
void CameraInfo::d(const std::vector<double>& _d) { m_d = _d; }

/*!
 * @brief This function moves the value in member d
 * @param _d New value to be moved in member d
 */
void CameraInfo::d(std::vector<double>&& _d) { m_d = std::move(_d); }

/*!
 * @brief This function returns a constant reference to member d
 * @return Constant reference to member d
 */
const std::vector<double>& CameraInfo::d() const { return m_d; }

/*!
 * @brief This function returns a reference to member d
 * @return Reference to member d
 */
std::vector<double>& CameraInfo::d() { return m_d; }

/*!
 * @brief This function copies the value in member k
 * @param _k New value to be copied in member k
 */
void CameraInfo::k(const sensor_msgs::msg::double__9& _k) { m_k = _k; }

/*!
 * @brief This function moves the value in member k
 * @param _k New value to be moved in member k
 */
void CameraInfo::k(sensor_msgs::msg::double__9&& _k) { m_k = std::move(_k); }

/*!
 * @brief This function returns a constant reference to member k
 * @return Constant reference to member k
 */
const sensor_msgs::msg::double__9& CameraInfo::k() const { return m_k; }

/*!
 * @brief This function returns a reference to member k
 * @return Reference to member k
 */
sensor_msgs::msg::double__9& CameraInfo::k() { return m_k; }

/*!
 * @brief This function copies the value in member r
 * @param _r New value to be copied in member r
 */
void CameraInfo::r(const sensor_msgs::msg::double__9& _r) { m_r = _r; }

/*!
 * @brief This function moves the value in member r
 * @param _r New value to be moved in member r
 */
void CameraInfo::r(sensor_msgs::msg::double__9&& _r) { m_r = std::move(_r); }

/*!
 * @brief This function returns a constant reference to member r
 * @return Constant reference to member r
 */
const sensor_msgs::msg::double__9& CameraInfo::r() const { return m_r; }

/*!
 * @brief This function returns a reference to member r
 * @return Reference to member r
 */
sensor_msgs::msg::double__9& CameraInfo::r() { return m_r; }

/*!
 * @brief This function copies the value in member p
 * @param _p New value to be copied in member p
 */
void CameraInfo::p(const sensor_msgs::msg::double__12& _p) { m_p = _p; }

/*!
 * @brief This function moves the value in member p
 * @param _p New value to be moved in member p
 */
void CameraInfo::p(sensor_msgs::msg::double__12&& _p) { m_p = std::move(_p); }

/*!
 * @brief This function returns a constant reference to member p
 * @return Constant reference to member p
 */
const sensor_msgs::msg::double__12& CameraInfo::p() const { return m_p; }

/*!
 * @brief This function returns a reference to member p
 * @return Reference to member p
 */
sensor_msgs::msg::double__12& CameraInfo::p() { return m_p; }

/*!
 * @brief This function sets a value in member binning_x
 * @param _binning_x New value for member binning_x
 */
void CameraInfo::binning_x(uint32_t _binning_x) { m_binning_x = _binning_x; }

/*!
 * @brief This function returns the value of member binning_x
 * @return Value of member binning_x
 */
uint32_t CameraInfo::binning_x() const { return m_binning_x; }

/*!
 * @brief This function returns a reference to member binning_x
 * @return Reference to member binning_x
 */
uint32_t& CameraInfo::binning_x() { return m_binning_x; }

/*!
 * @brief This function sets a value in member binning_y
 * @param _binning_y New value for member binning_y
 */
void CameraInfo::binning_y(uint32_t _binning_y) { m_binning_y = _binning_y; }

/*!
 * @brief This function returns the value of member binning_y
 * @return Value of member binning_y
 */
uint32_t CameraInfo::binning_y() const { return m_binning_y; }

/*!
 * @brief This function returns a reference to member binning_y
 * @return Reference to member binning_y
 */
uint32_t& CameraInfo::binning_y() { return m_binning_y; }

/*!
 * @brief This function copies the value in member roi
 * @param _roi New value to be copied in member roi
 */
void CameraInfo::roi(const sensor_msgs::msg::RegionOfInterest& _roi) {
  m_roi = _roi;
}

/*!
 * @brief This function moves the value in member roi
 * @param _roi New value to be moved in member roi
 */
void CameraInfo::roi(sensor_msgs::msg::RegionOfInterest&& _roi) {
  m_roi = std::move(_roi);
}

/*!
 * @brief This function returns a constant reference to member roi
 * @return Constant reference to member roi
 */
const sensor_msgs::msg::RegionOfInterest& CameraInfo::roi() const {
  return m_roi;
}

/*!
 * @brief This function returns a reference to member roi
 * @return Reference to member roi
 */
sensor_msgs::msg::RegionOfInterest& CameraInfo::roi() { return m_roi; }

}  // namespace msg

}  // namespace sensor_msgs
// Include auxiliary functions like for serializing/deserializing.
constexpr uint32_t sensor_msgs_msg_CameraInfo_max_cdr_typesize{1621UL};
constexpr uint32_t sensor_msgs_msg_CameraInfo_max_key_cdr_typesize{0UL};
#include <fastcdr/Cdr.h>
#include <fastcdr/exceptions/BadParamException.h>

#include <fastcdr/CdrSizeCalculator.hpp>
using namespace eprosima::fastcdr::exception;

namespace eprosima {
namespace fastcdr {

template <>
eProsima_user_DllExport size_t calculate_serialized_size(
    eprosima::fastcdr::CdrSizeCalculator& calculator,
    const sensor_msgs::msg::CameraInfo& data, size_t& current_alignment) {
  using namespace sensor_msgs::msg;

  static_cast<void>(data);

  eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding =
      calculator.get_encoding();
  size_t calculated_size{calculator.begin_calculate_type_serialized_size(
      eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version()
          ? eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
          : eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
      current_alignment)};

  calculated_size += calculator.calculate_member_serialized_size(
      eprosima::fastcdr::MemberId(0), data.header(), current_alignment);

  calculated_size += calculator.calculate_member_serialized_size(
      eprosima::fastcdr::MemberId(1), data.height(), current_alignment);

  calculated_size += calculator.calculate_member_serialized_size(
      eprosima::fastcdr::MemberId(2), data.width(), current_alignment);

  calculated_size += calculator.calculate_member_serialized_size(
      eprosima::fastcdr::MemberId(3), data.distortion_model(),
      current_alignment);

  calculated_size += calculator.calculate_member_serialized_size(
      eprosima::fastcdr::MemberId(4), data.d(), current_alignment);

  calculated_size += calculator.calculate_member_serialized_size(
      eprosima::fastcdr::MemberId(5), data.k(), current_alignment);

  calculated_size += calculator.calculate_member_serialized_size(
      eprosima::fastcdr::MemberId(6), data.r(), current_alignment);

  calculated_size += calculator.calculate_member_serialized_size(
      eprosima::fastcdr::MemberId(7), data.p(), current_alignment);

  calculated_size += calculator.calculate_member_serialized_size(
      eprosima::fastcdr::MemberId(8), data.binning_x(), current_alignment);

  calculated_size += calculator.calculate_member_serialized_size(
      eprosima::fastcdr::MemberId(9), data.binning_y(), current_alignment);

  calculated_size += calculator.calculate_member_serialized_size(
      eprosima::fastcdr::MemberId(10), data.roi(), current_alignment);

  calculated_size += calculator.end_calculate_type_serialized_size(
      previous_encoding, current_alignment);

  return calculated_size;
}

template <>
eProsima_user_DllExport void serialize(
    eprosima::fastcdr::Cdr& scdr, const sensor_msgs::msg::CameraInfo& data) {
  using namespace sensor_msgs::msg;

  eprosima::fastcdr::Cdr::state current_state(scdr);
  scdr.begin_serialize_type(
      current_state,
      eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version()
          ? eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
          : eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

  scdr << eprosima::fastcdr::MemberId(0) << data.header()
       << eprosima::fastcdr::MemberId(1) << data.height()
       << eprosima::fastcdr::MemberId(2) << data.width()
       << eprosima::fastcdr::MemberId(3) << data.distortion_model()
       << eprosima::fastcdr::MemberId(4) << data.d()
       << eprosima::fastcdr::MemberId(5) << data.k()
       << eprosima::fastcdr::MemberId(6) << data.r()
       << eprosima::fastcdr::MemberId(7) << data.p()
       << eprosima::fastcdr::MemberId(8) << data.binning_x()
       << eprosima::fastcdr::MemberId(9) << data.binning_y()
       << eprosima::fastcdr::MemberId(10) << data.roi();
  scdr.end_serialize_type(current_state);
}

template <>
eProsima_user_DllExport void deserialize(eprosima::fastcdr::Cdr& cdr,
                                         sensor_msgs::msg::CameraInfo& data) {
  using namespace sensor_msgs::msg;

  cdr.deserialize_type(
      eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version()
          ? eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
          : eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
      [&data](eprosima::fastcdr::Cdr& dcdr,
              const eprosima::fastcdr::MemberId& mid) -> bool {
        bool ret_value = true;
        switch (mid.id) {
          case 0:
            dcdr >> data.header();
            break;

          case 1:
            dcdr >> data.height();
            break;

          case 2:
            dcdr >> data.width();
            break;

          case 3:
            dcdr >> data.distortion_model();
            break;

          case 4:
            dcdr >> data.d();
            break;

          case 5:
            dcdr >> data.k();
            break;

          case 6:
            dcdr >> data.r();
            break;

          case 7:
            dcdr >> data.p();
            break;

          case 8:
            dcdr >> data.binning_x();
            break;

          case 9:
            dcdr >> data.binning_y();
            break;

          case 10:
            dcdr >> data.roi();
            break;

          default:
            ret_value = false;
            break;
        }
        return ret_value;
      });
}

void serialize_key(eprosima::fastcdr::Cdr& scdr,
                   const sensor_msgs::msg::CameraInfo& data) {
  using namespace sensor_msgs::msg;

  static_cast<void>(scdr);
  static_cast<void>(data);
}

}  // namespace fastcdr
}  // namespace eprosima

// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file CameraInfos.cpp
 * This header file contains the implementation of the serialization functions.
 *
 * This file was generated by the tool fastddsgen.
 */

#include <fastdds/rtps/common/CdrSerialization.hpp>

using SerializedPayload_t = eprosima::fastrtps::rtps::SerializedPayload_t;
using InstanceHandle_t = eprosima::fastrtps::rtps::InstanceHandle_t;
using DataRepresentationId_t = eprosima::fastdds::dds::DataRepresentationId_t;

namespace sensor_msgs {
namespace msg {

CameraInfo::CameraInfo() {
  setName("sensor_msgs::msg::dds_::CameraInfo_");
  uint32_t type_size =
#if FASTCDR_VERSION_MAJOR == 1
      static_cast<uint32_t>(CameraInfo::getMaxCdrSerializedSize());
#else
      sensor_msgs_msg_CameraInfo_max_cdr_typesize;
#endif
  type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(
      type_size, 4));         /* possible submessage alignment */
  m_typeSize = type_size + 4; /*encapsulation*/
  m_isGetKeyDefined = false;
  uint32_t keyLength = sensor_msgs_msg_CameraInfo_max_key_cdr_typesize > 16
                           ? sensor_msgs_msg_CameraInfo_max_key_cdr_typesize
                           : 16;
  m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
  memset(m_keyBuffer, 0, keyLength);
}

CameraInfo::~CameraInfo() {
  if (m_keyBuffer != nullptr) {
    free(m_keyBuffer);
  }
}

bool CameraInfo::serialize(void* data, SerializedPayload_t* payload,
                           DataRepresentationId_t data_representation) {
  CameraInfo* p_type = static_cast<CameraInfo*>(data);

  // Object that manages the raw buffer.
  eprosima::fastcdr::FastBuffer fastbuffer(
      reinterpret_cast<char*>(payload->data), payload->max_size);
  // Object that serializes the data.
  eprosima::fastcdr::Cdr ser(
      fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
      data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION
          ? eprosima::fastcdr::CdrVersion::XCDRv1
          : eprosima::fastcdr::CdrVersion::XCDRv2);
  payload->encapsulation =
      ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE
                                                                 : CDR_LE;
#if FASTCDR_VERSION_MAJOR > 1
  ser.set_encoding_flag(
      data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION
          ? eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
          : eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
#endif  // FASTCDR_VERSION_MAJOR > 1

  try {
    // Serialize encapsulation
    ser.serialize_encapsulation();
    // Serialize the object.
    ser << *p_type;
  } catch (eprosima::fastcdr::exception::Exception& /*exception*/) {
    return false;
  }

  // Get the serialized length
#if FASTCDR_VERSION_MAJOR == 1
  payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
#else
  payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
#endif  // FASTCDR_VERSION_MAJOR == 1
  return true;
}

bool CameraInfo::deserialize(SerializedPayload_t* payload, void* data) {
  try {
    // Convert DATA to pointer of your type
    CameraInfo* p_type = static_cast<CameraInfo*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(
        reinterpret_cast<char*>(payload->data), payload->length);

    // Object that deserializes the data.
    eprosima::fastcdr::Cdr deser(fastbuffer,
                                 eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
#if FASTCDR_VERSION_MAJOR == 1
                                 ,
                                 eprosima::fastcdr::Cdr::CdrType::DDS_CDR
#endif  // FASTCDR_VERSION_MAJOR == 1
    );

    // Deserialize encapsulation.
    deser.read_encapsulation();
    payload->encapsulation =
        deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE
                                                                     : CDR_LE;

    // Deserialize the object.
    deser >> *p_type;
  } catch (eprosima::fastcdr::exception::Exception& /*exception*/) {
    return false;
  }

  return true;
}

std::function<uint32_t()> CameraInfo::getSerializedSizeProvider(
    void* data, DataRepresentationId_t data_representation) {
  return [data, data_representation]() -> uint32_t {
#if FASTCDR_VERSION_MAJOR == 1
    static_cast<void>(data_representation);
    return static_cast<uint32_t>(
               type::getCdrSerializedSize(*static_cast<CameraInfo*>(data))) +
           4u /*encapsulation*/;
#else
    try {
      eprosima::fastcdr::CdrSizeCalculator calculator(
          data_representation ==
                  DataRepresentationId_t::XCDR_DATA_REPRESENTATION
              ? eprosima::fastcdr::CdrVersion::XCDRv1
              : eprosima::fastcdr::CdrVersion::XCDRv2);
      size_t current_alignment{0};
      return static_cast<uint32_t>(calculator.calculate_serialized_size(
                 *static_cast<CameraInfo*>(data), current_alignment)) +
             4u /*encapsulation*/;
    } catch (eprosima::fastcdr::exception::Exception& /*exception*/) {
      return 0;
    }
#endif  // FASTCDR_VERSION_MAJOR == 1
  };
}

void* CameraInfo::createData() {
  return reinterpret_cast<void*>(new CameraInfo());
}

void CameraInfo::deleteData(void* data) {
  delete (reinterpret_cast<CameraInfo*>(data));
}

bool CameraInfo::getKey(void* data, InstanceHandle_t* handle, bool force_md5) {
  if (!m_isGetKeyDefined) {
    return false;
  }

  CameraInfo* p_type = static_cast<CameraInfo*>(data);

  // Object that manages the raw buffer.
  eprosima::fastcdr::FastBuffer fastbuffer(
      reinterpret_cast<char*>(m_keyBuffer),
      sensor_msgs_msg_CameraInfo_max_key_cdr_typesize);

  // Object that serializes the data.
  eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS,
                             eprosima::fastcdr::CdrVersion::XCDRv1);
#if FASTCDR_VERSION_MAJOR == 1
  p_type->serializeKey(ser);
#else
  eprosima::fastcdr::serialize_key(ser, *p_type);
#endif  // FASTCDR_VERSION_MAJOR == 1
  if (force_md5 || sensor_msgs_msg_CameraInfo_max_key_cdr_typesize > 16) {
    m_md5.init();
#if FASTCDR_VERSION_MAJOR == 1
    m_md5.update(m_keyBuffer,
                 static_cast<unsigned int>(ser.getSerializedDataLength()));
#else
    m_md5.update(m_keyBuffer,
                 static_cast<unsigned int>(ser.get_serialized_data_length()));
#endif  // FASTCDR_VERSION_MAJOR == 1
    m_md5.finalize();
    for (uint8_t i = 0; i < 16; ++i) {
      handle->value[i] = m_md5.digest[i];
    }
  } else {
    for (uint8_t i = 0; i < 16; ++i) {
      handle->value[i] = m_keyBuffer[i];
    }
  }
  return true;
}

}  // End of namespace msg

}  // End of namespace sensor_msgs
