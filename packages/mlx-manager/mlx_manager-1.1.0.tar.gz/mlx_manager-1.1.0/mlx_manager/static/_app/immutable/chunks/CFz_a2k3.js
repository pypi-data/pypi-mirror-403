var u=Object.defineProperty;var i=o=>{throw TypeError(o)};var p=(o,s,t)=>s in o?u(o,s,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[s]=t;var l=(o,s,t)=>p(o,typeof s!="symbol"?s+"":s,t),h=(o,s,t)=>s.has(o)||i("Cannot "+t);var r=(o,s,t)=>(h(o,s,"read from private field"),t?t.call(o):s.get(o)),c=(o,s,t)=>s.has(o)?i("Cannot add the same private member more than once"):s instanceof WeakSet?s.add(o):s.set(o,t);import{s as g,b as S,g as f,c as y}from"./CNYbWU2B.js";import{m as w}from"./D9xfsXh9.js";var d;class _{constructor(){c(this,d,g(S(new Map)));l(this,"eventSources",new Map)}get downloads(){return f(r(this,d))}set downloads(s){y(r(this,d),s,!0)}async startDownload(s){if(this.isDownloading(s))return;const t={model_id:s,task_id:"",status:"pending",progress:0,downloaded_bytes:0,total_bytes:0},e=new Map(this.downloads);e.set(s,t),this.downloads=e;try{const{task_id:a}=await w.startDownload(s);this.updateDownload(s,{task_id:a}),this.connectSSE(s,a)}catch(a){this.updateDownload(s,{status:"failed",error:a instanceof Error?a.message:"Download failed"})}}connectSSE(s,t){this.closeSSE(s);const e=new EventSource(`/api/models/download/${t}/progress`);this.eventSources.set(s,e),e.onmessage=a=>{try{const n=JSON.parse(a.data);this.updateDownload(s,{status:n.status,progress:n.progress||0,downloaded_bytes:n.downloaded_bytes||0,total_bytes:n.total_bytes||0,error:n.error}),(n.status==="completed"||n.status==="failed")&&this.closeSSE(s)}catch{}},e.onerror=()=>{this.closeSSE(s)}}closeSSE(s){const t=this.eventSources.get(s);t&&(t.close(),this.eventSources.delete(s))}updateDownload(s,t){const e=this.downloads.get(s);if(e){const a=new Map(this.downloads);a.set(s,{...e,...t}),this.downloads=a}}reconnect(s,t,e){if(this.eventSources.has(s))return;const a={model_id:s,task_id:t,status:e.status||"downloading",progress:e.progress||0,downloaded_bytes:e.downloaded_bytes||0,total_bytes:e.total_bytes||0},n=new Map(this.downloads);n.set(s,a),this.downloads=n,this.connectSSE(s,t)}async loadActiveDownloads(){try{const s=await w.getActiveDownloads();for(const t of s)(t.status==="starting"||t.status==="downloading"||t.status==="pending")&&this.reconnect(t.model_id,t.task_id,{status:t.status,progress:t.progress,downloaded_bytes:t.downloaded_bytes,total_bytes:t.total_bytes})}catch{}}isDownloading(s){const t=this.downloads.get(s);return t?t.status==="pending"||t.status==="starting"||t.status==="downloading":!1}getProgress(s){return this.downloads.get(s)}getAllDownloads(){return Array.from(this.downloads.values())}clearCompleted(){const s=new Map;for(const[t,e]of this.downloads)e.status!=="completed"&&e.status!=="failed"&&s.set(t,e);this.downloads=s}cleanup(){for(const[s]of this.eventSources)this.closeSSE(s)}}d=new WeakMap;const E=new _;export{E as d};
