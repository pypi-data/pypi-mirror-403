# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: core/communication.proto, core/json_schema.proto, core/span.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from datetime import (
    datetime,
    timedelta,
)
from typing import (
    TYPE_CHECKING,
    Dict,
    List,
    Optional,
)

import betterproto
import betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class JsonSchemaType(betterproto.Enum):
    """
    JSON schema type enumeration
     Language-agnostic type classification for JSON values
    """

    UNSPECIFIED = 0
    NUMBER = 1
    STRING = 2
    BOOLEAN = 3
    NULL = 4
    UNDEFINED = 5
    OBJECT = 6
    ORDERED_LIST = 7
    UNORDERED_LIST = 8
    FUNCTION = 9


class EncodingType(betterproto.Enum):
    """Encoding type for data serialization"""

    UNSPECIFIED = 0
    BASE64 = 1


class DecodedType(betterproto.Enum):
    """
    Decoded content type classification
     Describes the semantic type of decoded content
    """

    UNSPECIFIED = 0
    JSON = 1
    HTML = 2
    CSS = 3
    JAVASCRIPT = 4
    XML = 5
    YAML = 6
    MARKDOWN = 7
    CSV = 8
    SQL = 9
    GRAPHQL = 10
    PLAIN_TEXT = 11
    FORM_DATA = 12
    MULTIPART_FORM = 13
    PDF = 14
    AUDIO = 15
    VIDEO = 16
    GZIP = 17
    BINARY = 18
    JPEG = 19
    PNG = 20
    GIF = 21
    WEBP = 22
    SVG = 23
    ZIP = 24


class PackageType(betterproto.Enum):
    """
    Package type classification enum
     Langauge agnostic
    """

    UNSPECIFIED = 0
    HTTP = 1
    GRAPHQL = 2
    GRPC = 3
    PG = 4
    MYSQL = 5
    MONGODB = 6
    REDIS = 7
    KAFKA = 8
    RABBITMQ = 9
    FIRESTORE = 10
    PRISMA = 11


class SpanKind(betterproto.Enum):
    """OpenTelemetry-compatible span kinds"""

    UNSPECIFIED = 0
    INTERNAL = 1
    SERVER = 2
    CLIENT = 3
    PRODUCER = 4
    CONSUMER = 5


class StatusCode(betterproto.Enum):
    UNSPECIFIED = 0
    OK = 1
    ERROR = 2


class MatchScope(betterproto.Enum):
    """Match scope - where the match was found"""

    UNSPECIFIED = 0
    TRACE = 1
    GLOBAL = 2


class MatchType(betterproto.Enum):
    """Match type - how the match was found"""

    UNSPECIFIED = 0
    INPUT_VALUE_HASH = 1
    INPUT_VALUE_HASH_REDUCED_SCHEMA = 2
    INPUT_SCHEMA_HASH = 3
    INPUT_SCHEMA_HASH_REDUCED_SCHEMA = 4
    FUZZY = 5
    FALLBACK = 6


class Runtime(betterproto.Enum):
    """SDK runtime environment"""

    UNSPECIFIED = 0
    NODE = 1
    PYTHON = 2


class MessageType(betterproto.Enum):
    UNSPECIFIED = 0
    SDK_CONNECT = 1
    MOCK_REQUEST = 2
    INBOUND_SPAN = 3
    ALERT = 4
    ENV_VAR_REQUEST = 5
    SET_TIME_TRAVEL = 6


@dataclass(eq=False, repr=False)
class JsonSchema(betterproto.Message):
    """
    Recursive JSON schema message
     Describes the structure and metadata of JSON data
    """

    type: "JsonSchemaType" = betterproto.enum_field(1)
    """The type of this schema node"""

    properties: Dict[str, "JsonSchema"] = betterproto.map_field(
        2, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    """For OBJECT types: map of property names to their schemas"""

    items: Optional["JsonSchema"] = betterproto.message_field(3, optional=True)
    """For ORDERED_LIST/UNORDERED_LIST types: schema of list items"""

    encoding: Optional["EncodingType"] = betterproto.enum_field(4, optional=True)
    """Optional encoding information (e.g., BASE64)"""

    decoded_type: Optional["DecodedType"] = betterproto.enum_field(5, optional=True)
    """Optional decoded content type (e.g., JSON, HTML)"""

    match_importance: Optional[float] = betterproto.double_field(6, optional=True)
    """
    Match importance for test matching (0.0 to 1.0)
     0.0 = lowest importance, 1.0 = highest importance
    """


@dataclass(eq=False, repr=False)
class Span(betterproto.Message):
    """Universal span structure that works for all instrumentation types"""

    trace_id: str = betterproto.string_field(1)
    """Core span identity"""

    span_id: str = betterproto.string_field(2)
    parent_span_id: str = betterproto.string_field(3)
    name: str = betterproto.string_field(4)
    """Visual name"""

    package_name: str = betterproto.string_field(5)
    """Instrumentation identity"""

    instrumentation_name: str = betterproto.string_field(6)
    submodule_name: str = betterproto.string_field(7)
    package_type: "PackageType" = betterproto.enum_field(8)
    """Package type classification"""

    input_value: "betterproto_lib_google_protobuf.Struct" = betterproto.message_field(9)
    """Input/output data"""

    output_value: "betterproto_lib_google_protobuf.Struct" = betterproto.message_field(
        10
    )
    input_schema: "JsonSchema" = betterproto.message_field(11)
    output_schema: "JsonSchema" = betterproto.message_field(12)
    input_schema_hash: str = betterproto.string_field(13)
    """Hash-based matching and validation"""

    output_schema_hash: str = betterproto.string_field(14)
    input_value_hash: str = betterproto.string_field(15)
    output_value_hash: str = betterproto.string_field(16)
    kind: "SpanKind" = betterproto.enum_field(17)
    """Span metadata"""

    status: "SpanStatus" = betterproto.message_field(18)
    is_pre_app_start: bool = betterproto.bool_field(19)
    timestamp: datetime = betterproto.message_field(20)
    """Timing information"""

    duration: timedelta = betterproto.message_field(21)
    is_root_span: bool = betterproto.bool_field(22)
    """Span relationships and state"""

    metadata: "betterproto_lib_google_protobuf.Struct" = betterproto.message_field(23)
    environment: Optional[str] = betterproto.string_field(24, optional=True)
    """Environment information"""

    id: Optional[str] = betterproto.string_field(25, optional=True)
    """Database record ID (used for caching and batch fetching)"""


@dataclass(eq=False, repr=False)
class SpanStatus(betterproto.Message):
    """Span completion status"""

    code: "StatusCode" = betterproto.enum_field(1)
    message: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class SpanEvent(betterproto.Message):
    """Span events (logs) - optional"""

    name: str = betterproto.string_field(1)
    timestamp: datetime = betterproto.message_field(2)
    attributes: Dict[str, "betterproto_lib_google_protobuf.Value"] = (
        betterproto.map_field(3, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE)
    )


@dataclass(eq=False, repr=False)
class SpanLink(betterproto.Message):
    """Span links - optional"""

    trace_id: str = betterproto.string_field(1)
    span_id: str = betterproto.string_field(2)
    attributes: Dict[str, "betterproto_lib_google_protobuf.Value"] = (
        betterproto.map_field(3, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE)
    )


@dataclass(eq=False, repr=False)
class Trace(betterproto.Message):
    """Trace collection"""

    trace_id: str = betterproto.string_field(1)
    spans: List["Span"] = betterproto.message_field(2)
    started_at: datetime = betterproto.message_field(3)
    completed_at: datetime = betterproto.message_field(4)
    metadata: Dict[str, str] = betterproto.map_field(
        5, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass(eq=False, repr=False)
class SimilarityCandidate(betterproto.Message):
    """Similarity candidate for ranking matches"""

    span_id: str = betterproto.string_field(1)
    score: float = betterproto.float_field(2)


@dataclass(eq=False, repr=False)
class MatchLevel(betterproto.Message):
    """Match level information"""

    match_type: "MatchType" = betterproto.enum_field(1)
    match_scope: "MatchScope" = betterproto.enum_field(2)
    match_description: str = betterproto.string_field(3)
    similarity_score: Optional[float] = betterproto.float_field(4, optional=True)
    """Similarity scoring fields (populated when multiple matches exist)"""

    top_candidates: List["SimilarityCandidate"] = betterproto.message_field(5)


@dataclass(eq=False, repr=False)
class ConnectRequest(betterproto.Message):
    """SDK connection handshake"""

    service_id: str = betterproto.string_field(1)
    sdk_version: str = betterproto.string_field(2)
    min_cli_version: str = betterproto.string_field(3)
    metadata: "betterproto_lib_google_protobuf.Struct" = betterproto.message_field(4)
    runtime: "Runtime" = betterproto.enum_field(5)


@dataclass(eq=False, repr=False)
class ConnectResponse(betterproto.Message):
    success: bool = betterproto.bool_field(1)
    error: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class GetMockRequest(betterproto.Message):
    request_id: str = betterproto.string_field(1)
    test_id: str = betterproto.string_field(2)
    outbound_span: "Span" = betterproto.message_field(3)
    stack_trace: str = betterproto.string_field(4)
    operation: str = betterproto.string_field(5)
    tags: Dict[str, str] = betterproto.map_field(
        6, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    requested_at: datetime = betterproto.message_field(7)


@dataclass(eq=False, repr=False)
class GetMockResponse(betterproto.Message):
    request_id: str = betterproto.string_field(1)
    found: bool = betterproto.bool_field(2)
    response_data: "betterproto_lib_google_protobuf.Struct" = betterproto.message_field(
        3
    )
    """Opaque response data - CLI returns as-is from stored spans"""

    metadata: "betterproto_lib_google_protobuf.Struct" = betterproto.message_field(4)
    error: str = betterproto.string_field(5)
    """Error information"""

    error_code: str = betterproto.string_field(6)
    matched_span_id: str = betterproto.string_field(7)
    """Mock metadata"""

    matched_at: datetime = betterproto.message_field(8)
    match_level: Optional["MatchLevel"] = betterproto.message_field(9, optional=True)
    """Match information (populated when found=true)"""


@dataclass(eq=False, repr=False)
class SdkMessage(betterproto.Message):
    """Message types for the Unix socket protocol"""

    type: "MessageType" = betterproto.enum_field(1)
    request_id: str = betterproto.string_field(2)
    connect_request: "ConnectRequest" = betterproto.message_field(3, group="payload")
    get_mock_request: "GetMockRequest" = betterproto.message_field(4, group="payload")
    send_inbound_span_for_replay_request: "SendInboundSpanForReplayRequest" = (
        betterproto.message_field(5, group="payload")
    )
    send_alert_request: "SendAlertRequest" = betterproto.message_field(
        6, group="payload"
    )
    env_var_request: "EnvVarRequest" = betterproto.message_field(7, group="payload")
    set_time_travel_response: "SetTimeTravelResponse" = betterproto.message_field(
        8, group="payload"
    )


@dataclass(eq=False, repr=False)
class CliMessage(betterproto.Message):
    type: "MessageType" = betterproto.enum_field(1)
    request_id: str = betterproto.string_field(2)
    connect_response: "ConnectResponse" = betterproto.message_field(3, group="payload")
    get_mock_response: "GetMockResponse" = betterproto.message_field(4, group="payload")
    send_inbound_span_for_replay_response: "SendInboundSpanForReplayResponse" = (
        betterproto.message_field(5, group="payload")
    )
    env_var_response: "EnvVarResponse" = betterproto.message_field(6, group="payload")
    set_time_travel_request: "SetTimeTravelRequest" = betterproto.message_field(
        7, group="payload"
    )


@dataclass(eq=False, repr=False)
class SendInboundSpanForReplayRequest(betterproto.Message):
    span: "Span" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class SendInboundSpanForReplayResponse(betterproto.Message):
    success: bool = betterproto.bool_field(1)


@dataclass(eq=False, repr=False)
class SendAlertRequest(betterproto.Message):
    version_mismatch: "InstrumentationVersionMismatchAlert" = betterproto.message_field(
        1, group="alert"
    )
    unpatched_dependency: "UnpatchedDependencyAlert" = betterproto.message_field(
        2, group="alert"
    )


@dataclass(eq=False, repr=False)
class InstrumentationVersionMismatchAlert(betterproto.Message):
    module_name: str = betterproto.string_field(1)
    requested_version: str = betterproto.string_field(2)
    supported_versions: List[str] = betterproto.string_field(3)
    sdk_version: str = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class UnpatchedDependencyAlert(betterproto.Message):
    stack_trace: str = betterproto.string_field(1)
    trace_test_server_span_id: str = betterproto.string_field(2)
    sdk_version: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class EnvVarRequest(betterproto.Message):
    trace_test_server_span_id: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class EnvVarResponse(betterproto.Message):
    env_vars: Dict[str, str] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass(eq=False, repr=False)
class SetTimeTravelRequest(betterproto.Message):
    """
    Request from CLI to SDK to start time travel before request replay
     Currently only used for python SDK
    """

    timestamp_seconds: float = betterproto.double_field(1)
    """Unix timestamp in seconds (can include fractional seconds)"""

    trace_id: str = betterproto.string_field(2)
    """The trace ID this time travel is for (for debugging/logging)"""

    timestamp_source: str = betterproto.string_field(3)
    """
    Description of why this timestamp was chosen: "first_span" or "server_span"
    """


@dataclass(eq=False, repr=False)
class SetTimeTravelResponse(betterproto.Message):
    """Response from SDK acknowledging time travel was set"""

    success: bool = betterproto.bool_field(1)
    error: str = betterproto.string_field(2)


class MockServiceStub(betterproto.ServiceStub):
    async def connect(
        self,
        connect_request: "ConnectRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ConnectResponse":
        return await self._unary_unary(
            "/tusk.drift.core.v1.MockService/Connect",
            connect_request,
            ConnectResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_mock(
        self,
        get_mock_request: "GetMockRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetMockResponse":
        return await self._unary_unary(
            "/tusk.drift.core.v1.MockService/GetMock",
            get_mock_request,
            GetMockResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def send_inbound_span_for_replay(
        self,
        send_inbound_span_for_replay_request: "SendInboundSpanForReplayRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SendInboundSpanForReplayResponse":
        return await self._unary_unary(
            "/tusk.drift.core.v1.MockService/SendInboundSpanForReplay",
            send_inbound_span_for_replay_request,
            SendInboundSpanForReplayResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class MockServiceBase(ServiceBase):

    async def connect(self, connect_request: "ConnectRequest") -> "ConnectResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_mock(self, get_mock_request: "GetMockRequest") -> "GetMockResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def send_inbound_span_for_replay(
        self, send_inbound_span_for_replay_request: "SendInboundSpanForReplayRequest"
    ) -> "SendInboundSpanForReplayResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_connect(
        self, stream: "grpclib.server.Stream[ConnectRequest, ConnectResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.connect(request)
        await stream.send_message(response)

    async def __rpc_get_mock(
        self, stream: "grpclib.server.Stream[GetMockRequest, GetMockResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_mock(request)
        await stream.send_message(response)

    async def __rpc_send_inbound_span_for_replay(
        self,
        stream: "grpclib.server.Stream[SendInboundSpanForReplayRequest, SendInboundSpanForReplayResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.send_inbound_span_for_replay(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/tusk.drift.core.v1.MockService/Connect": grpclib.const.Handler(
                self.__rpc_connect,
                grpclib.const.Cardinality.UNARY_UNARY,
                ConnectRequest,
                ConnectResponse,
            ),
            "/tusk.drift.core.v1.MockService/GetMock": grpclib.const.Handler(
                self.__rpc_get_mock,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetMockRequest,
                GetMockResponse,
            ),
            "/tusk.drift.core.v1.MockService/SendInboundSpanForReplay": grpclib.const.Handler(
                self.__rpc_send_inbound_span_for_replay,
                grpclib.const.Cardinality.UNARY_UNARY,
                SendInboundSpanForReplayRequest,
                SendInboundSpanForReplayResponse,
            ),
        }
