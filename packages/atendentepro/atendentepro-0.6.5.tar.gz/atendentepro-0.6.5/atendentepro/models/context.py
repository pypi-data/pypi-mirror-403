# -*- coding: utf-8 -*-
"""Context models for AtendentePro agents."""

from __future__ import annotations

from dataclasses import dataclass, field as dataclass_field
from typing import Any, Callable, Dict, List, Optional

from pydantic import BaseModel, Field


class ContextNote(BaseModel):
    """
    Shared context model used across all agents.
    
    Contains structured summaries generated by previous agents
    to guide subsequent handoffs.
    """
    
    handoff_summaries: dict[str, dict] = Field(
        default_factory=dict,
        description="Resumos estruturados gerados por agentes anteriores para orientar prÃ³ximos handoffs.",
    )


# =============================================================================
# ACCESS FILTERING MODELS
# =============================================================================

@dataclass
class UserContext:
    """
    User context for access filtering.
    
    Contains user identification and role information used to filter
    access to agents, prompts, and tools.
    
    Attributes:
        user_id: Unique user identifier
        role: User role (e.g., "admin", "cliente", "vendedor")
        metadata: Additional user metadata
        
    Example:
        >>> user = UserContext(
        ...     user_id="user123",
        ...     role="vendedor",
        ...     metadata={"department": "sales", "level": 2}
        ... )
    """
    user_id: Optional[str] = None
    role: Optional[str] = None
    metadata: Dict[str, Any] = dataclass_field(default_factory=dict)


@dataclass
class AccessFilter:
    """
    Filter for controlling access to agents, prompts, and tools.
    
    Supports both whitelist (allowed_*) and blacklist (denied_*) patterns.
    User-level filters take precedence over role-level filters.
    
    Attributes:
        allowed_roles: If set, only these roles can access
        denied_roles: If set, these roles cannot access
        allowed_users: If set, only these users can access (overrides role)
        denied_users: If set, these users cannot access (overrides role)
        
    Example:
        >>> # Only admin and manager can access
        >>> filter1 = AccessFilter(allowed_roles=["admin", "gerente"])
        >>> 
        >>> # Everyone except clients
        >>> filter2 = AccessFilter(denied_roles=["cliente"])
        >>> 
        >>> # Specific premium users
        >>> filter3 = AccessFilter(allowed_users=["premium_user_1", "premium_user_2"])
    """
    allowed_roles: Optional[List[str]] = None
    denied_roles: Optional[List[str]] = None
    allowed_users: Optional[List[str]] = None
    denied_users: Optional[List[str]] = None
    
    def is_allowed(self, ctx: Optional[UserContext]) -> bool:
        """
        Check if user/role has access.
        
        Evaluation order:
        1. If no context provided, allow (no filter applied)
        2. Check denied_users (if user is denied, block)
        3. Check allowed_users (if set and user not in list, block)
        4. Check denied_roles (if role is denied, block)
        5. Check allowed_roles (if set and role not in list, block)
        6. Allow by default
        
        Args:
            ctx: User context to check
            
        Returns:
            True if access is allowed, False otherwise
        """
        if ctx is None:
            return True  # No context = no filter
        
        # User-level checks (highest priority)
        if self.denied_users and ctx.user_id in self.denied_users:
            return False
        if self.allowed_users:
            if ctx.user_id in self.allowed_users:
                return True  # Explicitly allowed user
            # If allowed_users is set but user not in list, check roles
            # unless no role filters are set
            if not self.allowed_roles and not self.denied_roles:
                return False
        
        # Role-level checks
        if self.denied_roles and ctx.role in self.denied_roles:
            return False
        if self.allowed_roles and ctx.role not in self.allowed_roles:
            return False
        
        return True  # No filter matched = allow


@dataclass
class FilteredPromptSection:
    """
    Conditional prompt section that appears based on access filter.
    
    Allows adding role/user-specific instructions to agent prompts.
    
    Attributes:
        content: The prompt content to add
        filter: Access filter determining when to include this section
        
    Example:
        >>> # Section for admins only
        >>> admin_section = FilteredPromptSection(
        ...     content="## Admin Tools\\nYou can delete users and manage permissions.",
        ...     filter=AccessFilter(allowed_roles=["admin"])
        ... )
    """
    content: str
    filter: AccessFilter
    
    def get_content_if_allowed(self, ctx: Optional[UserContext]) -> str:
        """Return content if user has access, empty string otherwise."""
        if self.filter.is_allowed(ctx):
            return self.content
        return ""


@dataclass
class FilteredTool:
    """
    Tool with access filter.
    
    Wraps a function_tool with an access filter to control who can use it.
    
    Attributes:
        tool: The function_tool callable
        filter: Access filter determining who can use this tool
        
    Example:
        >>> @function_tool
        ... def delete_user(user_id: str) -> str:
        ...     return f"User {user_id} deleted"
        >>> 
        >>> admin_tool = FilteredTool(
        ...     tool=delete_user,
        ...     filter=AccessFilter(allowed_roles=["admin"])
        ... )
    """
    tool: Callable
    filter: AccessFilter
    
    def get_tool_if_allowed(self, ctx: Optional[UserContext]) -> Optional[Callable]:
        """Return tool if user has access, None otherwise."""
        if self.filter.is_allowed(ctx):
            return self.tool
        return None

