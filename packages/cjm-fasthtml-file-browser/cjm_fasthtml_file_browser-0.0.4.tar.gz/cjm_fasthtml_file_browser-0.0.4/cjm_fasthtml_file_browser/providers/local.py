"""Local file system provider for interactive directory navigation."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/providers/local.ipynb.

# %% auto #0
__all__ = ['LocalFileSystemProvider']

# %% ../../nbs/providers/local.ipynb #c3d4e5f6
import asyncio
import os
from pathlib import Path
from typing import List, Optional, Tuple

from cjm_file_discovery.core.models import FileInfo, FileType
from cjm_file_discovery.core.config import ExtensionMapping
from cjm_file_discovery.utils.formatting import get_mime_type

from ..core.models import DirectoryListing

# %% ../../nbs/providers/local.ipynb #e5f6a7b8
class LocalFileSystemProvider:
    """Local file system provider for interactive navigation."""
    
    def __init__(
        self,
        extension_mapping: Optional[ExtensionMapping] = None  # For file type detection
    ):
        """Initialize with optional extension mapping."""
        self._extension_mapping = extension_mapping or ExtensionMapping()

    @property
    def name(self) -> str:  # Provider identifier
        """Provider identifier."""
        return "local"

    @property
    def root_path(self) -> str:  # Root path (filesystem root)
        """Root path for this provider."""
        return "/"

    @property
    def path_separator(self) -> str:  # Path separator
        """Path separator character."""
        return os.sep
    
    def _get_file_info(
        self,
        path: Path  # Path object
    ) -> Optional[FileInfo]:  # FileInfo or None on error
        """Get FileInfo for a path."""
        try:
            stat = path.stat()
            is_dir = path.is_dir()
            ext = path.suffix.lstrip('.').lower() if path.suffix and not is_dir else None
            file_type = self._extension_mapping.get_type(ext) if ext else FileType.OTHER
            
            return FileInfo(
                name=path.name,
                path=str(path.absolute()),
                is_directory=is_dir,
                size=stat.st_size if not is_dir else None,
                modified=stat.st_mtime,
                created=getattr(stat, 'st_birthtime', stat.st_ctime),
                file_type=file_type if not is_dir else FileType.OTHER,
                extension=ext,
                mime_type=get_mime_type(str(path)) if not is_dir else None,
                provider_name=self.name
            )
        except (OSError, PermissionError):
            return None

    def list_directory(
        self,
        path: str  # Directory path to list
    ) -> DirectoryListing:  # Directory contents
        """List contents of a directory."""
        p = Path(path).resolve()
        
        # Check if path exists and is a directory
        if not p.exists():
            return DirectoryListing(
                path=str(p),
                items=[],
                error=f"Path does not exist: {path}"
            )
        
        if not p.is_dir():
            return DirectoryListing(
                path=str(p),
                items=[],
                error=f"Path is not a directory: {path}"
            )
        
        # Get parent path
        parent = p.parent if p != p.parent else None
        
        # List directory contents
        items: List[FileInfo] = []
        try:
            for entry in p.iterdir():
                file_info = self._get_file_info(entry)
                if file_info is not None:
                    items.append(file_info)
        except PermissionError:
            return DirectoryListing(
                path=str(p),
                items=[],
                parent_path=str(parent) if parent else None,
                provider_name=self.name,
                error="Permission denied"
            )
        
        return DirectoryListing(
            path=str(p),
            items=items,
            parent_path=str(parent) if parent else None,
            provider_name=self.name,
            total_items=len(items)
        )

    async def list_directory_async(
        self,
        path: str  # Directory path to list
    ) -> DirectoryListing:  # Directory contents
        """Async list contents of a directory."""
        loop = asyncio.get_event_loop()
        return await loop.run_in_executor(None, self.list_directory, path)

    def get_file_info(
        self,
        path: str  # Path to file/directory
    ) -> Optional[FileInfo]:  # FileInfo or None if not found
        """Get metadata for a single file/directory."""
        p = Path(path)
        if not p.exists():
            return None
        return self._get_file_info(p)

    def get_parent_path(
        self,
        path: str  # Current path
    ) -> Optional[str]:  # Parent path, or None if at root
        """Get parent directory path."""
        p = Path(path).resolve()
        parent = p.parent
        if parent == p:  # At root
            return None
        return str(parent)

    def join_path(
        self,
        base: str,   # Base path
        *parts: str  # Path parts to join
    ) -> str:  # Joined path
        """Join path components."""
        return str(Path(base).joinpath(*parts))

    def normalize_path(
        self,
        path: str  # Path to normalize
    ) -> str:  # Normalized/resolved path
        """Normalize/resolve a path."""
        return str(Path(path).resolve())

    def is_valid_path(
        self,
        path: str  # Path to validate
    ) -> Tuple[bool, Optional[str]]:  # (valid, error_message)
        """Validate path."""
        try:
            p = Path(path).resolve()
            if not p.exists():
                return (False, f"Path does not exist: {path}")
            return (True, None)
        except (ValueError, OSError) as e:
            return (False, str(e))

    def path_exists(
        self,
        path: str  # Path to check
    ) -> bool:  # True if path exists
        """Check if path exists."""
        return Path(path).exists()

    def is_directory(
        self,
        path: str  # Path to check
    ) -> bool:  # True if path is a directory
        """Check if path is a directory."""
        return Path(path).is_dir()
    
    def get_home_path(self) -> str:  # User's home directory
        """Get the user's home directory."""
        return str(Path.home())
