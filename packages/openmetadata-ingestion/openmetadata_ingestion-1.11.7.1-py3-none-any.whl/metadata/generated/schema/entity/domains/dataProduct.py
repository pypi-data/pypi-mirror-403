# generated by datamodel-codegen:
#   filename:  entity/domains/dataProduct.json
#   timestamp: 2026-01-30T06:35:57+00:00

from __future__ import annotations

from enum import Enum
from typing import List, Optional

from pydantic import ConfigDict, Field
from typing_extensions import Annotated

from metadata.ingestion.models.custom_pydantic import BaseModel

from ...type import (
    basic,
    entityHistory,
    entityReference,
    entityReferenceList,
    status,
    tagLabel,
)


class LifecycleStage(Enum):
    IDEATION = 'IDEATION'
    DESIGN = 'DESIGN'
    DEVELOPMENT = 'DEVELOPMENT'
    TESTING = 'TESTING'
    PRODUCTION = 'PRODUCTION'
    DEPRECATED = 'DEPRECATED'
    RETIRED = 'RETIRED'


class PortType(Enum):
    INPUT = 'INPUT'
    OUTPUT = 'OUTPUT'


class PortProtocol(Enum):
    REST = 'REST'
    GRPC = 'GRPC'
    GRAPHQL = 'GRAPHQL'
    JDBC = 'JDBC'
    KAFKA = 'KAFKA'
    FILE = 'FILE'
    S3 = 'S3'
    AZURE_BLOB = 'AZURE_BLOB'
    GCS = 'GCS'
    WEBHOOK = 'WEBHOOK'
    CUSTOM = 'CUSTOM'


class PortFormat(Enum):
    JSON = 'JSON'
    CSV = 'CSV'
    PARQUET = 'PARQUET'
    AVRO = 'AVRO'
    ORC = 'ORC'
    XML = 'XML'
    PROTOBUF = 'PROTOBUF'
    DELTA = 'DELTA'
    ICEBERG = 'ICEBERG'
    CUSTOM = 'CUSTOM'


class Tier(Enum):
    GOLD = 'GOLD'
    SILVER = 'SILVER'
    BRONZE = 'BRONZE'
    CUSTOM = 'CUSTOM'


class SlaDefinition(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    tier: Annotated[
        Optional[Tier], Field(None, description='SLA tier (e.g., GOLD, SILVER, BRONZE)')
    ]
    availability: Annotated[
        Optional[float],
        Field(
            None,
            description='Expected availability percentage (e.g., 99.9)',
            ge=0.0,
            le=100.0,
        ),
    ]
    responseTime: Annotated[
        Optional[int], Field(None, description='Expected response time in milliseconds')
    ]
    dataFreshness: Annotated[
        Optional[int], Field(None, description='Maximum data staleness in minutes')
    ]
    dataQuality: Annotated[
        Optional[float],
        Field(None, description='Minimum data quality score', ge=0.0, le=100.0),
    ]


class DataProductPort(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: Annotated[str, Field(description='Name of the port')]
    displayName: Annotated[
        Optional[str], Field(None, description='Display name of the port')
    ]
    description: Annotated[
        Optional[str], Field(None, description='Description of the port')
    ]
    portType: PortType
    protocol: Optional[PortProtocol] = PortProtocol.REST
    format: Optional[PortFormat] = PortFormat.JSON
    endpoint: Annotated[
        Optional[str], Field(None, description='Endpoint URL or connection string')
    ]
    dataAsset: Annotated[
        Optional[entityReference.EntityReference],
        Field(
            None, description='Reference to the data asset exposed through this port'
        ),
    ]


class DataProduct(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Annotated[basic.Uuid, Field(description='Unique ID of the Data Product')]
    name: Annotated[
        basic.EntityName, Field(description='A unique name of the Data Product')
    ]
    fullyQualifiedName: Annotated[
        Optional[basic.FullyQualifiedEntityName],
        Field(
            None,
            description='FullyQualifiedName is `domain.dataProductName` or `sub-domain.dataProductName`.',
        ),
    ]
    displayName: Annotated[
        Optional[str],
        Field(
            None,
            description="Name used for display purposes. Example 'Marketing', 'Payments', etc.",
        ),
    ]
    description: Annotated[
        basic.Markdown, Field(description='Description of the Data Product.')
    ]
    style: Optional[basic.Style] = None
    version: Annotated[
        Optional[entityHistory.EntityVersion],
        Field(None, description='Metadata version of the entity.'),
    ]
    updatedAt: Annotated[
        Optional[basic.Timestamp],
        Field(
            None,
            description='Last update time corresponding to the new version of the entity in Unix epoch time milliseconds.',
        ),
    ]
    updatedBy: Annotated[
        Optional[str], Field(None, description='User who made the update.')
    ]
    impersonatedBy: Annotated[
        Optional[basic.ImpersonatedBy],
        Field(
            None,
            description='Bot user that performed the action on behalf of the actual user.',
        ),
    ]
    href: Annotated[
        Optional[basic.Href],
        Field(None, description='Link to the resource corresponding to this entity.'),
    ]
    owners: Annotated[
        Optional[entityReferenceList.EntityReferenceList],
        Field(None, description='Owners of this Data Product.'),
    ]
    experts: Annotated[
        Optional[entityReferenceList.EntityReferenceList],
        Field(None, description='List of users who are experts for this Data Product.'),
    ]
    reviewers: Annotated[
        Optional[entityReferenceList.EntityReferenceList],
        Field(
            None, description='User references of the reviewers for this Data Product.'
        ),
    ]
    domains: Annotated[
        Optional[entityReferenceList.EntityReferenceList],
        Field(
            None,
            description='Domains or sub-domains to which this Data Product belongs to.',
        ),
    ]
    assets: Annotated[
        Optional[entityReferenceList.EntityReferenceList],
        Field(
            None,
            description='Data assets collection that is part of this data product.',
        ),
    ]
    inputPorts: Annotated[
        Optional[List[DataProductPort]],
        Field([], description='Input ports for consuming data into this data product'),
    ]
    outputPorts: Annotated[
        Optional[List[DataProductPort]],
        Field([], description='Output ports for exposing data from this data product'),
    ]
    lifecycleStage: Annotated[
        Optional[LifecycleStage],
        Field(
            LifecycleStage.DEVELOPMENT,
            description='Current lifecycle stage of the data product',
        ),
    ]
    sla: Annotated[
        Optional[SlaDefinition],
        Field(None, description='Service Level Agreement for this data product'),
    ]
    consumesFrom: Annotated[
        Optional[entityReferenceList.EntityReferenceList],
        Field(
            [], description='Other data products that this product consumes data from'
        ),
    ]
    providesTo: Annotated[
        Optional[entityReferenceList.EntityReferenceList],
        Field(
            [], description='Other data products that consume data from this product'
        ),
    ]
    tags: Annotated[
        Optional[List[tagLabel.TagLabel]],
        Field([], description='Tags associated with the Data Product.'),
    ]
    changeDescription: Annotated[
        Optional[entityHistory.ChangeDescription],
        Field(None, description='Change that lead to this version of the entity.'),
    ]
    incrementalChangeDescription: Annotated[
        Optional[entityHistory.ChangeDescription],
        Field(None, description='Change that lead to this version of the entity.'),
    ]
    extension: Annotated[
        Optional[basic.EntityExtension],
        Field(
            None,
            description='Entity extension data with custom attributes added to the entity.',
        ),
    ]
    followers: Annotated[
        Optional[entityReferenceList.EntityReferenceList],
        Field(None, description='Followers of this entity.'),
    ]
    entityStatus: Annotated[
        Optional[status.EntityStatus],
        Field(
            status.EntityStatus.Unprocessed, description='Status of the Data Product.'
        ),
    ]
