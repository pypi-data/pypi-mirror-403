# generated by datamodel-codegen:
#   filename:  entity/data/dataContract.json
#   timestamp: 2026-01-30T06:35:57+00:00

from __future__ import annotations

from enum import Enum
from typing import List, Optional

from pydantic import ConfigDict, Field
from typing_extensions import Annotated

from metadata.ingestion.models.custom_pydantic import BaseModel

from ...type import (
    basic,
    contractExecutionStatus,
    entityHistory,
    entityReference,
    entityReferenceList,
    status,
)
from . import table


class LatestResult(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    timestamp: Optional[basic.Timestamp] = None
    status: Optional[contractExecutionStatus.ContractExecutionStatus] = None
    message: Optional[str] = None
    resultId: Optional[basic.Uuid] = None


class ContractStatus(Enum):
    Draft = 'Draft'
    Active = 'Active'
    Deprecated = 'Deprecated'


class ContractUpdate(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    timestamp: Annotated[
        basic.Timestamp, Field(description='Timestamp when the contract was updated.')
    ]
    updatedBy: Annotated[str, Field(description='User who updated the contract.')]
    impersonatedBy: Annotated[
        Optional[basic.ImpersonatedBy],
        Field(
            None,
            description='Bot user that performed the action on behalf of the actual user.',
        ),
    ]
    changeDescription: Annotated[
        Optional[basic.Markdown],
        Field(None, description='Description of changes made to the contract.'),
    ]
    version: Annotated[
        str, Field(description='Version number of the contract after the update.')
    ]


class RowFilter(BaseModel):
    columnName: Annotated[
        Optional[str],
        Field(None, description='Column to apply the filter', title='Column Name'),
    ]
    values: Annotated[
        Optional[List[str]],
        Field(None, description='Values applied to the filter', title='Filter Values'),
    ]


class Policy(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    accessPolicy: Annotated[
        Optional[str],
        Field(
            None,
            description='Reference to an access policy ID or name that should govern this data',
            title='Access Policy',
        ),
    ]
    identities: Annotated[
        Optional[List[str]],
        Field(
            None,
            description='List of groups that are intended consumers of the data',
            title='Consumer AD Groups',
        ),
    ]
    rowFilters: Annotated[
        Optional[List[RowFilter]],
        Field(
            None,
            description='List of filters that define what subset of the data is accessible to the consumers',
            title='Row Data Filters',
        ),
    ]


class ContractSecurity(BaseModel):
    dataClassification: Annotated[
        Optional[str],
        Field(
            None,
            description='Expected data classification (e.g. Confidential, PII, etc.)',
            title='Data Classification',
        ),
    ]
    policies: Annotated[
        Optional[List[Policy]],
        Field(
            None,
            description='Intended consumers of the data (e.g. internal teams, external partners, etc.)',
            title='Data Consumers',
        ),
    ]


class Unit(Enum):
    hour = 'hour'
    day = 'day'
    week = 'week'
    month = 'month'
    year = 'year'


class RefreshFrequency(BaseModel):
    interval: int
    unit: Unit


class Unit1(Enum):
    minute = 'minute'
    hour = 'hour'
    day = 'day'


class MaxLatency(BaseModel):
    value: int
    unit: Unit1


class Timezone(Enum):
    GMT_11_00__Pacific_Niue_ = 'GMT-11:00 (Pacific/Niue)'
    GMT_10_00__Pacific_Honolulu_ = 'GMT-10:00 (Pacific/Honolulu)'
    GMT_09_30__Pacific_Marquesas_ = 'GMT-09:30 (Pacific/Marquesas)'
    GMT_09_00__America_Anchorage_ = 'GMT-09:00 (America/Anchorage)'
    GMT_08_00__America_Los_Angeles_ = 'GMT-08:00 (America/Los Angeles)'
    GMT_07_00__America_Denver_ = 'GMT-07:00 (America/Denver)'
    GMT_06_00__America_Chicago_ = 'GMT-06:00 (America/Chicago)'
    GMT_05_00__America_New_York_ = 'GMT-05:00 (America/New York)'
    GMT_04_00__America_Santiago_ = 'GMT-04:00 (America/Santiago)'
    GMT_03_00__America_Sao_Paulo_ = 'GMT-03:00 (America/Sao Paulo)'
    GMT_02_30__Atlantic_Newfoundland_ = 'GMT-02:30 (Atlantic/Newfoundland)'
    GMT_02_00__Atlantic_South_Georgia_ = 'GMT-02:00 (Atlantic/South_Georgia)'
    GMT_01_00__Atlantic_Azores_ = 'GMT-01:00 (Atlantic/Azores)'
    GMT_00_00__Europe_London_ = 'GMT+00:00 (Europe/London)'
    GMT_01_00__Europe_Paris_ = 'GMT+01:00 (Europe/Paris)'
    GMT_02_00__Europe_Athens_ = 'GMT+02:00 (Europe/Athens)'
    GMT_03_00__Europe_Moscow_ = 'GMT+03:00 (Europe/Moscow)'
    GMT_03_00__Asia_Iran_ = 'GMT+03:00 (Asia/Iran)'
    GMT_04_00__Asia_Dubai_ = 'GMT+04:00 (Asia/Dubai)'
    GMT_04_30__Asia_Afghanistan_ = 'GMT+04:30 (Asia/Afghanistan)'
    GMT_05_00__Asia_Karachi_ = 'GMT+05:00 (Asia/Karachi)'
    GMT_05_30__Asia_Kolkata_ = 'GMT+05:30 (Asia/Kolkata)'
    GMT_05_45__Asia_Nepal_ = 'GMT+05:45 (Asia/Nepal)'
    GMT_06_00__Asia_Dhaka_ = 'GMT+06:00 (Asia/Dhaka)'
    GMT_06_00__Asia_Myanmar_ = 'GMT+06:00 (Asia/Myanmar)'
    GMT_07_00__Asia_Bangkok_ = 'GMT+07:00 (Asia/Bangkok)'
    GMT_08_00__Asia_Shanghai_ = 'GMT+08:00 (Asia/Shanghai)'
    GMT_08_45__Australia_Australian_Central_Western_Standard_Time_ = (
        'GMT+08:45 (Australia/Australian Central Western Standard Time)'
    )
    GMT_09_00__Asia_Tokyo_ = 'GMT+09:00 (Asia/Tokyo)'
    GMT_09_00__Australia_Adelaide_ = 'GMT+09:00 (Australia/Adelaide)'
    GMT_10_00__Australia_Sydney_ = 'GMT+10:00 (Australia/Sydney)'
    GMT_10_30__Australia_Lord_Howe_ = 'GMT+10:30 (Australia/Lord Howe)'
    GMT_11_00__Pacific_Norfolk_ = 'GMT+11:00 (Pacific/Norfolk)'
    GMT_12_00__Pacific_Auckland_ = 'GMT+12:00 (Pacific/Auckland)'
    GMT_13_00__Pacific_Tongatapu_ = 'GMT+13:00 (Pacific/Tongatapu)'
    GMT_14_00__Pacific_Kiritimati_ = 'GMT+14:00 (Pacific/Kiritimati)'


class Unit2(Enum):
    day = 'day'
    week = 'week'
    month = 'month'
    year = 'year'


class Retention(BaseModel):
    period: int
    unit: Unit2


class ContractSLA(BaseModel):
    refreshFrequency: Annotated[
        Optional[RefreshFrequency],
        Field(
            None,
            description='Expected frequency of data updates (e.g. every 1 day)',
            title='Refresh Frequency',
        ),
    ]
    maxLatency: Annotated[
        Optional[MaxLatency],
        Field(
            None,
            description='Maximum acceptable latency between data generation and availability (e.g. 4 hours)',
            title='Maximum Latency',
        ),
    ]
    availabilityTime: Annotated[
        Optional[str],
        Field(
            None,
            description='Time of day by which data is expected to be available (e.g. "09:00 UTC")',
            title='Availability Time',
        ),
    ]
    timezone: Annotated[
        Optional[Timezone],
        Field(
            Timezone.GMT_00_00__Europe_London_,
            description='Timezone for the availability time. UTC by default.',
            title='Timezone',
        ),
    ]
    retention: Annotated[
        Optional[Retention],
        Field(
            None,
            description='How long the data is retained (if relevant)',
            title='Data Retention Period',
        ),
    ]
    columnName: Annotated[
        Optional[str],
        Field(
            None,
            description='Column that represents the refresh time of the data (if applicable)',
            title='Column Name',
        ),
    ]


class DataContract(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Annotated[
        basic.Uuid,
        Field(description='Unique identifier of this data contract instance.'),
    ]
    name: Annotated[basic.EntityName, Field(description='Name of the data contract.')]
    displayName: Annotated[
        Optional[str], Field(None, description='Display name of the data contract.')
    ]
    fullyQualifiedName: Annotated[
        Optional[basic.FullyQualifiedEntityName],
        Field(None, description='Fully qualified name of the data contract.'),
    ]
    description: Annotated[
        Optional[basic.Markdown],
        Field(None, description='Description of the data contract.'),
    ]
    version: Annotated[
        Optional[entityHistory.EntityVersion],
        Field(None, description='Metadata version of the entity.'),
    ]
    updatedAt: Annotated[
        Optional[basic.Timestamp],
        Field(
            None,
            description='Last update time corresponding to the new version of the entity in Unix epoch time milliseconds.',
        ),
    ]
    updatedBy: Annotated[
        Optional[str], Field(None, description='User who made the update.')
    ]
    impersonatedBy: Annotated[
        Optional[basic.ImpersonatedBy],
        Field(
            None,
            description='Bot user that performed the action on behalf of the actual user.',
        ),
    ]
    createdAt: Annotated[
        Optional[basic.Timestamp],
        Field(
            None,
            description='Timestamp in Unix epoch time milliseconds corresponding to when the data contract was created.',
        ),
    ]
    createdBy: Annotated[
        Optional[str],
        Field(None, description='User or Bot who created the data contract.'),
    ]
    href: Annotated[
        Optional[basic.Href],
        Field(None, description='Link to this data contract resource.'),
    ]
    entityStatus: Annotated[
        Optional[status.EntityStatus],
        Field(
            status.EntityStatus.Draft,
            description='Approval status of the data contract.',
        ),
    ]
    entity: Annotated[
        entityReference.EntityReference,
        Field(
            description='Reference to the data entity (table, topic, etc.) this contract applies to.'
        ),
    ]
    testSuite: Annotated[
        Optional[entityReference.EntityReference],
        Field(
            None,
            description='Reference to the test suite that contains tests related to this data contract.',
        ),
    ]
    schema_: Annotated[
        Optional[List[table.Column]],
        Field(
            None, alias='schema', description='Schema definition for the data contract.'
        ),
    ]
    semantics: Annotated[
        Optional[List[basic.SemanticsRule]],
        Field(None, description='Semantics rules defined in the data contract.'),
    ]
    termsOfUse: Annotated[
        Optional[basic.Markdown],
        Field(
            None,
            description='Terms of use for the data contract for both human and AI agents consumption.',
        ),
    ]
    security: Annotated[
        Optional[ContractSecurity],
        Field(
            None,
            description='Security and access policy expectations defined in the data contract.',
            title='Contract Security',
        ),
    ]
    sla: Annotated[
        Optional[ContractSLA],
        Field(
            None,
            description='Service Level Agreement expectations defined in the data contract.',
            title='Contract SLA',
        ),
    ]
    qualityExpectations: Annotated[
        Optional[List[entityReference.EntityReference]],
        Field(None, description='Quality expectations defined in the data contract.'),
    ]
    contractUpdates: Annotated[
        Optional[List[ContractUpdate]],
        Field(None, description='History of updates to the data contract.'),
    ]
    owners: Annotated[
        Optional[entityReferenceList.EntityReferenceList],
        Field(None, description='Owners of this data contract.'),
    ]
    reviewers: Annotated[
        Optional[entityReferenceList.EntityReferenceList],
        Field(
            None, description='User references of the reviewers for this data contract.'
        ),
    ]
    effectiveFrom: Annotated[
        Optional[basic.DateTime],
        Field(None, description='Date from which this data contract is effective.'),
    ]
    effectiveUntil: Annotated[
        Optional[basic.DateTime],
        Field(None, description='Date until which this data contract is effective.'),
    ]
    changeDescription: Annotated[
        Optional[entityHistory.ChangeDescription],
        Field(None, description='Change that led to this version of the entity.'),
    ]
    incrementalChangeDescription: Annotated[
        Optional[entityHistory.ChangeDescription],
        Field(None, description='Incremental change description of the entity.'),
    ]
    deleted: Annotated[
        Optional[bool],
        Field(
            False, description='When `true` indicates the entity has been soft deleted.'
        ),
    ]
    sourceUrl: Annotated[
        Optional[basic.SourceUrl],
        Field(None, description='Source URL of the data contract.'),
    ]
    latestResult: Annotated[
        Optional[LatestResult],
        Field(None, description='Latest validation result for this data contract.'),
    ]
    extension: Annotated[
        Optional[basic.EntityExtension],
        Field(
            None,
            description='Entity extension data with custom attributes added to the entity.',
        ),
    ]
