"""Configuration file discovery and management for MCP clients."""

from __future__ import annotations

import json
import os
import shutil
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Any

import platformdirs


class MCPScope(Enum):
    """Enumeration of MCP configuration scopes."""
    GLOBAL = "global"      # User-level, applies everywhere
    PROJECT = "project"    # Project-level, applies to specific directory
    LOCAL = "local"        # Local/session-level


@dataclass
class MCPConfigPath:
    """Represents a configuration path with its scope."""
    path: Path
    scope: MCPScope
    description: str = ""


@dataclass
class MCPClient:
    """Represents an MCP client with its configuration paths."""

    name: str
    display_name: str
    config_paths: list[MCPConfigPath] = field(default_factory=list)
    workspace_config: str | None = None  # Relative path for workspace configs
    config_format: str = "json"  # "json" or "yaml"
    config_key: str = "mcpServers"  # Key for MCP servers in config

    def get_config_path(self, scope: MCPScope | None = None) -> MCPConfigPath | None:
        """Get the first existing config path, optionally filtered by scope."""
        paths = [p for p in self.config_paths if scope is None or p.scope == scope]
        for config_path in paths:
            if config_path.path.exists():
                return config_path
        return paths[0] if paths else None

    def get_all_paths(self, scope: MCPScope | None = None) -> list[MCPConfigPath]:
        """Get all config paths, optionally filtered by scope."""
        if scope is None:
            return self.config_paths
        return [p for p in self.config_paths if p.scope == scope]

    def exists(self) -> bool:
        """Check if any config file exists."""
        return any(p.path.exists() for p in self.config_paths)


def get_claude_desktop_config_paths() -> list[Path]:
    """Get Claude Desktop configuration paths for the current OS."""
    paths = []

    if os.name == "nt":  # Windows
        appdata = os.environ.get("APPDATA", "")
        if appdata:
            paths.append(Path(appdata) / "Claude" / "claude_desktop_config.json")
    elif os.name == "posix":
        if "darwin" in os.uname().sysname.lower():  # macOS
            paths.append(
                Path.home()
                / "Library"
                / "Application Support"
                / "Claude"
                / "claude_desktop_config.json"
            )
        else:  # Linux
            paths.append(
                Path.home() / ".config" / "Claude" / "claude_desktop_config.json"
            )

    return paths


def get_claude_code_config_paths() -> list[MCPConfigPath]:
    """Get Claude Code (CLI) configuration paths for the current OS.
    
    Claude Code stores MCP servers in two locations:
    - Global: ~/.claude.json (mcpServers field) - applies to all projects
    - Project: .mcp.json (mcpServers field) - applies to current project
    """
    paths = []
    
    # Global scope: ~/.claude.json (stores mcpServers for all projects)
    paths.append(MCPConfigPath(
        path=Path.home() / ".claude.json",
        scope=MCPScope.GLOBAL,
        description="User-level config, applies everywhere"
    ))
    
    # Project scope: .mcp.json (project root - for team sharing)
    paths.append(MCPConfigPath(
        path=Path.cwd() / ".mcp.json",
        scope=MCPScope.PROJECT,
        description="Project-level config, checked into VCS"
    ))
    
    return paths


def get_vscode_config_paths() -> list[MCPConfigPath]:
    """Get VS Code MCP configuration paths for the current OS.
    
    VS Code supports both global and workspace-level configs:
    - Global: User settings
    - Project: Workspace settings (.vscode/mcp.json)
    """
    paths = []

    if os.name == "nt":  # Windows
        appdata = os.environ.get("APPDATA", "")
        if appdata:
            paths.append(MCPConfigPath(
                path=Path(appdata) / "Code" / "User" / "mcp.json",
                scope=MCPScope.GLOBAL,
                description="User-level settings"
            ))
            paths.append(MCPConfigPath(
                path=Path.cwd() / ".vscode" / "mcp.json",
                scope=MCPScope.PROJECT,
                description="Workspace-level settings"
            ))
    elif os.name == "posix":
        if "darwin" in os.uname().sysname.lower():  # macOS
            paths.append(MCPConfigPath(
                path=Path.home()
                / "Library"
                / "Application Support"
                / "Code"
                / "User"
                / "mcp.json",
                scope=MCPScope.GLOBAL,
                description="User-level settings"
            ))
            paths.append(MCPConfigPath(
                path=Path.cwd() / ".vscode" / "mcp.json",
                scope=MCPScope.PROJECT,
                description="Workspace-level settings"
            ))
        else:  # Linux
            paths.append(MCPConfigPath(
                path=Path.home() / ".config" / "Code" / "User" / "mcp.json",
                scope=MCPScope.GLOBAL,
                description="User-level settings"
            ))
            paths.append(MCPConfigPath(
                path=Path.cwd() / ".vscode" / "mcp.json",
                scope=MCPScope.PROJECT,
                description="Workspace-level settings"
            ))

    return paths


def get_cursor_config_paths() -> list[Path]:
    """Get Cursor MCP configuration paths for the current OS.
    
    Cursor inherits VS Code's settings structure. While no explicit MCP config documentation exists,
    Cursor settings are accessible via Ctrl/Cmd+Shift+J. MCP configuration likely follows VS Code patterns.
    """
    paths = []

    if os.name == "nt":  # Windows
        appdata = os.environ.get("APPDATA", "")
        if appdata:
            # Cursor settings directory (similar to VS Code)
            paths.append(Path(appdata) / "Cursor" / "User" / "settings.json")
            # Fallback to mcp.json if it exists
            paths.append(Path(appdata) / "Cursor" / "User" / "mcp.json")
    elif os.name == "posix":
        if "darwin" in os.uname().sysname.lower():  # macOS
            paths.append(
                Path.home()
                / "Library"
                / "Application Support"
                / "Cursor"
                / "User"
                / "settings.json"
            )
            paths.append(
                Path.home()
                / "Library"
                / "Application Support"
                / "Cursor"
                / "User"
                / "mcp.json"
            )
        else:  # Linux
            paths.append(Path.home() / ".config" / "Cursor" / "User" / "settings.json")
            paths.append(Path.home() / ".config" / "Cursor" / "User" / "mcp.json")

    return paths


def get_windsurf_config_paths() -> list[Path]:
    """Get Windsurf MCP configuration paths for the current OS.
    
    Windsurf is built on Codeium and uses ~/.codeium/mcp_config.json for MCP server configuration.
    This file stores mcpServers object with command/args for local servers and serverUrl for remote HTTP servers.
    """
    paths = []
    
    # Windsurf uses ~/.codeium/mcp_config.json (same as Codeium)
    # Cross-platform: same path on Windows, macOS, and Linux
    paths.append(Path.home() / ".codeium" / "mcp_config.json")

    return paths


def get_goose_config_paths() -> list[Path]:
    """Get Goose (Block) configuration paths for the current OS."""
    paths = []
    
    # Goose uses ~/.config/goose/config.yaml
    if os.name == "nt":  # Windows
        appdata = os.environ.get("APPDATA", "")
        if appdata:
            paths.append(Path(appdata) / "goose" / "config.yaml")
    else:
        paths.append(Path.home() / ".config" / "goose" / "config.yaml")
    
    return paths


def get_cline_config_paths() -> list[Path]:
    """Get Cline (VS Code extension) configuration paths."""
    paths = []
    
    # Cline stores config in VS Code's globalStorage
    if os.name == "nt":  # Windows
        appdata = os.environ.get("APPDATA", "")
        if appdata:
            paths.append(Path(appdata) / "Code" / "User" / "globalStorage" / "saoudrizwan.claude-dev" / "cline_mcp_settings.json")
    elif os.name == "posix":
        if "darwin" in os.uname().sysname.lower():  # macOS
            paths.append(
                Path.home()
                / "Library"
                / "Application Support"
                / "Code"
                / "User"
                / "globalStorage"
                / "saoudrizwan.claude-dev"
                / "cline_mcp_settings.json"
            )
        else:  # Linux
            paths.append(
                Path.home()
                / ".config"
                / "Code"
                / "User"
                / "globalStorage"
                / "saoudrizwan.claude-dev"
                / "cline_mcp_settings.json"
            )
    
    return paths


def get_roo_code_config_paths() -> list[Path]:
    """Get Roo Code (VS Code extension) configuration paths."""
    paths = []
    
    if os.name == "nt":  # Windows
        appdata = os.environ.get("APPDATA", "")
        if appdata:
            paths.append(Path(appdata) / "Code" / "User" / "globalStorage" / "rooveterinaryinc.roo-cline" / "mcp_settings.json")
    elif os.name == "posix":
        if "darwin" in os.uname().sysname.lower():  # macOS
            paths.append(
                Path.home()
                / "Library"
                / "Application Support"
                / "Code"
                / "User"
                / "globalStorage"
                / "rooveterinaryinc.roo-cline"
                / "mcp_settings.json"
            )
        else:  # Linux
            paths.append(
                Path.home()
                / ".config"
                / "Code"
                / "User"
                / "globalStorage"
                / "rooveterinaryinc.roo-cline"
                / "mcp_settings.json"
            )
    
    return paths


def get_continue_config_paths() -> list[Path]:
    """Get Continue configuration paths."""
    paths = []
    
    # Continue uses ~/.continue/config.yaml or .continue/mcpServers/
    paths.append(Path.home() / ".continue" / "config.yaml")
    
    return paths


def get_zed_config_paths() -> list[Path]:
    """Get Zed editor configuration paths.
    
    Zed stores MCP server configuration in settings.json under the context_servers field.
    The configuration supports both local servers (via command) and remote servers (via URL).
    """
    paths = []
    
    if os.name == "nt":  # Windows
        appdata = os.environ.get("APPDATA", "")
        if appdata:
            # Windows: %AppData%\Zed\settings.json
            paths.append(Path(appdata) / "Zed" / "settings.json")
    else:  # macOS and Linux
        # macOS & Linux: ~/.config/zed/settings.json
        paths.append(Path.home() / ".config" / "zed" / "settings.json")
    
    return paths


def get_lm_studio_config_paths() -> list[Path]:
    """Get LM Studio configuration paths."""
    paths = []
    
    if os.name == "nt":  # Windows
        appdata = os.environ.get("APPDATA", "")
        if appdata:
            paths.append(Path(appdata) / "LM Studio" / "mcp.json")
    elif os.name == "posix":
        if "darwin" in os.uname().sysname.lower():  # macOS
            paths.append(Path.home() / ".lmstudio" / "mcp.json")
        else:  # Linux
            paths.append(Path.home() / ".lmstudio" / "mcp.json")
    
    return paths


def get_amazon_q_config_paths() -> list[Path]:
    """Get Amazon Q CLI configuration paths."""
    paths = []
    
    # Amazon Q uses ~/.aws/amazonq/mcp.json
    paths.append(Path.home() / ".aws" / "amazonq" / "mcp.json")
    
    return paths


def get_gemini_cli_config_paths() -> list[MCPConfigPath]:
    """Get Gemini CLI configuration paths.
    
    Gemini CLI stores MCP servers in two locations:
    - Global: ~/.gemini/settings.json (mcpServers field) - applies to all projects
    - Project: .gemini/settings.json (mcpServers field) - applies to current project
    """
    paths = []
    
    # Global scope: ~/.gemini/settings.json
    paths.append(MCPConfigPath(
        path=Path.home() / ".gemini" / "settings.json",
        scope=MCPScope.GLOBAL,
        description="User-level config, applies everywhere"
    ))
    
    # Project scope: .gemini/settings.json
    paths.append(MCPConfigPath(
        path=Path.cwd() / ".gemini" / "settings.json",
        scope=MCPScope.PROJECT,
        description="Project-level config, checked into VCS"
    ))
    
    return paths


def get_codex_config_paths() -> list[Path]:
    """Get OpenAI Codex CLI configuration paths."""
    paths = []
    
    # Codex uses ~/.codex/config.json
    paths.append(Path.home() / ".codex" / "config.json")
    
    return paths


def get_amp_config_paths() -> list[Path]:
    """Get Amp (Sourcegraph) configuration paths."""
    paths = []
    
    # Amp uses VS Code mcp.json format
    if os.name == "nt":  # Windows
        appdata = os.environ.get("APPDATA", "")
        if appdata:
            paths.append(Path(appdata) / "Code" / "User" / "mcp.json")
    elif os.name == "posix":
        if "darwin" in os.uname().sysname.lower():  # macOS
            paths.append(
                Path.home()
                / "Library"
                / "Application Support"
                / "Code"
                / "User"
                / "mcp.json"
            )
        else:  # Linux
            paths.append(Path.home() / ".config" / "Code" / "User" / "mcp.json")
    
    return paths


def get_opencode_config_paths() -> list[Path]:
    """Get OpenCode CLI configuration paths."""
    paths = []
    
    # OpenCode uses ~/.opencode/config.json
    paths.append(Path.home() / ".opencode" / "config.json")
    
    return paths


def get_warp_config_paths() -> list[Path]:
    """Get Warp terminal configuration paths."""
    paths = []
    
    if os.name == "posix":
        if "darwin" in os.uname().sysname.lower():  # macOS
            paths.append(
                Path.home()
                / "Library"
                / "Application Support"
                / "dev.warp.Warp-Stable"
                / "mcp_servers.json"
            )
    
    return paths


def get_jetbrains_config_paths() -> list[Path]:
    """Get JetBrains (AI Assistant/Junie) configuration paths."""
    paths = []
    
    # JetBrains uses ~/.junie/mcp.json or project-level .junie/mcp/
    paths.append(Path.home() / ".junie" / "mcp.json")
    
    return paths


def get_antigravity_config_paths() -> list[Path]:
    """Get Google Antigravity configuration paths.
    
    Google Antigravity stores MCP config in ~/.gemini/antigravity/mcp_config.json.
    This is accessed via MCP Store > Manage MCP Servers > View raw config in the app.
    """
    paths = []
    
    # Antigravity uses ~/.gemini/antigravity/mcp_config.json (cross-platform)
    paths.append(Path.home() / ".gemini" / "antigravity" / "mcp_config.json")
    
    return paths


def get_supported_clients() -> list[MCPClient]:
    """Get all supported MCP clients with their configuration paths."""
    return [
        # Desktop Apps
        MCPClient(
            name="claude_desktop",
            display_name="Claude Desktop",
            config_paths=get_claude_desktop_config_paths(),
        ),
        MCPClient(
            name="cursor",
            display_name="Cursor",
            config_paths=get_cursor_config_paths(),
            workspace_config=".cursor/mcp.json",
        ),
        MCPClient(
            name="windsurf",
            display_name="Windsurf (Codeium)",
            config_paths=get_windsurf_config_paths(),
            workspace_config=".windsurf/mcp.json",
        ),
        MCPClient(
            name="vscode",
            display_name="VS Code (GitHub Copilot)",
            config_paths=get_vscode_config_paths(),
            workspace_config=".vscode/mcp.json",
        ),
        MCPClient(
            name="lm_studio",
            display_name="LM Studio",
            config_paths=get_lm_studio_config_paths(),
        ),
        MCPClient(
            name="zed",
            display_name="Zed Editor",
            config_paths=get_zed_config_paths(),
            config_key="mcp",  # Zed uses "mcp" key in settings.json
        ),
        MCPClient(
            name="warp",
            display_name="Warp Terminal",
            config_paths=get_warp_config_paths(),
        ),
        # CLI Tools
        MCPClient(
            name="claude_code",
            display_name="Claude Code (CLI)",
            config_paths=get_claude_code_config_paths(),
        ),
        MCPClient(
            name="goose",
            display_name="Goose (Block)",
            config_paths=get_goose_config_paths(),
            config_format="yaml",
            config_key="extensions",  # Goose uses "extensions" in YAML
        ),
        MCPClient(
            name="gemini_cli",
            display_name="Gemini CLI (Google)",
            config_paths=get_gemini_cli_config_paths(),
        ),
        MCPClient(
            name="amazon_q",
            display_name="Amazon Q CLI",
            config_paths=get_amazon_q_config_paths(),
        ),
        MCPClient(
            name="codex",
            display_name="Codex CLI (OpenAI)",
            config_paths=get_codex_config_paths(),
        ),
        MCPClient(
            name="opencode",
            display_name="OpenCode CLI",
            config_paths=get_opencode_config_paths(),
        ),
        # VS Code Extensions
        MCPClient(
            name="cline",
            display_name="Cline (VS Code)",
            config_paths=get_cline_config_paths(),
        ),
        MCPClient(
            name="roo_code",
            display_name="Roo Code (VS Code)",
            config_paths=get_roo_code_config_paths(),
        ),
        MCPClient(
            name="continue",
            display_name="Continue",
            config_paths=get_continue_config_paths(),
            config_format="yaml",
            workspace_config=".continue/mcpServers/",
        ),
        MCPClient(
            name="amp",
            display_name="Amp (Sourcegraph)",
            config_paths=get_amp_config_paths(),
        ),
        # JetBrains
        MCPClient(
            name="jetbrains",
            display_name="JetBrains (Junie/AI Assistant)",
            config_paths=get_jetbrains_config_paths(),
            workspace_config=".junie/mcp/",
        ),
        # Google
        MCPClient(
            name="antigravity",
            display_name="Google Antigravity",
            config_paths=get_antigravity_config_paths(),
        ),
        # Custom
        MCPClient(
            name="custom",
            display_name="Custom Location",
            config_paths=[],
        ),
    ]


def detect_installed_clients() -> list[MCPClient]:
    """Detect which MCP clients are installed (have config directories)."""
    installed = []
    for client in get_supported_clients():
        if client.name == "custom":
            installed.append(client)  # Always include custom option
        elif client.config_paths:
            # Check if parent directory exists (client is installed)
            for path in client.config_paths:
                if path.parent.exists():
                    installed.append(client)
                    break
    return installed


def read_config(path: Path) -> dict[str, Any]:
    """Read and parse an MCP configuration file."""
    if not path.exists():
        return {"mcpServers": {}}

    try:
        with open(path, "r", encoding="utf-8") as f:
            content = f.read().strip()
            if not content:
                return {"mcpServers": {}}
            
            # Handle YAML files (for Goose, Continue)
            if path.suffix in [".yaml", ".yml"]:
                try:
                    import yaml
                    data = yaml.safe_load(content) or {}
                except ImportError:
                    # Fallback: treat as JSON if yaml not installed
                    data = json.loads(content)
            else:
                data = json.loads(content)
            
            # Ensure mcpServers key exists
            if "mcpServers" not in data:
                data["mcpServers"] = {}
            return data
    except (json.JSONDecodeError, Exception):
        return {"mcpServers": {}}


def write_config(path: Path, config: dict[str, Any], backup: bool = True) -> None:
    """Write an MCP configuration file with optional backup."""
    # Create parent directories if needed
    path.parent.mkdir(parents=True, exist_ok=True)

    # Backup existing file
    if backup and path.exists():
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_path = path.with_suffix(f".{timestamp}.backup{path.suffix}")
        shutil.copy2(path, backup_path)

    # Write new config
    if path.suffix in [".yaml", ".yml"]:
        try:
            import yaml
            with open(path, "w", encoding="utf-8") as f:
                yaml.safe_dump(config, f, default_flow_style=False, sort_keys=False)
        except ImportError:
            # Fallback to JSON
            with open(path, "w", encoding="utf-8") as f:
                json.dump(config, f, indent=2, ensure_ascii=False)
    else:
        with open(path, "w", encoding="utf-8") as f:
            json.dump(config, f, indent=2, ensure_ascii=False)


def get_servers(config: dict[str, Any]) -> dict[str, Any]:
    """Get the MCP servers from a configuration."""
    return config.get("mcpServers", {})


def add_server(
    config: dict[str, Any], name: str, server_config: dict[str, Any]
) -> dict[str, Any]:
    """Add a server to the configuration."""
    if "mcpServers" not in config:
        config["mcpServers"] = {}
    config["mcpServers"][name] = server_config
    return config


def remove_server(config: dict[str, Any], name: str) -> dict[str, Any]:
    """Remove a server from the configuration."""
    if "mcpServers" in config and name in config["mcpServers"]:
        del config["mcpServers"][name]
    return config


def get_current_directory_config() -> Path:
    """Get a config path in the current working directory."""
    return Path.cwd() / "mcp_servers.json"
