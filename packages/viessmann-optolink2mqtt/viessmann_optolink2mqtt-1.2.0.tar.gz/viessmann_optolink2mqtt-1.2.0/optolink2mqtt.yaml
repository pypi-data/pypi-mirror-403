#
# Viessmann-optolink2mqtt configuration file
# All values shown here are the default values
#

logging:
  # logging.level: defines the logging level; it can be one of the following:
  #  - DEBUG
  #  - INFO
  #  - WARNING
  #  - ERROR
  #  - CRITICAL
  level: DEBUG

  # optolink2mqtt will report its own status (e.g. number of errors) every N seconds on its log output
  # and on the specific '<mqtt.publish_topic_prefix>/status' topic
  report_status_period_sec: 600

optolink:
  serial_port: '/dev/ttyUSB0'     # Serial port for Optolink device (mandatory, default: '/dev/ttyUSB0')
  show_received_bytes: False      # Useful for debugging purposes only
  reconnect_period_sec: 5         # Period (in seconds) to wait before reconnecting to Optolink device if connection is lost

mqtt:
  # broker: details about the MQTT broker
  broker:
    host: localhost
    port: 1883
    #username:
    #password:
  
  # client_id: the identifier of the MQTT client created by optolink2mqtt; this is useful to identify optolink2mqtt
  # when inspecting the MQTT broker logs
  clientid: optolink2mqtt
  
  # qos: it can be:
  #  - At most once (QoS 0)
  #  - At least once (QoS 1)
  #  - Exactly once (QoS 2)
  # see https://www.hivemq.com/blog/mqtt-essentials-part-6-mqtt-quality-of-service-levels/
  qos: 0
  
  # retain: if set to true, the message will be set as the "last known good"/retained message for 
  # each topic populated by optolink2mqtt
  retain: false

  # reconnect_period_sec: defines how frequently optolink2mqtt will re-attempt a connection to the MQTT broker
  # if the connection is lost. You should be setting this parameter to the smallest value that makes sense
  # according to your optolink2mqtt scheduling rules.
  reconnect_period_sec: 5

  # request: name of the topic that optolink2mqtt will subscribe to, and where it will wait for information requests;
  # FIXME: this feature is not yet implemented !! If you need it please open an issue on GitHub !!
  request_topic: "optolink2mqtt/request/"

  ha_discovery:
    # ha_discovery.enabled: if set to true, optolink2mqtt will publish a "homeassistant" MQTT discovery topic
    # for each task having the 'ha_discovery' configuration parameters set.
    # This will enable HomeAssistant to immediately recognize as sensors the information published by optolink2mqtt
    # (see https://www.home-assistant.io/integrations/sensor.mqtt/)
    enabled: true

    # ha_discovery.topic: defines the topic that optolink2mqtt will publish its "homeassistant" MQTT discovery topics;
    topic: homeassistant

    # ha_discovery.device_name: the name of the device grouping all sensors published to HomeAssistant;
    # it defaults to the <hostname> of the computer
    device_name: "Vitocal"  # or Vitodens, etc

# this is the core of config, defininig which registers should be read by optolink2mqtt, how frequently and
# how they should be published to MQTT
registers_poll_list:

  - name: external_temperature
    sampling_period_seconds: 10

    # each register of the Viessmann device has a few key attributes you need to know/discover:
    # the address, its length (in bytes), its scale factor, whether the number contained is signed or not,
    # and if the register is writable or read-only.
    register: 0x0101
    length: 2
    scale_factor: 0.1
    signed: false
    writable: false

    # the whole "ha_discovery" section is optional and is useful only if you have
    # mqtt.ha_discovery.enabled set to "true" and you use HomeAssistant.
    ha_discovery:
      name: "External Temperature"
      platform: sensor                   # this can be "sensor", "binary_sensor"
      device_class: temperature          # see https://www.home-assistant.io/integrations/sensor.mqtt/#device-class
      unit_of_measurement: "°C"          # for a list of supported measurement units check https://github.com/f18m/viessmann-optolink2mqtt/blob/main/src/optolink2mqtt/ha_units.py


  # another register example, showing a different measurement unit:

  - name: dhw_electric_energy_kwh
    sampling_period_seconds: 600
    register: 0x1670
    length: 4
    scale_factor: 0.1
    signed: false
    writable: false
    ha_discovery:
      name: "Domestic Hot Water Electric Energy kWh"
      platform: sensor
      device_class: energy
      unit_of_measurement: "kWh"

  
  # another register example, showing an enumerated value:

  - name: heating_circuit_1_mode
    sampling_period_seconds: 20
    register: 0xB000
    length: 1
    scale_factor: 1
    signed: false
    # IMPORTANT: when a register is flagged as "writable: true", optolink2mqtt will
    # subscribe to the specific MQTT topic '<mqtt.publish_topic_prefix>/<register.name>/set'
    # and will write to the Viessmann device any value that is received from that topic
    writable: true
    enum:
      0: "Off"
      1: "DHW only"
      2: "Heating/Cooling/DHW (time program)"
      4: "Permanently reduced"
      5: "Permanently normal"
      6: "Normal/Off (time program)"
      7: "Cooling only"
    ha_discovery:
      name: "Heating Circuit 1 Mode"
      platform: sensor
      device_class: enum
      entity_category: config
  
  # another register example, showing a writable target temperature:

  - name: dhw_temperature_set
    sampling_period_seconds: 600
    register: 0x6000
    length: 2
    scale_factor: 0.1
    writable: true
    ha_discovery:
      name: "Domestic Hot Water Set Temperature"
      platform: number
      device_class: temperature
      entity_category: config
      unit_of_measurement: "°C"
      min: 20
      max: 60
      step: 1
      mode: "box"
      optimistic: false


  # another register example, showing a binary_sensor of type "running":

  - name: heating_circuit_pump
    sampling_period_seconds: 20
    register: 0x0484
    length: 1
    scale_factor: 1
    signed: false
    writable: false
    ha_discovery:
      name: "Secondary Circuit Pump"
      platform: binary_sensor
      device_class: running
      payload_on: "1"
      payload_off: "0"


  # yet another example, showing the "byte_filter" feature:
  # this is useful because in some cases the Viessmann register is 3 bytes long,
  # but only 2 bytes are relevant for the actual value; in this case you can
  # use the "byte_filter" to specify which bytes should be considered when
  # extracting the value from the register raw data.

  - name: dhw_temperature_top
    sampling_period_seconds: 20
    register: 0x01CD
    length: 3
    scale_factor: 0.1
    byte_filter: "b:0:1"  # of the 3 bytes, consider only the first two bytes; then apply the scale factor
    signed: true
    writable: false
    ha_discovery:
      name: "Domestic Hot Water Top Temperature"
      platform: sensor
      device_class: temperature
      unit_of_measurement: "°C"


  # PLEASE NOTE THAT DISCOVERING THE CORRECT REGISTERS TO POLL IS
  # SOMETHING YOU NEED TO DO BY YOURSELF, AS IT DEPENDS ON THE
  # MODEL OF YOUR VIESSMANN DEVICE AND ITS CONFIGURATION.
  # Check the README of this project for some hints on that.
