# coding: utf-8

"""
    BioT Facade

    APIs document description for facade service

    The version of the OpenAPI document: 1.2.29
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import date
from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from biotmed_facade_sdk.models.address import Address
from biotmed_facade_sdk.models.mfa_dto import MfaDto
from biotmed_facade_sdk.models.name import Name
from biotmed_facade_sdk.models.reference_attribute_uuidid_request import ReferenceAttributeUUIDIdRequest

from typing import Optional, Set
from typing_extensions import Self

# BioT Code Start: extra/custom attributes support imports
from typing import Any, Dict, ClassVar, List
from pydantic import Field, model_validator
# BioT Code End

class PatientSelfSignUpFacadeRequest(BaseModel):
    """
    PatientSelfSignUpFacadeRequest

    Note: This model supports custom attributes. Recommended access:
      - Pass custom fields via dict unpacking: Model(..., **{"custom_field": "value"})
      - Read custom fields via model.get("custom_field") or model["custom_field"]
    """ # noqa: E501
    name: Name = Field(alias="_name")
    description: Optional[StrictStr] = Field(default=None, description="A description, can be up to 5000 characters long", alias="_description")
    email: StrictStr = Field(description="An email address in the RFC-5322 specification", alias="_email")
    phone: Optional[StrictStr] = Field(default=None, description="A person's phone An E.164 formatted phone number", alias="_phone")
    locale: Optional[StrictStr] = Field(default=None, description="A person's locale Locale in the following format: {language-ISO639}-{countryCode-ISO3166} lowercase.", alias="_locale")
    gender: Optional[StrictStr] = Field(default=None, description="A persons gender", alias="_gender")
    date_of_birth: Optional[date] = Field(default=None, description="A person's date of birth A UTC date in the ISO-8601 format", alias="_dateOfBirth")
    address: Optional[Address] = Field(default=None, alias="_address")
    mfa: Optional[MfaDto] = Field(default=None, alias="_mfa")
    credential_type: Optional[StrictStr] = Field(default=None, description="What type of credentials is used when logging in to the system. Default:PASSWORD", alias="_credentialType")
    additional_phone: Optional[StrictStr] = Field(default=None, description="An E.164 formatted phone number", alias="_additionalPhone")
    national_id: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=50)]] = Field(default=None, description="A person's national ID", alias="_nationalId")
    username: StrictStr = Field(description="User's username. Can be an email or a regular username. With this username you login to the system.", alias="_username")
    password: StrictStr = Field(description="A password", alias="_password")
    device_registration_code: Optional[StrictStr] = Field(default=None, description="The registration code entity that is attached to the device", alias="_deviceRegistrationCode")
    owner_organization: ReferenceAttributeUUIDIdRequest = Field(alias="_ownerOrganization")
    caregiver: Optional[ReferenceAttributeUUIDIdRequest] = Field(default=None, alias="_caregiver")
    # BioT Code Start: Store custom attributes in a dedicated dict (safe default)
    additional_properties: Dict[str, Any] = Field(default_factory=dict)
    # BioT Code End
    __properties: ClassVar[List[str]] = ["_name", "_description", "_email", "_phone", "_locale", "_gender", "_dateOfBirth", "_address", "_mfa", "_credentialType", "_additionalPhone", "_nationalId", "_username", "_password", "_deviceRegistrationCode", "_ownerOrganization", "_caregiver"]

    @field_validator('gender')
    def gender_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['MALE', 'FEMALE', 'UNDISCLOSED']):
            raise ValueError("must be one of enum values ('MALE', 'FEMALE', 'UNDISCLOSED')")
        return value

    @field_validator('credential_type')
    def credential_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['PASSWORD', 'OTP']):
            raise ValueError("must be one of enum values ('PASSWORD', 'OTP')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
        # BioT Code Start: Allow extra fields for custom attributes
        extra='allow',
        # BioT Code End
    )

    # BioT Code Start: Sync Pydantic v2 extras into additional_properties
    @model_validator(mode='after')
    def _sync_additional_properties(self):
        """
        Sync unknown fields from Pydantic v2 `model_extra` into additional_properties.

        - When `extra='allow'`, unknown fields are stored in `model_extra`.
        - We copy them into additional_properties for OpenAPI Generator compatibility.
        """
        if self.model_extra:
            self.additional_properties.update(self.model_extra)
        return self
    # BioT Code End

    # BioT Code Start: Make dot-access to custom attributes type-check as Any (pyright-friendly)
    def __getattr__(self, item: str) -> Any:
        """
        Fallback for dynamic/custom attributes.

        This makes `model.some_custom_attr` resolve to `Any` in static type checkers
        instead of raising `reportUnknownMemberType`.
        """
        if item in self.additional_properties:
            return self.additional_properties[item]
        # also check model_extra directly (in case sync didn't run yet)
        if self.model_extra and item in self.model_extra:
            return self.model_extra[item]
        raise AttributeError(f"'{self.__class__.__name__}' has no field or custom property '{item}'")
    # BioT Code End

    # BioT Code Start: Dict-style access for custom attributes (and fields)
    def __getitem__(self, key: str) -> Any:
        """
        Support dict-style access:
          - defined fields by python name (e.g. 'name')
          - defined fields by alias (e.g. '_name') via to_dict fallback
          - custom attributes stored in additional_properties
        """
        if key in self.additional_properties:
            return self.additional_properties[key]
        if self.model_extra and key in self.model_extra:
            return self.model_extra[key]

        # Try direct attribute (python field name)
        if hasattr(self, key):
            try:
                return getattr(self, key)
            except AttributeError:
                pass

        # Try alias / serialized keys through to_dict()
        d = self.to_dict()
        if key in d:
            return d[key]

        raise KeyError(f"'{self.__class__.__name__}' has no field or custom property '{key}'")

    def get(self, key: str, default: Any = None) -> Any:
        """dict.get() style safe access."""
        try:
            return self[key]
        except KeyError:
            return default
    # BioT Code End

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    # BioT Code Start: Override model_dump_json to flatten custom attributes to top level
    def model_dump_json(self, *, indent: Optional[int] = None, by_alias: bool = True, **kwargs: Any) -> str:
        """Return JSON representation with custom attributes flattened to top level."""
        json_kwargs = {k: v for k, v in kwargs.items()
                      if k not in ['by_alias', 'exclude', 'exclude_none', 'exclude_unset',
                                   'exclude_defaults', 'include', 'mode', 'round_trip',
                                   'warnings', 'serialize_as_any']}
        return json.dumps(self.to_dict(), indent=indent, default=str, **json_kwargs)
    # BioT Code End

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PatientSelfSignUpFacadeRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of name
        if self.name:
            _dict['_name'] = self.name.to_dict()
        # override the default output from pydantic by calling `to_dict()` of address
        if self.address:
            _dict['_address'] = self.address.to_dict()
        # override the default output from pydantic by calling `to_dict()` of mfa
        if self.mfa:
            _dict['_mfa'] = self.mfa.to_dict()
        # override the default output from pydantic by calling `to_dict()` of owner_organization
        if self.owner_organization:
            _dict['_ownerOrganization'] = self.owner_organization.to_dict()
        # override the default output from pydantic by calling `to_dict()` of caregiver
        if self.caregiver:
            _dict['_caregiver'] = self.caregiver.to_dict()
        # BioT Code Start: puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value
        # BioT Code End
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PatientSelfSignUpFacadeRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "_name": Name.from_dict(obj["_name"]) if obj.get("_name") is not None else None,
            "_description": obj.get("_description"),
            "_email": obj.get("_email"),
            "_phone": obj.get("_phone"),
            "_locale": obj.get("_locale"),
            "_gender": obj.get("_gender"),
            "_dateOfBirth": obj.get("_dateOfBirth"),
            "_address": Address.from_dict(obj["_address"]) if obj.get("_address") is not None else None,
            "_mfa": MfaDto.from_dict(obj["_mfa"]) if obj.get("_mfa") is not None else None,
            "_credentialType": obj.get("_credentialType"),
            "_additionalPhone": obj.get("_additionalPhone"),
            "_nationalId": obj.get("_nationalId"),
            "_username": obj.get("_username"),
            "_password": obj.get("_password"),
            "_deviceRegistrationCode": obj.get("_deviceRegistrationCode"),
            "_ownerOrganization": ReferenceAttributeUUIDIdRequest.from_dict(obj["_ownerOrganization"]) if obj.get("_ownerOrganization") is not None else None,
            "_caregiver": ReferenceAttributeUUIDIdRequest.from_dict(obj["_caregiver"]) if obj.get("_caregiver") is not None else None
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj


