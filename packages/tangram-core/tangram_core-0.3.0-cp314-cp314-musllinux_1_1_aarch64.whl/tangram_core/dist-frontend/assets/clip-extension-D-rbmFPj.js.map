{"version":3,"file":"clip-extension-D-rbmFPj.js","sources":["../../../../node_modules/.pnpm/@deck.gl+extensions@9.2.6_@deck.gl+core@9.2.6_@luma.gl+core@9.2.6_@luma.gl+engine@9.2.6_5c09a49e98f56e8f519d17f9a85d7b3a/node_modules/@deck.gl/extensions/dist/clip/clip-extension.js"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { LayerExtension } from '@deck.gl/core';\nconst defaultProps = {\n    clipBounds: [0, 0, 1, 1],\n    clipByInstance: undefined\n};\nconst shaderFunction = /* glsl */ `\nuniform clipUniforms {\n  vec4 bounds;\n} clip;\n\nbool clip_isInBounds(vec2 position) {\n  return position.x >= clip.bounds[0] && position.y >= clip.bounds[1] && position.x < clip.bounds[2] && position.y < clip.bounds[3];\n}\n`;\n/*\n * The vertex-shader version clips geometries by their anchor position\n * e.g. ScatterplotLayer - show if the center of a circle is within bounds\n */\nconst shaderModuleVs = {\n    name: 'clip',\n    vs: shaderFunction,\n    uniformTypes: {\n        bounds: 'vec4<f32>'\n    }\n};\nconst injectionVs = {\n    'vs:#decl': /* glsl */ `\nout float clip_isVisible;\n`,\n    'vs:DECKGL_FILTER_GL_POSITION': /* glsl */ `\n  clip_isVisible = float(clip_isInBounds(geometry.worldPosition.xy));\n`,\n    'fs:#decl': /* glsl */ `\nin float clip_isVisible;\n`,\n    'fs:DECKGL_FILTER_COLOR': /* glsl */ `\n  if (clip_isVisible < 0.5) discard;\n`\n};\n/*\n * The fragment-shader version clips pixels at the bounds\n * e.g. PolygonLayer - show the part of the polygon that intersect with the bounds\n */\nconst shaderModuleFs = {\n    name: 'clip',\n    fs: shaderFunction,\n    uniformTypes: {\n        bounds: 'vec4<f32>'\n    }\n};\nconst injectionFs = {\n    'vs:#decl': /* glsl */ `\nout vec2 clip_commonPosition;\n`,\n    'vs:DECKGL_FILTER_GL_POSITION': /* glsl */ `\n  clip_commonPosition = geometry.position.xy;\n`,\n    'fs:#decl': /* glsl */ `\nin vec2 clip_commonPosition;\n`,\n    'fs:DECKGL_FILTER_COLOR': /* glsl */ `\n  if (!clip_isInBounds(clip_commonPosition)) discard;\n`\n};\n/** Adds support for clipping rendered layers by rectangular bounds. */\nclass ClipExtension extends LayerExtension {\n    getShaders() {\n        // If `clipByInstance: true`, the entire object is shown/hidden based on its anchor position (done by vertex shader)\n        // Otherwise, the object is trimmed by the clip bounds (done by fragment shader)\n        // Default behavior: consider a layer instanced if it has attribute `instancePositions`\n        let clipByInstance = 'instancePositions' in this.getAttributeManager().attributes;\n        // Users can override by setting the `clipByInstance` prop\n        if (this.props.clipByInstance !== undefined) {\n            clipByInstance = Boolean(this.props.clipByInstance);\n        }\n        this.state.clipByInstance = clipByInstance;\n        return clipByInstance\n            ? {\n                modules: [shaderModuleVs],\n                inject: injectionVs\n            }\n            : {\n                modules: [shaderModuleFs],\n                inject: injectionFs\n            };\n    }\n    /* eslint-disable camelcase */\n    draw() {\n        const { clipBounds } = this.props;\n        const clipProps = {};\n        if (this.state.clipByInstance) {\n            clipProps.bounds = clipBounds;\n        }\n        else {\n            const corner0 = this.projectPosition([clipBounds[0], clipBounds[1], 0]);\n            const corner1 = this.projectPosition([clipBounds[2], clipBounds[3], 0]);\n            clipProps.bounds = [\n                Math.min(corner0[0], corner1[0]),\n                Math.min(corner0[1], corner1[1]),\n                Math.max(corner0[0], corner1[0]),\n                Math.max(corner0[1], corner1[1])\n            ];\n        }\n        this.setShaderModuleProps({ clip: clipProps });\n    }\n}\nClipExtension.defaultProps = defaultProps;\nClipExtension.extensionName = 'ClipExtension';\nexport default ClipExtension;\n//# sourceMappingURL=clip-extension.js.map"],"names":["defaultProps","shaderFunction","shaderModuleVs","injectionVs","shaderModuleFs","injectionFs","ClipExtension","LayerExtension","clipByInstance","clipBounds","clipProps","corner0","corner1"],"mappings":"kDAIA,MAAMA,EAAe,CACjB,WAAY,CAAC,EAAG,EAAG,EAAG,CAAC,EACvB,eAAgB,MACpB,EACMC,EAA4B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAa5BC,EAAiB,CACnB,KAAM,OACN,GAAID,EACJ,aAAc,CACV,OAAQ,WAChB,CACA,EACME,EAAc,CAChB,WAAuB;AAAA;AAAA,EAGvB,+BAA2C;AAAA;AAAA,EAG3C,WAAuB;AAAA;AAAA,EAGvB,yBAAqC;AAAA;AAAA,CAGzC,EAKMC,EAAiB,CACnB,KAAM,OACN,GAAIH,EACJ,aAAc,CACV,OAAQ,WAChB,CACA,EACMI,EAAc,CAChB,WAAuB;AAAA;AAAA,EAGvB,+BAA2C;AAAA;AAAA,EAG3C,WAAuB;AAAA;AAAA,EAGvB,yBAAqC;AAAA;AAAA,CAGzC,EAEA,MAAMC,UAAsBC,CAAe,CACvC,YAAa,CAIT,IAAIC,EAAiB,sBAAuB,KAAK,oBAAmB,EAAG,WAEvE,OAAI,KAAK,MAAM,iBAAmB,SAC9BA,EAAiB,EAAQ,KAAK,MAAM,gBAExC,KAAK,MAAM,eAAiBA,EACrBA,EACD,CACE,QAAS,CAACN,CAAc,EACxB,OAAQC,CACxB,EACc,CACE,QAAS,CAACC,CAAc,EACxB,OAAQC,CACxB,CACI,CAEA,MAAO,CACH,KAAM,CAAE,WAAAI,GAAe,KAAK,MACtBC,EAAY,CAAA,EAClB,GAAI,KAAK,MAAM,eACXA,EAAU,OAASD,MAElB,CACD,MAAME,EAAU,KAAK,gBAAgB,CAACF,EAAW,CAAC,EAAGA,EAAW,CAAC,EAAG,CAAC,CAAC,EAChEG,EAAU,KAAK,gBAAgB,CAACH,EAAW,CAAC,EAAGA,EAAW,CAAC,EAAG,CAAC,CAAC,EACtEC,EAAU,OAAS,CACf,KAAK,IAAIC,EAAQ,CAAC,EAAGC,EAAQ,CAAC,CAAC,EAC/B,KAAK,IAAID,EAAQ,CAAC,EAAGC,EAAQ,CAAC,CAAC,EAC/B,KAAK,IAAID,EAAQ,CAAC,EAAGC,EAAQ,CAAC,CAAC,EAC/B,KAAK,IAAID,EAAQ,CAAC,EAAGC,EAAQ,CAAC,CAAC,CAC/C,CACQ,CACA,KAAK,qBAAqB,CAAE,KAAMF,CAAS,CAAE,CACjD,CACJ,CACAJ,EAAc,aAAeN,EAC7BM,EAAc,cAAgB","x_google_ignoreList":[0]}