{"version":3,"file":"image-loader-hHJsndO6.js","sources":["../../../../node_modules/.pnpm/@loaders.gl+images@4.3.4_@loaders.gl+core@4.3.4/node_modules/@loaders.gl/images/dist/lib/utils/version.js","../../../../node_modules/.pnpm/@loaders.gl+images@4.3.4_@loaders.gl+core@4.3.4/node_modules/@loaders.gl/images/dist/lib/category-api/image-type.js","../../../../node_modules/.pnpm/@loaders.gl+images@4.3.4_@loaders.gl+core@4.3.4/node_modules/@loaders.gl/images/dist/lib/category-api/parsed-image-api.js","../../../../node_modules/.pnpm/@loaders.gl+images@4.3.4_@loaders.gl+core@4.3.4/node_modules/@loaders.gl/images/dist/lib/parsers/svg-utils.js","../../../../node_modules/.pnpm/@loaders.gl+images@4.3.4_@loaders.gl+core@4.3.4/node_modules/@loaders.gl/images/dist/lib/parsers/parse-to-image.js","../../../../node_modules/.pnpm/@loaders.gl+images@4.3.4_@loaders.gl+core@4.3.4/node_modules/@loaders.gl/images/dist/lib/parsers/parse-to-image-bitmap.js","../../../../node_modules/.pnpm/@loaders.gl+images@4.3.4_@loaders.gl+core@4.3.4/node_modules/@loaders.gl/images/dist/lib/category-api/parse-isobmff-binary.js","../../../../node_modules/.pnpm/@loaders.gl+images@4.3.4_@loaders.gl+core@4.3.4/node_modules/@loaders.gl/images/dist/lib/category-api/binary-image-api.js","../../../../node_modules/.pnpm/@loaders.gl+images@4.3.4_@loaders.gl+core@4.3.4/node_modules/@loaders.gl/images/dist/lib/parsers/parse-to-node-image.js","../../../../node_modules/.pnpm/@loaders.gl+images@4.3.4_@loaders.gl+core@4.3.4/node_modules/@loaders.gl/images/dist/lib/parsers/parse-image.js","../../../../node_modules/.pnpm/@loaders.gl+images@4.3.4_@loaders.gl+core@4.3.4/node_modules/@loaders.gl/images/dist/image-loader.js"],"sourcesContent":["// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nexport const VERSION = typeof \"4.3.3\" !== 'undefined' ? \"4.3.3\" : 'latest';\n","import { isBrowser } from '@loaders.gl/loader-utils';\n// @ts-ignore TS2339: Property does not exist on type\nconst parseImageNode = globalThis.loaders?.parseImageNode;\nconst IMAGE_SUPPORTED = typeof Image !== 'undefined'; // NOTE: \"false\" positives if jsdom is installed\nconst IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== 'undefined';\nconst NODE_IMAGE_SUPPORTED = Boolean(parseImageNode);\nconst DATA_SUPPORTED = isBrowser ? true : NODE_IMAGE_SUPPORTED;\n/**\n * Checks if a loaders.gl image type is supported\n * @param type image type string\n */\nexport function isImageTypeSupported(type) {\n    switch (type) {\n        case 'auto':\n            // Should only ever be false in Node.js, if polyfills have not been installed...\n            return IMAGE_BITMAP_SUPPORTED || IMAGE_SUPPORTED || DATA_SUPPORTED;\n        case 'imagebitmap':\n            return IMAGE_BITMAP_SUPPORTED;\n        case 'image':\n            return IMAGE_SUPPORTED;\n        case 'data':\n            return DATA_SUPPORTED;\n        default:\n            throw new Error(`@loaders.gl/images: image ${type} not supported in this environment`);\n    }\n}\n/**\n * Returns the \"most performant\" supported image type on this platform\n * @returns image type string\n */\nexport function getDefaultImageType() {\n    if (IMAGE_BITMAP_SUPPORTED) {\n        return 'imagebitmap';\n    }\n    if (IMAGE_SUPPORTED) {\n        return 'image';\n    }\n    if (DATA_SUPPORTED) {\n        return 'data';\n    }\n    // This should only happen in Node.js\n    throw new Error('Install \\'@loaders.gl/polyfills\\' to parse images under Node.js');\n}\n","export function isImage(image) {\n    return Boolean(getImageTypeOrNull(image));\n}\nexport function deleteImage(image) {\n    switch (getImageType(image)) {\n        case 'imagebitmap':\n            image.close();\n            break;\n        default:\n        // Nothing to do for images and image data objects\n    }\n}\nexport function getImageType(image) {\n    const format = getImageTypeOrNull(image);\n    if (!format) {\n        throw new Error('Not an image');\n    }\n    return format;\n}\nexport function getImageSize(image) {\n    return getImageData(image);\n}\nexport function getImageData(image) {\n    switch (getImageType(image)) {\n        case 'data':\n            return image;\n        case 'image':\n        case 'imagebitmap':\n            // Extract the image data from the image via a canvas\n            const canvas = document.createElement('canvas');\n            // TODO - reuse the canvas?\n            const context = canvas.getContext('2d');\n            if (!context) {\n                throw new Error('getImageData');\n            }\n            // @ts-ignore\n            canvas.width = image.width;\n            // @ts-ignore\n            canvas.height = image.height;\n            // @ts-ignore\n            context.drawImage(image, 0, 0);\n            // @ts-ignore\n            return context.getImageData(0, 0, image.width, image.height);\n        default:\n            throw new Error('getImageData');\n    }\n}\n// PRIVATE\n// eslint-disable-next-line complexity\nfunction getImageTypeOrNull(image) {\n    if (typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n        return 'imagebitmap';\n    }\n    if (typeof Image !== 'undefined' && image instanceof Image) {\n        return 'image';\n    }\n    if (image && typeof image === 'object' && image.data && image.width && image.height) {\n        return 'data';\n    }\n    return null;\n}\n","// SVG parsing has limitations, e.g:\n// https://bugs.chromium.org/p/chromium/issues/detail?id=606319\nconst SVG_DATA_URL_PATTERN = /^data:image\\/svg\\+xml/;\nconst SVG_URL_PATTERN = /\\.svg((\\?|#).*)?$/;\nexport function isSVG(url) {\n    return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));\n}\nexport function getBlobOrSVGDataUrl(arrayBuffer, url) {\n    if (isSVG(url)) {\n        // Prepare a properly tagged data URL, and load using normal mechanism\n        const textDecoder = new TextDecoder();\n        let xmlText = textDecoder.decode(arrayBuffer);\n        // TODO Escape in browser to support e.g. Chinese characters\n        try {\n            if (typeof unescape === 'function' && typeof encodeURIComponent === 'function') {\n                xmlText = unescape(encodeURIComponent(xmlText));\n            }\n        }\n        catch (error) {\n            throw new Error(error.message);\n        }\n        // base64 encoding is safer. utf-8 fails in some browsers\n        const src = `data:image/svg+xml;base64,${btoa(xmlText)}`;\n        return src;\n    }\n    return getBlob(arrayBuffer, url);\n}\nexport function getBlob(arrayBuffer, url) {\n    if (isSVG(url)) {\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=606319\n        // return new Blob([new Uint8Array(arrayBuffer)], {type: 'image/svg+xml'});\n        throw new Error('SVG cannot be parsed directly to imagebitmap');\n    }\n    // TODO - how to determine mime type? Param? Sniff here?\n    return new Blob([new Uint8Array(arrayBuffer)]); // MIME type not needed?\n}\n","import { getBlobOrSVGDataUrl } from \"./svg-utils.js\";\n// Parses html image from array buffer\nexport async function parseToImage(arrayBuffer, options, url) {\n    // Note: image parsing requires conversion to Blob (for createObjectURL).\n    // Potentially inefficient for not using `response.blob()` (and for File / Blob inputs)...\n    // But presumably not worth adding 'blob' flag to loader objects?\n    const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer, url);\n    const URL = self.URL || self.webkitURL;\n    const objectUrl = typeof blobOrDataUrl !== 'string' && URL.createObjectURL(blobOrDataUrl);\n    try {\n        return await loadToImage(objectUrl || blobOrDataUrl, options);\n    }\n    finally {\n        if (objectUrl) {\n            URL.revokeObjectURL(objectUrl);\n        }\n    }\n}\nexport async function loadToImage(url, options) {\n    const image = new Image();\n    image.src = url;\n    // The `image.onload()` callback does not guarantee that the image has been decoded\n    // so a main thread \"freeze\" can be incurred when using the image for the first time.\n    // `Image.decode()` returns a promise that completes when image is decoded.\n    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/decode\n    // Note: When calling `img.decode()`, we do not need to wait for `img.onload()`\n    // Note: `HTMLImageElement.decode()` is not available in Edge and IE11\n    if (options.image && options.image.decode && image.decode) {\n        await image.decode();\n        return image;\n    }\n    // Create a promise that tracks onload/onerror callbacks\n    return await new Promise((resolve, reject) => {\n        try {\n            image.onload = () => resolve(image);\n            image.onerror = (error) => {\n                const message = error instanceof Error ? error.message : 'error';\n                reject(new Error(message));\n            };\n        }\n        catch (error) {\n            reject(error);\n        }\n    });\n}\n","import { isSVG, getBlob } from \"./svg-utils.js\";\nimport { parseToImage } from \"./parse-to-image.js\";\nconst EMPTY_OBJECT = {};\nlet imagebitmapOptionsSupported = true;\n/**\n * Asynchronously parses an array buffer into an ImageBitmap - this contains the decoded data\n * ImageBitmaps are supported on worker threads, but not supported on Edge, IE11 and Safari\n * https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap#Browser_compatibility\n *\n * TODO - createImageBitmap supports source rect (5 param overload), pass through?\n */\nexport async function parseToImageBitmap(arrayBuffer, options, url) {\n    let blob;\n    // Cannot parse SVG directly to ImageBitmap, parse to Image first\n    if (isSVG(url)) {\n        // Note: this only works on main thread\n        const image = await parseToImage(arrayBuffer, options, url);\n        blob = image;\n    }\n    else {\n        // Create blob from the array buffer\n        blob = getBlob(arrayBuffer, url);\n    }\n    const imagebitmapOptions = options && options.imagebitmap;\n    return await safeCreateImageBitmap(blob, imagebitmapOptions);\n}\n/**\n * Safely creates an imageBitmap with options\n * *\n * Firefox crashes if imagebitmapOptions is supplied\n * Avoid supplying if not provided or supported, remember if not supported\n */\nasync function safeCreateImageBitmap(blob, imagebitmapOptions = null) {\n    if (isEmptyObject(imagebitmapOptions) || !imagebitmapOptionsSupported) {\n        imagebitmapOptions = null;\n    }\n    if (imagebitmapOptions) {\n        try {\n            // @ts-ignore Options\n            return await createImageBitmap(blob, imagebitmapOptions);\n        }\n        catch (error) {\n            console.warn(error); // eslint-disable-line\n            imagebitmapOptionsSupported = false;\n        }\n    }\n    return await createImageBitmap(blob);\n}\nfunction isEmptyObject(object) {\n    // @ts-ignore\n    for (const key in object || EMPTY_OBJECT) {\n        return false;\n    }\n    return true;\n}\n","// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// code adapted from https://github.com/sindresorhus/file-type under MIT license\n/**\n * Tests if a buffer is in ISO base media file format (ISOBMFF) @see https://en.wikipedia.org/wiki/ISO_base_media_file_format\n * (ISOBMFF is a media container standard based on the Apple QuickTime container format)\n */\nexport function getISOBMFFMediaType(buffer) {\n    // Almost all ISO base media files start with `ftyp` box. (It's not required to be first, but it's recommended to be.)\n    if (!checkString(buffer, 'ftyp', 4)) {\n        return null;\n    }\n    // Extra check: test for 8859-1 printable characters (for simplicity, it's a mask which also catches one non-printable character).\n    if ((buffer[8] & 0x60) === 0x00) {\n        return null;\n    }\n    // `ftyp` box must contain a brand major identifier, which must consist of ISO 8859-1 printable characters.\n    return decodeMajorBrand(buffer);\n}\n/**\n * brands explained @see https://github.com/strukturag/libheif/issues/83\n * code adapted from @see https://github.com/sindresorhus/file-type/blob/main/core.js#L489-L492\n */\nexport function decodeMajorBrand(buffer) {\n    const brandMajor = getUTF8String(buffer, 8, 12).replace('\\0', ' ').trim();\n    switch (brandMajor) {\n        case 'avif':\n        case 'avis':\n            return { extension: 'avif', mimeType: 'image/avif' };\n        default:\n            return null;\n    }\n    // We don't need these now, but they are easy to add\n    // case 'mif1':\n    //   return {extension: 'heic', mimeType: 'image/heif'};\n    // case 'msf1':\n    //   return {extension: 'heic', mimeType: 'image/heif-sequence'};\n    // case 'heic':\n    // case 'heix':\n    //   return {extension: 'heic', mimeType: 'image/heic'};\n    // case 'hevc':\n    // case 'hevx':\n    //   return {extension: 'heic', mimeType: 'image/heic-sequence'};\n    // case 'qt':\n    //   return {ext: 'mov', mime: 'video/quicktime'};\n    // case 'M4V':\n    // case 'M4VH':\n    // case 'M4VP':\n    //   return {ext: 'm4v', mime: 'video/x-m4v'};\n    // case 'M4P':\n    //   return {ext: 'm4p', mime: 'video/mp4'};\n    // case 'M4B':\n    //   return {ext: 'm4b', mime: 'audio/mp4'};\n    // case 'M4A':\n    //   return {ext: 'm4a', mime: 'audio/x-m4a'};\n    // case 'F4V':\n    //   return {ext: 'f4v', mime: 'video/mp4'};\n    // case 'F4P':\n    //   return {ext: 'f4p', mime: 'video/mp4'};\n    // case 'F4A':\n    //   return {ext: 'f4a', mime: 'audio/mp4'};\n    // case 'F4B':\n    //   return {ext: 'f4b', mime: 'audio/mp4'};\n    // case 'crx':\n    //   return {ext: 'cr3', mime: 'image/x-canon-cr3'};\n    // default:\n    // if (brandMajor.startsWith('3g')) {\n    //   if (brandMajor.startsWith('3g2')) {\n    //     return {ext: '3g2', mime: 'video/3gpp2'};\n    //   }\n    //   return {ext: '3gp', mime: 'video/3gpp'};\n    // }\n    // return {ext: 'mp4', mime: 'video/mp4'};\n}\n/** Interpret a chunk of bytes as a UTF8 string */\nfunction getUTF8String(array, start, end) {\n    return String.fromCharCode(...array.slice(start, end));\n}\nfunction stringToBytes(string) {\n    return [...string].map((character) => character.charCodeAt(0));\n}\nfunction checkString(buffer, header, offset = 0) {\n    const headerBytes = stringToBytes(header);\n    for (let i = 0; i < headerBytes.length; ++i) {\n        if (headerBytes[i] !== buffer[i + offset]) {\n            return false;\n        }\n    }\n    return true;\n}\n","// Attributions\n// * Based on binary-gltf-utils under MIT license: Copyright (c) 2016-17 Karl Cheng\nimport { getISOBMFFMediaType } from \"./parse-isobmff-binary.js\";\nconst BIG_ENDIAN = false;\nconst LITTLE_ENDIAN = true;\n/**\n * Extracts `{mimeType, width and height}` from a memory buffer containing a known image format\n * Currently supports `image/png`, `image/jpeg`, `image/bmp` and `image/gif`.\n * @param binaryData: DataView | ArrayBuffer image file memory to parse\n * @returns metadata or null if memory is not a valid image file format layout.\n */\nexport function getBinaryImageMetadata(binaryData) {\n    const dataView = toDataView(binaryData);\n    return (getPngMetadata(dataView) ||\n        getJpegMetadata(dataView) ||\n        getGifMetadata(dataView) ||\n        getBmpMetadata(dataView) ||\n        getISOBMFFMetadata(dataView));\n}\n// ISOBMFF\nfunction getISOBMFFMetadata(binaryData) {\n    const buffer = new Uint8Array(binaryData instanceof DataView ? binaryData.buffer : binaryData);\n    const mediaType = getISOBMFFMediaType(buffer);\n    if (!mediaType) {\n        return null;\n    }\n    return {\n        mimeType: mediaType.mimeType,\n        // TODO - decode width and height\n        width: 0,\n        height: 0\n    };\n}\n// PNG\nfunction getPngMetadata(binaryData) {\n    const dataView = toDataView(binaryData);\n    // Check file contains the first 4 bytes of the PNG signature.\n    const isPng = dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 0x89504e47;\n    if (!isPng) {\n        return null;\n    }\n    // Extract size from a binary PNG file\n    return {\n        mimeType: 'image/png',\n        width: dataView.getUint32(16, BIG_ENDIAN),\n        height: dataView.getUint32(20, BIG_ENDIAN)\n    };\n}\n// GIF\n// Extract size from a binary GIF file\n// TODO: GIF is not this simple\nfunction getGifMetadata(binaryData) {\n    const dataView = toDataView(binaryData);\n    // Check first 4 bytes of the GIF signature (\"GIF8\").\n    const isGif = dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 0x47494638;\n    if (!isGif) {\n        return null;\n    }\n    // GIF is little endian.\n    return {\n        mimeType: 'image/gif',\n        width: dataView.getUint16(6, LITTLE_ENDIAN),\n        height: dataView.getUint16(8, LITTLE_ENDIAN)\n    };\n}\n// BMP\n// TODO: BMP is not this simple\nexport function getBmpMetadata(binaryData) {\n    const dataView = toDataView(binaryData);\n    // Check magic number is valid (first 2 characters should be \"BM\").\n    // The mandatory bitmap file header is 14 bytes long.\n    const isBmp = dataView.byteLength >= 14 &&\n        dataView.getUint16(0, BIG_ENDIAN) === 0x424d &&\n        dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength;\n    if (!isBmp) {\n        return null;\n    }\n    // BMP is little endian.\n    return {\n        mimeType: 'image/bmp',\n        width: dataView.getUint32(18, LITTLE_ENDIAN),\n        height: dataView.getUint32(22, LITTLE_ENDIAN)\n    };\n}\n// JPEG\n// Extract width and height from a binary JPEG file\nfunction getJpegMetadata(binaryData) {\n    const dataView = toDataView(binaryData);\n    // Check file contains the JPEG \"start of image\" (SOI) marker\n    // followed by another marker.\n    const isJpeg = dataView.byteLength >= 3 &&\n        dataView.getUint16(0, BIG_ENDIAN) === 0xffd8 &&\n        dataView.getUint8(2) === 0xff;\n    if (!isJpeg) {\n        return null;\n    }\n    const { tableMarkers, sofMarkers } = getJpegMarkers();\n    // Exclude the two byte SOI marker.\n    let i = 2;\n    while (i + 9 < dataView.byteLength) {\n        const marker = dataView.getUint16(i, BIG_ENDIAN);\n        // The frame that contains the width and height of the JPEG image.\n        if (sofMarkers.has(marker)) {\n            return {\n                mimeType: 'image/jpeg',\n                height: dataView.getUint16(i + 5, BIG_ENDIAN), // Number of lines\n                width: dataView.getUint16(i + 7, BIG_ENDIAN) // Number of pixels per line\n            };\n        }\n        // Miscellaneous tables/data preceding the frame header.\n        if (!tableMarkers.has(marker)) {\n            return null;\n        }\n        // Length includes size of length parameter but not the two byte header.\n        i += 2;\n        i += dataView.getUint16(i, BIG_ENDIAN);\n    }\n    return null;\n}\nfunction getJpegMarkers() {\n    // Tables/misc header markers.\n    // DQT, DHT, DAC, DRI, COM, APP_n\n    const tableMarkers = new Set([0xffdb, 0xffc4, 0xffcc, 0xffdd, 0xfffe]);\n    for (let i = 0xffe0; i < 0xfff0; ++i) {\n        tableMarkers.add(i);\n    }\n    // SOF markers and DHP marker.\n    // These markers are after tables/misc data.\n    const sofMarkers = new Set([\n        0xffc0, 0xffc1, 0xffc2, 0xffc3, 0xffc5, 0xffc6, 0xffc7, 0xffc9, 0xffca, 0xffcb, 0xffcd, 0xffce,\n        0xffcf, 0xffde\n    ]);\n    return { tableMarkers, sofMarkers };\n}\n// TODO - move into image module?\nfunction toDataView(data) {\n    if (data instanceof DataView) {\n        return data;\n    }\n    if (ArrayBuffer.isView(data)) {\n        return new DataView(data.buffer);\n    }\n    // TODO: make these functions work for Node.js buffers?\n    // if (bufferToArrayBuffer) {\n    //   data = bufferToArrayBuffer(data);\n    // }\n    // Careful - Node Buffers will look like ArrayBuffers (keep after isBuffer)\n    if (data instanceof ArrayBuffer) {\n        return new DataView(data);\n    }\n    throw new Error('toDataView');\n}\n","import { assert } from '@loaders.gl/loader-utils';\nimport { getBinaryImageMetadata } from \"../category-api/binary-image-api.js\";\n// Use polyfills if installed to parsed image using get-pixels\nexport async function parseToNodeImage(arrayBuffer, options) {\n    const { mimeType } = getBinaryImageMetadata(arrayBuffer) || {};\n    // @ts-ignore\n    const parseImageNode = globalThis.loaders?.parseImageNode;\n    assert(parseImageNode); // '@loaders.gl/polyfills not installed'\n    // @ts-expect-error TODO should we throw error in this case?\n    return await parseImageNode(arrayBuffer, mimeType);\n}\n","import { assert } from '@loaders.gl/loader-utils';\nimport { isImageTypeSupported, getDefaultImageType } from \"../category-api/image-type.js\";\nimport { getImageData } from \"../category-api/parsed-image-api.js\";\nimport { parseToImage } from \"./parse-to-image.js\";\nimport { parseToImageBitmap } from \"./parse-to-image-bitmap.js\";\nimport { parseToNodeImage } from \"./parse-to-node-image.js\";\n// Parse to platform defined image type (data on node, ImageBitmap or HTMLImage on browser)\n// eslint-disable-next-line complexity\nexport async function parseImage(arrayBuffer, options, context) {\n    options = options || {};\n    const imageOptions = options.image || {};\n    // The user can request a specific output format via `options.image.type`\n    const imageType = imageOptions.type || 'auto';\n    const { url } = context || {};\n    // Note: For options.image.type === `data`, we may still need to load as `image` or `imagebitmap`\n    const loadType = getLoadableImageType(imageType);\n    let image;\n    switch (loadType) {\n        case 'imagebitmap':\n            image = await parseToImageBitmap(arrayBuffer, options, url);\n            break;\n        case 'image':\n            image = await parseToImage(arrayBuffer, options, url);\n            break;\n        case 'data':\n            // Node.js loads imagedata directly\n            image = await parseToNodeImage(arrayBuffer, options);\n            break;\n        default:\n            assert(false);\n    }\n    // Browser: if options.image.type === 'data', we can now extract data from the loaded image\n    if (imageType === 'data') {\n        image = getImageData(image);\n    }\n    return image;\n}\n// Get a loadable image type from image type\nfunction getLoadableImageType(type) {\n    switch (type) {\n        case 'auto':\n        case 'data':\n            // Browser: For image data we need still need to load using an image format\n            // Node: the default image type is `data`.\n            return getDefaultImageType();\n        default:\n            // Throw an error if not supported\n            isImageTypeSupported(type);\n            return type;\n    }\n}\n","// import type { ImageType } from '@loaders.gl/schema';\nimport { VERSION } from \"./lib/utils/version.js\";\nimport { parseImage } from \"./lib/parsers/parse-image.js\";\nimport { getBinaryImageMetadata } from \"./lib/category-api/binary-image-api.js\";\nconst EXTENSIONS = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'ico', 'svg', 'avif'];\nconst MIME_TYPES = [\n    'image/png',\n    'image/jpeg',\n    'image/gif',\n    'image/webp',\n    'image/avif',\n    'image/bmp',\n    'image/vnd.microsoft.icon',\n    'image/svg+xml'\n];\nconst DEFAULT_IMAGE_LOADER_OPTIONS = {\n    image: {\n        type: 'auto',\n        decode: true // if format is HTML\n    }\n    // imagebitmap: {} - passes (platform dependent) parameters to ImageBitmap constructor\n};\n/**\n * Loads a platform-specific image type\n * Note: This type can be used as input data to WebGL texture creation\n */\nexport const ImageLoader = {\n    dataType: null,\n    batchType: null,\n    id: 'image',\n    module: 'images',\n    name: 'Images',\n    version: VERSION,\n    mimeTypes: MIME_TYPES,\n    extensions: EXTENSIONS,\n    parse: parseImage,\n    // TODO: byteOffset, byteLength;\n    tests: [(arrayBuffer) => Boolean(getBinaryImageMetadata(new DataView(arrayBuffer)))],\n    options: DEFAULT_IMAGE_LOADER_OPTIONS\n};\n"],"names":["VERSION","parseImageNode","IMAGE_SUPPORTED","IMAGE_BITMAP_SUPPORTED","NODE_IMAGE_SUPPORTED","DATA_SUPPORTED","isBrowser","isImageTypeSupported","type","getDefaultImageType","getImageType","image","format","getImageTypeOrNull","getImageData","canvas","context","SVG_DATA_URL_PATTERN","SVG_URL_PATTERN","isSVG","url","getBlobOrSVGDataUrl","arrayBuffer","xmlText","error","getBlob","parseToImage","options","blobOrDataUrl","URL","objectUrl","loadToImage","resolve","reject","message","EMPTY_OBJECT","imagebitmapOptionsSupported","parseToImageBitmap","blob","imagebitmapOptions","safeCreateImageBitmap","isEmptyObject","object","key","getISOBMFFMediaType","buffer","checkString","decodeMajorBrand","getUTF8String","array","start","end","stringToBytes","string","character","header","offset","headerBytes","BIG_ENDIAN","LITTLE_ENDIAN","getBinaryImageMetadata","binaryData","dataView","toDataView","getPngMetadata","getJpegMetadata","getGifMetadata","getBmpMetadata","getISOBMFFMetadata","mediaType","tableMarkers","sofMarkers","getJpegMarkers","i","marker","data","parseToNodeImage","mimeType","assert","parseImage","imageType","loadType","getLoadableImageType","EXTENSIONS","MIME_TYPES","DEFAULT_IMAGE_LOADER_OPTIONS","ImageLoader"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10]}