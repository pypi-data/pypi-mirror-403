{"version":3,"file":"pick-layers-pass-C-3k0wbN.js","sources":["../../../../node_modules/.pnpm/@deck.gl+core@9.2.6/node_modules/@deck.gl/core/dist/passes/pass.js","../../../../node_modules/.pnpm/@deck.gl+core@9.2.6/node_modules/@deck.gl/core/dist/passes/layers-pass.js","../../../../node_modules/.pnpm/@deck.gl+core@9.2.6/node_modules/@deck.gl/core/dist/passes/pick-layers-pass.js"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/**\n * Base class for passes\n * @todo v9 - should the luma.gl RenderPass be owned by this class?\n * Currently owned by subclasses\n */\nexport default class Pass {\n    /** Create a new Pass instance */\n    constructor(device, props = { id: 'pass' }) {\n        const { id } = props;\n        this.id = id; // id of this pass\n        this.device = device;\n        this.props = { ...props };\n    }\n    setProps(props) {\n        Object.assign(this.props, props);\n    }\n    render(params) { } // eslint-disable-line @typescript-eslint/no-empty-function\n    cleanup() { } // eslint-disable-line @typescript-eslint/no-empty-function\n}\n//# sourceMappingURL=pass.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport Pass from \"./pass.js\";\n/** A Pass that renders all layers */\nexport default class LayersPass extends Pass {\n    constructor() {\n        super(...arguments);\n        this._lastRenderIndex = -1;\n    }\n    render(options) {\n        // @ts-expect-error TODO - assuming WebGL context\n        const [width, height] = this.device.canvasContext.getDrawingBufferSize();\n        // Explicitly specify clearColor and clearDepth, overriding render pass defaults.\n        const clearCanvas = options.clearCanvas ?? true;\n        const clearColor = options.clearColor ?? (clearCanvas ? [0, 0, 0, 0] : false);\n        const clearDepth = clearCanvas ? 1 : false;\n        const clearStencil = clearCanvas ? 0 : false;\n        const colorMask = options.colorMask ?? 0xf;\n        const parameters = { viewport: [0, 0, width, height] };\n        if (options.colorMask) {\n            parameters.colorMask = colorMask;\n        }\n        if (options.scissorRect) {\n            parameters.scissorRect = options.scissorRect;\n        }\n        const renderPass = this.device.beginRenderPass({\n            framebuffer: options.target,\n            parameters,\n            clearColor: clearColor,\n            clearDepth,\n            clearStencil\n        });\n        try {\n            return this._drawLayers(renderPass, options);\n        }\n        finally {\n            renderPass.end();\n            // TODO(ibgreen): WebGPU - submit may not be needed here but initial port had issues with out of render loop rendering\n            this.device.submit();\n        }\n    }\n    /** Draw a list of layers in a list of viewports */\n    _drawLayers(renderPass, options) {\n        const { target, shaderModuleProps, viewports, views, onViewportActive, clearStack = true } = options;\n        options.pass = options.pass || 'unknown';\n        if (clearStack) {\n            this._lastRenderIndex = -1;\n        }\n        const renderStats = [];\n        for (const viewport of viewports) {\n            const view = views && views[viewport.id];\n            // Update context to point to this viewport\n            onViewportActive?.(viewport);\n            const drawLayerParams = this._getDrawLayerParams(viewport, options);\n            // render this viewport\n            const subViewports = viewport.subViewports || [viewport];\n            for (const subViewport of subViewports) {\n                const stats = this._drawLayersInViewport(renderPass, {\n                    target,\n                    shaderModuleProps,\n                    viewport: subViewport,\n                    view,\n                    pass: options.pass,\n                    layers: options.layers\n                }, drawLayerParams);\n                renderStats.push(stats);\n            }\n        }\n        return renderStats;\n    }\n    // When a viewport contains multiple subviewports (e.g. repeated web mercator map),\n    // this is only done once for the parent viewport\n    /* Resolve the parameters needed to draw each layer */\n    _getDrawLayerParams(viewport, { layers, pass, isPicking = false, layerFilter, cullRect, effects, shaderModuleProps }, \n    /** Internal flag, true if only used to determine whether each layer should be drawn */\n    evaluateShouldDrawOnly = false) {\n        const drawLayerParams = [];\n        const indexResolver = layerIndexResolver(this._lastRenderIndex + 1);\n        const drawContext = {\n            layer: layers[0],\n            viewport,\n            isPicking,\n            renderPass: pass,\n            cullRect\n        };\n        const layerFilterCache = {};\n        for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {\n            const layer = layers[layerIndex];\n            // Check if we should draw layer\n            const shouldDrawLayer = this._shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache);\n            const layerParam = { shouldDrawLayer };\n            if (shouldDrawLayer && !evaluateShouldDrawOnly) {\n                layerParam.shouldDrawLayer = true;\n                // This is the \"logical\" index for ordering this layer in the stack\n                // used to calculate polygon offsets\n                // It can be the same as another layer\n                layerParam.layerRenderIndex = indexResolver(layer, shouldDrawLayer);\n                layerParam.shaderModuleProps = this._getShaderModuleProps(layer, effects, pass, shaderModuleProps);\n                layerParam.layerParameters = {\n                    ...layer.context.deck?.props.parameters,\n                    ...this.getLayerParameters(layer, layerIndex, viewport)\n                };\n            }\n            drawLayerParams[layerIndex] = layerParam;\n        }\n        return drawLayerParams;\n    }\n    // Draws a list of layers in one viewport\n    // TODO - when picking we could completely skip rendering viewports that dont\n    // intersect with the picking rect\n    /* eslint-disable max-depth, max-statements, complexity */\n    _drawLayersInViewport(renderPass, { layers, shaderModuleProps: globalModuleParameters, pass, target, viewport, view }, drawLayerParams) {\n        const glViewport = getGLViewport(this.device, {\n            shaderModuleProps: globalModuleParameters,\n            target,\n            viewport\n        });\n        if (view) {\n            const { clear, clearColor, clearDepth, clearStencil } = view.props;\n            if (clear) {\n                // If clear option is set, clear all buffers by default.\n                let colorToUse = [0, 0, 0, 0];\n                let depthToUse = 1.0;\n                let stencilToUse = 0;\n                if (Array.isArray(clearColor)) {\n                    colorToUse = [...clearColor.slice(0, 3), clearColor[3] || 255].map(c => c / 255);\n                }\n                else if (clearColor === false) {\n                    colorToUse = false;\n                }\n                if (clearDepth !== undefined) {\n                    depthToUse = clearDepth;\n                }\n                if (clearStencil !== undefined) {\n                    stencilToUse = clearStencil;\n                }\n                const clearRenderPass = this.device.beginRenderPass({\n                    framebuffer: target,\n                    parameters: {\n                        viewport: glViewport,\n                        scissorRect: glViewport\n                    },\n                    clearColor: colorToUse,\n                    clearDepth: depthToUse,\n                    clearStencil: stencilToUse\n                });\n                clearRenderPass.end();\n            }\n        }\n        // render layers in normal colors\n        const renderStatus = {\n            totalCount: layers.length,\n            visibleCount: 0,\n            compositeCount: 0,\n            pickableCount: 0\n        };\n        renderPass.setParameters({ viewport: glViewport });\n        // render layers in normal colors\n        for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {\n            const layer = layers[layerIndex];\n            const drawLayerParameters = drawLayerParams[layerIndex];\n            const { shouldDrawLayer } = drawLayerParameters;\n            // Calculate stats\n            if (shouldDrawLayer && layer.props.pickable) {\n                renderStatus.pickableCount++;\n            }\n            if (layer.isComposite) {\n                renderStatus.compositeCount++;\n            }\n            if (layer.isDrawable && drawLayerParameters.shouldDrawLayer) {\n                const { layerRenderIndex, shaderModuleProps, layerParameters } = drawLayerParameters;\n                // Draw the layer\n                renderStatus.visibleCount++;\n                this._lastRenderIndex = Math.max(this._lastRenderIndex, layerRenderIndex);\n                // overwrite layer.context.viewport with the sub viewport\n                if (shaderModuleProps.project) {\n                    shaderModuleProps.project.viewport = viewport;\n                }\n                // TODO v9 - we are sending renderPass both as a parameter and through the context.\n                // Long-term, it is likely better not to have user defined layer methods have to access\n                // the \"global\" layer context.\n                layer.context.renderPass = renderPass;\n                try {\n                    layer._drawLayer({\n                        renderPass,\n                        shaderModuleProps,\n                        uniforms: { layerIndex: layerRenderIndex },\n                        parameters: layerParameters\n                    });\n                }\n                catch (err) {\n                    layer.raiseError(err, `drawing ${layer} to ${pass}`);\n                }\n            }\n        }\n        return renderStatus;\n    }\n    /* eslint-enable max-depth, max-statements */\n    /* Methods for subclass overrides */\n    shouldDrawLayer(layer) {\n        return true;\n    }\n    getShaderModuleProps(layer, effects, otherShaderModuleProps) {\n        return null;\n    }\n    getLayerParameters(layer, layerIndex, viewport) {\n        return layer.props.parameters;\n    }\n    /* Private */\n    _shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache) {\n        const shouldDrawLayer = layer.props.visible && this.shouldDrawLayer(layer);\n        if (!shouldDrawLayer) {\n            return false;\n        }\n        drawContext.layer = layer;\n        let parent = layer.parent;\n        while (parent) {\n            // @ts-ignore\n            if (!parent.props.visible || !parent.filterSubLayer(drawContext)) {\n                return false;\n            }\n            drawContext.layer = parent;\n            parent = parent.parent;\n        }\n        if (layerFilter) {\n            const rootLayerId = drawContext.layer.id;\n            if (!(rootLayerId in layerFilterCache)) {\n                layerFilterCache[rootLayerId] = layerFilter(drawContext);\n            }\n            if (!layerFilterCache[rootLayerId]) {\n                return false;\n            }\n        }\n        // If a layer is drawn, update its viewportChanged flag\n        layer.activateViewport(drawContext.viewport);\n        return true;\n    }\n    _getShaderModuleProps(layer, effects, pass, overrides) {\n        // @ts-expect-error TODO - assuming WebGL context\n        const devicePixelRatio = this.device.canvasContext.cssToDeviceRatio();\n        const layerProps = layer.internalState?.propsInTransition || layer.props;\n        const shaderModuleProps = {\n            layer: layerProps,\n            picking: {\n                isActive: false\n            },\n            project: {\n                viewport: layer.context.viewport,\n                devicePixelRatio,\n                modelMatrix: layerProps.modelMatrix,\n                coordinateSystem: layerProps.coordinateSystem,\n                coordinateOrigin: layerProps.coordinateOrigin,\n                autoWrapLongitude: layer.wrapLongitude\n            }\n        };\n        if (effects) {\n            for (const effect of effects) {\n                mergeModuleParameters(shaderModuleProps, effect.getShaderModuleProps?.(layer, shaderModuleProps));\n            }\n        }\n        return mergeModuleParameters(shaderModuleProps, this.getShaderModuleProps(layer, effects, shaderModuleProps), overrides);\n    }\n}\n// If the _index prop is defined, return a layer index that's relative to its parent\n// Otherwise return the index of the layer among all rendered layers\n// This is done recursively, i.e. if the user overrides a layer's default index,\n// all its descendants will be resolved relative to that index.\n// This implementation assumes that parent layers always appear before its children\n// which is true if the layer array comes from the LayerManager\nexport function layerIndexResolver(startIndex = 0, layerIndices = {}) {\n    const resolvers = {};\n    const resolveLayerIndex = (layer, isDrawn) => {\n        const indexOverride = layer.props._offset;\n        const layerId = layer.id;\n        const parentId = layer.parent && layer.parent.id;\n        let index;\n        if (parentId && !(parentId in layerIndices)) {\n            // Populate layerIndices with the parent layer's index\n            resolveLayerIndex(layer.parent, false);\n        }\n        if (parentId in resolvers) {\n            const resolver = (resolvers[parentId] =\n                resolvers[parentId] || layerIndexResolver(layerIndices[parentId], layerIndices));\n            index = resolver(layer, isDrawn);\n            resolvers[layerId] = resolver;\n        }\n        else if (Number.isFinite(indexOverride)) {\n            index = indexOverride + (layerIndices[parentId] || 0);\n            // Mark layer as needing its own resolver\n            // We don't actually create it until it's used for the first time\n            resolvers[layerId] = null;\n        }\n        else {\n            index = startIndex;\n        }\n        if (isDrawn && index >= startIndex) {\n            startIndex = index + 1;\n        }\n        layerIndices[layerId] = index;\n        return index;\n    };\n    return resolveLayerIndex;\n}\n// Convert viewport top-left CSS coordinates to bottom up WebGL coordinates\nfunction getGLViewport(device, { shaderModuleProps, target, viewport }) {\n    const pixelRatio = shaderModuleProps?.project?.devicePixelRatio ??\n        // @ts-expect-error TODO - assuming WebGL context\n        device.canvasContext.cssToDeviceRatio();\n    // Default framebuffer is used when writing to canvas\n    // @ts-expect-error TODO - assuming WebGL context\n    const [, drawingBufferHeight] = device.canvasContext.getDrawingBufferSize();\n    const height = target ? target.height : drawingBufferHeight;\n    // Convert viewport top-left CSS coordinates to bottom up WebGL coordinates\n    const dimensions = viewport;\n    return [\n        dimensions.x * pixelRatio,\n        height - (dimensions.y + dimensions.height) * pixelRatio,\n        dimensions.width * pixelRatio,\n        dimensions.height * pixelRatio\n    ];\n}\nfunction mergeModuleParameters(target, ...sources) {\n    for (const source of sources) {\n        if (source) {\n            for (const key in source) {\n                if (target[key]) {\n                    Object.assign(target[key], source[key]);\n                }\n                else {\n                    target[key] = source[key];\n                }\n            }\n        }\n    }\n    return target;\n}\n//# sourceMappingURL=layers-pass.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport LayersPass from \"./layers-pass.js\";\nimport log from \"../utils/log.js\";\nconst PICKING_BLENDING = {\n    blendColorOperation: 'add',\n    blendColorSrcFactor: 'one',\n    blendColorDstFactor: 'zero',\n    blendAlphaOperation: 'add',\n    blendAlphaSrcFactor: 'constant',\n    blendAlphaDstFactor: 'zero'\n};\nexport default class PickLayersPass extends LayersPass {\n    constructor() {\n        super(...arguments);\n        this._colorEncoderState = null;\n    }\n    render(props) {\n        if ('pickingFBO' in props) {\n            // When drawing into an off-screen buffer, use the alpha channel to encode layer index\n            return this._drawPickingBuffer(props);\n        }\n        // When drawing to screen (debug mode), do not use the alpha channel so that result is always visible\n        return super.render(props);\n    }\n    // Private\n    // Draws list of layers and viewports into the picking buffer\n    // Note: does not sample the buffer, that has to be done by the caller\n    _drawPickingBuffer({ layers, layerFilter, views, viewports, onViewportActive, pickingFBO, deviceRect: { x, y, width, height }, cullRect, effects, pass = 'picking', pickZ, shaderModuleProps }) {\n        this.pickZ = pickZ;\n        const colorEncoderState = this._resetColorEncoder(pickZ);\n        const scissorRect = [x, y, width, height];\n        // Make sure we clear scissor test and fbo bindings in case of exceptions\n        // We are only interested in one pixel, no need to render anything else\n        // Note that the callback here is called synchronously.\n        // Set blend mode for picking\n        // always overwrite existing pixel with [r,g,b,layerIndex]\n        const renderStatus = super.render({\n            target: pickingFBO,\n            layers,\n            layerFilter,\n            views,\n            viewports,\n            onViewportActive,\n            cullRect,\n            effects: effects?.filter(e => e.useInPicking),\n            pass,\n            isPicking: true,\n            shaderModuleProps,\n            clearColor: [0, 0, 0, 0],\n            colorMask: 0xf,\n            scissorRect\n        });\n        // Clear the temp field\n        this._colorEncoderState = null;\n        const decodePickingColor = colorEncoderState && decodeColor.bind(null, colorEncoderState);\n        return { decodePickingColor, stats: renderStatus };\n    }\n    shouldDrawLayer(layer) {\n        const { pickable, operation } = layer.props;\n        return ((pickable && operation.includes('draw')) ||\n            operation.includes('terrain') ||\n            operation.includes('mask'));\n    }\n    getShaderModuleProps(layer, effects, otherShaderModuleProps) {\n        return {\n            picking: {\n                isActive: 1,\n                isAttribute: this.pickZ\n            },\n            lighting: { enabled: false }\n        };\n    }\n    getLayerParameters(layer, layerIndex, viewport) {\n        // TODO use Parameters type\n        const pickParameters = {\n            ...layer.props.parameters\n        };\n        const { pickable, operation } = layer.props;\n        if (!this._colorEncoderState || operation.includes('terrain')) {\n            pickParameters.blend = false;\n        }\n        else if (pickable && operation.includes('draw')) {\n            Object.assign(pickParameters, PICKING_BLENDING);\n            pickParameters.blend = true;\n            // TODO: blendColor no longer part of luma.gl API\n            pickParameters.blendColor = encodeColor(this._colorEncoderState, layer, viewport);\n        }\n        return pickParameters;\n    }\n    _resetColorEncoder(pickZ) {\n        // Track encoded layer indices\n        this._colorEncoderState = pickZ\n            ? null\n            : {\n                byLayer: new Map(),\n                byAlpha: []\n            };\n        // Temporarily store it on the instance so that it can be accessed by this.getLayerParameters\n        return this._colorEncoderState;\n    }\n}\n// Assign an unique alpha value for each pickable layer and track the encoding in the cache object\n// Returns normalized blend color\nfunction encodeColor(encoded, layer, viewport) {\n    const { byLayer, byAlpha } = encoded;\n    let a;\n    // Encode layerIndex in the alpha channel\n    // TODO - combine small layers to better utilize the picking color space\n    let entry = byLayer.get(layer);\n    if (entry) {\n        entry.viewports.push(viewport);\n        a = entry.a;\n    }\n    else {\n        a = byLayer.size + 1;\n        if (a <= 255) {\n            entry = { a, layer, viewports: [viewport] };\n            byLayer.set(layer, entry);\n            byAlpha[a] = entry;\n        }\n        else {\n            log.warn('Too many pickable layers, only picking the first 255')();\n            a = 0;\n        }\n    }\n    return [0, 0, 0, a / 255];\n}\n// Given a picked color, retrieve the corresponding layer and viewports from cache\nfunction decodeColor(encoded, pickedColor) {\n    const entry = encoded.byAlpha[pickedColor[3]];\n    return (entry && {\n        pickedLayer: entry.layer,\n        pickedViewports: entry.viewports,\n        pickedObjectIndex: entry.layer.decodePickingColor(pickedColor)\n    });\n}\n//# sourceMappingURL=pick-layers-pass.js.map"],"names":["Pass","device","props","id","params","LayersPass","options","width","height","clearCanvas","clearColor","clearDepth","clearStencil","colorMask","parameters","renderPass","target","shaderModuleProps","viewports","views","onViewportActive","clearStack","renderStats","viewport","view","drawLayerParams","subViewports","subViewport","stats","layers","pass","isPicking","layerFilter","cullRect","effects","evaluateShouldDrawOnly","indexResolver","layerIndexResolver","drawContext","layerFilterCache","layerIndex","layer","shouldDrawLayer","layerParam","globalModuleParameters","glViewport","getGLViewport","clear","colorToUse","depthToUse","stencilToUse","c","renderStatus","drawLayerParameters","layerRenderIndex","layerParameters","err","otherShaderModuleProps","parent","rootLayerId","overrides","devicePixelRatio","layerProps","effect","mergeModuleParameters","startIndex","layerIndices","resolvers","resolveLayerIndex","isDrawn","indexOverride","layerId","parentId","index","resolver","pixelRatio","drawingBufferHeight","dimensions","sources","source","key","PICKING_BLENDING","PickLayersPass","pickingFBO","x","y","pickZ","colorEncoderState","scissorRect","e","decodeColor","pickable","operation","pickParameters","encodeColor","encoded","byLayer","byAlpha","a","entry","log","pickedColor"],"mappings":"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","x_google_ignoreList":[0,1,2]}