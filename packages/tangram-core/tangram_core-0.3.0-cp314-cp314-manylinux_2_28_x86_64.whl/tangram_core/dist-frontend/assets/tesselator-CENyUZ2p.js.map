{"version":3,"file":"tesselator-CENyUZ2p.js","sources":["../../../../node_modules/.pnpm/@luma.gl+shadertools@9.2.6_@luma.gl+core@9.2.6/node_modules/@luma.gl/shadertools/dist/modules/lighting/gouraud-material/gouraud-material.js","../../../../node_modules/.pnpm/@deck.gl+core@9.2.6/node_modules/@deck.gl/core/dist/lib/composite-layer.js","../../../../node_modules/.pnpm/@deck.gl+core@9.2.6/node_modules/@deck.gl/core/dist/utils/tesselator.js"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { lighting } from \"../lights/lighting.js\";\nimport { PHONG_VS, PHONG_FS } from \"../phong-material/phong-shaders-glsl.js\";\nimport { PHONG_WGSL } from \"../phong-material/phong-shaders-wgsl.js\";\n/** In Gouraud shading, color is calculated for each triangle vertex normal, and then color is interpolated colors across the triangle */\nexport const gouraudMaterial = {\n    props: {},\n    name: 'gouraudMaterial',\n    // Note these are switched between phong and gouraud\n    vs: PHONG_FS.replace('phongMaterial', 'gouraudMaterial'),\n    fs: PHONG_VS.replace('phongMaterial', 'gouraudMaterial'),\n    source: PHONG_WGSL.replaceAll('phongMaterial', 'gouraudMaterial'),\n    defines: {\n        LIGHTING_VERTEX: true\n    },\n    dependencies: [lighting],\n    uniformTypes: {\n        ambient: 'f32',\n        diffuse: 'f32',\n        shininess: 'f32',\n        specularColor: 'vec3<f32>'\n    },\n    defaultUniforms: {\n        ambient: 0.35,\n        diffuse: 0.6,\n        shininess: 32,\n        specularColor: [0.15, 0.15, 0.15]\n    },\n    getUniforms(props) {\n        const uniforms = { ...props };\n        if (uniforms.specularColor) {\n            uniforms.specularColor = uniforms.specularColor.map(x => x / 255);\n        }\n        return { ...gouraudMaterial.defaultUniforms, ...uniforms };\n    }\n};\n//# sourceMappingURL=gouraud-material.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport Layer from \"./layer.js\";\nimport debug from \"../debug/index.js\";\nimport { flatten } from \"../utils/flatten.js\";\nimport { PROP_TYPES_SYMBOL } from \"../lifecycle/constants.js\";\nconst TRACE_RENDER_LAYERS = 'compositeLayer.renderLayers';\nclass CompositeLayer extends Layer {\n    /** `true` if this layer renders other layers */\n    get isComposite() {\n        return true;\n    }\n    /** `true` if the layer renders to screen */\n    get isDrawable() {\n        return false;\n    }\n    /** Returns true if all async resources are loaded */\n    get isLoaded() {\n        return super.isLoaded && this.getSubLayers().every(layer => layer.isLoaded);\n    }\n    /** Return last rendered sub layers */\n    getSubLayers() {\n        return (this.internalState && this.internalState.subLayers) || [];\n    }\n    // initializeState is usually not needed for composite layers\n    // Provide empty definition to disable check for missing definition\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    initializeState(context) { }\n    /** Updates selected state members and marks the composite layer to need rerender */\n    setState(updateObject) {\n        super.setState(updateObject);\n        // Trigger a layer update\n        // Although conceptually layer.draw and compositeLayer.renderLayers are equivalent,\n        // they are executed during different lifecycles.\n        // draw can be called without calling updateState (e.g. most viewport changes),\n        // while renderLayers can only be called during a recursive layer update.\n        this.setNeedsUpdate();\n    }\n    /** called to augment the info object that is bubbled up from a sublayer\n        override Layer.getPickingInfo() because decoding / setting uniform do\n        not apply to a composite layer. */\n    getPickingInfo({ info }) {\n        const { object } = info;\n        const isDataWrapped = object && object.__source && object.__source.parent && object.__source.parent.id === this.id;\n        if (!isDataWrapped) {\n            return info;\n        }\n        // override object with picked data\n        info.object = object.__source.object;\n        info.index = object.__source.index;\n        return info;\n    }\n    /**\n     * Filters sub layers at draw time. Return true if the sub layer should be drawn.\n     */\n    filterSubLayer(context) {\n        return true;\n    }\n    /** Returns true if sub layer needs to be rendered */\n    shouldRenderSubLayer(subLayerId, data) {\n        return data && data.length;\n    }\n    /** Returns sub layer class for a specific sublayer */\n    getSubLayerClass(subLayerId, DefaultLayerClass) {\n        const { _subLayerProps: overridingProps } = this.props;\n        return ((overridingProps &&\n            overridingProps[subLayerId] &&\n            overridingProps[subLayerId].type) ||\n            DefaultLayerClass);\n    }\n    /** When casting user data into another format to pass to sublayers,\n        add reference to the original object and object index */\n    getSubLayerRow(row, sourceObject, sourceObjectIndex) {\n        // @ts-ignore (TS2339) adding undefined property\n        row.__source = {\n            parent: this,\n            object: sourceObject,\n            index: sourceObjectIndex\n        };\n        return row;\n    }\n    /** Some composite layers cast user data into another format before passing to sublayers\n      We need to unwrap them before calling the accessor so that they see the original data\n      objects */\n    getSubLayerAccessor(accessor) {\n        if (typeof accessor === 'function') {\n            const objectInfo = {\n                index: -1,\n                // @ts-ignore accessing resolved data\n                data: this.props.data,\n                target: []\n            };\n            return (x, i) => {\n                if (x && x.__source) {\n                    objectInfo.index = x.__source.index;\n                    // @ts-ignore (TS2349) Out is never a function\n                    return accessor(x.__source.object, objectInfo);\n                }\n                // @ts-ignore (TS2349) Out is never a function\n                return accessor(x, i);\n            };\n        }\n        return accessor;\n    }\n    /** Returns sub layer props for a specific sublayer */\n    // eslint-disable-next-line complexity\n    getSubLayerProps(sublayerProps = {}) {\n        const { opacity, pickable, visible, parameters, getPolygonOffset, highlightedObjectIndex, autoHighlight, highlightColor, coordinateSystem, coordinateOrigin, wrapLongitude, positionFormat, modelMatrix, extensions, fetch, operation, _subLayerProps: overridingProps } = this.props;\n        const newProps = {\n            id: '',\n            updateTriggers: {},\n            opacity,\n            pickable,\n            visible,\n            parameters,\n            getPolygonOffset,\n            highlightedObjectIndex,\n            autoHighlight,\n            highlightColor,\n            coordinateSystem,\n            coordinateOrigin,\n            wrapLongitude,\n            positionFormat,\n            modelMatrix,\n            extensions,\n            fetch,\n            operation\n        };\n        const overridingSublayerProps = overridingProps && sublayerProps.id && overridingProps[sublayerProps.id];\n        const overridingSublayerTriggers = overridingSublayerProps && overridingSublayerProps.updateTriggers;\n        const sublayerId = sublayerProps.id || 'sublayer';\n        if (overridingSublayerProps) {\n            const propTypes = this.props[PROP_TYPES_SYMBOL];\n            const subLayerPropTypes = sublayerProps.type ? sublayerProps.type._propTypes : {};\n            for (const key in overridingSublayerProps) {\n                const propType = subLayerPropTypes[key] || propTypes[key];\n                // eslint-disable-next-line\n                if (propType && propType.type === 'accessor') {\n                    overridingSublayerProps[key] = this.getSubLayerAccessor(overridingSublayerProps[key]);\n                }\n            }\n        }\n        Object.assign(newProps, sublayerProps, \n        // experimental feature that allows users to override sublayer props via parent layer prop\n        overridingSublayerProps);\n        newProps.id = `${this.props.id}-${sublayerId}`;\n        newProps.updateTriggers = {\n            all: this.props.updateTriggers?.all,\n            ...sublayerProps.updateTriggers,\n            ...overridingSublayerTriggers\n        };\n        // Pass through extension props\n        // @ts-ignore (TS2532) extensions is always defined after merging with default props\n        for (const extension of extensions) {\n            const passThroughProps = extension.getSubLayerProps.call(this, extension);\n            if (passThroughProps) {\n                Object.assign(newProps, passThroughProps, {\n                    updateTriggers: Object.assign(newProps.updateTriggers, passThroughProps.updateTriggers)\n                });\n            }\n        }\n        return newProps;\n    }\n    /** Update sub layers to highlight the hovered object */\n    _updateAutoHighlight(info) {\n        for (const layer of this.getSubLayers()) {\n            layer.updateAutoHighlight(info);\n        }\n    }\n    /** Override base Layer method */\n    _getAttributeManager() {\n        return null;\n    }\n    /** (Internal) Called after an update to rerender sub layers */\n    _postUpdate(updateParams, forceUpdate) {\n        // @ts-ignore (TS2531) this method is only called internally when internalState is defined\n        let subLayers = this.internalState.subLayers;\n        const shouldUpdate = !subLayers || this.needsUpdate();\n        if (shouldUpdate) {\n            const subLayersList = this.renderLayers();\n            // Flatten the returned array, removing any null, undefined or false\n            // this allows layers to render sublayers conditionally\n            // (see CompositeLayer.renderLayers docs)\n            subLayers = flatten(subLayersList, Boolean);\n            // @ts-ignore (TS2531) this method is only called internally when internalState is defined\n            this.internalState.subLayers = subLayers;\n        }\n        debug(TRACE_RENDER_LAYERS, this, shouldUpdate, subLayers);\n        // populate reference to parent layer (this layer)\n        // NOTE: needs to be done even when reusing layers as the parent may have changed\n        for (const layer of subLayers) {\n            layer.parent = this;\n        }\n    }\n}\nCompositeLayer.layerName = 'CompositeLayer';\nexport default CompositeLayer;\n//# sourceMappingURL=composite-layer.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { createIterable, getAccessorFromBuffer } from \"./iterable-utils.js\";\nimport defaultTypedArrayManager from \"./typed-array-manager.js\";\nimport assert from \"./assert.js\";\nimport { Buffer } from '@luma.gl/core';\nexport default class Tesselator {\n    constructor(opts) {\n        this.indexStarts = [0];\n        this.vertexStarts = [0];\n        this.vertexCount = 0;\n        this.instanceCount = 0;\n        const { attributes = {} } = opts;\n        this.typedArrayManager = defaultTypedArrayManager;\n        this.attributes = {};\n        this._attributeDefs = attributes;\n        this.opts = opts;\n        this.updateGeometry(opts);\n    }\n    /* Public methods */\n    updateGeometry(opts) {\n        Object.assign(this.opts, opts);\n        const { data, buffers = {}, getGeometry, geometryBuffer, positionFormat, dataChanged, normalize = true } = this.opts;\n        this.data = data;\n        this.getGeometry = getGeometry;\n        this.positionSize =\n            // @ts-ignore (2339) when geometryBuffer is a luma Buffer, size falls back to positionFormat\n            (geometryBuffer && geometryBuffer.size) || (positionFormat === 'XY' ? 2 : 3);\n        this.buffers = buffers;\n        this.normalize = normalize;\n        // Handle external logical value\n        if (geometryBuffer) {\n            assert(data.startIndices); // binary data missing startIndices\n            this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);\n            if (!normalize) {\n                // skip packing and set attribute value directly\n                // TODO - avoid mutating user-provided object\n                buffers.vertexPositions = geometryBuffer;\n            }\n        }\n        this.geometryBuffer = buffers.vertexPositions;\n        if (Array.isArray(dataChanged)) {\n            // is partial update\n            for (const dataRange of dataChanged) {\n                this._rebuildGeometry(dataRange);\n            }\n        }\n        else {\n            this._rebuildGeometry();\n        }\n    }\n    updatePartialGeometry({ startRow, endRow }) {\n        this._rebuildGeometry({ startRow, endRow });\n    }\n    getGeometryFromBuffer(geometryBuffer) {\n        const value = geometryBuffer.value || geometryBuffer;\n        if (!ArrayBuffer.isView(value)) {\n            // Cannot read binary geometries\n            return null;\n        }\n        // @ts-ignore (2322) NumericArray not assignable to GeometryT\n        return getAccessorFromBuffer(value, {\n            size: this.positionSize,\n            offset: geometryBuffer.offset,\n            stride: geometryBuffer.stride,\n            startIndices: this.data.startIndices\n        });\n    }\n    /* Private utility methods */\n    _allocate(instanceCount, copy) {\n        // allocate attributes\n        const { attributes, buffers, _attributeDefs, typedArrayManager } = this;\n        for (const name in _attributeDefs) {\n            if (name in buffers) {\n                // Use external buffer\n                typedArrayManager.release(attributes[name]);\n                attributes[name] = null;\n            }\n            else {\n                const def = _attributeDefs[name];\n                // If dataRange is supplied, this is a partial update.\n                // In case we need to reallocate the typed array, it will need the old values copied\n                // before performing partial update.\n                def.copy = copy;\n                attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);\n            }\n        }\n    }\n    /**\n     * Visit all objects\n     * `data` is expected to be an iterable consistent with the base Layer expectation\n     */\n    _forEachGeometry(visitor, startRow, endRow) {\n        const { data, getGeometry } = this;\n        const { iterable, objectInfo } = createIterable(data, startRow, endRow);\n        for (const object of iterable) {\n            objectInfo.index++;\n            const geometry = getGeometry ? getGeometry(object, objectInfo) : null;\n            visitor(geometry, objectInfo.index);\n        }\n    }\n    /* eslint-disable complexity,max-statements */\n    _rebuildGeometry(dataRange) {\n        if (!this.data) {\n            return;\n        }\n        let { indexStarts, vertexStarts, instanceCount } = this;\n        const { data, geometryBuffer } = this;\n        const { startRow = 0, endRow = Infinity } = dataRange || {};\n        const normalizedData = {};\n        if (!dataRange) {\n            // Full update - regenerate buffer layout from scratch\n            indexStarts = [0];\n            vertexStarts = [0];\n        }\n        if (this.normalize || !geometryBuffer) {\n            this._forEachGeometry((geometry, dataIndex) => {\n                const normalizedGeometry = geometry && this.normalizeGeometry(geometry);\n                normalizedData[dataIndex] = normalizedGeometry;\n                vertexStarts[dataIndex + 1] =\n                    vertexStarts[dataIndex] +\n                        (normalizedGeometry ? this.getGeometrySize(normalizedGeometry) : 0);\n            }, startRow, endRow);\n            // count instances\n            instanceCount = vertexStarts[vertexStarts.length - 1];\n        }\n        else {\n            // assume user provided data is already normalized\n            vertexStarts = data.startIndices;\n            instanceCount = vertexStarts[data.length] || 0;\n            if (ArrayBuffer.isView(geometryBuffer)) {\n                instanceCount = instanceCount || geometryBuffer.length / this.positionSize;\n            }\n            else if (geometryBuffer instanceof Buffer) {\n                const byteStride = this.positionSize * 4;\n                instanceCount = instanceCount || geometryBuffer.byteLength / byteStride;\n            }\n            else if (geometryBuffer.buffer) {\n                const byteStride = geometryBuffer.stride || this.positionSize * 4;\n                instanceCount = instanceCount || geometryBuffer.buffer.byteLength / byteStride;\n            }\n            else if (geometryBuffer.value) {\n                const bufferValue = geometryBuffer.value;\n                const elementStride = \n                // @ts-ignore (2339) if stride is not specified, will fall through to positionSize\n                geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;\n                instanceCount = instanceCount || bufferValue.length / elementStride;\n            }\n        }\n        // allocate attributes\n        this._allocate(instanceCount, Boolean(dataRange));\n        this.indexStarts = indexStarts;\n        this.vertexStarts = vertexStarts;\n        this.instanceCount = instanceCount;\n        // @ts-ignore (2739) context will be populated in the loop\n        const context = {};\n        this._forEachGeometry((geometry, dataIndex) => {\n            const normalizedGeometry = normalizedData[dataIndex] || geometry;\n            context.vertexStart = vertexStarts[dataIndex];\n            context.indexStart = indexStarts[dataIndex];\n            const vertexEnd = dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;\n            context.geometrySize = vertexEnd - vertexStarts[dataIndex];\n            context.geometryIndex = dataIndex;\n            this.updateGeometryAttributes(normalizedGeometry, context);\n        }, startRow, endRow);\n        this.vertexCount = indexStarts[indexStarts.length - 1];\n    }\n}\n//# sourceMappingURL=tesselator.js.map"],"names":["gouraudMaterial","PHONG_FS","PHONG_VS","PHONG_WGSL","lighting","props","uniforms","x","TRACE_RENDER_LAYERS","CompositeLayer","Layer","layer","context","updateObject","info","object","subLayerId","data","DefaultLayerClass","overridingProps","row","sourceObject","sourceObjectIndex","accessor","objectInfo","i","sublayerProps","opacity","pickable","visible","parameters","getPolygonOffset","highlightedObjectIndex","autoHighlight","highlightColor","coordinateSystem","coordinateOrigin","wrapLongitude","positionFormat","modelMatrix","extensions","fetch","operation","newProps","overridingSublayerProps","overridingSublayerTriggers","sublayerId","propTypes","PROP_TYPES_SYMBOL","subLayerPropTypes","key","propType","extension","passThroughProps","updateParams","forceUpdate","subLayers","shouldUpdate","subLayersList","flatten","debug","Tesselator","opts","attributes","defaultTypedArrayManager","buffers","getGeometry","geometryBuffer","dataChanged","normalize","assert","dataRange","startRow","endRow","value","getAccessorFromBuffer","instanceCount","copy","_attributeDefs","typedArrayManager","name","def","visitor","iterable","createIterable","geometry","indexStarts","vertexStarts","normalizedData","dataIndex","normalizedGeometry","Buffer","byteStride","bufferValue","elementStride","vertexEnd"],"mappings":"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","x_google_ignoreList":[0,1,2]}