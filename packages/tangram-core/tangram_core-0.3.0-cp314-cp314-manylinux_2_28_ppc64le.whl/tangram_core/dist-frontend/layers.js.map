{"version":3,"file":"layers.js","sources":["../../../node_modules/.pnpm/@deck.gl+layers@9.2.6_@deck.gl+core@9.2.6_@loaders.gl+core@4.3.4_@luma.gl+core@9.2.6_@l_5aff0b42a0cad74c3df9dc79be75de3a/node_modules/@deck.gl/layers/dist/line-layer/line-layer-uniforms.js","../../../node_modules/.pnpm/@deck.gl+layers@9.2.6_@deck.gl+core@9.2.6_@loaders.gl+core@4.3.4_@luma.gl+core@9.2.6_@l_5aff0b42a0cad74c3df9dc79be75de3a/node_modules/@deck.gl/layers/dist/line-layer/line-layer.wgsl.js","../../../node_modules/.pnpm/@deck.gl+layers@9.2.6_@deck.gl+core@9.2.6_@loaders.gl+core@4.3.4_@luma.gl+core@9.2.6_@l_5aff0b42a0cad74c3df9dc79be75de3a/node_modules/@deck.gl/layers/dist/line-layer/line-layer-vertex.glsl.js","../../../node_modules/.pnpm/@deck.gl+layers@9.2.6_@deck.gl+core@9.2.6_@loaders.gl+core@4.3.4_@luma.gl+core@9.2.6_@l_5aff0b42a0cad74c3df9dc79be75de3a/node_modules/@deck.gl/layers/dist/line-layer/line-layer-fragment.glsl.js","../../../node_modules/.pnpm/@deck.gl+layers@9.2.6_@deck.gl+core@9.2.6_@loaders.gl+core@4.3.4_@luma.gl+core@9.2.6_@l_5aff0b42a0cad74c3df9dc79be75de3a/node_modules/@deck.gl/layers/dist/line-layer/line-layer.js","../../../node_modules/.pnpm/@deck.gl+layers@9.2.6_@deck.gl+core@9.2.6_@loaders.gl+core@4.3.4_@luma.gl+core@9.2.6_@l_5aff0b42a0cad74c3df9dc79be75de3a/node_modules/@deck.gl/layers/dist/column-layer/grid-cell-layer.js"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst uniformBlockWGSL = /* wgsl */ `\\\nstruct LineUniforms {\n  widthScale: f32,\n  widthMinPixels: f32,\n  widthMaxPixels: f32,\n  useShortestPath: f32,\n  widthUnits: i32,\n};\n\n@group(0) @binding(1)\nvar<uniform> line: LineUniforms;\n`;\nconst uniformBlockGLSL = /* glsl */ `\\\nuniform lineUniforms {\n  float widthScale;\n  float widthMinPixels;\n  float widthMaxPixels;\n  float useShortestPath;\n  highp int widthUnits;\n} line;\n`;\nexport const lineUniforms = {\n    name: 'line',\n    source: uniformBlockWGSL,\n    vs: uniformBlockGLSL,\n    fs: uniformBlockGLSL,\n    uniformTypes: {\n        widthScale: 'f32',\n        widthMinPixels: 'f32',\n        widthMaxPixels: 'f32',\n        useShortestPath: 'f32',\n        widthUnits: 'i32'\n    }\n};\n//# sourceMappingURL=line-layer-uniforms.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport const shaderWGSL = /* wgsl */ `\\\n// ---------- Helper Structures & Functions ----------\n\n// Placeholder filter functions.\nfn deckgl_filter_size(offset: vec3<f32>, geometry: Geometry) -> vec3<f32> {\n  return offset;\n}\nfn deckgl_filter_gl_position(p: vec4<f32>, geometry: Geometry) -> vec4<f32> {\n  return p;\n}\nfn deckgl_filter_color(color: vec4<f32>, geometry: Geometry) -> vec4<f32> {\n  return color;\n}\n\n// Compute an extrusion offset given a line direction (in clipspace),\n// an offset direction (-1 or 1), and a width in pixels.\n// Assumes a uniform \"project\" with a viewportSize field is available.\nfn getExtrusionOffset(line_clipspace: vec2<f32>, offset_direction: f32, width: f32) -> vec2<f32> {\n  // project.viewportSize should be provided as a uniform (not shown here)\n  let dir_screenspace = normalize(line_clipspace * project.viewportSize);\n  // Rotate by 90Â°: (x,y) becomes (-y,x)\n  let rotated = vec2<f32>(-dir_screenspace.y, dir_screenspace.x);\n  return rotated * offset_direction * width / 2.0;\n}\n\n// Splits the line between two points at a given x coordinate.\n// Interpolates the y and z components.\nfn splitLine(a: vec3<f32>, b: vec3<f32>, x: f32) -> vec3<f32> {\n  let t: f32 = (x - a.x) / (b.x - a.x);\n  return vec3<f32>(x, a.yz + t * (b.yz - a.yz));\n}\n\n// ---------- Uniforms & Global Structures ----------\n\n// Uniforms for line, color, and project are assumed to be defined elsewhere.\n// For example:\n//\n// @group(0) @binding(0)\n// var<uniform> line: LineUniform;\n//\n// struct ColorUniform {\n//   opacity: f32,\n// };\n// @group(0) @binding(1)\n// var<uniform> color: ColorUniform;\n//\n// struct ProjectUniform {\n//   viewportSize: vec2<f32>,\n// };\n// @group(0) @binding(2)\n// var<uniform> project: ProjectUniform;\n\n\n\n// ---------- Vertex Output Structure ----------\n\nstruct Varyings {\n  @builtin(position) gl_Position: vec4<f32>,\n  @location(0) vColor: vec4<f32>,\n  @location(1) uv: vec2<f32>,\n};\n\n// ---------- Vertex Shader Entry Point ----------\n\n@vertex\nfn vertexMain(\n  @location(0) positions: vec3<f32>,\n  @location(1) instanceSourcePositions: vec3<f32>,\n  @location(2) instanceTargetPositions: vec3<f32>,\n  @location(3) instanceSourcePositions64Low: vec3<f32>,\n  @location(4) instanceTargetPositions64Low: vec3<f32>,\n  @location(5) instanceColors: vec4<f32>,\n  @location(6) instancePickingColors: vec3<f32>,\n  @location(7) instanceWidths: f32\n) -> Varyings {\n  var geometry: Geometry;\n  geometry.worldPosition = instanceSourcePositions;\n  geometry.worldPositionAlt = instanceTargetPositions;\n\n  var source_world: vec3<f32> = instanceSourcePositions;\n  var target_world: vec3<f32> = instanceTargetPositions;\n  var source_world_64low: vec3<f32> = instanceSourcePositions64Low;\n  var target_world_64low: vec3<f32> = instanceTargetPositions64Low;\n\n  // Apply shortest-path adjustments if needed.\n  if (line.useShortestPath > 0.5 || line.useShortestPath < -0.5) {\n    source_world.x = (source_world.x + 180.0 % 360.0) - 180.0;\n    target_world.x = (target_world.x + 180.0 % 360.0) - 180.0;\n    let deltaLng: f32 = target_world.x - source_world.x;\n\n    if (deltaLng * line.useShortestPath > 180.0) {\n      source_world.x = source_world.x + 360.0 * line.useShortestPath;\n      source_world = splitLine(source_world, target_world, 180.0 * line.useShortestPath);\n      source_world_64low = vec3<f32>(0.0, 0.0, 0.0);\n    } else if (deltaLng * line.useShortestPath < -180.0) {\n      target_world.x = target_world.x + 360.0 * line.useShortestPath;\n      target_world = splitLine(source_world, target_world, 180.0 * line.useShortestPath);\n      target_world_64low = vec3<f32>(0.0, 0.0, 0.0);\n    } else if (line.useShortestPath < 0.0) {\n      var abortOut: Varyings;\n      abortOut.gl_Position = vec4<f32>(0.0);\n      abortOut.vColor = vec4<f32>(0.0);\n      abortOut.uv = vec2<f32>(0.0);\n      return abortOut;\n    }\n  }\n\n  // Project Pos and target positions to clip space.\n  let sourceResult = project_position_to_clipspace_and_commonspace(source_world, source_world_64low, vec3<f32>(0.0));\n  let targetResult = project_position_to_clipspace_and_commonspace(target_world, target_world_64low, vec3<f32>(0.0));\n  let sourcePos: vec4<f32> = sourceResult.clipPosition;\n  let targetPos: vec4<f32> = targetResult.clipPosition;\n  let source_commonspace: vec4<f32> = sourceResult.commonPosition;\n  let target_commonspace: vec4<f32> = targetResult.commonPosition;\n\n  // Interpolate along the line segment.\n  let segmentIndex: f32 = positions.x;\n  let p: vec4<f32> = sourcePos + segmentIndex * (targetPos - sourcePos);\n  geometry.position = source_commonspace + segmentIndex * (target_commonspace - source_commonspace);\n  let uv: vec2<f32> = positions.xy;\n  geometry.uv = uv;\n  geometry.pickingColor = instancePickingColors;\n\n  // Determine width in pixels.\n  let widthPixels: f32 = clamp(\n    project_unit_size_to_pixel(instanceWidths * line.widthScale, line.widthUnits),\n    line.widthMinPixels, line.widthMaxPixels\n  );\n\n  // Compute extrusion offset.\n  let extrusion: vec2<f32> = getExtrusionOffset(targetPos.xy - sourcePos.xy, positions.y, widthPixels);\n  let offset: vec3<f32> = vec3<f32>(extrusion, 0.0);\n\n  // Apply deck.gl filter functions.\n  let filteredOffset = deckgl_filter_size(offset, geometry);\n  let filteredP = deckgl_filter_gl_position(p, geometry);\n\n  let clipOffset: vec2<f32> = project_pixel_size_to_clipspace(filteredOffset.xy);\n  let finalPosition: vec4<f32> = filteredP + vec4<f32>(clipOffset, 0.0, 0.0);\n\n  // Compute color.\n  var vColor: vec4<f32> = vec4<f32>(instanceColors.rgb, instanceColors.a * color.opacity);\n  // vColor = deckgl_filter_color(vColor, geometry);\n\n  var output: Varyings;\n  output.gl_Position = finalPosition;\n  output.vColor = vColor;\n  output.uv = uv;\n  return output;\n}\n\n@fragment\nfn fragmentMain(\n  @location(0) vColor: vec4<f32>,\n  @location(1) uv: vec2<f32>\n) -> @location(0) vec4<f32> {\n  // Create and initialize geometry with the provided uv.\n  var geometry: Geometry;\n  geometry.uv = uv;\n\n  // Start with the input color.\n  var fragColor: vec4<f32> = vColor;\n\n  // Apply the deck.gl filter to the color.\n  fragColor = deckgl_filter_color(fragColor, geometry);\n\n  // Apply premultiplied alpha as required by transparent canvas\n  fragColor = deckgl_premultiplied_alpha(fragColor);\n\n  return fragColor;\n}\n`;\n//# sourceMappingURL=line-layer.wgsl.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport default `\\\n#version 300 es\n#define SHADER_NAME line-layer-vertex-shader\nin vec3 positions;\nin vec3 instanceSourcePositions;\nin vec3 instanceTargetPositions;\nin vec3 instanceSourcePositions64Low;\nin vec3 instanceTargetPositions64Low;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nin float instanceWidths;\nout vec4 vColor;\nout vec2 uv;\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\nvec2 dir_screenspace = normalize(line_clipspace * project.viewportSize);\ndir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\nreturn dir_screenspace * offset_direction * width / 2.0;\n}\nvec3 splitLine(vec3 a, vec3 b, float x) {\nfloat t = (x - a.x) / (b.x - a.x);\nreturn vec3(x, mix(a.yz, b.yz, t));\n}\nvoid main(void) {\ngeometry.worldPosition = instanceSourcePositions;\ngeometry.worldPositionAlt = instanceTargetPositions;\nvec3 source_world = instanceSourcePositions;\nvec3 target_world = instanceTargetPositions;\nvec3 source_world_64low = instanceSourcePositions64Low;\nvec3 target_world_64low = instanceTargetPositions64Low;\nif (line.useShortestPath > 0.5 || line.useShortestPath < -0.5) {\nsource_world.x = mod(source_world.x + 180., 360.0) - 180.;\ntarget_world.x = mod(target_world.x + 180., 360.0) - 180.;\nfloat deltaLng = target_world.x - source_world.x;\nif (deltaLng * line.useShortestPath > 180.) {\nsource_world.x += 360. * line.useShortestPath;\nsource_world = splitLine(source_world, target_world, 180. * line.useShortestPath);\nsource_world_64low = vec3(0.0);\n} else if (deltaLng * line.useShortestPath < -180.) {\ntarget_world.x += 360. * line.useShortestPath;\ntarget_world = splitLine(source_world, target_world, 180. * line.useShortestPath);\ntarget_world_64low = vec3(0.0);\n} else if (line.useShortestPath < 0.) {\ngl_Position = vec4(0.);\nreturn;\n}\n}\nvec4 source_commonspace;\nvec4 target_commonspace;\nvec4 source = project_position_to_clipspace(source_world, source_world_64low, vec3(0.), source_commonspace);\nvec4 target = project_position_to_clipspace(target_world, target_world_64low, vec3(0.), target_commonspace);\nfloat segmentIndex = positions.x;\nvec4 p = mix(source, target, segmentIndex);\ngeometry.position = mix(source_commonspace, target_commonspace, segmentIndex);\nuv = positions.xy;\ngeometry.uv = uv;\ngeometry.pickingColor = instancePickingColors;\nfloat widthPixels = clamp(\nproject_size_to_pixel(instanceWidths * line.widthScale, line.widthUnits),\nline.widthMinPixels, line.widthMaxPixels\n);\nvec3 offset = vec3(\ngetExtrusionOffset(target.xy - source.xy, positions.y, widthPixels),\n0.0);\nDECKGL_FILTER_SIZE(offset, geometry);\nDECKGL_FILTER_GL_POSITION(p, geometry);\ngl_Position = p + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);\nvColor = vec4(instanceColors.rgb, instanceColors.a * layer.opacity);\nDECKGL_FILTER_COLOR(vColor, geometry);\n}\n`;\n//# sourceMappingURL=line-layer-vertex.glsl.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport default `\\\n#version 300 es\n#define SHADER_NAME line-layer-fragment-shader\nprecision highp float;\nin vec4 vColor;\nin vec2 uv;\nout vec4 fragColor;\nvoid main(void) {\ngeometry.uv = uv;\nfragColor = vColor;\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n`;\n//# sourceMappingURL=line-layer-fragment.glsl.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Layer, project32, color, picking, UNIT } from '@deck.gl/core';\nimport { Model, Geometry } from '@luma.gl/engine';\nimport { lineUniforms } from \"./line-layer-uniforms.js\";\nimport { shaderWGSL as source } from \"./line-layer.wgsl.js\";\nimport vs from \"./line-layer-vertex.glsl.js\";\nimport fs from \"./line-layer-fragment.glsl.js\";\nconst DEFAULT_COLOR = [0, 0, 0, 255];\nconst defaultProps = {\n    getSourcePosition: { type: 'accessor', value: (x) => x.sourcePosition },\n    getTargetPosition: { type: 'accessor', value: (x) => x.targetPosition },\n    getColor: { type: 'accessor', value: DEFAULT_COLOR },\n    getWidth: { type: 'accessor', value: 1 },\n    widthUnits: 'pixels',\n    widthScale: { type: 'number', value: 1, min: 0 },\n    widthMinPixels: { type: 'number', value: 0, min: 0 },\n    widthMaxPixels: { type: 'number', value: Number.MAX_SAFE_INTEGER, min: 0 }\n};\n/**\n * A layer that renders straight lines joining pairs of source and target coordinates.\n */\nclass LineLayer extends Layer {\n    getBounds() {\n        return this.getAttributeManager()?.getBounds([\n            'instanceSourcePositions',\n            'instanceTargetPositions'\n        ]);\n    }\n    getShaders() {\n        return super.getShaders({ vs, fs, source, modules: [project32, color, picking, lineUniforms] });\n    }\n    // This layer has its own wrapLongitude logic\n    get wrapLongitude() {\n        return false;\n    }\n    initializeState() {\n        const attributeManager = this.getAttributeManager();\n        /* eslint-disable max-len */\n        attributeManager.addInstanced({\n            instanceSourcePositions: {\n                size: 3,\n                type: 'float64',\n                fp64: this.use64bitPositions(),\n                transition: true,\n                accessor: 'getSourcePosition'\n            },\n            instanceTargetPositions: {\n                size: 3,\n                type: 'float64',\n                fp64: this.use64bitPositions(),\n                transition: true,\n                accessor: 'getTargetPosition'\n            },\n            instanceColors: {\n                size: this.props.colorFormat.length,\n                type: 'unorm8',\n                transition: true,\n                accessor: 'getColor',\n                defaultValue: [0, 0, 0, 255]\n            },\n            instanceWidths: {\n                size: 1,\n                transition: true,\n                accessor: 'getWidth',\n                defaultValue: 1\n            }\n        });\n        /* eslint-enable max-len */\n    }\n    updateState(params) {\n        super.updateState(params);\n        if (params.changeFlags.extensionsChanged) {\n            this.state.model?.destroy();\n            this.state.model = this._getModel();\n            this.getAttributeManager().invalidateAll();\n        }\n    }\n    draw({ uniforms }) {\n        const { widthUnits, widthScale, widthMinPixels, widthMaxPixels, wrapLongitude } = this.props;\n        const model = this.state.model;\n        const lineProps = {\n            widthUnits: UNIT[widthUnits],\n            widthScale,\n            widthMinPixels,\n            widthMaxPixels,\n            useShortestPath: wrapLongitude ? 1 : 0\n        };\n        model.shaderInputs.setProps({ line: lineProps });\n        model.draw(this.context.renderPass);\n        if (wrapLongitude) {\n            // Render a second copy for the clipped lines at the 180th meridian\n            model.shaderInputs.setProps({ line: { ...lineProps, useShortestPath: -1 } });\n            model.draw(this.context.renderPass);\n        }\n    }\n    _getModel() {\n        // TODO(ibgreen): WebGPU complication: Matching attachment state of the renderpass requires including a depth buffer\n        const parameters = this.context.device.type === 'webgpu'\n            ? {\n                depthWriteEnabled: true,\n                depthCompare: 'less-equal'\n            }\n            : undefined;\n        /*\n         *  (0, -1)-------------_(1, -1)\n         *       |          _,-\"  |\n         *       o      _,-\"      o\n         *       |  _,-\"          |\n         *   (0, 1)\"-------------(1, 1)\n         */\n        const positions = [0, -1, 0, 0, 1, 0, 1, -1, 0, 1, 1, 0];\n        return new Model(this.context.device, {\n            ...this.getShaders(),\n            id: this.props.id,\n            bufferLayout: this.getAttributeManager().getBufferLayouts(),\n            geometry: new Geometry({\n                topology: 'triangle-strip',\n                attributes: {\n                    positions: { size: 3, value: new Float32Array(positions) }\n                }\n            }),\n            parameters,\n            isInstanced: true\n        });\n    }\n}\nLineLayer.layerName = 'LineLayer';\nLineLayer.defaultProps = defaultProps;\nexport default LineLayer;\n//# sourceMappingURL=line-layer.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { UNIT } from '@deck.gl/core';\nimport { CubeGeometry } from '@luma.gl/engine';\nimport ColumnLayer from \"./column-layer.js\";\nconst defaultProps = {\n    cellSize: { type: 'number', min: 0, value: 1000 },\n    offset: { type: 'array', value: [1, 1] }\n};\nclass GridCellLayer extends ColumnLayer {\n    _updateGeometry() {\n        const geometry = new CubeGeometry();\n        this.state.fillModel.setGeometry(geometry);\n    }\n    draw({ uniforms }) {\n        const { elevationScale, extruded, offset, coverage, cellSize, angle, radiusUnits } = this.props;\n        const fillModel = this.state.fillModel;\n        const columnProps = {\n            radius: cellSize / 2,\n            radiusUnits: UNIT[radiusUnits],\n            angle,\n            offset,\n            extruded,\n            stroked: false,\n            coverage,\n            elevationScale,\n            edgeDistance: 1,\n            isStroke: false,\n            widthUnits: 0,\n            widthScale: 0,\n            widthMinPixels: 0,\n            widthMaxPixels: 0\n        };\n        fillModel.shaderInputs.setProps({ column: columnProps });\n        fillModel.draw(this.context.renderPass);\n    }\n}\nGridCellLayer.layerName = 'GridCellLayer';\nGridCellLayer.defaultProps = defaultProps;\nexport default GridCellLayer;\n//# sourceMappingURL=grid-cell-layer.js.map"],"names":["uniformBlockWGSL","uniformBlockGLSL","lineUniforms","shaderWGSL","vs","fs","DEFAULT_COLOR","defaultProps","x","LineLayer","Layer","source","project32","color","picking","params","uniforms","widthUnits","widthScale","widthMinPixels","widthMaxPixels","wrapLongitude","model","lineProps","UNIT","parameters","positions","Model","Geometry","GridCellLayer","ColumnLayer","geometry","CubeGeometry","elevationScale","extruded","offset","coverage","cellSize","angle","radiusUnits","fillModel","columnProps"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5]}