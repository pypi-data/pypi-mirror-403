{"version":3,"file":"globe-viewport-tqhQW7C4.js","sources":["../../../../node_modules/.pnpm/@deck.gl+core@9.2.6/node_modules/@deck.gl/core/dist/viewports/globe-viewport.js"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Matrix4 } from '@math.gl/core';\nimport Viewport from \"./viewport.js\";\nimport { PROJECTION_MODE } from \"../lib/constants.js\";\nimport { altitudeToFovy, fovyToAltitude } from '@math.gl/web-mercator';\nimport { MAX_LATITUDE } from '@math.gl/web-mercator';\nimport { vec3, vec4 } from '@math.gl/core';\nconst DEGREES_TO_RADIANS = Math.PI / 180;\nconst RADIANS_TO_DEGREES = 180 / Math.PI;\nconst EARTH_RADIUS = 6370972;\nconst GLOBE_RADIUS = 256;\nfunction getDistanceScales() {\n    const unitsPerMeter = GLOBE_RADIUS / EARTH_RADIUS;\n    const unitsPerDegree = (Math.PI / 180) * GLOBE_RADIUS;\n    return {\n        unitsPerMeter: [unitsPerMeter, unitsPerMeter, unitsPerMeter],\n        unitsPerMeter2: [0, 0, 0],\n        metersPerUnit: [1 / unitsPerMeter, 1 / unitsPerMeter, 1 / unitsPerMeter],\n        unitsPerDegree: [unitsPerDegree, unitsPerDegree, unitsPerMeter],\n        unitsPerDegree2: [0, 0, 0],\n        degreesPerUnit: [1 / unitsPerDegree, 1 / unitsPerDegree, 1 / unitsPerMeter]\n    };\n}\nclass GlobeViewport extends Viewport {\n    constructor(opts = {}) {\n        const { longitude = 0, zoom = 0, \n        // Matches Maplibre defaults\n        // https://github.com/maplibre/maplibre-gl-js/blob/f8ab4b48d59ab8fe7b068b102538793bbdd4c848/src/geo/projection/globe_transform.ts#L632-L633\n        nearZMultiplier = 0.5, farZMultiplier = 1, resolution = 10 } = opts;\n        let { latitude = 0, height, altitude = 1.5, fovy } = opts;\n        // Clamp to web mercator limit to prevent bad inputs\n        latitude = Math.max(Math.min(latitude, MAX_LATITUDE), -MAX_LATITUDE);\n        height = height || 1;\n        if (fovy) {\n            altitude = fovyToAltitude(fovy);\n        }\n        else {\n            fovy = altitudeToFovy(altitude);\n        }\n        // Exagerate distance by latitude to match the Web Mercator distortion\n        // The goal is that globe and web mercator projection results converge at high zoom\n        // https://github.com/maplibre/maplibre-gl-js/blob/f8ab4b48d59ab8fe7b068b102538793bbdd4c848/src/geo/projection/globe_transform.ts#L575-L577\n        const scale = Math.pow(2, zoom - zoomAdjust(latitude));\n        const nearZ = opts.nearZ ?? nearZMultiplier;\n        const farZ = opts.farZ ?? (altitude + (GLOBE_RADIUS * 2 * scale) / height) * farZMultiplier;\n        // Calculate view matrix\n        const viewMatrix = new Matrix4().lookAt({ eye: [0, -altitude, 0], up: [0, 0, 1] });\n        viewMatrix.rotateX(latitude * DEGREES_TO_RADIANS);\n        viewMatrix.rotateZ(-longitude * DEGREES_TO_RADIANS);\n        viewMatrix.scale(scale / height);\n        super({\n            ...opts,\n            // x, y, width,\n            height,\n            // view matrix\n            viewMatrix,\n            longitude,\n            latitude,\n            zoom,\n            // projection matrix parameters\n            distanceScales: getDistanceScales(),\n            fovy,\n            focalDistance: altitude,\n            near: nearZ,\n            far: farZ\n        });\n        this.scale = scale;\n        this.latitude = latitude;\n        this.longitude = longitude;\n        this.fovy = fovy;\n        this.resolution = resolution;\n    }\n    get projectionMode() {\n        return PROJECTION_MODE.GLOBE;\n    }\n    getDistanceScales() {\n        return this.distanceScales;\n    }\n    getBounds(options = {}) {\n        const unprojectOption = { targetZ: options.z || 0 };\n        const left = this.unproject([0, this.height / 2], unprojectOption);\n        const top = this.unproject([this.width / 2, 0], unprojectOption);\n        const right = this.unproject([this.width, this.height / 2], unprojectOption);\n        const bottom = this.unproject([this.width / 2, this.height], unprojectOption);\n        if (right[0] < this.longitude)\n            right[0] += 360;\n        if (left[0] > this.longitude)\n            left[0] -= 360;\n        return [\n            Math.min(left[0], right[0], top[0], bottom[0]),\n            Math.min(left[1], right[1], top[1], bottom[1]),\n            Math.max(left[0], right[0], top[0], bottom[0]),\n            Math.max(left[1], right[1], top[1], bottom[1])\n        ];\n    }\n    unproject(xyz, { topLeft = true, targetZ } = {}) {\n        const [x, y, z] = xyz;\n        const y2 = topLeft ? y : this.height - y;\n        const { pixelUnprojectionMatrix } = this;\n        let coord;\n        if (Number.isFinite(z)) {\n            // Has depth component\n            coord = transformVector(pixelUnprojectionMatrix, [x, y2, z, 1]);\n        }\n        else {\n            // since we don't know the correct projected z value for the point,\n            // unproject two points to get a line and then find the point on that line that intersects with the sphere\n            const coord0 = transformVector(pixelUnprojectionMatrix, [x, y2, -1, 1]);\n            const coord1 = transformVector(pixelUnprojectionMatrix, [x, y2, 1, 1]);\n            const lt = ((targetZ || 0) / EARTH_RADIUS + 1) * GLOBE_RADIUS;\n            const lSqr = vec3.sqrLen(vec3.sub([], coord0, coord1));\n            const l0Sqr = vec3.sqrLen(coord0);\n            const l1Sqr = vec3.sqrLen(coord1);\n            const sSqr = (4 * l0Sqr * l1Sqr - (lSqr - l0Sqr - l1Sqr) ** 2) / 16;\n            const dSqr = (4 * sSqr) / lSqr;\n            const r0 = Math.sqrt(l0Sqr - dSqr);\n            const dr = Math.sqrt(Math.max(0, lt * lt - dSqr));\n            const t = (r0 - dr) / Math.sqrt(lSqr);\n            coord = vec3.lerp([], coord0, coord1, t);\n        }\n        const [X, Y, Z] = this.unprojectPosition(coord);\n        if (Number.isFinite(z)) {\n            return [X, Y, Z];\n        }\n        return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];\n    }\n    projectPosition(xyz) {\n        const [lng, lat, Z = 0] = xyz;\n        const lambda = lng * DEGREES_TO_RADIANS;\n        const phi = lat * DEGREES_TO_RADIANS;\n        const cosPhi = Math.cos(phi);\n        const D = (Z / EARTH_RADIUS + 1) * GLOBE_RADIUS;\n        return [Math.sin(lambda) * cosPhi * D, -Math.cos(lambda) * cosPhi * D, Math.sin(phi) * D];\n    }\n    unprojectPosition(xyz) {\n        const [x, y, z] = xyz;\n        const D = vec3.len(xyz);\n        const phi = Math.asin(z / D);\n        const lambda = Math.atan2(x, -y);\n        const lng = lambda * RADIANS_TO_DEGREES;\n        const lat = phi * RADIANS_TO_DEGREES;\n        const Z = (D / GLOBE_RADIUS - 1) * EARTH_RADIUS;\n        return [lng, lat, Z];\n    }\n    projectFlat(xyz) {\n        return xyz;\n    }\n    unprojectFlat(xyz) {\n        return xyz;\n    }\n    /**\n     * Pan the globe using delta-based movement\n     * @param coords - the geographic coordinates where the pan started\n     * @param pixel - the current screen position\n     * @param startPixel - the screen position where the pan started\n     * @returns updated viewport options with new longitude/latitude\n     */\n    panByPosition([startLng, startLat, startZoom], pixel, startPixel) {\n        // Scale rotation speed inversely with zoom, to approximate constant panning speed\n        const scale = Math.pow(2, this.zoom - zoomAdjust(this.latitude));\n        const rotationSpeed = 0.25 / scale;\n        const longitude = startLng + rotationSpeed * (startPixel[0] - pixel[0]);\n        let latitude = startLat - rotationSpeed * (startPixel[1] - pixel[1]);\n        latitude = Math.max(Math.min(latitude, MAX_LATITUDE), -MAX_LATITUDE);\n        const out = { longitude, latitude, zoom: startZoom - zoomAdjust(startLat) };\n        out.zoom += zoomAdjust(out.latitude);\n        return out;\n    }\n}\nGlobeViewport.displayName = 'GlobeViewport';\nexport default GlobeViewport;\nexport function zoomAdjust(latitude) {\n    const scaleAdjust = Math.PI * Math.cos((latitude * Math.PI) / 180);\n    return Math.log2(scaleAdjust);\n}\nfunction transformVector(matrix, vector) {\n    const result = vec4.transformMat4([], vector, matrix);\n    vec4.scale(result, result, 1 / result[3]);\n    return result;\n}\n//# sourceMappingURL=globe-viewport.js.map"],"names":["DEGREES_TO_RADIANS","RADIANS_TO_DEGREES","EARTH_RADIUS","GLOBE_RADIUS","getDistanceScales","unitsPerMeter","unitsPerDegree","GlobeViewport","Viewport","opts","longitude","zoom","nearZMultiplier","farZMultiplier","resolution","latitude","height","altitude","fovy","MAX_LATITUDE","fovyToAltitude","altitudeToFovy","scale","zoomAdjust","nearZ","farZ","viewMatrix","Matrix4","PROJECTION_MODE","options","unprojectOption","left","top","right","bottom","xyz","topLeft","targetZ","x","y","z","y2","pixelUnprojectionMatrix","coord","transformVector","coord0","coord1","lt","lSqr","vec3.sqrLen","vec3.sub","l0Sqr","l1Sqr","dSqr","r0","dr","t","vec3.lerp","X","Y","Z","lng","lat","lambda","phi","cosPhi","D","vec3.len","startLng","startLat","startZoom","pixel","startPixel","rotationSpeed","out","scaleAdjust","matrix","vector","result","vec4.transformMat4","vec4.scale"],"mappings":"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","x_google_ignoreList":[0]}