import logging
import os
import re
import sys
import time

from sandroid.core.toolbox import Toolbox

from .datagather import DataGather

try:
    from dexray_intercept import AppProfiler, setup_frida_device
except ImportError:
    logger = logging.getLogger(__name__)
    logger.warning(
        "dexray-intercept package not installed. Malware monitoring will be disabled."
    )
    AppProfiler = None
    setup_frida_device = None

logger = logging.getLogger(__name__)


# Set up dedicated dexray log file
def _setup_dexray_logging():
    """Set up dedicated file logging for dexray-intercept in the Sandroid results folder."""
    dexray_logger = logging.getLogger("dexray_intercept")

    # Check if we already have a file handler to avoid duplicates
    has_file_handler = any(
        isinstance(handler, logging.FileHandler) for handler in dexray_logger.handlers
    )

    if not has_file_handler and os.getenv("RESULTS_PATH"):
        # Create dexray_intercept folder at results root level (sibling to raw/)
        dexray_dir = os.path.join(os.getenv("RESULTS_PATH"), "dexray_intercept")
        os.makedirs(dexray_dir, exist_ok=True)

        dexray_log_path = os.path.join(dexray_dir, "dexray.log")
        file_handler = logging.FileHandler(dexray_log_path)
        file_handler.setLevel(logging.DEBUG)
        file_formatter = logging.Formatter(
            "%(asctime)s~%(levelname)s~%(message)s~module:%(module)s~function:%(funcName)s"
        )
        file_handler.setFormatter(file_formatter)
        dexray_logger.addHandler(file_handler)
        dexray_logger.setLevel(logging.DEBUG)

        logger.info(f"Dexray logs will be saved to {dexray_log_path}")


def _strip_color_codes(text):
    """Strip ANSI color codes and Rich markup to get visual length.

    Args:
        text: Text possibly containing ANSI color codes and Rich markup

    Returns:
        Text with color codes and markup removed
    """
    # Strip ANSI escape codes
    ansi_escape = re.compile(r"\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])")
    text = ansi_escape.sub("", text)

    # Strip Rich markup tags like [success], [/success], [bold], etc.
    # Handle escaped brackets \[ which should be kept as [
    # First, temporarily replace escaped brackets
    text = text.replace("\\[", "\x00ESCAPED_BRACKET\x00")
    # Remove Rich markup tags
    rich_markup = re.compile(r"\[/?[a-zA-Z0-9_.]+\]")
    text = rich_markup.sub("", text)
    # Restore escaped brackets
    text = text.replace("\x00ESCAPED_BRACKET\x00", "[")

    return text


def _box_line(content, width=76, align="center", border_style="primary"):
    """Create a properly aligned box line with color support.

    Args:
        content: Text content (may contain Rich markup)
        width: Total width of the box content area (default 76)
        align: Alignment ('center', 'left', or 'right')
        border_style: Style for the border (default "primary")

    Returns:
        Properly formatted box line with borders
    """
    # Calculate visual length (without color codes/markup)
    visual_length = len(_strip_color_codes(content))

    # Calculate padding
    if align == "center":
        total_padding = width - visual_length
        left_pad = total_padding // 2
        right_pad = total_padding - left_pad
    elif align == "left":
        left_pad = 2
        right_pad = width - visual_length - left_pad
    else:  # right
        right_pad = 2
        left_pad = width - visual_length - right_pad

    # Apply border color to the ║ characters
    return f"[{border_style}]║[/{border_style}]{' ' * left_pad}{content}{' ' * right_pad}[{border_style}]║[/{border_style}]"


def _interactive_hook_selection(current_hooks):
    """Interactive hook selection for dexray-intercept with visual toggle interface.

    Args:
        current_hooks: Dictionary of currently enabled hooks

    Returns:
        Updated hook configuration dictionary
    """
    import click

    from sandroid.core.console import SandroidConsole

    console = SandroidConsole.get()

    # Define hook groups with their descriptions
    hook_groups = {
        "crypto": {
            "name": "Crypto Hooks",
            "description": "AES, encodings, keystore operations",
            "hooks": ["aes_hooks", "encodings_hooks", "keystore_hooks"],
        },
        "network": {
            "name": "Network Hooks",
            "description": "Web requests, sockets, HTTP/HTTPS traffic",
            "hooks": ["web_hooks", "socket_hooks"],
        },
        "filesystem": {
            "name": "Filesystem Hooks",
            "description": "File operations, database access",
            "hooks": ["file_system_hooks", "database_hooks"],
        },
        "ipc": {
            "name": "IPC Hooks",
            "description": "Binder, intents, broadcasts, shared preferences",
            "hooks": [
                "shared_prefs_hooks",
                "binder_hooks",
                "intent_hooks",
                "broadcast_hooks",
            ],
        },
        "process": {
            "name": "Process Hooks",
            "description": "Native libraries, runtime, DEX unpacking",
            "hooks": [
                "dex_unpacking_hooks",
                "java_dex_unpacking_hooks",
                "native_library_hooks",
                "process_hooks",
                "runtime_hooks",
            ],
        },
        "services": {
            "name": "Service Hooks",
            "description": "Bluetooth, camera, clipboard, location, telephony",
            "hooks": [
                "bluetooth_hooks",
                "camera_hooks",
                "clipboard_hooks",
                "location_hooks",
                "telephony_hooks",
            ],
        },
        "bypass": {
            "name": "Anti-Analysis Bypass Hooks",
            "description": "Root, frida, debugger, emulator detection",
            "hooks": ["bypass_hooks"],
        },
    }

    def display_hooks(hooks, groups):
        """Display hooks with visual status indicators."""
        console.print(f"\n[primary]╔{'═' * 76}╗[/primary]")
        console.print(_box_line("[bold]Dexray-Intercept Hook Configuration[/bold]"))
        console.print(f"[primary]╚{'═' * 76}╝[/primary]\n")

        # Count enabled hooks
        enabled_count = sum(
            1
            for hook_list in groups.values()
            for hook in hook_list["hooks"]
            if hooks.get(hook, False)
        )
        total_individual_hooks = sum(len(group["hooks"]) for group in groups.values())

        console.print(
            f"Status: [success]{enabled_count}[/success]/{total_individual_hooks} hook categories enabled\n"
        )

        # Display each group
        for idx, (group_key, group_info) in enumerate(groups.items(), 1):
            # Check if any hook in this group is enabled
            group_enabled = any(hooks.get(hook, False) for hook in group_info["hooks"])

            # Visual status indicator
            if group_enabled:
                status_icon = "[success]●[/success]"
                status_text = "[success]ON [/success]"
            else:
                status_icon = "[error]○[/error]"
                status_text = "[error]OFF[/error]"

            # Display hook group with proper alignment
            # Calculate padding to align status indicators
            name_width = 35  # Fixed width for name column
            name = group_info["name"]
            padding = " " * max(0, name_width - len(name))

            console.print(
                f"[accent]\\[{idx}][/accent] {status_icon} [bold]{name}[/bold]{padding}\\[{status_text}]"
            )
            console.print(f"    [primary]{group_info['description']}[/primary]")

            # Show individual hooks in this group
            hooks_in_group = [
                f"[success]{h.replace('_', ' ').title()}[/success]"
                if hooks.get(h, False)
                else f"[error]{h.replace('_', ' ').title()}[/error]"
                for h in group_info["hooks"]
            ]
            console.print(f"    Hooks: {', '.join(hooks_in_group)}")
            console.print()

    updated_hooks = current_hooks.copy()

    # Ask if user wants to customize
    display_hooks(updated_hooks, hook_groups)

    console.print(f"[primary]╔{'═' * 76}╗[/primary]")
    console.print(_box_line("[bold]Would you like to customize hooks?[/bold]"))
    console.print(f"[primary]╠{'═' * 76}╣[/primary]")
    console.print(
        _box_line(
            "[accent]\\[y][/accent] Customize hook selection (toggle categories by number)",
            align="left",
        )
    )
    console.print(
        _box_line(
            "[accent]\\[n][/accent] Use current configuration (press [success]ENTER[/success] to accept default)",
            align="left",
        )
    )
    console.print(f"[primary]╚{'═' * 76}╝[/primary]\n")

    try:
        choice = click.getchar().lower()
        if choice not in ["y", "yes"]:
            enabled_count = sum(1 for v in updated_hooks.values() if v)
            console.print(
                f"\n[success]✓ Using current configuration ({enabled_count} hook categories enabled)[/success]\n"
            )
            return updated_hooks
    except (KeyboardInterrupt, EOFError):
        console.print("\n[warning]Using default configuration[/warning]\n")
        return updated_hooks

    # Interactive toggle mode
    while True:
        display_hooks(updated_hooks, hook_groups)

        console.print(f"[primary]╔{'═' * 76}╗[/primary]")
        console.print(_box_line("[bold]Toggle Hook Categories[/bold]"))
        console.print(f"[primary]╠{'═' * 76}╣[/primary]")
        console.print(
            _box_line(
                f"[accent]\\[1-{len(hook_groups)}][/accent] Toggle a hook category on/off",
                align="left",
            )
        )
        console.print(
            _box_line(
                "[accent]\\[a][/accent]   Enable all hook categories",
                align="left",
            )
        )
        console.print(
            _box_line(
                "[accent]\\[d][/accent]   Disable all hook categories",
                align="left",
            )
        )
        console.print(
            _box_line(
                "[accent]\\[q][/accent]   Finish and save configuration",
                align="left",
            )
        )
        console.print(f"[primary]╚{'═' * 76}╝[/primary]\n")

        console.print("[success]► Enter your choice:[/success] ", end="")

        try:
            choice = click.getchar().lower()
            console.print(f"[accent]{choice}[/accent]")  # Echo choice

            if choice == "q":
                break
            if choice == "a":
                # Enable all hooks
                for group_info in hook_groups.values():
                    for hook in group_info["hooks"]:
                        updated_hooks[hook] = True
                console.print("[success]✓ All hooks enabled[/success]\n")
            elif choice == "d":
                # Disable all hooks
                for group_info in hook_groups.values():
                    for hook in group_info["hooks"]:
                        updated_hooks[hook] = False
                console.print("[warning]✓ All hooks disabled[/warning]\n")
            elif choice.isdigit() and 1 <= int(choice) <= len(hook_groups):
                # Toggle specific group
                idx = int(choice) - 1
                group_key = list(hook_groups.keys())[idx]
                group_info = hook_groups[group_key]

                # Check current state
                group_enabled = any(
                    updated_hooks.get(hook, False) for hook in group_info["hooks"]
                )

                # Toggle all hooks in this group
                new_state = not group_enabled
                for hook in group_info["hooks"]:
                    updated_hooks[hook] = new_state

                state_text = (
                    "[success]enabled[/success]"
                    if new_state
                    else "[error]disabled[/error]"
                )
                console.print(
                    f"[primary]✓ {group_info['name']} {state_text}[/primary]\n"
                )
            else:
                console.print("[error]Invalid choice. Please try again.[/error]\n")

        except (KeyboardInterrupt, EOFError):
            console.print(
                "\n[warning]Configuration cancelled. Using previous settings.[/warning]\n"
            )
            return current_hooks

    # Show final summary
    enabled_hooks = [hook for hook, enabled in updated_hooks.items() if enabled]
    console.print(f"\n[success]╔{'═' * 76}╗[/success]")
    console.print(_box_line("[bold]Configuration Saved[/bold]", border_style="success"))
    console.print(f"[success]╚{'═' * 76}╝[/success]\n")

    if enabled_hooks:
        console.print(
            f"[success]✓ {len(enabled_hooks)} hook categories enabled:[/success]"
        )
        for hook in enabled_hooks:
            console.print(f"  [success]●[/success] {hook.replace('_', ' ').title()}")
    else:
        console.print(
            "[warning]! Warning: No hooks enabled. Dexray-intercept will run but won't capture events.[/warning]"
        )

    console.print()
    return updated_hooks


def _interactive_approfiler_configuration(current_settings=None):
    """Interactive AppProfiler configuration with visual interface.

    Args:
        current_settings: Dict with default settings (optional)

    Returns:
        Dict with configured settings, or None if cancelled
    """
    import click

    from sandroid.core.console import SandroidConsole

    console = SandroidConsole.get()

    # Default settings
    settings = {
        "enable_stacktrace": current_settings.get("enable_stacktrace", False)
        if current_settings
        else False,
        "deactivate_unlink": current_settings.get("deactivate_unlink", False)
        if current_settings
        else False,
        "enable_fritap": current_settings.get("enable_fritap", False)
        if current_settings
        else False,
        "fritap_output_dir": current_settings.get("fritap_output_dir", "fritap_output")
        if current_settings
        else "fritap_output",
        "custom_scripts": current_settings.get("custom_scripts", [])
        if current_settings
        else [],
    }

    # Setting descriptions
    descriptions = {
        "enable_stacktrace": "Show full call stacks for hook invocations (helps identify caller)",
        "deactivate_unlink": "Prevent file unlink operations (keeps files from being deleted)",
        "enable_fritap": "Enable TLS key extraction and traffic capture",
        "fritap_output_dir": "Directory for fritap output files (relative to dexray_intercept/)",
        "custom_scripts": "Additional Frida scripts to load alongside dexray-intercept",
    }

    def draw_box():
        """Draw the configuration interface."""
        width = 76

        console.print(f"\n[primary]╔{'═' * width}╗[/primary]")
        console.print(_box_line("[bold]AppProfiler Configuration[/bold]", width))
        console.print(
            _box_line(
                "[accent]Press [success]Enter[/success] to use defaults, or configure options below[/accent]",
                width,
            )
        )
        console.print(f"[primary]╠{'═' * width}╣[/primary]")

        # Stack traces
        status = "[success]✓[/success]" if settings["enable_stacktrace"] else " "
        console.print(
            _box_line(
                f"\\[{status}] Stack Traces:      [accent]{'Enabled' if settings['enable_stacktrace'] else 'Disabled'}[/accent]",
                width,
                align="left",
            )
        )
        console.print(
            _box_line(
                f"    [dim]{descriptions['enable_stacktrace']}[/dim]",
                width,
                align="left",
            )
        )
        console.print(_box_line("", width))

        # File unlinking
        status = "[success]✓[/success]" if settings["deactivate_unlink"] else " "
        console.print(
            _box_line(
                f"\\[{status}] Deactivate Unlink: [accent]{'Yes (keep files)' if settings['deactivate_unlink'] else 'No (normal behavior)'}[/accent]",
                width,
                align="left",
            )
        )
        console.print(
            _box_line(
                f"    [dim]{descriptions['deactivate_unlink']}[/dim]",
                width,
                align="left",
            )
        )
        console.print(_box_line("", width))

        # FriTap
        status = "[success]✓[/success]" if settings["enable_fritap"] else " "
        console.print(
            _box_line(
                f"\\[{status}] FriTap:            [accent]{'Enabled' if settings['enable_fritap'] else 'Disabled'}[/accent]",
                width,
                align="left",
            )
        )
        console.print(
            _box_line(
                f"    [dim]{descriptions['enable_fritap']}[/dim]", width, align="left"
            )
        )
        console.print(
            _box_line(
                f"    Output Dir: {settings['fritap_output_dir']}", width, align="left"
            )
        )
        console.print(_box_line("", width))

        # Custom scripts
        script_count = len(settings["custom_scripts"])
        script_display = f"{script_count} script(s)" if script_count > 0 else "None"
        console.print(
            _box_line(
                f"Custom Scripts:    [accent]{script_display}[/accent]",
                width,
                align="left",
            )
        )
        if script_count > 0:
            for i, script in enumerate(
                settings["custom_scripts"][:3], 1
            ):  # Show first 3
                script_name = script.split("/")[-1]  # Show just filename
                console.print(_box_line(f"    {i}. {script_name}", width, align="left"))
            if script_count > 3:
                console.print(
                    _box_line(
                        f"    ... and {script_count - 3} more", width, align="left"
                    )
                )

        # Controls
        console.print(f"[primary]╠{'═' * width}╣[/primary]")
        console.print(
            _box_line(
                "\\[S] Toggle Stack Traces  \\[U] Toggle Unlink  \\[F] Toggle FriTap",
                width,
                align="left",
            )
        )
        console.print(
            _box_line(
                "\\[D] Set FriTap Dir  \\[C] Add Custom Script  \\[R] Remove Script",
                width,
                align="left",
            )
        )
        console.print(
            _box_line(
                "[success]\\[Enter][/success] Continue  [error]\\[Esc][/error] Cancel",
                width,
                align="left",
            )
        )
        console.print(f"[primary]╚{'═' * width}╝[/primary]")

    # Main interaction loop
    while True:
        click.clear()
        draw_box()

        console.print("\n[primary]Your choice:[/primary] ", end="")
        choice = click.getchar().lower()

        if choice == "\r" or choice == "\n":  # Enter
            break
        if choice == "\x1b":  # ESC
            console.print(
                "\n[warning]Configuration cancelled. Using previous settings.[/warning]\n"
            )
            return current_settings
        if choice == "s":  # Toggle stack traces
            settings["enable_stacktrace"] = not settings["enable_stacktrace"]
        elif choice == "u":  # Toggle unlink
            settings["deactivate_unlink"] = not settings["deactivate_unlink"]
        elif choice == "f":  # Toggle fritap
            # If enabling FriTap, check if network capture is running
            if not settings["enable_fritap"]:  # About to enable
                settings["enable_fritap"] = True

                # Check if network capture is already running
                if not Toolbox.is_capturing_network():
                    console.print("\n[warning]╔{'═' * 74}╗[/warning]")
                    console.print(
                        "[warning]║[/warning] [accent]Network capture is not currently active[/accent]"
                        + " " * 32
                        + "[warning]║[/warning]"
                    )
                    console.print(
                        "[warning]║[/warning] [dim]FriTap extracts TLS keys for decrypting HTTPS traffic.[/dim]"
                        + " " * 16
                        + "[warning]║[/warning]"
                    )
                    console.print(
                        "[warning]║[/warning] [dim]It works best when combined with network packet capture.[/dim]"
                        + " " * 13
                        + "[warning]║[/warning]"
                    )
                    console.print("[warning]╚{'═' * 74}╝[/warning]")
                    console.print(
                        "[primary]Would you like to enable network capture?[/primary]"
                    )
                    console.print("[accent]  [y][/accent] Yes, enable network capture")
                    console.print("[dim]  [n][/dim] No, continue with FriTap only")

                    network_choice = click.getchar().lower()
                    if network_choice == "y":
                        console.print(
                            "\n[success]Network capture will be started with FriTap.[/success]"
                        )
                        console.print(
                            "[dim]Note: You'll need to start network capture from the main menu (press 'w')[/dim]"
                        )
                        input("\nPress Enter to continue...")
                    else:
                        console.print(
                            "\n[dim]FriTap will be enabled without network capture.[/dim]"
                        )
                        input("\nPress Enter to continue...")
            else:  # About to disable
                settings["enable_fritap"] = False
        elif choice == "d":  # Set fritap dir
            console.print(
                "\n[primary]Enter FriTap output directory (relative to dexray_intercept/):[/primary]"
            )
            console.print(f"[dim]Current: {settings['fritap_output_dir']}[/dim]")
            console.print("[dim]Press Enter to keep current, or type new path:[/dim]")
            new_dir = input("» ").strip()
            if new_dir:
                settings["fritap_output_dir"] = new_dir
        elif choice == "c":  # Add custom script
            console.print("\n[primary]Enter path to custom Frida script:[/primary]")
            script_path = input("» ").strip()
            if script_path:
                import os

                if os.path.exists(script_path):
                    settings["custom_scripts"].append(script_path)
                    console.print(f"[success]✓ Script added: {script_path}[/success]")
                else:
                    console.print(f"[error]✗ File not found: {script_path}[/error]")
                input("\nPress Enter to continue...")
        elif choice == "r":  # Remove custom script
            if settings["custom_scripts"]:
                console.print("\n[primary]Custom Scripts:[/primary]")
                for i, script in enumerate(settings["custom_scripts"], 1):
                    console.print(f"[accent]{i}.[/accent] {script}")
                console.print(
                    "\n[primary]Enter number to remove (or press Enter to cancel):[/primary]"
                )
                choice_str = input("» ").strip()
                if choice_str.isdigit():
                    idx = int(choice_str) - 1
                    if 0 <= idx < len(settings["custom_scripts"]):
                        removed = settings["custom_scripts"].pop(idx)
                        console.print(f"[success]✓ Removed: {removed}[/success]")
                        input("\nPress Enter to continue...")

    # Show final summary
    click.clear()
    console.print(f"\n[success]╔{'═' * 76}╗[/success]")
    console.print(_box_line("[bold]Configuration Saved[/bold]", border_style="success"))
    console.print(f"[success]╚{'═' * 76}╝[/success]\n")

    # Show enabled features
    enabled_features = []
    if settings["enable_stacktrace"]:
        enabled_features.append("Stack Traces")
    if settings["deactivate_unlink"]:
        enabled_features.append("Deactivate Unlink")
    if settings["enable_fritap"]:
        enabled_features.append(f"FriTap (output: {settings['fritap_output_dir']})")
    if settings["custom_scripts"]:
        enabled_features.append(f"{len(settings['custom_scripts'])} Custom Script(s)")

    if enabled_features:
        console.print("[success]✓ Enabled features:[/success]")
        for feature in enabled_features:
            console.print(f"  [success]●[/success] {feature}")
    else:
        console.print(
            "[primary]Using default configuration (no optional features enabled)[/primary]"
        )

    console.print()
    return settings


class MalwareMonitor(DataGather):
    """This class monitors provides a wrapper for the Dexray Intercept package to implement it into Sandroid.

    .. note::
        Inherits from :class:`DataGather`.

    **Attributes:**
        - **logger** (*Logger*): Logger instance for the class.
        - **last_results** (*dict*): Stores the last results of the monitoring.
        - **job_manager** (*JobManager*): Manages Frida jobs.
        - **process_session** (*Session*): Current Frida process session.
        - **app_package** (*str*): Package name of the application being monitored.
        - **profiler** (*AppProfiler*): Instance of the AppProfiler class.
        - **frida_script_path** (*str*): Path to the Frida script.
        - **running** (*bool*): Indicates if the monitoring is currently running.
        - **last_output** (*str*): Stores the last output of the profiling.
        - **_new_results_available** (*bool*): Indicates if there are new results available.
    """

    def __init__(
        self,
        path_filters=None,
        debug_mode=False,
        enable_full_stacktrace=False,
        enable_fritap=False,
        fritap_output_dir="fritap_output",
        custom_scripts=None,
        deactivate_unlink=False,
    ):
        """Initializes the MalwareMonitor with dexray-intercept API.

        :param path_filters: List of file paths to filter for monitoring.
        :type path_filters: list or None
        :param debug_mode: Enable verbose/debug output (shows devlog messages from dexray-intercept)
        :type debug_mode: bool
        :param enable_full_stacktrace: Enable full stack traces for hook invocations
        :type enable_full_stacktrace: bool
        :param enable_fritap: Enable fritap for TLS key extraction
        :type enable_fritap: bool
        :param fritap_output_dir: Directory for fritap output files (relative to dexray_intercept/)
        :type fritap_output_dir: str
        :param custom_scripts: List of paths to custom Frida scripts to load
        :type custom_scripts: list or None
        :param deactivate_unlink: Prevent file unlink operations
        :type deactivate_unlink: bool
        """
        super().__init__()

        if AppProfiler is None:
            logger.error(
                "dexray-intercept not available. MalwareMonitor will not function."
            )
            self.available = False
            return

        self.available = True
        if path_filters == []:
            self.path_filters = None
        else:
            self.path_filters = path_filters

        self.debug_mode = debug_mode  # Store debug mode for passing to dexray-intercept

        # Store AppProfiler settings (can be overridden by interactive configuration)
        self.profiler_settings = {
            "enable_stacktrace": enable_full_stacktrace,
            "deactivate_unlink": deactivate_unlink,
            "enable_fritap": enable_fritap,
            "fritap_output_dir": fritap_output_dir,
            "custom_scripts": custom_scripts or [],
        }

        # Keep individual attributes for backward compatibility and easy access
        self.enable_full_stacktrace = enable_full_stacktrace
        self.enable_fritap = enable_fritap
        self.fritap_output_dir = fritap_output_dir
        self.deactivate_unlink = deactivate_unlink
        self.custom_script = custom_scripts or []

        self.last_results = {}
        self.job_manager = Toolbox.get_frida_job_manager()
        self.process_session = None  # Will be set up with new API
        self.app_package = None
        self.frida_device = None
        self.profiler = None

        self.running = False
        self.last_output = None
        self._new_results_available = False

        # Snapshot management (for spawn mode)
        self.snapshot_name = (
            None  # Will be set if user creates snapshot before analysis
        )
        self.should_revert_snapshot = False  # Flag to track if we should revert on stop

        # Hook configuration for dexray-intercept
        # Enable critical hooks by default for malware analysis
        # Matches: dexray-intercept -s --enable-dex-unpacking --enable-aes --hooks-filesystem --hooks-network
        self.hook_config = {
            # Crypto hooks
            "aes_hooks": True,
            # Network hooks (--hooks-network)
            "web_hooks": True,
            "socket_hooks": True,
            # Filesystem hooks (--hooks-filesystem)
            "file_system_hooks": True,
            "database_hooks": False,
            # DEX unpacking hooks (--enable-dex-unpacking)
            "dex_unpacking_hooks": True,
            "java_dex_unpacking_hooks": True,
        }

        # Set up dedicated dexray logging
        _setup_dexray_logging()

        logger.info(
            "MalwareMonitor initialized with dexray-intercept API and path filters: "
            + str(self.path_filters)
        )

    def start_monitoring(self) -> bool:
        """Start monitoring the application (non-blocking).

        Returns:
            True if monitoring started successfully, False otherwise
        """
        if not self.available:
            logger.error(
                "MalwareMonitor not available due to missing dexray-intercept package"
            )
            return False

        if self.running:
            logger.warning("MalwareMonitor is already running")
            return False

        try:
            # Interactive hook selection FIRST (before spawning/attaching)
            if sys.stdin.isatty() and sys.stdout.isatty():
                try:
                    self.hook_config = _interactive_hook_selection(self.hook_config)
                except (KeyboardInterrupt, EOFError):
                    print("\n\nHook selection cancelled. Using default configuration.")
                    logger.info(
                        "Interactive hook selection cancelled by user, using defaults"
                    )

                # AppProfiler configuration SECOND (after hooks, before session)
                try:
                    configured_settings = _interactive_approfiler_configuration(
                        self.profiler_settings
                    )
                    if configured_settings:
                        # Update settings with user configuration
                        self.profiler_settings = configured_settings
                        # Sync individual attributes
                        self.enable_full_stacktrace = configured_settings[
                            "enable_stacktrace"
                        ]
                        self.deactivate_unlink = configured_settings[
                            "deactivate_unlink"
                        ]
                        self.enable_fritap = configured_settings["enable_fritap"]
                        self.fritap_output_dir = configured_settings[
                            "fritap_output_dir"
                        ]
                        self.custom_script = configured_settings["custom_scripts"]
                except (KeyboardInterrupt, EOFError):
                    print(
                        "\n\nAppProfiler configuration cancelled. Using default settings."
                    )
                    logger.info(
                        "Interactive AppProfiler configuration cancelled by user, using defaults"
                    )
            else:
                logger.info(
                    "Non-interactive session detected, using default hook configuration and AppProfiler settings"
                )

            # Snapshot creation prompt (SPAWN mode only, BEFORE session creation)
            # This ensures a clean state to revert to after analysis
            if Toolbox.is_spawn_mode() and sys.stdin.isatty() and sys.stdout.isatty():
                from datetime import datetime

                import click

                from sandroid.core.console import SandroidConsole

                console = SandroidConsole.get()
                console.print(f"\n[primary]╔{'═' * 76}╗[/primary]")
                console.print(_box_line("[bold]Snapshot Management[/bold]"))
                console.print(
                    _box_line(
                        "[accent]Create snapshot before analysis? (Allows revert after)[/accent]"
                    )
                )
                console.print(f"[primary]╠{'═' * 76}╣[/primary]")
                console.print(
                    _box_line(
                        "This will save the current AVD state before spawning the app.",
                        align="left",
                    )
                )
                console.print(
                    _box_line(
                        "You can revert to this state when stopping the analysis.",
                        align="left",
                    )
                )
                console.print(f"[primary]╠{'═' * 76}╣[/primary]")
                console.print(
                    _box_line(
                        "[success]\\[Y][/success] Yes (recommended)  "
                        "[error]\\[N][/error] No",
                        align="left",
                    )
                )
                console.print(f"[primary]╚{'═' * 76}╝[/primary]")

                console.print(
                    "\n[primary]Create snapshot? [[success]Y[/success]/[error]n[/error]]:[/primary] ",
                    end="",
                )
                choice = click.getchar().lower()
                console.print(f"[accent]{choice}[/accent]")

                if choice != "n":  # Default to yes (Enter, y, or any other key)
                    # Generate snapshot name with timestamp
                    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                    self.snapshot_name = f"sandroid_malware_{timestamp}".encode()

                    console.print(
                        f"\n[primary]Creating snapshot: [accent]{self.snapshot_name.decode()}[/accent][/primary]"
                    )
                    Toolbox.create_snapshot(self.snapshot_name)
                    self.should_revert_snapshot = True
                    console.print(
                        "[success]✓ Snapshot created successfully[/success]\n"
                    )
                    logger.info(f"Created snapshot: {self.snapshot_name.decode()}")
                else:
                    console.print("\n[warning]Skipping snapshot creation[/warning]\n")
                    logger.info("User declined snapshot creation")

            # NOW get the unified session (supports both spawn and attach modes)
            session, mode, app_info = Toolbox.get_frida_session_for_spotlight()

            self.dexray_mode = mode
            self.process_session = session
            self.app_package = app_info["package_name"]
            self.frida_device = app_info["device"]
            self._app_pid = app_info["pid"]

            # Get result folder path for dexray dumps
            # Use RESULTS_PATH to put dexray_intercept at root level (sibling to raw/)
            results_path = os.getenv("RESULTS_PATH", "./results/")
            dexray_base_path = os.path.join(results_path, "dexray_intercept")
            os.makedirs(dexray_base_path, exist_ok=True)

            # Make fritap_output_dir relative to dexray_intercept folder
            fritap_full_path = os.path.join(dexray_base_path, self.fritap_output_dir)

            # Create profiler with configured settings from interactive configuration
            # DUAL mode provides terminal output and JSON collection
            self.profiler = AppProfiler(
                self.process_session,
                self.debug_mode,
                output_format="DUAL",
                base_path=dexray_base_path,
                deactivate_unlink=self.deactivate_unlink,  # From configuration
                hook_config=self.hook_config,
                enable_stacktrace=self.enable_full_stacktrace,  # From configuration
                enable_fritap=self.enable_fritap,  # From configuration
                fritap_output_dir=fritap_full_path,  # Full path relative to dexray_intercept
                target_name=self.app_package,
                spawn_mode=self.dexray_mode,
                custom_scripts=self.custom_script,  # From configuration
            )

            # Start profiling
            script = self.profiler.start_profiling()
            self.running = True
            Toolbox.malware_monitor_running = True

            # Resume spawned process now that hooks are installed
            if mode == "spawn":
                Toolbox.resume_spawned_process_after_hooks(
                    self.frida_device, app_info["pid"]
                )

            logger.info(
                f"MalwareMonitor started in {mode.upper()} mode for package: {self.app_package} "
                f"(PID: {app_info['pid']})"
            )
            return True

        except Exception as e:
            logger.error(f"Error starting MalwareMonitor: {e}")
            self.running = False
            Toolbox.malware_monitor_running = False
            return False

    def stop_monitoring(self):
        """Stop monitoring and collect results."""
        if not self.running:
            logger.warning("MalwareMonitor is not running")
            return

        try:
            if self.profiler:
                self.profiler.stop_profiling()
                profile_data = self.profiler.get_profile_data()

                # Convert ProfileData to JSON-serializable dict
                # Try multiple methods to handle different dexray-intercept versions
                try:
                    # Pydantic v2
                    if hasattr(profile_data, "model_dump"):
                        self.last_output = profile_data.model_dump()
                    # Pydantic v1
                    elif hasattr(profile_data, "dict"):
                        self.last_output = profile_data.dict()
                    # Dataclass
                    elif hasattr(profile_data, "__dataclass_fields__"):
                        from dataclasses import asdict

                        self.last_output = asdict(profile_data)
                    # Fallback: use vars() or convert to string
                    else:
                        logger.warning(
                            "ProfileData type not recognized, attempting basic serialization"
                        )
                        self.last_output = (
                            vars(profile_data)
                            if hasattr(profile_data, "__dict__")
                            else str(profile_data)
                        )
                except Exception as conv_error:
                    logger.error(f"Failed to convert ProfileData to dict: {conv_error}")
                    # Store as string representation as last resort
                    self.last_output = {
                        "profile_data": str(profile_data),
                        "error": "Serialization failed",
                    }

                # Export JSON profile to dexray_intercept folder
                # Use RESULTS_PATH to put dexray_intercept at root level (sibling to raw/)
                results_path = os.getenv("RESULTS_PATH", "./results/")
                dexray_dir = os.path.join(results_path, "dexray_intercept")

                # Ensure dexray_intercept directory exists
                os.makedirs(dexray_dir, exist_ok=True)

                # Use timestamp format matching standalone dexray-intercept
                timestamp = time.strftime("%Y-%m-%d_%H-%M-%S")
                json_filename = f"profile_{self.app_package}_{timestamp}.json"
                json_filepath = os.path.join(dexray_dir, json_filename)

                try:
                    # Write profile data as JSON
                    written_path = (
                        self.profiler.profile_collector.write_profile_to_file(
                            json_filepath
                        )
                    )
                    success_msg = f"Dexray profile exported to: {written_path}"
                    logger.info(success_msg)
                    print(f"\n[+] {success_msg}")

                    # Register tool usage for exit summary
                    Toolbox.mark_tool_used("dexray-intercept", files=[written_path])
                except TypeError as type_error:
                    # Handle non-JSON-serializable objects (e.g., NetworkEvent)
                    logger.warning(f"Standard JSON serialization failed: {type_error}")
                    logger.info(
                        "Attempting fallback serialization with custom encoder..."
                    )

                    # Fallback: serialize with custom encoder that handles complex objects
                    try:
                        import json

                        def _json_encoder(obj):
                            """Custom JSON encoder for non-serializable objects."""
                            # Handle Pydantic models
                            if hasattr(obj, "model_dump"):
                                return obj.model_dump()
                            if hasattr(obj, "dict"):
                                return obj.dict()
                            # Handle dataclasses
                            if hasattr(obj, "__dataclass_fields__"):
                                from dataclasses import asdict

                                return asdict(obj)
                            # Handle objects with __dict__
                            if hasattr(obj, "__dict__"):
                                return obj.__dict__
                            # Handle datetime
                            if hasattr(obj, "isoformat"):
                                return obj.isoformat()
                            # Handle bytes
                            if isinstance(obj, bytes):
                                return obj.decode("utf-8", errors="replace")
                            # Fallback to string representation
                            return str(obj)

                        # Get profile data and serialize manually
                        if self.last_output:
                            with open(json_filepath, "w") as f:
                                json.dump(
                                    self.last_output, f, indent=2, default=_json_encoder
                                )
                            success_msg = f"Dexray profile exported (fallback) to: {json_filepath}"
                            logger.info(success_msg)
                            print(f"\n[+] {success_msg}")
                            Toolbox.mark_tool_used(
                                "dexray-intercept", files=[json_filepath]
                            )
                        else:
                            logger.warning(
                                "No profile data available for fallback export"
                            )
                    except Exception as fallback_error:
                        error_msg = f"Fallback export also failed: {fallback_error}"
                        logger.error(error_msg)
                        print(f"\n[-] {error_msg}")
                except Exception as export_error:
                    error_msg = f"Failed to export JSON profile to {json_filepath}: {export_error}"
                    logger.error(error_msg)
                    print(f"\n[-] {error_msg}")

                logger.info("MalwareMonitor stopped and data collected")

            # Snapshot revert prompt (if snapshot was created)
            if self.snapshot_name and self.should_revert_snapshot:
                if sys.stdin.isatty() and sys.stdout.isatty():
                    import click

                    from sandroid.core.console import SandroidConsole

                    console = SandroidConsole.get()
                    console.print(f"\n[primary]╔{'═' * 76}╗[/primary]")
                    console.print(_box_line("[bold]Snapshot Revert[/bold]"))
                    console.print(
                        _box_line(
                            f"[accent]Revert to snapshot: {self.snapshot_name.decode()}?[/accent]"
                        )
                    )
                    console.print(f"[primary]╠{'═' * 76}╣[/primary]")
                    console.print(
                        _box_line(
                            "This will restore the AVD to the state before analysis.",
                            align="left",
                        )
                    )
                    console.print(
                        _box_line(
                            "All changes made during analysis will be lost.",
                            align="left",
                        )
                    )
                    console.print(f"[primary]╠{'═' * 76}╣[/primary]")
                    console.print(
                        _box_line(
                            "[success]\\[Y][/success] Yes (recommended)  "
                            "[error]\\[N][/error] No (keep changes)",
                            align="left",
                        )
                    )
                    console.print(f"[primary]╚{'═' * 76}╝[/primary]")

                    console.print(
                        "\n[primary]Revert to snapshot? [[success]Y[/success]/[error]n[/error]]:[/primary] ",
                        end="",
                    )
                    choice = click.getchar().lower()
                    console.print(f"[accent]{choice}[/accent]")

                    if choice != "n":  # Default to yes
                        console.print(
                            f"\n[primary]Reverting to snapshot: [accent]{self.snapshot_name.decode()}[/accent][/primary]"
                        )
                        Toolbox.load_snapshot(self.snapshot_name)
                        console.print(
                            "[success]✓ Snapshot restored successfully[/success]\n"
                        )
                        logger.info(
                            f"Reverted to snapshot: {self.snapshot_name.decode()}"
                        )
                    else:
                        console.print(
                            "\n[warning]Keeping current AVD state[/warning]\n"
                        )
                        logger.info("User declined snapshot revert")

            self._new_results_available = True
        except Exception as e:
            logger.error(f"Error stopping MalwareMonitor: {e}")
        finally:
            # Always reset state flags to ensure clean state
            self.running = False
            Toolbox.malware_monitor_running = False

    def gather(self):
        """Gather data from the monitored application using dexray-intercept.

        .. warning::
            Context dependent behavior: Calling this method acts as a toggle, it starts or stops the monitoring process based on the current state.
        """
        if self.running:
            self.stop_monitoring()
        else:
            self.start_monitoring()

    def has_new_results(self):
        """Check if there are new results available.

        :returns: True if there are new results, False otherwise.
        :rtype: bool
        """
        if self.running:
            return False
        return self._new_results_available  # Updated variable name

    def return_data(self):
        """Return the last profiling data.

        This method returns the last profiling data and resets the new results flag.

        :returns: The last profiling data in JSON format.
        :rtype: str
        """
        self._new_results_available = False  # Updated variable name
        return self.last_output

    def pretty_print(self):
        """Not implemented"""
