### /home/matthew/mlg-cli/src/henchman/cli/repl.py
```python
1: """REPL (Read-Eval-Print Loop) for interactive mode.
2: 
3: This module provides the main interactive loop for the CLI.
4: """
5: 
6: from __future__ import annotations
7: 
8: import asyncio
9: import contextlib
10: import time
11: from dataclasses import dataclass
12: from pathlib import Path
13: from typing import Any
14: 
15: from rich.console import Console
16: 
17: from henchman.cli.commands import CommandContext, CommandRegistry, parse_command
18: from henchman.cli.commands.builtins import get_builtin_commands
19: from henchman.cli.console import OutputRenderer
20: from henchman.cli.input import create_session, expand_at_references, is_slash_command
21: from henchman.config.schema import Settings
22: from henchman.core.agent import Agent
23: from henchman.core.events import AgentEvent, EventType
24: from henchman.core.session import Session, SessionManager, SessionMessage
25: from henchman.providers.base import ModelProvider, ToolCall
26: from henchman.tools.registry import ToolRegistry
27: from henchman.tools.builtins import (
28:     AskUserTool,
29:     EditFileTool,
30:     GlobTool,
31:     GrepTool,
32:     LsTool,
33:     ReadFileTool,
34:     ShellTool,
35:     WebFetchTool,
36:     WriteFileTool,
37: )
38: 
39: 
40: @dataclass
41: class ReplConfig:
42:     """Configuration for the REPL.
43: 
44:     Attributes:
45:         prompt: The prompt string to display.
46:         system_prompt: System prompt for the agent.
47:         auto_save: Whether to auto-save sessions.
48:     """
49: 
50:     prompt: str = "â¯ "
51:     system_prompt: str = ""
52:     auto_save: bool = True
53: 
54: 
55: class Repl:
56:     """The main REPL (Read-Eval-Print Loop) for interactive mode.
57: 
58:     The Repl class orchestrates the main interaction loop, connecting
59:     the agent, tools, commands, and UI components.
60:     """
61: 
62:     def __init__(
63:         self,
64:         provider: ModelProvider,
65:         console: Console,
66:         config: ReplConfig | None = None,
67:         session_manager: SessionManager | None = None,
68:         settings: Settings | None = None,
69:     ) -> None:
70:         """Initialize the REPL.
71: 
72:         Args:
73:             provider: The model provider to use.
74:             console: Rich console for output.
75:             config: REPL configuration.
76:             session_manager: Optional session manager for saving sessions.
77:             settings: Global application settings.
78:         """
79:         self.provider = provider
80:         self.console = console
81:         self.config = config or ReplConfig()
82:         self.settings = settings
83:         self.session_manager = session_manager or SessionManager()
84:         self.session: Session | None = None
85: 
86:         # Initialize components
87:         self.tool_registry = ToolRegistry()
88:         self._register_builtin_tools()
89:         
90:         # Create agent with tools from registry
91:         self.agent = Agent(
92:             provider, 
93:             tools=self.tool_registry.get_declarations(),
94:             system_prompt=self.config.system_prompt
95:         )
96:         
97:         self.command_registry = CommandRegistry()
98:         self.renderer = OutputRenderer(console)
99:         self.prompt_session = create_session(bottom_toolbar=self._get_toolbar_status)
100: 
101:         # Register built-in commands
102:         for cmd in get_builtin_commands():
103:             self.command_registry.register(cmd)
104: 
105:         # Initialize session
106:         project_hash = self.session_manager.compute_project_hash(Path.cwd())
107:         self.session = self.session_manager.create_session(project_hash)
108: 
109:         # Track REPL state
110:         self.running = False
111: 
112:         # Track if agent is currently running (for interruption)
113:         self.agent_running = False
114:         self._agent_task: asyncio.Task[Any] | None = None
115: 
116:         # Track Ctrl+C timing for double-tap exit
117:         self._last_interrupt_time: float | None = None
118: 
119:     def _register_builtin_tools(self) -> None:
120:         """Register all built-in tools with the tool registry."""
121:         builtin_tools = [
122:             AskUserTool(),
123:             EditFileTool(),
124:             GlobTool(),
125:             GrepTool(),
126:             LsTool(),
127:             ReadFileTool(),
128:             ShellTool(),
129:             WebFetchTool(),
130:             WriteFileTool(),
131:         ]
132:         
133:         for tool in builtin_tools:
134:             try:
135:                 self.tool_registry.register(tool)
136:             except ValueError:
137:                 # Tool already registered, skip
138:                 pass
139: 
140:     async def run(self) -> None:
141:         """Run the main REPL loop.
142: 
143:         This method runs until the user exits with /quit, Ctrl+C, or Ctrl+D.
144:         """
145:         self.running = True
146:         self._print_welcome()
147: 
148:         try:
149:             while self.running:
150:                 try:
151:                     user_input = await self._get_input()
152:                     should_continue = await self.process_input(user_input)
153:                     if not should_continue:
154:                         break
155:                 except KeyboardInterrupt:
156:                     # Ctrl+C handling with double-tap to exit
157:                     current_time = time.time()
158: 
159:                     # Check if this is a double Ctrl+C within 2 seconds
160:                     if self._last_interrupt_time is not None:
161:                         time_since_last = current_time - self._last_interrupt_time
162:                         if time_since_last < 2.0:  # Double Ctrl+C within 2 seconds
163:                             self.console.print("\n[bold red]Exiting...[/]")
164:                             break  # Exit the REPL
165: 
166:                     # Check if agent is running and interrupt it
167:                     if self.agent_running and self._agent_task:  # pragma: no cover
168:                         self.console.print("\n[dim]Interrupting agent...[/]")
169:                         self._agent_task.cancel()
170:                         with contextlib.suppress(asyncio.CancelledError):
171:                             await self._agent_task
172:                         self.agent_running = False
173:                         self._agent_task = None
174:                     else:  # pragma: no cover
175:                         pass
176: 
177:                     # First Ctrl+C or spaced out
178:                     self.console.print("\n[dim]Press Ctrl+C again to exit[/]")
179:                     self._last_interrupt_time = current_time
180:                     continue
181:                 except EOFError:
182:                     self.console.print()
183:                     break
184:         finally:
185:             self.running = False
186:             self._auto_save_session()
187:             self._print_goodbye()
188: 
189:     def _print_welcome(self) -> None:
190:         """Print welcome message."""
191:         self.console.print(
192:             "[bold blue]Henchman-AI[/] - /help for commands, /quit to exit\n"
193:         )
194: 
195:     def _print_goodbye(self) -> None:
196:         """Print goodbye message."""
197:         self.console.print("[dim]Goodbye![/]")
198: 
199:     def _auto_save_session(self) -> None:
200:         """Auto-save the session if enabled and session has content."""
201:         if not self.config.auto_save:
202:             return
203:         if self.session_manager is None or self.session is None:  # pragma: no cover
204:             return
205:         if len(self.session.messages) == 0:
206:             return
207: 
208:         self.session_manager.save(self.session)
209: 
210:     def _get_toolbar_status(self) -> list[tuple[str, str]]:
211:         """Get the status for the bottom toolbar.
212: 
213:         Returns:
214:             List of style/text tuples for the toolbar.
215:         """
216:         from henchman.providers.base import Message
217:         from henchman.utils.tokens import TokenCounter
218: 
219:         mode = "CHAT"
220:         if self.session and self.session.plan_mode:
221:             mode = "PLAN MODE"
222: 
223:         status = [("class:toolbar.mode", f" {mode} ")]
224: 
225:         try:
226:             if self.session:
227:                 counter = TokenCounter()
228:                 messages = [
229:                     Message(role=m.role, content=m.content or "")
230:                     for m in self.session.messages
231:                 ]
232:                 token_count = counter.count_messages(messages)
233:                 status.append(("class:toolbar.tokens", f" Tokens: {token_count} "))
234:         except Exception:
235:             # Silently fail if token counting fails
236:             pass
237: 
238:         return status
239: 
240:     async def _get_input(self) -> str:
241:         """Get input from the user.
242: 
243:         Returns:
244:             User input string.
245: 
246:         Raises:
247:             KeyboardInterrupt: If user presses Ctrl+C.
248:             EOFError: If user presses Ctrl+D.
249:         """
250:         return await self.prompt_session.prompt_async(self.config.prompt)
251: 
252:     async def process_input(self, user_input: str) -> bool:
253:         """Process a single user input.
254: 
255:         Args:
256:             user_input: The user's input string.
257: 
258:         Returns:
259:             True to continue running, False to exit.
260:         """
261:         # Skip empty input
262:         stripped = user_input.strip()
263:         if not stripped:
264:             return True
265: 
266:         # Handle slash commands
267:         if is_slash_command(stripped):
268:             return await self._handle_command(stripped)
269: 
270:         # Expand @file references
271:         expanded = await expand_at_references(stripped)
272: 
273:         # Run through agent
274:         await self._run_agent(expanded)
275:         return True
276: 
277:     async def _handle_command(self, input_text: str) -> bool:
278:         """Handle a slash command.
279: 
280:         Args:
281:             input_text: The command input (with leading /).
282: 
283:         Returns:
284:             True to continue running, False to exit.
285:         """
286:         parsed = parse_command(input_text)
287:         if parsed is None:
288:             return True
289: 
290:         cmd_name, args = parsed
291: 
292:         # Special handling for /quit
293:         if cmd_name == "quit":
294:             return False
295: 
296:         # Special handling for /clear - clear agent history
297:         if cmd_name == "clear":
298:             self.agent.clear_history()
299:             self.renderer.console.clear()
300:             self.renderer.success("History cleared")
301:             return True
302: 
303:         # Try to execute the command
304:         cmd = self.command_registry.get(cmd_name)
305:         if cmd is None:
306:             self.renderer.error(f"Unknown command: /{cmd_name}")
307:             self.renderer.muted("Type /help for available commands")
308:             return True
309: 
310:         ctx = CommandContext(
311:             console=self.console,
312:             args=args,
313:             agent=self.agent,
314:             tool_registry=self.tool_registry,
315:             session=self.session,
316:         )
317:         await cmd.execute(ctx)
318:         return True
319: 
320:     async def _run_agent(self, user_input: str) -> None:
321:         """Run the agent with user input.
322: 
323:         Args:
324:             user_input: The processed user input.
325:         """
326:         # Mark agent as running
327:         self.agent_running = True
328:         self._agent_task = asyncio.current_task()
329: 
330:         # Record user message to session
331:         if self.session is not None:  # pragma: no branch
332:             self.session.messages.append(SessionMessage(role="user", content=user_input))
333: 
334:         # Collect assistant response
335:         assistant_content: list[str] = []
336: 
337:         try:
338:             async for event in self.agent.run(user_input):
339:                 await self._handle_agent_event(event, assistant_content)
340:         except Exception as e:  # pragma: no cover
341:             self.renderer.error(f"Error: {e}")
342:         finally:
343:             # Mark agent as not running
344:             self.agent_running = False
345:             self._agent_task = None
346: 
347:         # Record assistant response to session
348:         if self.session is not None and assistant_content:
349:             self.session.messages.append(
350:                 SessionMessage(role="assistant", content="".join(assistant_content))
351:             )
352: 
353:     async def _handle_agent_event(
354:         self, event: AgentEvent, content_collector: list[str] | None = None
355:     ) -> None:
356:         """Handle an event from the agent.
357: 
358:         Args:
359:             event: The agent event to handle.
360:             content_collector: Optional list to collect content for session recording.
361:         """
362:         if event.type == EventType.CONTENT:
363:             # Stream content to console
364:             self.console.print(event.data, end="")
365:             # Collect for session recording
366:             if content_collector is not None and event.data:
367:                 content_collector.append(event.data)
368: 
369:         elif event.type == EventType.THOUGHT:
370:             # Show thinking in muted style
371:             self.renderer.muted(f"[thinking] {event.data}")
372: 
373:         elif event.type == EventType.TOOL_CALL_REQUEST:
374:             # Handle tool call
375:             await self._handle_tool_call(event.data)
376: 
377:         elif event.type == EventType.FINISHED:
378:             # Print newline after streaming content
379:             self.console.print()
380: 
381:         elif event.type == EventType.ERROR:
382:             self.renderer.error(str(event.data))  # pragma: no branch
383: 
384:     async def _handle_tool_call(self, tool_call: ToolCall) -> None:
385:         """Handle a tool call from the agent.
386: 
387:         Args:
388:             tool_call: The tool call to execute.
389:         """
390:         if not isinstance(tool_call, ToolCall):
391:             return
392: 
393:         self.renderer.muted(f"\n[tool] {tool_call.name}({tool_call.arguments})")
394: 
395:         # Execute the tool
396:         result = await self.tool_registry.execute(tool_call.name, tool_call.arguments)
397: 
398:         # Show result to user
399:         if result.display:
400:             self.renderer.info(result.display)
401:         elif result.success:
402:             self.renderer.success(f"Tool {tool_call.name} executed successfully")
403:         else:
404:             self.renderer.error(f"Tool {tool_call.name} failed: {result.error}")
405: 
406:         # Submit result to agent
407:         self.agent.submit_tool_result(tool_call.id, result.content)
408: 
409:         # Continue agent execution with tool result
410:         async for event in self.agent.continue_with_tool_results():
411:             await self._handle_agent_event(event)
```
