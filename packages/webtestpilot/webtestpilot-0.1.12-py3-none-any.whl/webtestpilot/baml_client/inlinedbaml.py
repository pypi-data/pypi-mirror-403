# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

_file_map = {

    "clients.baml": "// Learn more about clients at https://docs.boundaryml.com/docs/snippets/clients/overview\n\n// This is a stub client definition.\n// Actual provider clients (with real implementations) are selected and\n// instantiated at runtime based on the config/env\nclient<llm> Base {\n  provider \"openai-generic\"\n  options {\n    base_url \"\"\n  }\n}\n\nclient<llm> GPT_5 {\n  provider openai\n  options {\n    model \"gpt-5\"\n    base_url env.OPENAI_BASE_URL\n    api_key env.OPENAI_API_KEY\n  }\n}\n\nclient<llm> GPT_4_1 {\n  provider openai\n  options {\n    model \"gpt-4.1\"\n    base_url env.OPENAI_BASE_URL\n    api_key env.OPENAI_API_KEY\n    temperature 0.0\n  }\n}\n\nclient<llm> GPT_4_1_mini {\n  provider openai\n  options {\n    model \"gpt-4.1-mini\"\n    base_url \"https://api.key77qiqi.com/v1\"\n    api_key env.OPENAI_API_KEY\n    temperature 0.0\n  }\n}\n\nclient<llm> GPT_4_o_mini {\n  provider openai\n  options {\n    model \"gpt-4o-mini\"\n    base_url \"https://api.key77qiqi.com/v1\"\n    api_key \"sk-Sa9jcgKwFMrKXkHDHxulrgYXMWpMRyt3sGEAxbtHcvGTBaC0\"\n    temperature 0.0\n  }\n}\n\nclient<llm> GUI_Grounding_Model {\n  provider \"openai-generic\"\n  options {\n    base_url \"http://202.120.37.109:23497/v1\"\n    model \"inclusionAI/UI-Venus-Ground-7B\"\n    api_key \"token-abc123\"\n    temperature 0.0\n  }\n}",
    "executor/action.baml": "template_string SoMPrompt(screenshot: image, task: string, active_elements: string) #\"\n  {{_.role(\"user\")}}\n  You are a UI/UX expert skilled at interacting with websites.\n\n  You are provided with:\n  1. A screenshot of the current web application state.\n  2. A mapping of active elements in the form [ID] -> [XPATH].\n    - Each active element has been overlaid with a colored box and labeled with a numerical [ID] visible on the screenshot.\n\n  Please follow these steps in order:\n  1. Analyze the screenshot and mapping to determine the next action required to complete the task.\n  2. List all active elements as [ID] -> [Expected Function], describing what each element likely does.\n  3. Propose one or more of the following actions in Python format, calling the functions directly as shown below (within a Python code block):\n  \n  ```python\n  click_by_label(label=\"...\") # Click on an element given its label. Arg: label (int)\n  type(label=\"...\", content=\"...\") # Type text into an input element given its label. Args: label (int), content (string)\n  press(key=\"...\") # Press Playwright keyboard key or character. Args: key (str)\n  no_answer() # If none of the colored boxes is the target, use this to request new boxes\n  wait() # Wait for 5s to load changes.\n  scroll() # Scroll to the bottom by one page height\n  finished() # No action required\n  ```\n\n  Pay attention to numerical labels that overlap other active elements; each label corresponds to the box of the same color.\n  Output by only following the steps.\n  If no GUI element matches the task, use `no_answer()`.\n  \n  Example output:\n  ```python\n  # Active elements:\n  # 55 -> 选择日期 12-28\n  # 56 -> 选择日期 12-29\n\n  click_by_label(label=\"56\")\n  ```\n\n  Task description: {{ task }}\n  Active elements:\n  {{ active_elements }}\n  Screenshot: {{ screenshot }}\n\"#\n\nfunction ProposeSoMActions(screenshot: image, task: string, active_elements: string) -> string {\n  client \"Base\"\n  prompt #\"\n    {{ SoMPrompt(screenshot, task, active_elements) }}\n  \"#\n}\n\nfunction LocateUIElement(screenshot: image, description: string) -> string {\n  client \"GUI_Grounding_Model\"\n  prompt #\"\n    {{_.role(\"user\")}}\n    Outline the position corresponding to the instruction and target description: {{description}}.\n    The output should be only [x1,y1,x2,y2].\n    Screenshot: {{ screenshot }}\n  \"#\n}\n\nfunction LLMCoordinate(screenshot: image, description: string) -> string {\n  client \"GPT_4_o_mini\"\n  prompt #\"\n    {{_.role(\"user\")}}\n    Outline the position corresponding to the instruction and target description: {{description}}.\n    The output should be only [x1,y1,x2,y2].\n    Screenshot: {{ screenshot }}\n  \"#\n}\n\ntest LLMCoordiateTest {\n  functions [LLMCoordinate]\n  args {\n    description \"Choose Beijing as destination\"\n    screenshot {file \"/Users/abcbum/Desktop/Projects/Cophi/GUI-Optimization/rlm-minimal/examples/Test.png\"}\n  }\n}\n\ntest GUI_Grounding_Model {\n  functions [LocateUIElement]\n  args {\n    description \"Choose Beijing as destination\"\n    screenshot {file \"/Users/abcbum/Desktop/Projects/Cophi/GUI-Optimization/rlm-minimal/examples/Test.png\"}\n  }\n}",
    "executor/assertion.baml": "class Step {\n  action string\n  expectation string\n}\n\nclass TestCase {\n  name string\n  steps Step[]\n}\n\nclass Feedback {\n    response string\n    reason string\n}\n\nclass History {\n    page_id string\n    layout string?\n    description string?\n    prev_action string?\n}\n\ntemplate_string Specification() #\"\n    # API Specification\n\n    ### Session API\n    - `history -> list[State]`: Chronological sequence of all captured states in the current test session.\n\n    ### State API\n    - `page_id -> str`: Canonical identifier for logical page/state identity.\n    - `title -> str`: Browser tab's visible title.\n    - `url -> str`: Current browser URL.\n    - `extract(instruction: str, schema: Type[BaseModel]) -> Type[BaseModel]`: Extract structured data from the state. `schema` should be a class inherited from `BaseModel`, NOT `BaseModel` itself.\n\n    Important requirements for `schema`:\n      - `schema` must be a subclass of `BaseModel` (a class that inherits from `BaseModel` and defines fields). Do NOT pass `BaseModel` itself.\n      - The subclass should declare the expected fields and their types. Example:\n        ```python\n        class User(BaseModel):\n            id: int\n            name: str\n        ```\n      - The extractor will populate and return an instance of the provided subclass (or data matching its schema). Provide only class objects, not instances or the `BaseModel` base class.\n      - If you provide a schema that is not a subclass of `BaseModel` or omits required fields, extraction will fail. Ensure the schema accurately reflects the structure you expect to extract from the state.\n      - Note that `list` or `dict` or `list[dict]` are not supported types for attributes, please specify inner types properly such as `list[str]`, ...\n      - Use same language with the interface for clarity when use .extract(). i.e. in Chinese interface, use Chinese terms in instruction.\n      - When want to get a list of items, please define a wrapper model. For example, to extract a list of `User` objects, define:\n        ```python\n        class User(BaseModel):\n            id: int\n            name: str\n        class UserList(BaseModel):\n            users: list[User]\n        ```\n        Then use `extract(\"...\", schema=UserList).users` to get it.\n\n    Examples:\n    - Correct: `extract(\"get user\", schema=User)` where `User` inherits from `BaseModel`.\n    - Incorrect: `extract(\"get user\", schema=BaseModel)` (do not pass the base type).\n\"#\n\ntemplate_string FormatHistory(history: History[]) #\"\n    {% for state in history %}\n    {% if loop.index == loop.length %}\n    Current State:\n    {% else %}\n    State ({{ loop.index0 }}):\n    {% endif %}\n        Page: {{ state.page_id or 'Unknown' }}\n    {% if state.description %}\n        Description: {{ state.description }}\n    {% endif %}\n    {% if state.layout %}\n        Layout: {{ state.layout }}\n    {% endif %}\n    {% if loop.index < loop.length %}\n        Action: {{ history[loop.index].prev_action }}\n    {% endif %}\n    {% endfor %}\n\"#\n\ntemplate_string FormatFeedback(feedback: Feedback[]) #\"\n    {% if feedback %}\n    {% for f in feedback %}\n    {{ _.role(\"user\") }}\n    # Feedback\n\n    Your previous assertion(s) might be incorrect:\n\n    {{ f.response }}\n\n    Reason: {{ f.reason }}\n\n    If you insist that it is correct, please output the same thing\n    Otherwise, modify the assertion\n    {% endfor %}\n    {% endif %}\n\"#",
    "executor/methods.baml": "class Output {\n    @@dynamic\n}\n\ntype Primitives = string | int | float | bool\ntype ExtractedData = Output | Primitives | Output[] | Primitives[]\n\n\nfunction ExtractFromState(screenshot: image, instruction: string) -> Output {\n    client \"Base\"\n    prompt #\"\n        {{_.role(\"user\")}}\n        Extract structured data from the webpage screenshot that is relevant to the instruction.\n\n        Screenshot: {{ screenshot }}\n\n        Instruction: {{ instruction }}\n        Make sure to comply the schema requirements. In case of list, no element match should return an empty list, not null.\n\n        {{ ctx.output_format }}\n    \"#\n}\n\nfunction ExtractFromElement(screenshot: image, html: string, instruction: string) -> Output {\n    client \"Base\"\n    prompt #\"\n        {{_.role(\"user\")}}\n        Extract structured data from the web UI element screenshot and HTML that is relevant to the instruction.\n\n        {{ screenshot }}\n\n        {{ html }}\n\n        Instruction: {{ instruction }}\n\n        {{ ctx.output_format }}\n    \"#\n}",
    "executor/postcondition.baml": "template_string PostconditionIntro() #\"\n    # Role\n    You are an expert QA tester.\n\n    # Objective\n    You are generating a **postcondition assertion** after a specific user action has been executed.\n    Your goal is to verify that the intended **effects** of the action have occurred.\n\n    # Instructions\n    - Construct a Python assertion function using the provided Session, State, and Element APIs as detailed below.\n    - Focus on **postcondition verification**: ensure the *intended outcome* is reflected in the state after the action.\n    - Identify which dependency types are relevant to the state change:\n        1. **Temporal Dependency:** Changes in a logical page over time (e.g., after an action, a formerly empty cart now has items).\n        2. **Data Dependency:** Propagation of information across states (e.g., product details remain consistent from search result to cart addition).\n        3. **Causal Dependency:** State changes resulting directly from user actions (e.g., clicking 'search' updates the page to show related items).\n    - Grounding: Use only information provided in the session or state. Do not invent or guess labels, text, or values.\n    - Prefer structural checks (e.g., count > 0, len >= N, is not None) when exact expected values are not known.\n    - No placeholders. Even if expectations are minimal.\n\n    - Write the assertion as a Python block:\n        ```python\n        def postcondition(session: Session):\n            ...\n        ```\n\n    # Important on assertion messages\n    - Assertions MUST have insightful, helpful messages with it, i.e. \"Message shown is not ...\", ...\n    - Messages should be helpful feedbacks for developer to know what to improve.\n\n    # MUST remember\n    - `schema` are classes that inherit from `BaseModel` but MUST MUST MUST NOT be `BaseModel` itself!.\n    - Code MUST be executable and does not have type error.\n    - Data models should be concise and sufficient for the assertions, unrelated details should be ignored.\n    - Use descriptive variable names for clarity.\n    - Minimal and to the point assertions.\n\n    # Avoid Common Pitfalls\n    - Avoid writing hardcoded values.\n    - Avoid checking page titles, `page_id` or `url`.\n    - Avoid matching exact terms or keywords in assertions, extract and check empty is better.\n\"#\n\ntemplate_string PostconditionExample() #\"\n    # Example 1\n    __input__\n    History:\n        State (0):\n            Page: Cart page;\n            Action: User clicks \"Continue Shopping\"\n        ...\n        State (4):\n            Page: Product detail view\n            Action: User adds the item to cart\n\n    Current: Cart page (After action)\n    Assert: Cart is correctly updated\n\n    __output__\n    ```python\n    def postcondition(session: Session):\n        # Define data models\n        class Product(BaseModel):\n            title: str = Field(..., description=\"The name of the product\")\n            price: float = Field(..., description=\"The unit price of the product in local currency\")\n            quantity: Optional[int] = Field(None, \"The quantity of this product (used in cart contexts). None indicates unlimited or not specified\")\n        \n        class Cart(BaseModel):\n            items: List[Product] = Field(default_factory=list, description=\"List of products in the cart with their respective quantities\")\n\n        # Extract product from latest state\n        added = session.history[-2].extract(\"get product detail\", schema=Product)\n\n        # Get current and prior cart items\n        current = session.history[-1].extract(\"get cart summary\", schema=Cart).items\n        prior = session.history[0].extract(\"get cart summary\", schema=Cart).items\n\n        # Assert cart contains prior items plus the added product\n        assert set(p.title for p in current) == set(p.title for p in prior + [added]) , \"Cart items do not match expected items after addition.\"\n\n    # Example 2: Check boolean flags\n    __input__\n    History: ...\n    Current State:\n        Page: Service Page\n        Description: ...\n        Layout: <Page>...</Page>\n    Current: Click \"Service\" button\n    Assert: Service page shows up\n\n    __output__\n    ```python\n    def postcondition(session: Session):\n        # Define data models for presence checking\n        class PresenceChecking(BaseModel):\n            service_menu_is_selected: bool = Field(..., description=\"Indicates if option A is selected\")\n            service_page_is_present: bool = Field(..., description=\"Indicates if the current page is related to services\")\n        \n        presence_checking = session.history[-1].extract(\"Check if the page is a service page\", schema=PresenceChecking)\n\n        # Check if service page is present\n        assert presence_checking.service_page_is_present is True, \"Service page is not displayed as expected.\"\n\n        # Check other flags if needed\n        assert presence_checking.service_menu_is_selected is False, \"Service menu should be selected.\"\n    ```\n\"#\n\nfunction GeneratePostcondition(screenshot: image, history: History[], action: string, verify: string, feedback: Feedback[]) -> string {\n    client \"Base\"\n    prompt #\"\n        {{_.role(\"system\")}}\n        {{ PostconditionIntro() }}\n        {{ Specification() }}\n        {{ PostconditionExample() }}\n\n        {{_.role(\"user\")}}\n        {{ screenshot }}\n\n        {{ FormatHistory(history) }}\n        After Action: {{ action }}\n        Assert: {{ verify }}\n        {{ FormatFeedback(feedback) }}\n    \"#\n}",
    "executor/reidentification.baml": "class PageAbstract {\n  name string\n  description string\n  layout string\n}\n\n\nfunction IsSameLogicalPage(page_a: image, page_b: image) -> bool {\n  client \"Base\"\n  prompt #\"\n    {{_.role(\"user\")}}\n    You are an expert UI/UX evaluator with deep knowledge of web page layout, semantics, and interaction patterns.\n\n    You are given two page screenshots. Determine whether they represent the same logical page \n    (i.e., the same underlying page in a web application or site), even if their visual states differ.\n\n    Guidelines:\n    1. Layout Consistency: Do the overall structure and arrangement of UI components match?\n\n    2. Functional Equivalence: Do they offer the same set of core actions and interactions?\n\n    3. Navigation Equivalence: Do they provide the same pathways to other parts of the application?\n\n    4. Two pages can be the same, even if their visual states differ. For example:\n        - One shows an expanded/triggered widget (e.g., dropdown, modal, accordion, pop-up).\n        - One contains different dynamic data but with the same type, structure, and placement.\n        - One has pre-filled or empty form fields, as long as the underlying form is the same.\n\n    {{ ctx.output_format }} with only \"True\" or \"False\".\n\n    {{ page_a }}\n\n    {{ page_b}}\n  \"#\n}\n\n\nfunction AbstractPage(page: image) -> PageAbstract {\n  client \"Base\"\n  prompt #\"\n    {{_.role(\"user\")}}\n    You are an expert UI/UX evaluator with deep knowledge of web page layout, semantics, and interaction patterns.\n    \n    You are given a page screenshot.\n    1. Assign a clear, semantically meaningful name to the page (e.g., Shopping Cart Page).\n    2. Write a summary <15 words describing both the function and visual state of the page.\n    3. Analyze the layout: extract as a page template in XML format. You may include non-data attributes for context.\n      ```example\n      <Page>\n        <Header visibleFor=\"allUsers\" role=\"navigation\" hasNotifications=\"true\" />\n        <Sidebar collapsible=\"true\" visible=\"true\" contains=\"menuItems\" />\n        <Breadcrumb currentPage=\"true\" hasPath=\"true\" />\n        <MainContent>\n          <CartItems type=\"list\" itemType=\"product\" selectable=\"true\" hasQuantity=\"true\" hasPrice=\"true\" availabilityState=\"enum\" />\n          <Recommendations type=\"list\" itemType=\"product\" algorithmType=\"collaborativeFiltering\" />\n        </MainContent>\n        <Footer role=\"footer\" contains=\"links,contactInfo\" />\n      </Page>\n      ```\n\n    {{ ctx.output_format }}\n\n    {{ page }}\n  \"#\n}",
    "generators.baml": "// This helps use auto generate libraries you can use in the language of\n// your choice. You can have multiple generators if you use multiple languages.\n// Just ensure that the output_dir is different for each generator.\ngenerator target {\n    // Valid values: \"python/pydantic\", \"typescript\", \"ruby/sorbet\", \"rest/openapi\"\n    output_type \"python/pydantic\"\n\n    // Where the generated code will be saved (relative to baml_src/)\n    output_dir \"../src/webtestpilot\"\n\n    // The version of the BAML package you have installed (e.g. same version as your baml-py or @boundaryml/baml).\n    // The BAML VSCode extension version should also match this version.\n    version \"0.214.0\"\n\n    // Valid values: \"sync\", \"async\"\n    // This controls what `b.FunctionName()` will be (sync or async).\n    default_client_mode sync\n}\n",
}

def get_baml_files():
    return _file_map