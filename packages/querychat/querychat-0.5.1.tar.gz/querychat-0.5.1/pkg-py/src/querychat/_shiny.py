from __future__ import annotations

from typing import TYPE_CHECKING, Any, ClassVar, Literal, Optional, overload

from narwhals.stable.v1.typing import IntoDataFrameT, IntoFrameT, IntoLazyFrameT
from shiny.express._stub_session import ExpressStubSession
from shiny.session import get_current_session
from shinychat import output_markdown_stream

from shiny import App, Inputs, Outputs, Session, reactive, render, req, ui

from ._icons import bs_icon
from ._querychat_base import TOOL_GROUPS, QueryChatBase
from ._shiny_module import ServerValues, mod_server, mod_ui
from ._utils import as_narwhals

if TYPE_CHECKING:
    from pathlib import Path

    import chatlas
    import ibis
    import narwhals.stable.v1 as nw
    import sqlalchemy
    from narwhals.stable.v1.typing import IntoFrame


class QueryChat(QueryChatBase[IntoFrameT]):
    """
    Create a QueryChat instance for Shiny applications.

    QueryChat enables natural language interaction with your data through an
    LLM-powered chat interface. It can be used in Shiny applications, as a
    standalone chat client, or in an interactive console.

    Examples
    --------
    **Basic Shiny app:**
    ```python
    from querychat import QueryChat

    qc = QueryChat(my_dataframe, "my_data")
    qc.app()
    ```

    **Standalone chat client:**
    ```python
    from querychat import QueryChat
    import pandas as pd

    df = pd.DataFrame({"a": [1, 2, 3], "b": [4, 5, 6]})
    qc = QueryChat(df, "my_data")

    # Get a chat client with all tools
    client = qc.client()
    response = client.chat("What's the average of column a?")

    # Start an interactive console chat
    qc.console()
    ```

    **Privacy-focused mode:** Only allow dashboard filtering, ensuring the LLM
    can't see any raw data.
    ```python
    qc = QueryChat(df, "my_data", tools="update")
    qc.app()
    ```

    Parameters
    ----------
    data_source
        Either a Narwhals-compatible data frame (e.g., Polars or Pandas) or a
        SQLAlchemy engine containing the table to query against.
    table_name
        If a data_source is a data frame, a name to use to refer to the table in
        SQL queries (usually the variable name of the data frame, but it doesn't
        have to be). If a data_source is a SQLAlchemy engine, the table_name is
        the name of the table in the database to query against.
    id
        An optional ID for the QueryChat module. If not provided, an ID will be
        generated based on the table_name.
    greeting
        A string in Markdown format, containing the initial message. If a
        pathlib.Path object is passed, querychat will read the contents of the
        path into a string with `.read_text()`. You can use
        `querychat.greeting()` to help generate a greeting from a querychat
        configuration. If no greeting is provided, one will be generated at the
        start of every new conversation.
    client
        A `chatlas.Chat` object or a string to be passed to
        `chatlas.ChatAuto()`'s `provider_model` parameter, describing the
        provider and model combination to use (e.g. `"openai/gpt-4.1"`,
        "anthropic/claude-sonnet-4-5", "google/gemini-2.5-flash". etc).

        If `client` is not provided, querychat consults the
        `QUERYCHAT_CLIENT` environment variable. If that is not set, it
        defaults to `"openai"`.
    tools
        Which querychat tools to include in the chat client by default. Can be:
        - A single tool string: `"update"` or `"query"`
        - A tuple of tools: `("update", "query")`
        - `None` or `()` to disable all tools

        Default is `("update", "query")` (both tools enabled).

        Set to `"update"` to prevent the LLM from accessing data values, only
        allowing dashboard filtering without answering questions.

        The tools can be overridden per-client by passing a different `tools`
        parameter to the `.client()` method.
    data_description
        Description of the data in plain text or Markdown. If a pathlib.Path
        object is passed, querychat will read the contents of the path into a
        string with `.read_text()`.
    categorical_threshold
        Threshold for determining if a column is categorical based on number of
        unique values.
    extra_instructions
        Additional instructions for the chat model. If a pathlib.Path object is
        passed, querychat will read the contents of the path into a string with
        `.read_text()`.
    prompt_template
        Path to or a string of a custom prompt file. If not provided, the default querychat
        template will be used. This should be a Markdown file that contains the
        system prompt template. The mustache template can use the following
        variables:
        - `{{db_engine}}`: The database engine used (e.g., "DuckDB")
        - `{{schema}}`: The schema of the data source, generated by
          `data_source.get_schema()`
        - `{{data_description}}`: The optional data description provided
        - `{{extra_instructions}}`: Any additional instructions provided

    """

    @overload
    def __init__(
        self: QueryChat[Any],
        data_source: None,
        table_name: str,
        *,
        id: Optional[str] = None,
        greeting: Optional[str | Path] = None,
        client: Optional[str | chatlas.Chat] = None,
        tools: TOOL_GROUPS | tuple[TOOL_GROUPS, ...] | None = ("update", "query"),
        data_description: Optional[str | Path] = None,
        categorical_threshold: int = 20,
        extra_instructions: Optional[str | Path] = None,
        prompt_template: Optional[str | Path] = None,
    ) -> None: ...

    @overload
    def __init__(
        self: QueryChat[ibis.Table],
        data_source: ibis.Table,
        table_name: str,
        *,
        id: Optional[str] = None,
        greeting: Optional[str | Path] = None,
        client: Optional[str | chatlas.Chat] = None,
        tools: TOOL_GROUPS | tuple[TOOL_GROUPS, ...] | None = ("update", "query"),
        data_description: Optional[str | Path] = None,
        categorical_threshold: int = 20,
        extra_instructions: Optional[str | Path] = None,
        prompt_template: Optional[str | Path] = None,
    ) -> None: ...

    @overload
    def __init__(
        self: QueryChat[IntoLazyFrameT],
        data_source: IntoLazyFrameT,
        table_name: str,
        *,
        id: Optional[str] = None,
        greeting: Optional[str | Path] = None,
        client: Optional[str | chatlas.Chat] = None,
        tools: TOOL_GROUPS | tuple[TOOL_GROUPS, ...] | None = ("update", "query"),
        data_description: Optional[str | Path] = None,
        categorical_threshold: int = 20,
        extra_instructions: Optional[str | Path] = None,
        prompt_template: Optional[str | Path] = None,
    ) -> None: ...

    @overload
    def __init__(
        self: QueryChat[IntoDataFrameT],
        data_source: IntoDataFrameT,
        table_name: str,
        *,
        id: Optional[str] = None,
        greeting: Optional[str | Path] = None,
        client: Optional[str | chatlas.Chat] = None,
        tools: TOOL_GROUPS | tuple[TOOL_GROUPS, ...] | None = ("update", "query"),
        data_description: Optional[str | Path] = None,
        categorical_threshold: int = 20,
        extra_instructions: Optional[str | Path] = None,
        prompt_template: Optional[str | Path] = None,
    ) -> None: ...

    @overload
    def __init__(
        self: QueryChat[nw.DataFrame],
        data_source: sqlalchemy.Engine,
        table_name: str,
        *,
        id: Optional[str] = None,
        greeting: Optional[str | Path] = None,
        client: Optional[str | chatlas.Chat] = None,
        tools: TOOL_GROUPS | tuple[TOOL_GROUPS, ...] | None = ("update", "query"),
        data_description: Optional[str | Path] = None,
        categorical_threshold: int = 20,
        extra_instructions: Optional[str | Path] = None,
        prompt_template: Optional[str | Path] = None,
    ) -> None: ...

    def __init__(
        self,
        data_source: IntoFrame | sqlalchemy.Engine | ibis.Table | None,
        table_name: str,
        *,
        id: Optional[str] = None,
        greeting: Optional[str | Path] = None,
        client: Optional[str | chatlas.Chat] = None,
        tools: TOOL_GROUPS | tuple[TOOL_GROUPS, ...] | None = ("update", "query"),
        data_description: Optional[str | Path] = None,
        categorical_threshold: int = 20,
        extra_instructions: Optional[str | Path] = None,
        prompt_template: Optional[str | Path] = None,
    ):
        super().__init__(
            data_source,
            table_name,
            greeting=greeting,
            client=client,
            tools=tools,
            data_description=data_description,
            categorical_threshold=categorical_threshold,
            extra_instructions=extra_instructions,
            prompt_template=prompt_template,
        )
        # Use table_name for ID since data_source might be None
        self.id = id or f"querychat_{table_name}"

    def app(
        self, *, bookmark_store: Literal["url", "server", "disable"] = "url"
    ) -> App:
        """
        Quickly chat with a dataset.

        Creates a Shiny app with a chat sidebar and data table view -- providing a
        quick-and-easy way to start chatting with your data.

        Parameters
        ----------
        bookmark_store
            The bookmarking store to use for the Shiny app. Options are:
                - `"url"`: Store bookmarks in the URL (default).
                - `"server"`: Store bookmarks on the server.
                - `"disable"`: Disable bookmarking.

        Returns
        -------
        :
            A Shiny App object that can be run with `app.run()` or served with `shiny run`.

        """
        data_source = self._require_data_source("app")
        enable_bookmarking = bookmark_store != "disable"
        table_name = data_source.table_name

        def app_ui(request):
            return ui.page_sidebar(
                self.sidebar(),
                ui.card(
                    ui.card_header(
                        ui.div(
                            ui.div(
                                bs_icon("terminal-fill"),
                                ui.output_text("query_title", inline=True),
                                class_="d-flex align-items-center gap-2",
                            ),
                            ui.output_ui("ui_reset", inline=True),
                            class_="hstack gap-3",
                        ),
                    ),
                    ui.output_ui("sql_output"),
                    fill=False,
                    style="max-height: 33%;",
                ),
                ui.card(
                    ui.card_header(bs_icon("table"), " Data"),
                    ui.output_data_frame("dt"),
                ),
                title=ui.span("querychat with ", ui.code(table_name)),
                class_="bslib-page-dashboard",
                fillable=True,
            )

        def app_server(input: Inputs, output: Outputs, session: Session):
            vals = mod_server(
                self.id,
                data_source=data_source,
                greeting=self.greeting,
                client=self._client,
                enable_bookmarking=enable_bookmarking,
            )

            @render.text
            def query_title():
                return vals.title() or "SQL Query"

            @render.ui
            def ui_reset():
                req(vals.sql())
                return ui.input_action_button(
                    "reset_query",
                    "Reset Query",
                    class_="btn btn-outline-danger btn-sm lh-1 ms-auto",
                )

            @reactive.effect
            @reactive.event(input.reset_query)
            def _():
                vals.sql.set(None)
                vals.title.set(None)

            @render.data_frame
            def dt():
                # Collect lazy sources (LazyFrame, Ibis Table) to eager DataFrame
                return as_narwhals(vals.df())

            @render.ui
            def sql_output():
                sql_value = vals.sql() or f"SELECT * FROM {table_name}"
                sql_code = f"```sql\n{sql_value}\n```"
                return output_markdown_stream(
                    "sql_code",
                    content=sql_code,
                    auto_scroll=False,
                    width="100%",
                )

        return App(app_ui, app_server, bookmark_store=bookmark_store)

    def sidebar(
        self,
        *,
        width: int = 400,
        height: str = "100%",
        fillable: bool = True,
        id: Optional[str] = None,
        **kwargs,
    ) -> ui.Sidebar:
        """
        Create a sidebar containing the querychat UI.

        Parameters
        ----------
        width
            Width of the sidebar in pixels.
        height
            Height of the sidebar.
        fillable
            Whether the sidebar should be fillable. Default is `True`.
        id
            Optional ID for the QueryChat instance. If not provided,
            will use the ID provided at initialization.
        **kwargs
            Additional arguments passed to `shiny.ui.sidebar()`.

        Returns
        -------
        :
            A sidebar UI component.

        """
        return ui.sidebar(
            self.ui(id=id),
            width=width,
            height=height,
            fillable=fillable,
            class_="querychat-sidebar",
            **kwargs,
        )

    def ui(self, *, id: Optional[str] = None, **kwargs):
        """
        Create the UI for the querychat component.

        Parameters
        ----------
        id
            Optional ID for the QueryChat instance. If not provided,
            will use the ID provided at initialization.
        **kwargs
            Additional arguments to pass to `shinychat.chat_ui()`.

        Returns
        -------
        :
            A UI component.

        """
        return mod_ui(id or self.id, **kwargs)

    def server(
        self,
        *,
        data_source: Optional[IntoFrame | sqlalchemy.Engine | ibis.Table] = None,
        enable_bookmarking: bool = False,
        id: Optional[str] = None,
    ) -> ServerValues[IntoFrameT]:
        """
        Initialize Shiny server logic.

        This method is intended for use in Shiny Code mode, where the user must
        explicitly call `.server()` within the Shiny server function. In Shiny
        Express mode, you can use `querychat.express.QueryChat` instead
        of `querychat.QueryChat`, which calls `.server()` automatically.

        Parameters
        ----------
        data_source
            Optional data source to use. If provided, sets the data_source property
            before initializing server logic. This is useful for the deferred pattern
            where data_source is not known at initialization time.
        enable_bookmarking
            Whether to enable bookmarking for the querychat module.
        id
            Optional module ID for the QueryChat instance. If not provided,
            will use the ID provided at initialization. This must match the ID
            used in the `.ui()` or `.sidebar()` methods.

        Examples
        --------
        ```python
        from shiny import App, render, ui
        from seaborn import load_dataset
        from querychat import QueryChat

        titanic = load_dataset("titanic")

        qc = QueryChat(titanic, "titanic")


        def app_ui(request):
            return ui.page_sidebar(
                qc.sidebar(),
                ui.card(
                    ui.card_header(ui.output_text("title")),
                    ui.output_data_frame("data_table"),
                ),
                title="Titanic QueryChat App",
                fillable=True,
            )


        def server(input, output, session):
            qc_vals = qc.server(enable_bookmarking=True)

            @render.data_frame
            def data_table():
                return qc_vals.df()

            @render.text
            def title():
                return qc_vals.title() or "My Data"


        app = App(app_ui, server, bookmark_store="url")
        ```

        Returns
        -------
        :
            A ServerValues dataclass containing session-specific reactive values
            and the chat client. See ServerValues documentation for details on
            the available attributes.

        """
        session = get_current_session()
        if session is None:
            raise RuntimeError(
                ".server() must be called within an active Shiny session (i.e., within the server function). "
            )

        if data_source is not None:
            self.data_source = data_source

        resolved_data_source = self._require_data_source("server")

        return mod_server(
            id or self.id,
            data_source=resolved_data_source,
            greeting=self.greeting,
            client=self.client,
            enable_bookmarking=enable_bookmarking,
        )


class QueryChatExpress(QueryChatBase[IntoFrameT]):
    """
    Use QueryChat with Shiny Express.

    This class makes it easy to use querychat within Shiny Express apps --
    it automatically calls `.server()` during initialization, so you don't
    have to do it manually.

    Examples
    --------
    ```python
    from querychat.express import QueryChat
    from seaborn import load_dataset
    from shiny.express import app_opts, render, ui

    titanic = load_dataset("titanic")

    qc = QueryChat(titanic, "titanic")
    qc.sidebar()

    with ui.card(fill=True):
        with ui.card_header():

            @render.text
            def title():
                return qc.title() or "Titanic Dataset"

        @render.data_frame
        def data_table():
            return qc.df()


    ui.page_opts(
        title="Titanic QueryChat App",
        fillable=True,
    )

    app_opts(bookmark_store="url")
    ```

    Parameters
    ----------
    data_source
        Either a Narwhals-compatible data frame (e.g., Polars or Pandas) or a
        SQLAlchemy engine containing the table to query against. Can be ``None``
        for deferred binding (set via the ``data_source`` property before the
        real session starts).
    table_name
        If a data_source is a data frame, a name to use to refer to the table in
        SQL queries (usually the variable name of the data frame, but it doesn't
        have to be). If a data_source is a SQLAlchemy engine, the table_name is
        the name of the table in the database to query against.
    id
        An optional ID for the QueryChat module. If not provided, an ID will be
        generated based on the table_name.
    greeting
        A string in Markdown format, containing the initial message. If a
        pathlib.Path object is passed, querychat will read the contents of the
        path into a string with `.read_text()`. You can use
        `querychat.greeting()` to help generate a greeting from a querychat
        configuration. If no greeting is provided, one will be generated at the
        start of every new conversation.
    client
        A `chatlas.Chat` object or a string to be passed to
        `chatlas.ChatAuto()`'s `provider_model` parameter, describing the
        provider and model combination to use (e.g. `"openai/gpt-4.1"`,
        "anthropic/claude-sonnet-4-5", "google/gemini-2.5-flash". etc).

        If `client` is not provided, querychat consults the
        `QUERYCHAT_CLIENT` environment variable. If that is not set, it
        defaults to `"openai"`.
    data_description
        Description of the data in plain text or Markdown. If a pathlib.Path
        object is passed, querychat will read the contents of the path into a
        string with `.read_text()`.
    categorical_threshold
        Threshold for determining if a column is categorical based on number of
        unique values.
    extra_instructions
        Additional instructions for the chat model. If a pathlib.Path object is
        passed, querychat will read the contents of the path into a string with
        `.read_text()`.
    prompt_template
        Path to or a string of a custom prompt file. If not provided, the default querychat
        template will be used. This should be a Markdown file that contains the
        system prompt template. The mustache template can use the following
        variables:
        - `{{db_engine}}`: The database engine used (e.g., "DuckDB")
        - `{{schema}}`: The schema of the data source, generated by
          `data_source.get_schema()`
        - `{{data_description}}`: The optional data description provided
        - `{{extra_instructions}}`: Any additional instructions provided

    """

    # Class-level cache for bookmarking settings detected during stub session
    _bookmarking_settings: ClassVar[dict[str, bool]] = {}

    @overload
    def __init__(
        self: QueryChatExpress[Any],
        data_source: None,
        table_name: str,
        *,
        id: Optional[str] = None,
        greeting: Optional[str | Path] = None,
        client: Optional[str | chatlas.Chat] = None,
        data_description: Optional[str | Path] = None,
        categorical_threshold: int = 20,
        extra_instructions: Optional[str | Path] = None,
        prompt_template: Optional[str | Path] = None,
        enable_bookmarking: Literal["auto", True, False] = "auto",
    ) -> None: ...

    @overload
    def __init__(
        self: QueryChatExpress[ibis.Table],
        data_source: ibis.Table,
        table_name: str,
        *,
        id: Optional[str] = None,
        greeting: Optional[str | Path] = None,
        client: Optional[str | chatlas.Chat] = None,
        data_description: Optional[str | Path] = None,
        categorical_threshold: int = 20,
        extra_instructions: Optional[str | Path] = None,
        prompt_template: Optional[str | Path] = None,
        enable_bookmarking: Literal["auto", True, False] = "auto",
    ) -> None: ...

    @overload
    def __init__(
        self: QueryChatExpress[IntoLazyFrameT],
        data_source: IntoLazyFrameT,
        table_name: str,
        *,
        id: Optional[str] = None,
        greeting: Optional[str | Path] = None,
        client: Optional[str | chatlas.Chat] = None,
        data_description: Optional[str | Path] = None,
        categorical_threshold: int = 20,
        extra_instructions: Optional[str | Path] = None,
        prompt_template: Optional[str | Path] = None,
        enable_bookmarking: Literal["auto", True, False] = "auto",
    ) -> None: ...

    @overload
    def __init__(
        self: QueryChatExpress[IntoDataFrameT],
        data_source: IntoDataFrameT,
        table_name: str,
        *,
        id: Optional[str] = None,
        greeting: Optional[str | Path] = None,
        client: Optional[str | chatlas.Chat] = None,
        data_description: Optional[str | Path] = None,
        categorical_threshold: int = 20,
        extra_instructions: Optional[str | Path] = None,
        prompt_template: Optional[str | Path] = None,
        enable_bookmarking: Literal["auto", True, False] = "auto",
    ) -> None: ...

    @overload
    def __init__(
        self: QueryChatExpress[nw.DataFrame],
        data_source: sqlalchemy.Engine,
        table_name: str,
        *,
        id: Optional[str] = None,
        greeting: Optional[str | Path] = None,
        client: Optional[str | chatlas.Chat] = None,
        data_description: Optional[str | Path] = None,
        categorical_threshold: int = 20,
        extra_instructions: Optional[str | Path] = None,
        prompt_template: Optional[str | Path] = None,
        enable_bookmarking: Literal["auto", True, False] = "auto",
    ) -> None: ...

    def __init__(
        self,
        data_source: IntoFrame | sqlalchemy.Engine | ibis.Table | None,
        table_name: str,
        *,
        id: Optional[str] = None,
        greeting: Optional[str | Path] = None,
        client: Optional[str | chatlas.Chat] = None,
        data_description: Optional[str | Path] = None,
        categorical_threshold: int = 20,
        extra_instructions: Optional[str | Path] = None,
        prompt_template: Optional[str | Path] = None,
        enable_bookmarking: Literal["auto", True, False] = "auto",
    ):
        # Sanity check: Express should always have a (stub/real) session
        session = get_current_session()
        if session is None:
            raise RuntimeError(
                "Unexpected error: No active Shiny session found. "
                "Is express.QueryChat() being called outside of a Shiny Express app?",
            )

        super().__init__(
            data_source,
            table_name,
            greeting=greeting,
            client=client,
            data_description=data_description,
            categorical_threshold=categorical_threshold,
            extra_instructions=extra_instructions,
            prompt_template=prompt_template,
        )
        self.id = id or f"querychat_{table_name}"

        # Determine bookmarking setting
        # During stub session: detect from app_opts and cache in class variable
        # During real session: retrieve from class variable
        enable: bool
        if enable_bookmarking == "auto":
            if isinstance(session, ExpressStubSession):
                store = session.app_opts.get("bookmark_store", "disable")
                enable = store != "disable"
                # Cache for the real session
                QueryChatExpress._bookmarking_settings[self.id] = enable
            else:
                # Retrieve and clean up (pop prevents memory accumulation)
                enable = QueryChatExpress._bookmarking_settings.pop(self.id, False)
        else:
            enable = enable_bookmarking

        self._vals = mod_server(
            self.id,
            data_source=self._data_source,
            greeting=self.greeting,
            client=self._client,
            enable_bookmarking=enable,
        )

    def sidebar(
        self,
        *,
        width: int = 400,
        height: str = "100%",
        fillable: bool = True,
        id: Optional[str] = None,
        **kwargs,
    ) -> ui.Sidebar:
        """
        Create a sidebar containing the querychat UI.

        Parameters
        ----------
        width
            Width of the sidebar in pixels.
        height
            Height of the sidebar.
        fillable
            Whether the sidebar should be fillable. Default is `True`.
        id
            Optional ID for the QueryChat instance. If not provided,
            will use the ID provided at initialization.
        **kwargs
            Additional arguments passed to `shiny.ui.sidebar()`.

        Returns
        -------
        :
            A sidebar UI component.

        """
        return ui.sidebar(
            self.ui(id=id),
            width=width,
            height=height,
            fillable=fillable,
            class_="querychat-sidebar",
            **kwargs,
        )

    def ui(self, *, id: Optional[str] = None, **kwargs):
        """
        Create the UI for the querychat component.

        Parameters
        ----------
        id
            Optional ID for the QueryChat instance. If not provided,
            will use the ID provided at initialization.
        **kwargs
            Additional arguments to pass to `shinychat.chat_ui()`.

        Returns
        -------
        :
            A UI component.

        """
        return mod_ui(id or self.id, **kwargs)

    def df(self) -> IntoFrameT:
        """
        Reactively read the current filtered data frame that is in effect.

        Returns
        -------
        :
            The current filtered data frame, in the same format as the original
            data source (e.g., polars DataFrame, Polars LazyFrame, Ibis Table).
            If no query has been set, returns the unfiltered data from the
            data source.

        """
        return self._vals.df()

    @overload
    def sql(self, query: None = None) -> str | None: ...

    @overload
    def sql(self, query: str) -> bool: ...

    def sql(self, query: Optional[str] = None) -> str | None | bool:
        """
        Reactively read (or set) the current SQL query that is in effect.

        Parameters
        ----------
        query
            If provided, sets the current SQL query to this value.

        Returns
        -------
        :
            If no `query` is provided, returns the current SQL query as a string
            (or `None` if no query has been set). If a `query` is provided,
            returns `True` if the query was changed to a new value, or `False`
            if it was the same as the current value.

        """
        if query is None:
            return self._vals.sql()
        else:
            return self._vals.sql.set(query)

    @overload
    def title(self, value: None = None) -> str | None: ...

    @overload
    def title(self, value: str) -> bool: ...

    def title(self, value: Optional[str] = None) -> str | None | bool:
        """
        Reactively read (or set) the current title that is in effect.

        The title is a short description of the current query that the LLM
        provides to us whenever it generates a new SQL query. It can be used as
        a status string for the data dashboard.

        Parameters
        ----------
        value
            If provided, sets the current title to this value.

        Returns
        -------
        :
            If no `value` is provided, returns the current title as a string, or
            `None` if no title has been set due to no SQL query being set. If a
            `value` is provided, sets the current title to this value and
            returns `True` if the title was changed to a new value, or `False`
            if it was the same as the current value.

        """
        if value is None:
            return self._vals.title()
        else:
            return self._vals.title.set(value)
