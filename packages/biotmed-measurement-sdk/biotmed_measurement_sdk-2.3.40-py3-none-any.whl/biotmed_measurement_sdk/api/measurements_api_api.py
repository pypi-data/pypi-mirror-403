# coding: utf-8

"""
    BioT Measurement Service

    APIs document (version: 2.12.1)

    The version of the OpenAPI document: 2.12.1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from datetime import datetime
from pydantic import Field, StrictStr, field_validator
from typing import Any, List, Optional
from typing_extensions import Annotated
from uuid import UUID
from biotmed_measurement_sdk.models.get_aggregated_measurements_response import GetAggregatedMeasurementsResponse
from biotmed_measurement_sdk.models.get_raw_measurements_response import GetRawMeasurementsResponse
from biotmed_measurement_sdk.models.measurement_bulk_request import MeasurementBulkRequest
from biotmed_measurement_sdk.models.measurement_bulk_response import MeasurementBulkResponse
from biotmed_measurement_sdk.models.measurement_message_from_device import MeasurementMessageFromDevice

from biotmed_measurement_sdk.api_client import ApiClient, RequestSerialized
from biotmed_measurement_sdk.api_response import ApiResponse
from biotmed_measurement_sdk.rest import RESTResponseType


class MeasurementsAPIApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def get_measurements(
        self,
        bin_interval_seconds: Annotated[str, Field(strict=True, description="This number defines the aggregation time in seconds. If 6 is provided, it will aggregate all measurements in a 6 seconds interval")],
        patient_id: Annotated[UUID, Field(description="The patient's ID")],
        start_time: Annotated[datetime, Field(description="The wanted start time for the historical measurements. In ISO8601 format")],
        end_time: Annotated[datetime, Field(description="The wanted end time for the historical measurements. In ISO8601 format")],
        attributes: Optional[List[StrictStr]] = None,
        source_entity_id: Annotated[Optional[Any], Field(description="The ID of the source entity who entered the measurements. Can be a device's id, a doctor's id, etc. If not sent all sources will be returned")] = None,
        session_id: Annotated[Optional[UUID], Field(description="The session's Id. If not sent all sessions will be returned")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetAggregatedMeasurementsResponse:
        """Get aggregated measurements

        Get aggregated measurements    Get all measurements for requested attributes, patient, in a predefined time range, in an aggregated format. attributes must have at least one value. sourceEntityId may be empty, in which case it will return measurements from all sourceEntities. sessionId may be empty, in which case it will return measurements from all sessions. endTime must be after startTime.   Query Parameters:  | Parameter   |Type   | Mandatory| Description          | Example   | |-------------|-------|----------|----------------------|-----------| |binIntervalSeconds|integer|true|This number defines the aggregation time in seconds. If 6 is provided, it will aggregate all measurements in a 6 seconds interval|1| |attributes|array|false|null|| |patientId|string|true|The patient's ID|3fa85f64-5717-4562-b3fc-2c963f66afa6| |sourceEntityId|string|false|The ID of the source entity who entered the measurements. Can be a device's id, a doctor's id, etc. If not sent all sources will be returned|device1| |sessionId|string|false|The session's Id. If not sent all sessions will be returned|6b52af6e-92c8-4827-aaf2-d8805586ab5f| |startTime|string|true|The wanted start time for the historical measurements. In ISO8601 format|2007-12-20T10:15:30Z| |endTime|string|true|The wanted end time for the historical measurements. In ISO8601 format|2007-12-20T10:15:30Z|   This API requires **PROTECTED_API** permission(s).  

        :param bin_interval_seconds: This number defines the aggregation time in seconds. If 6 is provided, it will aggregate all measurements in a 6 seconds interval (required)
        :type bin_interval_seconds: str
        :param patient_id: The patient's ID (required)
        :type patient_id: UUID
        :param start_time: The wanted start time for the historical measurements. In ISO8601 format (required)
        :type start_time: datetime
        :param end_time: The wanted end time for the historical measurements. In ISO8601 format (required)
        :type end_time: datetime
        :param attributes:
        :type attributes: List[str]
        :param source_entity_id: The ID of the source entity who entered the measurements. Can be a device's id, a doctor's id, etc. If not sent all sources will be returned
        :type source_entity_id: object
        :param session_id: The session's Id. If not sent all sessions will be returned
        :type session_id: UUID
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_measurements_serialize(
            bin_interval_seconds=bin_interval_seconds,
            patient_id=patient_id,
            start_time=start_time,
            end_time=end_time,
            attributes=attributes,
            source_entity_id=source_entity_id,
            session_id=session_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '200': "GetAggregatedMeasurementsResponse",
            '500': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '504': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_measurements_with_http_info(
        self,
        bin_interval_seconds: Annotated[str, Field(strict=True, description="This number defines the aggregation time in seconds. If 6 is provided, it will aggregate all measurements in a 6 seconds interval")],
        patient_id: Annotated[UUID, Field(description="The patient's ID")],
        start_time: Annotated[datetime, Field(description="The wanted start time for the historical measurements. In ISO8601 format")],
        end_time: Annotated[datetime, Field(description="The wanted end time for the historical measurements. In ISO8601 format")],
        attributes: Optional[List[StrictStr]] = None,
        source_entity_id: Annotated[Optional[Any], Field(description="The ID of the source entity who entered the measurements. Can be a device's id, a doctor's id, etc. If not sent all sources will be returned")] = None,
        session_id: Annotated[Optional[UUID], Field(description="The session's Id. If not sent all sessions will be returned")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetAggregatedMeasurementsResponse]:
        """Get aggregated measurements

        Get aggregated measurements    Get all measurements for requested attributes, patient, in a predefined time range, in an aggregated format. attributes must have at least one value. sourceEntityId may be empty, in which case it will return measurements from all sourceEntities. sessionId may be empty, in which case it will return measurements from all sessions. endTime must be after startTime.   Query Parameters:  | Parameter   |Type   | Mandatory| Description          | Example   | |-------------|-------|----------|----------------------|-----------| |binIntervalSeconds|integer|true|This number defines the aggregation time in seconds. If 6 is provided, it will aggregate all measurements in a 6 seconds interval|1| |attributes|array|false|null|| |patientId|string|true|The patient's ID|3fa85f64-5717-4562-b3fc-2c963f66afa6| |sourceEntityId|string|false|The ID of the source entity who entered the measurements. Can be a device's id, a doctor's id, etc. If not sent all sources will be returned|device1| |sessionId|string|false|The session's Id. If not sent all sessions will be returned|6b52af6e-92c8-4827-aaf2-d8805586ab5f| |startTime|string|true|The wanted start time for the historical measurements. In ISO8601 format|2007-12-20T10:15:30Z| |endTime|string|true|The wanted end time for the historical measurements. In ISO8601 format|2007-12-20T10:15:30Z|   This API requires **PROTECTED_API** permission(s).  

        :param bin_interval_seconds: This number defines the aggregation time in seconds. If 6 is provided, it will aggregate all measurements in a 6 seconds interval (required)
        :type bin_interval_seconds: str
        :param patient_id: The patient's ID (required)
        :type patient_id: UUID
        :param start_time: The wanted start time for the historical measurements. In ISO8601 format (required)
        :type start_time: datetime
        :param end_time: The wanted end time for the historical measurements. In ISO8601 format (required)
        :type end_time: datetime
        :param attributes:
        :type attributes: List[str]
        :param source_entity_id: The ID of the source entity who entered the measurements. Can be a device's id, a doctor's id, etc. If not sent all sources will be returned
        :type source_entity_id: object
        :param session_id: The session's Id. If not sent all sessions will be returned
        :type session_id: UUID
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_measurements_serialize(
            bin_interval_seconds=bin_interval_seconds,
            patient_id=patient_id,
            start_time=start_time,
            end_time=end_time,
            attributes=attributes,
            source_entity_id=source_entity_id,
            session_id=session_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '200': "GetAggregatedMeasurementsResponse",
            '500': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '504': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_measurements_without_preload_content(
        self,
        bin_interval_seconds: Annotated[str, Field(strict=True, description="This number defines the aggregation time in seconds. If 6 is provided, it will aggregate all measurements in a 6 seconds interval")],
        patient_id: Annotated[UUID, Field(description="The patient's ID")],
        start_time: Annotated[datetime, Field(description="The wanted start time for the historical measurements. In ISO8601 format")],
        end_time: Annotated[datetime, Field(description="The wanted end time for the historical measurements. In ISO8601 format")],
        attributes: Optional[List[StrictStr]] = None,
        source_entity_id: Annotated[Optional[Any], Field(description="The ID of the source entity who entered the measurements. Can be a device's id, a doctor's id, etc. If not sent all sources will be returned")] = None,
        session_id: Annotated[Optional[UUID], Field(description="The session's Id. If not sent all sessions will be returned")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get aggregated measurements

        Get aggregated measurements    Get all measurements for requested attributes, patient, in a predefined time range, in an aggregated format. attributes must have at least one value. sourceEntityId may be empty, in which case it will return measurements from all sourceEntities. sessionId may be empty, in which case it will return measurements from all sessions. endTime must be after startTime.   Query Parameters:  | Parameter   |Type   | Mandatory| Description          | Example   | |-------------|-------|----------|----------------------|-----------| |binIntervalSeconds|integer|true|This number defines the aggregation time in seconds. If 6 is provided, it will aggregate all measurements in a 6 seconds interval|1| |attributes|array|false|null|| |patientId|string|true|The patient's ID|3fa85f64-5717-4562-b3fc-2c963f66afa6| |sourceEntityId|string|false|The ID of the source entity who entered the measurements. Can be a device's id, a doctor's id, etc. If not sent all sources will be returned|device1| |sessionId|string|false|The session's Id. If not sent all sessions will be returned|6b52af6e-92c8-4827-aaf2-d8805586ab5f| |startTime|string|true|The wanted start time for the historical measurements. In ISO8601 format|2007-12-20T10:15:30Z| |endTime|string|true|The wanted end time for the historical measurements. In ISO8601 format|2007-12-20T10:15:30Z|   This API requires **PROTECTED_API** permission(s).  

        :param bin_interval_seconds: This number defines the aggregation time in seconds. If 6 is provided, it will aggregate all measurements in a 6 seconds interval (required)
        :type bin_interval_seconds: str
        :param patient_id: The patient's ID (required)
        :type patient_id: UUID
        :param start_time: The wanted start time for the historical measurements. In ISO8601 format (required)
        :type start_time: datetime
        :param end_time: The wanted end time for the historical measurements. In ISO8601 format (required)
        :type end_time: datetime
        :param attributes:
        :type attributes: List[str]
        :param source_entity_id: The ID of the source entity who entered the measurements. Can be a device's id, a doctor's id, etc. If not sent all sources will be returned
        :type source_entity_id: object
        :param session_id: The session's Id. If not sent all sessions will be returned
        :type session_id: UUID
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_measurements_serialize(
            bin_interval_seconds=bin_interval_seconds,
            patient_id=patient_id,
            start_time=start_time,
            end_time=end_time,
            attributes=attributes,
            source_entity_id=source_entity_id,
            session_id=session_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '200': "GetAggregatedMeasurementsResponse",
            '500': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '504': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_measurements_serialize(
        self,
        bin_interval_seconds,
        patient_id,
        start_time,
        end_time,
        attributes,
        source_entity_id,
        session_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'attributes': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if bin_interval_seconds is not None:
            
            _query_params.append(('binIntervalSeconds', bin_interval_seconds))
            
        if attributes is not None:
            
            _query_params.append(('attributes', attributes))
            
        if patient_id is not None:
            
            _query_params.append(('patientId', patient_id))
            
        if source_entity_id is not None:
            
            _query_params.append(('sourceEntityId', source_entity_id))
            
        if session_id is not None:
            
            _query_params.append(('sessionId', session_id))
            
        if start_time is not None:
            if isinstance(start_time, datetime):
                _query_params.append(
                    (
                        'startTime',
                        start_time.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            if isinstance(end_time, datetime):
                _query_params.append(
                    (
                        'endTime',
                        end_time.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('endTime', end_time))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/measurements/aggregated',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_raw_measurements(
        self,
        patient_id: Annotated[UUID, Field(description="The patient's ID")],
        start_time: Annotated[datetime, Field(description="The wanted start time for the historical measurements. In ISO8601 format")],
        end_time: Annotated[datetime, Field(description="The wanted end time for the historical measurements. In ISO8601 format")],
        attributes: Optional[List[StrictStr]] = None,
        source_entity_id: Annotated[Optional[Any], Field(description="The ID of the source entity who entered the measurements. Can be a device's id, a doctor's id, etc. If not sent all sources will be returned")] = None,
        session_id: Annotated[Optional[UUID], Field(description="The session's Id. If not sent all sessions will be returned")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetRawMeasurementsResponse:
        """Get raw measurements

        Get raw measurements    Get all measurements for requested attributes, patient, in a predefined time range, in an raw format. attributes must have at least one value. sourceEntityId may be empty, in which case it will return measurements from all sourceEntities. sessionId may be empty, in which case it will return measurements from all sessions. endTime must be after startTime.   Query Parameters:  | Parameter   |Type   | Mandatory| Description          | Example   | |-------------|-------|----------|----------------------|-----------| |attributes|array|false|null|| |patientId|string|true|The patient's ID|3fa85f64-5717-4562-b3fc-2c963f66afa6| |sourceEntityId|string|false|The ID of the source entity who entered the measurements. Can be a device's id, a doctor's id, etc. If not sent all sources will be returned|device1| |sessionId|string|false|The session's Id. If not sent all sessions will be returned|6b52af6e-92c8-4827-aaf2-d8805586ab5f| |startTime|string|true|The wanted start time for the historical measurements. In ISO8601 format|2007-12-20T10:15:30Z| |endTime|string|true|The wanted end time for the historical measurements. In ISO8601 format|2007-12-20T10:15:30Z|   This API requires **PROTECTED_API** permission(s).  

        :param patient_id: The patient's ID (required)
        :type patient_id: UUID
        :param start_time: The wanted start time for the historical measurements. In ISO8601 format (required)
        :type start_time: datetime
        :param end_time: The wanted end time for the historical measurements. In ISO8601 format (required)
        :type end_time: datetime
        :param attributes:
        :type attributes: List[str]
        :param source_entity_id: The ID of the source entity who entered the measurements. Can be a device's id, a doctor's id, etc. If not sent all sources will be returned
        :type source_entity_id: object
        :param session_id: The session's Id. If not sent all sessions will be returned
        :type session_id: UUID
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_raw_measurements_serialize(
            patient_id=patient_id,
            start_time=start_time,
            end_time=end_time,
            attributes=attributes,
            source_entity_id=source_entity_id,
            session_id=session_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '200': "GetRawMeasurementsResponse",
            '500': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '504': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_raw_measurements_with_http_info(
        self,
        patient_id: Annotated[UUID, Field(description="The patient's ID")],
        start_time: Annotated[datetime, Field(description="The wanted start time for the historical measurements. In ISO8601 format")],
        end_time: Annotated[datetime, Field(description="The wanted end time for the historical measurements. In ISO8601 format")],
        attributes: Optional[List[StrictStr]] = None,
        source_entity_id: Annotated[Optional[Any], Field(description="The ID of the source entity who entered the measurements. Can be a device's id, a doctor's id, etc. If not sent all sources will be returned")] = None,
        session_id: Annotated[Optional[UUID], Field(description="The session's Id. If not sent all sessions will be returned")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetRawMeasurementsResponse]:
        """Get raw measurements

        Get raw measurements    Get all measurements for requested attributes, patient, in a predefined time range, in an raw format. attributes must have at least one value. sourceEntityId may be empty, in which case it will return measurements from all sourceEntities. sessionId may be empty, in which case it will return measurements from all sessions. endTime must be after startTime.   Query Parameters:  | Parameter   |Type   | Mandatory| Description          | Example   | |-------------|-------|----------|----------------------|-----------| |attributes|array|false|null|| |patientId|string|true|The patient's ID|3fa85f64-5717-4562-b3fc-2c963f66afa6| |sourceEntityId|string|false|The ID of the source entity who entered the measurements. Can be a device's id, a doctor's id, etc. If not sent all sources will be returned|device1| |sessionId|string|false|The session's Id. If not sent all sessions will be returned|6b52af6e-92c8-4827-aaf2-d8805586ab5f| |startTime|string|true|The wanted start time for the historical measurements. In ISO8601 format|2007-12-20T10:15:30Z| |endTime|string|true|The wanted end time for the historical measurements. In ISO8601 format|2007-12-20T10:15:30Z|   This API requires **PROTECTED_API** permission(s).  

        :param patient_id: The patient's ID (required)
        :type patient_id: UUID
        :param start_time: The wanted start time for the historical measurements. In ISO8601 format (required)
        :type start_time: datetime
        :param end_time: The wanted end time for the historical measurements. In ISO8601 format (required)
        :type end_time: datetime
        :param attributes:
        :type attributes: List[str]
        :param source_entity_id: The ID of the source entity who entered the measurements. Can be a device's id, a doctor's id, etc. If not sent all sources will be returned
        :type source_entity_id: object
        :param session_id: The session's Id. If not sent all sessions will be returned
        :type session_id: UUID
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_raw_measurements_serialize(
            patient_id=patient_id,
            start_time=start_time,
            end_time=end_time,
            attributes=attributes,
            source_entity_id=source_entity_id,
            session_id=session_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '200': "GetRawMeasurementsResponse",
            '500': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '504': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_raw_measurements_without_preload_content(
        self,
        patient_id: Annotated[UUID, Field(description="The patient's ID")],
        start_time: Annotated[datetime, Field(description="The wanted start time for the historical measurements. In ISO8601 format")],
        end_time: Annotated[datetime, Field(description="The wanted end time for the historical measurements. In ISO8601 format")],
        attributes: Optional[List[StrictStr]] = None,
        source_entity_id: Annotated[Optional[Any], Field(description="The ID of the source entity who entered the measurements. Can be a device's id, a doctor's id, etc. If not sent all sources will be returned")] = None,
        session_id: Annotated[Optional[UUID], Field(description="The session's Id. If not sent all sessions will be returned")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get raw measurements

        Get raw measurements    Get all measurements for requested attributes, patient, in a predefined time range, in an raw format. attributes must have at least one value. sourceEntityId may be empty, in which case it will return measurements from all sourceEntities. sessionId may be empty, in which case it will return measurements from all sessions. endTime must be after startTime.   Query Parameters:  | Parameter   |Type   | Mandatory| Description          | Example   | |-------------|-------|----------|----------------------|-----------| |attributes|array|false|null|| |patientId|string|true|The patient's ID|3fa85f64-5717-4562-b3fc-2c963f66afa6| |sourceEntityId|string|false|The ID of the source entity who entered the measurements. Can be a device's id, a doctor's id, etc. If not sent all sources will be returned|device1| |sessionId|string|false|The session's Id. If not sent all sessions will be returned|6b52af6e-92c8-4827-aaf2-d8805586ab5f| |startTime|string|true|The wanted start time for the historical measurements. In ISO8601 format|2007-12-20T10:15:30Z| |endTime|string|true|The wanted end time for the historical measurements. In ISO8601 format|2007-12-20T10:15:30Z|   This API requires **PROTECTED_API** permission(s).  

        :param patient_id: The patient's ID (required)
        :type patient_id: UUID
        :param start_time: The wanted start time for the historical measurements. In ISO8601 format (required)
        :type start_time: datetime
        :param end_time: The wanted end time for the historical measurements. In ISO8601 format (required)
        :type end_time: datetime
        :param attributes:
        :type attributes: List[str]
        :param source_entity_id: The ID of the source entity who entered the measurements. Can be a device's id, a doctor's id, etc. If not sent all sources will be returned
        :type source_entity_id: object
        :param session_id: The session's Id. If not sent all sessions will be returned
        :type session_id: UUID
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_raw_measurements_serialize(
            patient_id=patient_id,
            start_time=start_time,
            end_time=end_time,
            attributes=attributes,
            source_entity_id=source_entity_id,
            session_id=session_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '200': "GetRawMeasurementsResponse",
            '500': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '504': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_raw_measurements_serialize(
        self,
        patient_id,
        start_time,
        end_time,
        attributes,
        source_entity_id,
        session_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'attributes': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if attributes is not None:
            
            _query_params.append(('attributes', attributes))
            
        if patient_id is not None:
            
            _query_params.append(('patientId', patient_id))
            
        if source_entity_id is not None:
            
            _query_params.append(('sourceEntityId', source_entity_id))
            
        if session_id is not None:
            
            _query_params.append(('sessionId', session_id))
            
        if start_time is not None:
            if isinstance(start_time, datetime):
                _query_params.append(
                    (
                        'startTime',
                        start_time.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            if isinstance(end_time, datetime):
                _query_params.append(
                    (
                        'endTime',
                        end_time.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('endTime', end_time))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/measurements/raw',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def save_measurement(
        self,
        measurement_message_from_device: MeasurementMessageFromDevice,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> MeasurementMessageFromDevice:
        """Save measurement

        Save measurement    Data sent in this manner cannot be monitored via the patient live observation window. The historical view is not affected. The session must be created before calling this API. This is done with the create or start session APIs.  (*)This parameter is mandatory only if its optional parent attribute is defined. Click <a href=\"https://docs.biot-med.com/docs/biot-rest-api#api-optional-parameters\" target=\"_blank\">here</a> for more information.  Request Body Parameters:  | Parameter   |Type   | Mandatory| Description          | Example   | |-------------|-------|----------|----------------------|-----------| |metadata|object|false||| |metadata.timestamp|string|true(*)|A UTC date-time in the ISO-8601 format|2007-12-20T10:15:30Z| |metadata.deviceId|string|false|The device id that sent the measurement|device12345| |metadata.patientId|string|false|The patient id that the measurement belongs to|3fa85f64-5717-4562-b3fc-2c963f66afa6| |metadata.sessionId|string|false|The session id that the measurement belongs to|6b52af6e-92c8-4827-aaf2-d8805586ab5f| |data|object|false|||   This API requires **PROTECTED_API** permission(s).  

        :param measurement_message_from_device: (required)
        :type measurement_message_from_device: MeasurementMessageFromDevice
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._save_measurement_serialize(
            measurement_message_from_device=measurement_message_from_device,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '200': "MeasurementMessageFromDevice",
            '500': "ErrorResponse",
            '401': "ErrorResponse",
            '413': "ErrorResponse",
            '403': "ErrorResponse",
            '504': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def save_measurement_with_http_info(
        self,
        measurement_message_from_device: MeasurementMessageFromDevice,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[MeasurementMessageFromDevice]:
        """Save measurement

        Save measurement    Data sent in this manner cannot be monitored via the patient live observation window. The historical view is not affected. The session must be created before calling this API. This is done with the create or start session APIs.  (*)This parameter is mandatory only if its optional parent attribute is defined. Click <a href=\"https://docs.biot-med.com/docs/biot-rest-api#api-optional-parameters\" target=\"_blank\">here</a> for more information.  Request Body Parameters:  | Parameter   |Type   | Mandatory| Description          | Example   | |-------------|-------|----------|----------------------|-----------| |metadata|object|false||| |metadata.timestamp|string|true(*)|A UTC date-time in the ISO-8601 format|2007-12-20T10:15:30Z| |metadata.deviceId|string|false|The device id that sent the measurement|device12345| |metadata.patientId|string|false|The patient id that the measurement belongs to|3fa85f64-5717-4562-b3fc-2c963f66afa6| |metadata.sessionId|string|false|The session id that the measurement belongs to|6b52af6e-92c8-4827-aaf2-d8805586ab5f| |data|object|false|||   This API requires **PROTECTED_API** permission(s).  

        :param measurement_message_from_device: (required)
        :type measurement_message_from_device: MeasurementMessageFromDevice
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._save_measurement_serialize(
            measurement_message_from_device=measurement_message_from_device,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '200': "MeasurementMessageFromDevice",
            '500': "ErrorResponse",
            '401': "ErrorResponse",
            '413': "ErrorResponse",
            '403': "ErrorResponse",
            '504': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def save_measurement_without_preload_content(
        self,
        measurement_message_from_device: MeasurementMessageFromDevice,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Save measurement

        Save measurement    Data sent in this manner cannot be monitored via the patient live observation window. The historical view is not affected. The session must be created before calling this API. This is done with the create or start session APIs.  (*)This parameter is mandatory only if its optional parent attribute is defined. Click <a href=\"https://docs.biot-med.com/docs/biot-rest-api#api-optional-parameters\" target=\"_blank\">here</a> for more information.  Request Body Parameters:  | Parameter   |Type   | Mandatory| Description          | Example   | |-------------|-------|----------|----------------------|-----------| |metadata|object|false||| |metadata.timestamp|string|true(*)|A UTC date-time in the ISO-8601 format|2007-12-20T10:15:30Z| |metadata.deviceId|string|false|The device id that sent the measurement|device12345| |metadata.patientId|string|false|The patient id that the measurement belongs to|3fa85f64-5717-4562-b3fc-2c963f66afa6| |metadata.sessionId|string|false|The session id that the measurement belongs to|6b52af6e-92c8-4827-aaf2-d8805586ab5f| |data|object|false|||   This API requires **PROTECTED_API** permission(s).  

        :param measurement_message_from_device: (required)
        :type measurement_message_from_device: MeasurementMessageFromDevice
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._save_measurement_serialize(
            measurement_message_from_device=measurement_message_from_device,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '200': "MeasurementMessageFromDevice",
            '500': "ErrorResponse",
            '401': "ErrorResponse",
            '413': "ErrorResponse",
            '403': "ErrorResponse",
            '504': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _save_measurement_serialize(
        self,
        measurement_message_from_device,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if measurement_message_from_device is not None:
            _body_params = measurement_message_from_device


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/measurements',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def save_measurements_bulk(
        self,
        measurement_bulk_request: MeasurementBulkRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> MeasurementBulkResponse:
        """Save measurements in bulk

        Save measurements in bulk    Data sent in this manner cannot be monitored via the patient live observation window. The historical view is not affected. The session must be created before calling this API. This is done with the create or start session APIs.  (*)This parameter is mandatory only if its optional parent attribute is defined. Click <a href=\"https://docs.biot-med.com/docs/biot-rest-api#api-optional-parameters\" target=\"_blank\">here</a> for more information.  Request Body Parameters:  | Parameter   |Type   | Mandatory| Description          | Example   | |-------------|-------|----------|----------------------|-----------| |measures|array|false|List of measurement to be written to  the DB|| |measures[index]|array|false|List of measurement to be written to  the DB|| |measures[index].metadata|object|false||| |measures[index].metadata.timestamp|string|true(*)|A UTC date-time in the ISO-8601 format|2007-12-20T10:15:30Z| |measures[index].metadata.deviceId|string|false|The device id that sent the measurement|device12345| |measures[index].metadata.patientId|string|false|The patient id that the measurement belongs to|3fa85f64-5717-4562-b3fc-2c963f66afa6| |measures[index].metadata.sessionId|string|false|The session id that the measurement belongs to|6b52af6e-92c8-4827-aaf2-d8805586ab5f| |measures[index].data|object|false|||   This API requires **PROTECTED_API** permission(s).  

        :param measurement_bulk_request: (required)
        :type measurement_bulk_request: MeasurementBulkRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._save_measurements_bulk_serialize(
            measurement_bulk_request=measurement_bulk_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '206': "MeasurementBulkResponse",
            '200': "MeasurementBulkResponse",
            '500': "ErrorResponse",
            '401': "ErrorResponse",
            '413': "ErrorResponse",
            '403': "ErrorResponse",
            '504': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def save_measurements_bulk_with_http_info(
        self,
        measurement_bulk_request: MeasurementBulkRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[MeasurementBulkResponse]:
        """Save measurements in bulk

        Save measurements in bulk    Data sent in this manner cannot be monitored via the patient live observation window. The historical view is not affected. The session must be created before calling this API. This is done with the create or start session APIs.  (*)This parameter is mandatory only if its optional parent attribute is defined. Click <a href=\"https://docs.biot-med.com/docs/biot-rest-api#api-optional-parameters\" target=\"_blank\">here</a> for more information.  Request Body Parameters:  | Parameter   |Type   | Mandatory| Description          | Example   | |-------------|-------|----------|----------------------|-----------| |measures|array|false|List of measurement to be written to  the DB|| |measures[index]|array|false|List of measurement to be written to  the DB|| |measures[index].metadata|object|false||| |measures[index].metadata.timestamp|string|true(*)|A UTC date-time in the ISO-8601 format|2007-12-20T10:15:30Z| |measures[index].metadata.deviceId|string|false|The device id that sent the measurement|device12345| |measures[index].metadata.patientId|string|false|The patient id that the measurement belongs to|3fa85f64-5717-4562-b3fc-2c963f66afa6| |measures[index].metadata.sessionId|string|false|The session id that the measurement belongs to|6b52af6e-92c8-4827-aaf2-d8805586ab5f| |measures[index].data|object|false|||   This API requires **PROTECTED_API** permission(s).  

        :param measurement_bulk_request: (required)
        :type measurement_bulk_request: MeasurementBulkRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._save_measurements_bulk_serialize(
            measurement_bulk_request=measurement_bulk_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '206': "MeasurementBulkResponse",
            '200': "MeasurementBulkResponse",
            '500': "ErrorResponse",
            '401': "ErrorResponse",
            '413': "ErrorResponse",
            '403': "ErrorResponse",
            '504': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def save_measurements_bulk_without_preload_content(
        self,
        measurement_bulk_request: MeasurementBulkRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Save measurements in bulk

        Save measurements in bulk    Data sent in this manner cannot be monitored via the patient live observation window. The historical view is not affected. The session must be created before calling this API. This is done with the create or start session APIs.  (*)This parameter is mandatory only if its optional parent attribute is defined. Click <a href=\"https://docs.biot-med.com/docs/biot-rest-api#api-optional-parameters\" target=\"_blank\">here</a> for more information.  Request Body Parameters:  | Parameter   |Type   | Mandatory| Description          | Example   | |-------------|-------|----------|----------------------|-----------| |measures|array|false|List of measurement to be written to  the DB|| |measures[index]|array|false|List of measurement to be written to  the DB|| |measures[index].metadata|object|false||| |measures[index].metadata.timestamp|string|true(*)|A UTC date-time in the ISO-8601 format|2007-12-20T10:15:30Z| |measures[index].metadata.deviceId|string|false|The device id that sent the measurement|device12345| |measures[index].metadata.patientId|string|false|The patient id that the measurement belongs to|3fa85f64-5717-4562-b3fc-2c963f66afa6| |measures[index].metadata.sessionId|string|false|The session id that the measurement belongs to|6b52af6e-92c8-4827-aaf2-d8805586ab5f| |measures[index].data|object|false|||   This API requires **PROTECTED_API** permission(s).  

        :param measurement_bulk_request: (required)
        :type measurement_bulk_request: MeasurementBulkRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._save_measurements_bulk_serialize(
            measurement_bulk_request=measurement_bulk_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '206': "MeasurementBulkResponse",
            '200': "MeasurementBulkResponse",
            '500': "ErrorResponse",
            '401': "ErrorResponse",
            '413': "ErrorResponse",
            '403': "ErrorResponse",
            '504': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _save_measurements_bulk_serialize(
        self,
        measurement_bulk_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if measurement_bulk_request is not None:
            _body_params = measurement_bulk_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/measurements/bulk',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


