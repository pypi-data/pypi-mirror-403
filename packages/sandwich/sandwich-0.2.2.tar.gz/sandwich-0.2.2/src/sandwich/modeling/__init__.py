from dataclasses import dataclass
from typing import Any

from sqlalchemy import Table

@dataclass(frozen=True)
class StgInfo:
    stg_name: str
    stg_schema: str
    hk_keys: dict[str, Any]
    bk_keys: dict[str, Any]
    sys_columns: dict[str, Any]
    bus_columns: dict[str, Any]

class Dv2ModelingMetadata:
    HEADER_TEMPLATE = """/* 
    =====================================================================
    AUTO-GENERATED CODE â€” DO NOT EDIT MANUALLY
    =====================================================================

    This stored procedure was automatically generated by:
      sandwich (https://pypi.org/project/sandwich/)

    Manual changes are discouraged.
    This file may be regenerated at any time, and all manual edits
    will be overwritten.

    Created on   : {created_on:%Y-%m-%d %H:%M:%S}
    Updated on   : {updated_on:%Y-%m-%d %H:%M:%S}
    Generator    : sandwich v{version}
    Entity name  : {entity_name}

    =====================================================================
*/
"""
    loaddate = "LoadDate"
    recordsource = "RecordSource"
    hashdiff = "HashDiff"
    is_available = "IsAvailable"
    names: list[str] = [loaddate, recordsource, hashdiff, is_available]
    # _dialects_config: dict[str, dict[str, str]] = {
    #     "mssql": {
    #         loaddate: "DATETIME2",
    #         recordsource: "VARCHAR(200)",
    #         hashdiff: "CHAR(40)",
    #         is_available: "BIT",
    #     },
    #     "postgres": {
    #         loaddate: "TIMESTAMP",
    #         recordsource: "TEXT",
    #         hashdiff: "CHAR(40)",
    #         is_available: "BOOLEAN",
    #     },
    # }
    def __init__(self):
        #self.dialect = dialect

        #self.column_types = self._dialects_config[self.dialect]
        self.required_columns: list[str] = [self.loaddate, self.recordsource]


modeling_metadata = Dv2ModelingMetadata()

def get_stg_info(stg: Table) -> StgInfo:
    hk_keys: dict[str, Any] = {}
    bk_keys: dict[str, Any] = {}
    sys_columns: dict[str, Any] = {}
    bus_columns: dict[str, Any] = {}

    for col in stg.columns.values():
        if col.name.startswith("hk_"):
            hk_keys[col.name] = col.type
        elif col.name.startswith("bk_"):
            bk_keys[col.name] = col.type
        elif col.name.startswith("sg_"):
            raise Exception(f"sg column '{col.name}' is not implemented yet")
        elif col.name.startswith("ts_"):
            raise Exception(f"ts column '{col.name}' is not implemented yet")
        elif col.name in modeling_metadata.names:
            # type_name = metadata.column_types[col.name]
            # if not str(col.type).startswith(type_name):
            #     raise Exception(f"{col.name} column must be `{type_name}` type, but it is `{str(col.type)}`")
            sys_columns[col.name] = col.type
        else:
            bus_columns[col.name] = col.type

    return StgInfo(
        stg_name=stg.name,
        stg_schema=stg.schema,
        hk_keys=hk_keys,
        bk_keys=bk_keys,
        sys_columns=sys_columns,
        bus_columns=bus_columns,
    )

def infer_template(stg_info: StgInfo):
    hk_count = len(stg_info.hk_keys)
    if hk_count == 0:
        raise Exception("hk column is required for `scd2dim` validation")
    elif hk_count > 1:
        return "link2fact"
    else:
        return "scd2dim"