import os
import pandas as pd
import shutil
import subprocess
from pathlib import Path
from string import Template
from typing import Callable
from .cycles import Cycles
from .cycles_tools import generate_control_file
from .cycles_tools import generate_nudge_file

class CyclesRunner():
    def __init__(self, *, simulations: pd.DataFrame, summary: str='summary.csv', control_dict: Callable, calibration_dict: Callable | dict | None=None, operation_template: str | Path | None=None, operation_dict: Callable | dict | None=None):
        self.simulations: pd.DataFrame = simulations
        self.summary_file: str = summary
        self.operation_template: Path | None = Path(operation_template) if operation_template is not None else None
        self.operation_dict: Callable | None = operation_dict
        self.control_dict: Callable = control_dict
        self.calibration_dict: Callable | dict | None = calibration_dict


    def run(self, cycles_executable: Path | str, *, options: str='', rm_input: bool=False, rm_output: bool=False, silence: bool=True) -> None:
        Path('summary').mkdir(exist_ok=True)

        if isinstance(cycles_executable, Path):
            cycles_executable = str(cycles_executable.resolve())

        comments = _generate_comment(cycles_executable, options)

        # Read simulation file
        first = True
        for _, row in self.simulations.iterrows():
            # Use defined simulation name
            name = self.control_dict(row)['simulation_name']

            print(f'{name} - ', end='')

            # Get name of operation file from defined control parameters
            operation_fn = self.control_dict(row)['operation_file']

            if self.operation_template is not None and self.operation_dict is not None:
                _generate_input_from_template(self.operation_template, Path('input') / operation_fn, self.operation_dict(row))

            if self.calibration_dict is not None:
                generate_nudge_file(Path('input') / f'{name}.nudge', self.calibration_dict(row) if callable(self.calibration_dict) else self.calibration_dict)

            generate_control_file(Path('input') / f'{name}.ctrl', self.control_dict(row))

            # Run a Cycles simulation
            if _run_cycles(cycles_executable, name, options=options, silence=silence) == 0:
                _write_summary(name, first, comments, Path('summary') / self.summary_file)
                print('Success')
                first = False
            else:
                print('Fail')

            if rm_input:
                (Path('input') / f'{name}.ctrl').unlink(missing_ok=True)
                (Path('input') / f'{name}_ss.soil').unlink(missing_ok=True)
                (Path('input') / f'{name}.nudge').unlink(missing_ok=True)

                # Only remove operation files if generated by Cycles runner
                if self.operation_template is not None and self.operation_dict is not None:
                    (Path('input') / operation_fn).unlink(missing_ok=True)

            if rm_output:
                shutil.rmtree(Path('output') / name, ignore_errors=True)


def _generate_comment(cycles_executable: str, options: str):
    result = subprocess.run(
        [cycles_executable, '-V'],
        shell=True if os.name == 'nt' else False,
        capture_output=True,
        text=True,
    )

    return f'# {"".join(result.stdout.splitlines())}{" with" if "s" in options else " without"} spin-up{", with calibration" if "c" in options else ""}{", grain model turned on" if "g" in options else ""}\n'


def _run_cycles(cycles_executable: str, simulation: str, options: str, silence: bool):
    cmd = [cycles_executable, options, simulation] if options else [cycles_executable, simulation]

    result = subprocess.run(
        cmd,
        shell=True if os.name == 'nt' else False,
        stdout=subprocess.DEVNULL if silence is True else None,
        stderr=subprocess.DEVNULL if silence is True else None,
    )

    return result.returncode


def _write_summary(simulation: str, header: bool, comments: str, summary_fn: Path) -> None:
    cycles = Cycles(path='.', simulation=simulation)
    cycles.read_output('harvest')
    cycles.output['harvest'].data.insert(0, 'simulation', simulation)

    with open(summary_fn, 'w' if header is True else 'a') as f:
        if header is True:
            f.write(comments)
        cycles.output['harvest'].data.to_csv(f, header=header, index=False)


def _generate_input_from_template(template_fn: Path, input_fn: Path, user_dict: dict) -> None:
    with open(template_fn) as f:
        operation_file_template = Template(f.read())

    with open(input_fn, 'w') as f:
        f.write(operation_file_template.substitute(user_dict) + '\n')
