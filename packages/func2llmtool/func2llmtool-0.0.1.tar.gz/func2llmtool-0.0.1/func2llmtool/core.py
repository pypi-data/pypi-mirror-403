"""Development of func2llmtool"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto #0
__all__ = ['FuncInfoPropsParam', 'FuncInfo']

# %% ../nbs/00_core.ipynb #53aed8f4
from typing import Callable, Literal
import inspect
from dataclasses import dataclass
# local imports
from .docments import docments, parse_docstring

# %% ../nbs/00_core.ipynb #efc015f5
@dataclass
class FuncInfoPropsParam:
    """Info related to argument, including automatic conversion"""
    type: str  # argument type
    description: str  # argument comment
    
    def __post_init__(self):
        """Automatically convert data type to name of datatype directly after init"""
        type_map = {str: "string", int: "integer", float: "number", bool: "boolean", list: "array", dict: "object"}
        if self.type in type_map: self.type = type_map[self.type]
        elif self.type not in type_map.values(): raise ValueError(f"Type {self.type} not supported.")

# %% ../nbs/00_core.ipynb #11669fa0
@dataclass(repr=False)
class FuncInfo:
    """Class that stores all data to outputing a OpenAI / LiteLLM tool description and necessary conversion functions."""
    func_name: str  # name of function
    description: str  # description what the function does
    properties: dict[str, FuncInfoPropsParam]  # explanation of each argument
    required: list[str]  # which arguments are required
    additional_properties: bool = False
    strict: bool = True

    def __call__(self, *args, **kwargs):
        return self.to_tool_dict()

    def __repr__(self):
        import json
        
        return json.dumps(self.to_tool_dict(), indent=4)
    
    @classmethod
    def from_func(
        cls,  # class variables
        f: str|Callable  # function itself or function name (needs to be executed)
    ) -> 'FuncInfo':
        """Extracts required data from a Python function"""

        # get function if only function name is provided
        if isinstance(f, str):
            frame = inspect.currentframe().f_back
            f = frame.f_locals.get(f) or frame.f_globals.get(f)
            if f is None: raise KeyError(f"Function '{f}' not found in caller's scope")
            # Dev Notebook
            if f is None:
                import sys
                f = getattr(sys.modules.get('__main__'), fname, None)

        # get variable doc annotations
        d = docments(f, full=True)

        prop_dict = {}
        required = []
        extra_desc = ""
        # loop over every param
        for param_name, dct in d.items():
            fipp = FuncInfoPropsParam(type=dct['anno'], description=dct['docment'])
            # get all non-return params
            if param_name != 'return':
                prop_dict[param_name] = fipp
                if dct['default'] == inspect._empty:
                    required.append(param_name)
            # add return type and comment to tool description (no field defined in standard)
            else:
                extra_desc = f" Return type: {fipp.type}"
                if fipp.description is not None or fipp.description != "":
                    extra_desc += f" ({fipp.description})"

        # Support parsing of Numpy-style docstrings
        parsed = parse_docstring(f.__doc__)
        doc = parsed.get('Summary', f.__doc__).strip() if parsed else f.__doc__

        return cls(
            func_name=f.__name__,
            description=doc + extra_desc,  # f.__doc__ +
            properties=prop_dict,
            required=required,
        )

    def to_tool_dict(self, format: Literal["litellm", "openai"] = "litellm") -> dict:
        """Exports data to OpenAI / LiteLLM tool dict format"""
        props = {k: {"type": v.type, "description": v.description} for k,v in self.properties.items()}

        if format == "litellm":
            return dict(
                type="function",
                function=dict(
                    name=self.func_name,
                    description=self.description,
                    parameters=dict(
                        type="object",
                        properties=props,
                        required=self.required,
                        additionalProperties=self.additional_properties
                    ),
                )
            )
        elif format == "openai":
            return dict(
                type="function",
                name=self.func_name,
                description=self.description,
                parameters=dict(
                    type="object",
                    properties=props,
                    required=self.required,
                    additionalProperties=self.additional_properties
                ),
                strict=self.strict,
            )
        else:
            raise ValueError(f"Unspported value for format: {format}")

    def set_strict(is_strict: bool):
        """Set strict mode. If True, only the parameters defined in the function will be used."""
        self.strict = is_strict

    def set_additional_properties(props: dict):
        """Set additional properties."""
        self.additional_properties = props
