<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Financial Plot - Interactive Charts</title>
    <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background-color: #1e1e1e;
            color: #ffffff;
            padding: 15px;
            height: 100vh;
            overflow: hidden;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding: 12px;
            background-color: #2d2d2d;
            border-radius: 8px;
        }

        .ticker-input {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .ticker-input input {
            padding: 8px 12px;
            border: 1px solid #404040;
            border-radius: 4px;
            background-color: #3d3d3d;
            color: #ffffff;
            font-size: 14px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            background-color: #007acc;
            color: white;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }

        .btn:hover {
            background-color: #005a9e;
        }

        .btn.secondary {
            background-color: #404040;
        }

        .btn.secondary:hover {
            background-color: #505050;
        }

        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            padding: 12px;
            background-color: #2d2d2d;
            border-radius: 8px;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .control-group label {
            font-size: 12px;
            color: #cccccc;
            margin-right: 5px;
        }

        .period-btn {
            padding: 6px 12px;
            border: 1px solid #404040;
            border-radius: 4px;
            background-color: #3d3d3d;
            color: #ffffff;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .period-btn:hover {
            background-color: #505050;
        }

        .period-btn.active {
            background-color: #007acc;
            border-color: #007acc;
        }

        .export-controls {
            display: flex;
            gap: 10px;
        }

        .chart-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            height: calc(100vh - 170px);
        }

        .price-chart {
            height: 70%;
            background-color: #2d2d2d;
            border-radius: 8px;
            position: relative;
        }

        .drawdown-chart {
            height: 30%;
            background-color: #2d2d2d;
            border-radius: 8px;
            position: relative;
        }

        .chart-title {
            position: absolute;
            top: 10px;
            left: 15px;
            font-size: 16px;
            font-weight: 600;
            z-index: 10;
            color: #ffffff;
        }

        .stats-overlay {
            position: absolute;
            top: 10px;
            right: 15px;
            background-color: rgba(45, 45, 45, 0.9);
            padding: 10px;
            border-radius: 6px;
            font-size: 12px;
            z-index: 10;
            min-width: 200px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }

        .stat-label {
            color: #cccccc;
        }

        .stat-value {
            color: #ffffff;
            font-weight: 600;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
            color: #cccccc;
        }

        .error {
            display: none;
            text-align: center;
            padding: 20px;
            color: #ff6b6b;
            background-color: #2d2d2d;
            border-radius: 8px;
            margin: 20px 0;
        }

        .animation-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .animation-controls input[type="range"] {
            width: 100px;
        }

        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                gap: 10px;
                align-items: stretch;
            }

            .controls {
                flex-direction: column;
                gap: 10px;
            }

            .control-group {
                flex-wrap: wrap;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="ticker-input">
            <input type="text" id="ticker" placeholder="Enter ticker symbol (e.g., AAPL, SPY)" value="SPY">
            <button class="btn" onclick="fetchData()">Load Data</button>
        </div>
        <div class="export-controls">
            <button class="btn secondary" onclick="exportData('csv')">Export CSV</button>
            <button class="btn secondary" onclick="exportData('json')">Export JSON</button>
            <button class="btn secondary" onclick="takeScreenshot()">Screenshot</button>
        </div>
    </div>

    <div class="controls">
        <div class="control-group">
            <label>Time Period:</label>
            <button class="period-btn" onclick="setPeriod('1m')">1M</button>
            <button class="period-btn" onclick="setPeriod('3m')">3M</button>
            <button class="period-btn" onclick="setPeriod('6m')">6M</button>
            <button class="period-btn" onclick="setPeriod('1y')">1Y</button>
            <button class="period-btn" onclick="setPeriod('2y')">2Y</button>
            <button class="period-btn" onclick="setPeriod('5y')">5Y</button>
            <button class="period-btn active" onclick="setPeriod('max')">MAX</button>
        </div>

        <div class="animation-controls">
            <label>Animation:</label>
            <button class="btn secondary" onclick="animateChart()">Play Timeline</button>
            <input type="range" id="animationSpeed" min="1" max="10" value="5" title="Animation Speed">
            <span>Speed</span>
        </div>
    </div>

    <div class="loading" id="loading">Loading data...</div>
    <div class="error" id="error"></div>

    <div class="chart-container">
        <div class="price-chart">
            <div class="chart-title">Normalized Price</div>
            <div class="stats-overlay" id="priceStats"></div>
            <div id="priceChart"></div>
        </div>
        <div class="drawdown-chart">
            <div class="chart-title">Drawdown</div>
            <div class="stats-overlay" id="drawdownStats"></div>
            <div id="drawdownChart"></div>
        </div>
    </div>

    <script>
        let priceChart = null;
        let drawdownChart = null;
        let currentPeriod = 'max';
        const currentInterval = '1d';  // Fixed to daily data
        let currentData = null;
        let animationTimer = null;
        let dataCache = new Map(); // Cache for faster subsequent loads
        let preloadPromise = null; // For parallel data loading
        let masterDataCache = new Map(); // Cache for full 5-year datasets
        let isPreloadingMaster = false;

        // Preload 5 years of data by default, then trim for shorter periods
        function preloadDefaultData() {
            const defaultTicker = document.getElementById('ticker').value || 'SPY';

            // Preload 5 years of daily data only
            const interval = '1d';
            const masterCacheKey = `${defaultTicker}_master_${interval}`;

            if (!masterDataCache.has(masterCacheKey) && !isPreloadingMaster) {
                isPreloadingMaster = true;

                console.log(`ðŸ”„ Preloading 5 years of daily data for ${defaultTicker}...`);

                fetchDataFromAPI(defaultTicker, '5y', interval)
                    .then(data => {
                        masterDataCache.set(masterCacheKey, data);
                        console.log(`âœ… Preloaded 5 years of daily data for ${defaultTicker}`);

                        // Show the data immediately
                        const trimmedData = trimDataToPeriod(data, currentPeriod);
                        currentData = trimmedData;
                        updateCharts(trimmedData, defaultTicker);
                        updateStats(trimmedData, defaultTicker);
                        showDataStatus('ðŸ“Š Data ready (5yr cached)');
                        setTimeout(() => hideError(), 2000);

                        isPreloadingMaster = false;
                    })
                    .catch(error => {
                        console.warn(`Failed to preload daily data:`, error);
                        isPreloadingMaster = false;
                    });
            }

            // Return the promise for the current period from master data if available
            if (masterDataCache.has(masterCacheKey)) {
                const masterData = masterDataCache.get(masterCacheKey);
                const trimmedData = trimDataToPeriod(masterData, currentPeriod);
                preloadPromise = Promise.resolve(trimmedData);
            } else {
                // Fallback to direct API call for current period
                preloadPromise = fetchDataFromAPI(defaultTicker, currentPeriod, currentInterval);
            }

            return preloadPromise;
        }

        // Function to trim master data to requested time period
        function trimDataToPeriod(masterData, period) {
            if (period === 'max' || period === '5y') {
                return masterData; // Return full dataset
            }

            const endDate = new Date(masterData.dates[masterData.dates.length - 1]);
            let startDate = new Date(endDate);

            // Calculate start date based on period
            switch(period) {
                case '1m':
                    startDate.setMonth(endDate.getMonth() - 1);
                    break;
                case '3m':
                    startDate.setMonth(endDate.getMonth() - 3);
                    break;
                case '6m':
                    startDate.setMonth(endDate.getMonth() - 6);
                    break;
                case '1y':
                    startDate.setFullYear(endDate.getFullYear() - 1);
                    break;
                case '2y':
                    startDate.setFullYear(endDate.getFullYear() - 2);
                    break;
                default:
                    return masterData; // Unknown period, return full data
            }

            // Find the index where data should start
            const startIndex = masterData.dates.findIndex(date => new Date(date) >= startDate);
            if (startIndex === -1) return masterData; // If no data found, return full dataset

            // Trim all data arrays
            const trimmedData = {
                ...masterData,
                dates: masterData.dates.slice(startIndex),
                price: {},
                drawdown: {},
                raw_price: {}
            };

            // Trim price data for each ticker
            Object.keys(masterData.price).forEach(ticker => {
                trimmedData.price[ticker] = masterData.price[ticker].slice(startIndex);
                if (masterData.drawdown[ticker]) {
                    trimmedData.drawdown[ticker] = masterData.drawdown[ticker].slice(startIndex);
                }
                if (masterData.raw_price && masterData.raw_price[ticker]) {
                    trimmedData.raw_price[ticker] = masterData.raw_price[ticker].slice(startIndex);
                }
            });

            // Recalculate period-specific metrics
            if (trimmedData.dates.length > 0) {
                const startDateObj = new Date(trimmedData.dates[0]);
                const endDateObj = new Date(trimmedData.dates[trimmedData.dates.length - 1]);
                trimmedData.period_days = Math.floor((endDateObj - startDateObj) / (1000 * 60 * 60 * 24));
                trimmedData.start_date = trimmedData.dates[0];
                trimmedData.end_date = trimmedData.dates[trimmedData.dates.length - 1];

                // Recalculate total return for trimmed period
                trimmedData.total_return = {};
                Object.keys(trimmedData.price).forEach(ticker => {
                    const prices = trimmedData.price[ticker].filter(p => p !== null);
                    if (prices.length > 1) {
                        const first = prices[0];
                        const last = prices[prices.length - 1];
                        trimmedData.total_return[ticker] = ((last - first) / first) * 100;
                    }
                });
            }

            return trimmedData;
        }

        // Initialize charts immediately for faster startup
        function initChartsEarly() {
            // Initialize charts as soon as DOM is ready
            setTimeout(() => {
                if (!priceChart || !drawdownChart) {
                    initCharts();
                }
            }, 0);
        }

        // Initialize charts
        function initCharts() {
            const chartOptions = {
                layout: {
                    background: { color: '#2d2d2d' },
                    textColor: '#ffffff',
                },
                grid: {
                    vertLines: { color: '#404040' },
                    horzLines: { color: '#404040' },
                },
                crosshair: {
                    mode: LightweightCharts.CrosshairMode.Normal,
                },
                rightPriceScale: {
                    borderColor: '#404040',
                },
                timeScale: {
                    borderColor: '#404040',
                    timeVisible: true,
                    secondsVisible: false,
                },
            };

            priceChart = LightweightCharts.createChart(document.getElementById('priceChart'), {
                ...chartOptions,
                height: document.querySelector('.price-chart').clientHeight - 40,
            });

            drawdownChart = LightweightCharts.createChart(document.getElementById('drawdownChart'), {
                ...chartOptions,
                height: document.querySelector('.drawdown-chart').clientHeight - 40,
            });

            // Sync crosshair between charts
            priceChart.subscribeCrosshairMove((param) => {
                if (param.time) {
                    drawdownChart.setCrosshairPosition(param.point?.x, param.time, param.point?.y);
                }
            });

            drawdownChart.subscribeCrosshairMove((param) => {
                if (param.time) {
                    priceChart.setCrosshairPosition(param.point?.x, param.time, param.point?.y);
                }
            });
        }

        function setPeriod(period) {
            document.querySelectorAll('.period-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            currentPeriod = period;

            const ticker = document.getElementById('ticker').value.toUpperCase();
            if (ticker) {
                // Try to use master data cache first
                const masterCacheKey = `${ticker}_master_1d`;
                if (masterDataCache.has(masterCacheKey)) {
                    console.log(`ðŸš€ Using cached 5yr data, trimming to ${period}`);
                    const masterData = masterDataCache.get(masterCacheKey);
                    const trimmedData = trimDataToPeriod(masterData, period);

                    currentData = trimmedData;
                    updateCharts(trimmedData, ticker);
                    updateStats(trimmedData, ticker);
                    showDataStatus('âš¡ Instant load from cache');
                    setTimeout(() => hideError(), 1500);
                } else {
                    // Fallback to regular cache or API call
                    const cacheKey = `${ticker}_${period}_1d`;
                    if (dataCache.has(cacheKey)) {
                        const cachedData = dataCache.get(cacheKey);
                        currentData = cachedData;
                        updateCharts(cachedData, ticker);
                        updateStats(cachedData, ticker);
                        showDataStatus('ðŸ“Š Loaded from cache');
                        setTimeout(() => hideError(), 1500);
                    } else {
                        fetchData();
                    }
                }
            }
        }

        // Direct API call function (separated from caching logic)
        async function fetchDataFromAPI(ticker, period, interval) {
            const url = `/data?ticker=${ticker}&since=${period}&interval=${interval}`;

            const response = await fetch(url);
            const data = await response.json();

            if (response.status === 404) {
                throw new Error(data.error);
            }

            return data;
        }

        async function fetchDataInternal(ticker, period, interval, updateUI = true) {
            // First, try to use master data cache and trim
            const masterCacheKey = `${ticker}_master_${interval}`;
            if (masterDataCache.has(masterCacheKey)) {
                console.log(`ðŸš€ Using master cache for ${ticker} ${period} ${interval}`);
                const masterData = masterDataCache.get(masterCacheKey);
                const trimmedData = trimDataToPeriod(masterData, period);

                if (updateUI) {
                    currentData = trimmedData;
                    updateCharts(trimmedData, ticker);
                    updateStats(trimmedData, ticker);
                    showDataStatus('âš¡ Instant load from 5yr cache');
                    setTimeout(() => hideError(), 1500);
                }
                return trimmedData;
            }

            // Second, try regular cache
            const cacheKey = `${ticker}_${period}_${interval}`;
            if (dataCache.has(cacheKey)) {
                console.log(`ðŸ“¦ Using regular cache for ${ticker} ${period} ${interval}`);
                const cachedData = dataCache.get(cacheKey);
                if (updateUI) {
                    currentData = cachedData;
                    updateCharts(cachedData, ticker);
                    updateStats(cachedData, ticker);
                    showDataStatus('ðŸ“Š Loaded from cache');
                    setTimeout(() => hideError(), 1500);
                }
                return cachedData;
            }

            // Third, make API call
            if (updateUI) {
                showLoading(true);
            }

            try {
                console.log(`ðŸŒ API call for ${ticker} ${period} ${interval}`);
                const data = await fetchDataFromAPI(ticker, period, interval);

                // Cache the result
                dataCache.set(cacheKey, data);

                // If this is a 5yr call, also cache as master data
                if (period === '5y') {
                    masterDataCache.set(masterCacheKey, data);
                    console.log(`ðŸ’¾ Cached as master data: ${masterCacheKey}`);
                }

                if (updateUI) {
                    currentData = data;
                    updateCharts(data, ticker);
                    updateStats(data, ticker);
                    showDataStatus('ðŸ“ˆ Fresh data loaded');
                    setTimeout(() => hideError(), 2000);
                }

                return data;

            } catch (error) {
                if (updateUI) showError(`Failed to fetch data: ${error.message}`);
                throw error;
            } finally {
                if (updateUI) showLoading(false);
            }
        }

        async function fetchData() {
            const ticker = document.getElementById('ticker').value.toUpperCase();
            if (!ticker) return;

            showLoading(true);
            hideError();

            try {
                await fetchDataInternal(ticker, currentPeriod, currentInterval, true);

                // Start preloading master data if not already cached
                const masterCacheKey = `${ticker}_master_1d`;
                if (!masterDataCache.has(masterCacheKey) && !isPreloadingMaster) {
                    // Preload in background for future use
                    setTimeout(() => {
                        if (!masterDataCache.has(masterCacheKey) && !isPreloadingMaster) {
                            console.log(`ðŸ”„ Background preload of 5yr daily data for ${ticker}...`);
                            isPreloadingMaster = true;

                            fetchDataFromAPI(ticker, '5y', '1d')
                                .then(data => {
                                    masterDataCache.set(masterCacheKey, data);
                                    console.log(`âœ… Background preload complete for ${ticker} daily`);
                                    isPreloadingMaster = false;
                                })
                                .catch(error => {
                                    console.warn('Background preload failed:', error);
                                    isPreloadingMaster = false;
                                });
                        }
                    }, 1000); // Start background preload 1 second after current load
                }
            } catch (error) {
                console.error('Error fetching data:', error);
            } finally {
                showLoading(false);
            }
        }

        function updateCharts(data, ticker) {
            if (!priceChart || !drawdownChart) initCharts();

            // Clear existing series - remove all series and recreate
            if (window.priceSeries) {
                priceChart.removeSeries(window.priceSeries);
                window.priceSeries = null;
            }
            if (window.drawdownSeries) {
                drawdownChart.removeSeries(window.drawdownSeries);
                window.drawdownSeries = null;
            }

            // Process data for charts
            const dates = data.dates;
            const tickers = Object.keys(data.price);

            // Create series for each ticker
            tickers.forEach((tickerName, index) => {
                const priceData = dates.map((date, i) => ({
                    time: date,
                    value: data.price[tickerName][i]
                })).filter(item => item.value !== null && !isNaN(item.value));

                const drawdownData = dates.map((date, i) => ({
                    time: date,
                    value: data.drawdown[tickerName][i]
                })).filter(item => item.value !== null && !isNaN(item.value));

                // Add price series (store reference for the primary ticker)
                const priceSeries = priceChart.addLineSeries({
                    color: getTickerColor(index),
                    lineWidth: 2,
                    priceFormat: {
                        type: 'price',
                        precision: 2,
                    },
                });
                priceSeries.setData(priceData);

                // Store reference to primary series for cleanup
                if (index === 0) {
                    window.priceSeries = priceSeries;
                }

                // Add drawdown series (store reference for the primary ticker)
                const drawdownSeries = drawdownChart.addAreaSeries({
                    topColor: `${getTickerColor(index)}40`,
                    bottomColor: `${getTickerColor(index)}00`,
                    lineColor: getTickerColor(index),
                    lineWidth: 2,
                    priceFormat: {
                        type: 'percent',
                        precision: 2,
                    },
                });
                drawdownSeries.setData(drawdownData);

                // Store reference to primary series for cleanup
                if (index === 0) {
                    window.drawdownSeries = drawdownSeries;
                }
            });

            // Fit charts to data
            priceChart.timeScale().fitContent();
            drawdownChart.timeScale().fitContent();
        }

        function getTickerColor(index) {
            const colors = ['#007acc', '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7', '#dda0dd', '#98d8c8'];
            return colors[index % colors.length];
        }

        function updateStats(data, ticker) {
            const tickers = Object.keys(data.price);

            // Update price stats
            const priceStatsHtml = tickers.map(tickerName => {
                const prices = data.price[tickerName].filter(p => p !== null);
                const latest = prices[prices.length - 1];
                const first = prices[0];
                const change = ((latest - first) / first * 100);

                return `
                    <div class="stat-row">
                        <span class="stat-label">${tickerName}:</span>
                        <span class="stat-value" style="color: ${change >= 0 ? '#4ecdc4' : '#ff6b6b'}">
                            ${change >= 0 ? '+' : ''}${change.toFixed(2)}%
                        </span>
                    </div>
                `;
            }).join('');

            document.getElementById('priceStats').innerHTML = priceStatsHtml;

            // Update drawdown stats
            const drawdownStatsHtml = tickers.map(tickerName => {
                const drawdowns = data.drawdown[tickerName].filter(d => d !== null);
                const maxDrawdown = Math.min(...drawdowns);

                return `
                    <div class="stat-row">
                        <span class="stat-label">${tickerName} Max DD:</span>
                        <span class="stat-value" style="color: #ff6b6b">
                            ${maxDrawdown.toFixed(2)}%
                        </span>
                    </div>
                `;
            }).join('');

            document.getElementById('drawdownStats').innerHTML = drawdownStatsHtml;
        }

        function showLoading(show) {
            const loadingEl = document.getElementById('loading');
            const chartsEl = document.querySelector('.chart-container');

            if (show) {
                loadingEl.style.display = 'block';
                loadingEl.textContent = 'Loading data...';
                // Don't hide charts immediately - keep them visible during transitions
            } else {
                loadingEl.style.display = 'none';
                chartsEl.style.opacity = '1';
            }
        }

        function showDataStatus(message) {
            const loadingEl = document.getElementById('loading');
            loadingEl.style.display = 'block';
            loadingEl.textContent = message;
            loadingEl.style.color = '#4ecdc4'; // Success color
        }

        function hideError() {
            document.getElementById('error').style.display = 'none';
        }

        function showError(message) {
            document.getElementById('error').textContent = message;
            document.getElementById('error').style.display = 'block';
        }

        function exportData(format) {
            if (!currentData) {
                alert('No data to export. Please load data first.');
                return;
            }

            const ticker = document.getElementById('ticker').value.toUpperCase();
            let content, filename, mimeType;

            if (format === 'csv') {
                content = convertToCSV(currentData);
                filename = `${ticker}_${currentPeriod}_${currentInterval}.csv`;
                mimeType = 'text/csv';
            } else if (format === 'json') {
                content = JSON.stringify(currentData, null, 2);
                filename = `${ticker}_${currentPeriod}_${currentInterval}.json`;
                mimeType = 'application/json';
            }

            downloadFile(content, filename, mimeType);
        }

        function convertToCSV(data) {
            const dates = data.dates;
            const tickers = Object.keys(data.price);

            let csv = 'Date,' + tickers.map(t => `${t}_Price,${t}_Drawdown`).join(',') + '\n';

            dates.forEach((date, i) => {
                let row = date;
                tickers.forEach(ticker => {
                    row += `,${data.price[ticker][i]},${data.drawdown[ticker][i]}`;
                });
                csv += row + '\n';
            });

            return csv;
        }

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }

        function takeScreenshot() {
            // Use html2canvas or similar library for screenshots
            alert('Screenshot functionality would require html2canvas library. For now, use browser\'s built-in screenshot.');
        }

        function animateChart() {
            if (!currentData) return;

            const speed = document.getElementById('animationSpeed').value;
            const dates = currentData.dates;
            let currentIndex = 0;

            if (animationTimer) {
                clearInterval(animationTimer);
                animationTimer = null;
                return;
            }

            animationTimer = setInterval(() => {
                if (currentIndex >= dates.length) {
                    clearInterval(animationTimer);
                    animationTimer = null;
                    return;
                }

                // Update charts with data up to current index
                const partialData = {
                    dates: dates.slice(0, currentIndex + 1),
                    price: {},
                    drawdown: {}
                };

                Object.keys(currentData.price).forEach(ticker => {
                    partialData.price[ticker] = currentData.price[ticker].slice(0, currentIndex + 1);
                    partialData.drawdown[ticker] = currentData.drawdown[ticker].slice(0, currentIndex + 1);
                });

                updateCharts(partialData, document.getElementById('ticker').value);
                currentIndex++;
            }, 1000 / speed);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            if (priceChart && drawdownChart) {
                priceChart.resize(
                    document.querySelector('.price-chart').clientWidth,
                    document.querySelector('.price-chart').clientHeight - 40
                );
                drawdownChart.resize(
                    document.querySelector('.drawdown-chart').clientWidth,
                    document.querySelector('.drawdown-chart').clientHeight - 40
                );
            }
        });

        // Initialize on page load - optimized for speed
        document.addEventListener('DOMContentLoaded', () => {
            // Check URL parameters for preloading instructions
            const urlParams = new URLSearchParams(window.location.search);
            const tickerParam = urlParams.get('ticker');
            const sinceParam = urlParams.get('since');
            const preloadParam = urlParams.get('preload');

            if (tickerParam) {
                document.getElementById('ticker').value = tickerParam.toUpperCase();
            }

            if (sinceParam) {
                currentPeriod = sinceParam;
                // Update active button
                document.querySelectorAll('.period-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.onclick.toString().includes(`'${sinceParam}'`)) {
                        btn.classList.add('active');
                    }
                });
            }

            // Start chart initialization immediately
            initChartsEarly();

            // If preload parameter is set, preload that amount of data
            if (preloadParam) {
                console.log(`ðŸŽ¯ CLI requested preload of ${preloadParam} data`);
                const ticker = document.getElementById('ticker').value || 'SPY';

                // Start preloading the requested amount
                fetchDataFromAPI(ticker, preloadParam, currentInterval)
                    .then(data => {
                        const masterCacheKey = `${ticker}_master_${currentInterval}`;
                        masterDataCache.set(masterCacheKey, data);
                        console.log(`âœ… Preloaded ${preloadParam} data as requested by CLI`);

                        // Show the current period from the preloaded data
                        const trimmedData = trimDataToPeriod(data, currentPeriod);
                        currentData = trimmedData;

                        // Wait for charts to be ready
                        const waitForCharts = () => {
                            if (priceChart && drawdownChart) {
                                updateCharts(trimmedData, ticker);
                                updateStats(trimmedData, ticker);
                                showDataStatus(`ðŸš€ ${preloadParam.toUpperCase()} data preloaded & ready`);
                                setTimeout(() => hideError(), 3000);
                            } else {
                                setTimeout(waitForCharts, 50);
                            }
                        };
                        waitForCharts();
                    })
                    .catch(error => {
                        console.error('Preload failed:', error);
                        // Fallback to regular preload
                        preloadDefaultData();
                    });
            } else {
                // Standard preloading
                preloadDefaultData();
            }

            // Wait for charts to be ready for any remaining initialization
            const checkAndFinalize = () => {
                if (priceChart && drawdownChart && !currentData) {
                    // If no data loaded yet, load default
                    preloadPromise?.then(data => {
                        if (data && !currentData) {
                            const defaultTicker = document.getElementById('ticker').value || 'SPY';
                            currentData = data;
                            updateCharts(data, defaultTicker);
                            updateStats(data, defaultTicker);
                        }
                    }).catch(error => {
                        console.warn('Default preload failed, will load on user interaction:', error);
                    });
                }
            };

            setTimeout(checkAndFinalize, 100);
        });

        // Handle Enter key in ticker input
        document.getElementById('ticker').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                fetchData();
            }
        });
    </script>
</body>
</html>
