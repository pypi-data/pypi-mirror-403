#!/usr/bin/env python3

import math, os, argparse, string
import tkinter, matplotlib
import matplotlib.pyplot as plt
import importlib.metadata
import numpy as np
from matplotlib import rcParams
from matplotlib.animation import FuncAnimation
import csv

# Hardcoded formatting, Yay!
defcolors  = ["#1f77b4", "#ff7f0e", "#2ca02c", "#7f0000", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf", "#aec7e8","#ffbb78", "#98df8a", "#ff9896", "#c5b0d5", "#c49c94", "#f7b6d2", "#c7c7c7", "#dbdb8d", "#9edae5"]
defmarkers = ["o", "+", "v", "x", "^", "<", ">", "s", "p", "*", ".", "D", "d", "h", "H", "|", "_"]
deflines   = [ 'solid', 'dashed', 'dashdot', 'dotted' ]

#argsparse for CLI commands
def CLIArguments():
    parser = argparse.ArgumentParser(
      prog='plotxvg',
      description=
"""
Simple script to quickly plot xy files produced by e.g. ACT or GROMACS.
There is limited support for Grace features such superscripts and subscripts
in labels. Remember to add an argument for each file you want to plot. 
If datasets with different x- or y-labels are loaded together the x- and y-labels of the latter dataset will be used.
One nice feature is that you can get live updates of plots that
are generated by a running program, using the -follow option.
""",
      epilog= 'Example: plotxvg -f filename1 filename2 -ls solid dashed -save path/to/saved_plot.pdf')
    parser.add_argument("-f",   "--filename", nargs="*", help="Filename(s) to read and plot", type=str, default=[])
    parser.add_argument("-follow", "--follow", help="Continuously update the plot by re-reading the input file(s). Use for CLI operations.", action="store_true")
    parser.add_argument("-debug", "--debug", help="Turn on printing of debugging messages", action="store_true")
    fontname="Arial"
    parser.add_argument("-font", "--fontname", help="Font for all text.", type=str, default=fontname)
    allfontsizes = 0
    parser.add_argument("-allfs", "--allfontsizes", help="Scale all font sizes equally, default "+str(allfontsizes), type=int, default=allfontsizes)
    axislabelfontsize=26
    parser.add_argument("-axfs", "--axislabelfontsize", help="Axis label font size, default "+str(axislabelfontsize), type=int, default=axislabelfontsize)
    titlefontsize=30
    parser.add_argument("-tfs", "--titlefontsize", help="Title font size, set to zero for no title, default "+str(titlefontsize), type=int, default=titlefontsize)
    legendfontsize=26
    parser.add_argument("-lfs", "--legendfontsize", help="Legend font size, set to zero for no legend, default "+str(legendfontsize), type=int, default=legendfontsize)
    tickfontsize=24
    parser.add_argument("-tickfs", "--tickfontsize", help="Tick font size, default "+str(tickfontsize), type=int, default=tickfontsize)
    parser.add_argument("-ls", "--linestyle", help="What kind of line style: solid, dashed, dashdot, dotted", nargs="+", type=str, default=None)
    parser.add_argument("-mk", "--marker", help="Use markers for data sets: o, +, x, <, >...", nargs="+", type=str, default=None)
    defmksize = 10
    parser.add_argument("-mksize", "--markersize", help="Size of filled markers for data sets, default "+str(defmksize), default=defmksize, type=int)
    defmkedgew = 2
    parser.add_argument("-mkwidth", "--markeredgewidth", help="Size of character markers (e.g. +) for data sets, default "+str(defmkedgew), default=defmkedgew, type=float)
    parser.add_argument("-colors", "--colors", help="Colors for the plots. Colors defined by the user will be applied to the datasets in order. If there are more datasets than color inputs, default colors will be used.", nargs="*", type=str, default=None)
    parser.add_argument("-save", "--save", help="Save plot. Please specify saving location and preferred filetype (.pdf, .png...)", type=str, default=None)
    parser.add_argument("-sqfig", "--squarefig", help="Make the figure square", action="store_true")
    parser.add_argument("-eqax", "--equalaxes", help="Make the plot square with equally large axes", action="store_true")
    parser.add_argument("-bar", "--bar", help="Make a bar graph", action="store_true")
    parser.add_argument("-noshow", "--noshow", help="Do not show the figure", action="store_true")
    parser.add_argument("-res", "--residual", help="Subtract x from y for all data sets - useful for correlation plots", action="store_true")
    parser.add_argument("-fl", "--filelabel", help="Add the filename to the labels in the plot (may yield long labels)", action="store_true")
    parser.add_argument("-logy", "--logy", help="Use a log scale on the Y-axis", action="store_true")
    parser.add_argument("-xmin", "--xmin", help="Minimum value of X-axis. Default = defined by data.", type=float, default=0.0)
    parser.add_argument("-xmax", "--xmax", help="Maximum value of X-axis. Default = defined by data.", type=float, default=0.0)
    parser.add_argument("-ymin", "--ymin", help="Minimum value of Y-axis. Default = defined by data.", type=float, default=0.0)
    parser.add_argument("-ymax", "--ymax", help="Maximum value of Y-axis. Default = defined by data.", type=float, default=0.0)
    xframe = 16
    parser.add_argument("-xframe", "--xframe", help="Width of the plot 100 pixels, default "+str(xframe), type=int, default=xframe)
    yframe = 9
    parser.add_argument("-yframe", "--yframe", help="Height of the plot 100 pixels, default "+str(yframe), type=int, default=yframe)
    parser.add_argument("-panels", "--panels", help="Generate different panels to plot in, one file per panel. Add 'side' for side-by side panels.", nargs="?", const="top", default=None, choices=["top", "side"])
    subfigx = -0.15
    subfigy = 1.0
    parser.add_argument("-sfx", "--subfigureX", help="X position of subfigure label when using panels. Default "+str(subfigx), type=float, default=subfigx)
    parser.add_argument("-sfy", "--subfigureY", help="Y position of subfigure label when using panels. Default "+str(subfigy), type=float, default=subfigy)
    parser.add_argument('-ign', '--ignore', help="legends of the series to ignore. Please specify the whole legend label.", nargs='*', default=[])
    parser.add_argument("-title", "--title", help="User-defined title(s). This flag overwrites pre-defined titles. If the user wants to use user-defined titles and pre-defined titles on different panels, use None as placeholders for pre-defined title panels. If the user wants to remove a specific panel title, put an empty string ''.", nargs="+", type=str, default=None)
    parser.add_argument("-notitles", "--notitles", help="Remove all titles (Both user-defined and title pre-defined by data.)", action="store_true")
    parser.add_argument("-dslegends", "--datasetlegends", help="Set user-defined legends. If legends are already defined in the input file they are combined for each dataset i.e. '<user-defined legend> <pre-defined legend>'.", nargs="*", type=str, default=None)
    parser.add_argument("-sharelabel", "--sharelabel", help="Show only the x-labels on the last row of plots and the y-labels on the first column of plots (useful if all subplots share the same x- and y-labels)", action="store_true")
    leg_x = 0.02
    parser.add_argument("-legend_x", "--legend_x", help="Put the legend box horizontally on this position, default "+str(leg_x), type=float, default=leg_x)
    leg_y = 0.98
    parser.add_argument("-legend_y", "--legend_y", help="Put the legend box vertically on this position, default "+str(leg_y), type=float, default=leg_y)
    parser.add_argument("-stats", "--stats", help="Print RMSD and R2 values of datasets (x-axis is reference data and y-axis holds the predicted values)", action="store_true")
    col_x = 0
    parser.add_argument("-colx", "--colx", help="Choose what x column you would like from for example a csv file. Choose only one column. Default is column "+str(col_x), type=int, default=col_x)
    col_y = 3
    parser.add_argument("-coly", "--coly", help="Choose what y column(s) you would like from for example a csv file. Default is column "+str(col_y), nargs="+", type=str, default=str(col_y))
    parser.add_argument("-v", "--version", action="version", version=f"plotXVG version " + importlib.metadata.version('plotxvg') + ". MatPlotLib version " + matplotlib.__version__ )
    parser.add_argument("-heatmap", "--heatmap", help="2D heatmap plot", action="store_true")
    parser.add_argument("-contour", "--contour", help="Contour 2D plot", action="store_true")
    parser.add_argument("-cmap", "--colormap", help="Matplotlib colormap", type=str, default="viridis")
    parser.add_argument("-levels", "--levels", help="Number of contour levels", type=int, default=15)
    parser.add_argument("-bins", "--bins", help="Number of bins for 2D histogram", type=int, default=50)
    parser.add_argument("-gibbs", "--gibbs", help="Calculates Gibbs free energy from probabilty density", action="store_true")   
    parser.add_argument("-temp", "--temperature", help="At what temperature to calcuate Gibbs free energy according to G = kBT - log(P).", type=float, default=298.15)
    parser.add_argument("-kde", "--kde", help="Calculate probability density using kernel density estimation (kde). Preferably combined with contour rather than heatmap. OBS! You need the scipy package for this function.", action="store_true")
    parser.add_argument("-showdots", "--showdots", help="Choose to show the scattered dots together with kde.", action="store_true")
    return parser.parse_args()

class APIArguments:
    """
    This class acts as the bridge between CLI commands (args) and API commands (kwargs).
    """
    def __init__(self, **kwargs):
        #Using the same names and defaults as the argparse arguments
        self.filename = kwargs.get("filename", [])
        self.follow = kwargs.get("follow", False)
        self.debug = kwargs.get("debug", False)
        self.fontname = kwargs.get("fontname", kwargs.get("font", "Arial"))
        self.allfontsizes = kwargs.get("allfontsizes", kwargs.get("allfs", 0))
        self.axislabelfontsize = kwargs.get("axislabelfontsize", kwargs.get("axfs", 26))
        self.titlefontsize = kwargs.get("titlefontsize", kwargs.get("tfs", 30))
        self.legendfontsize = kwargs.get("legendfontsize", kwargs.get("lfs", 26))
        self.tickfontsize = kwargs.get("tickfontsize", kwargs.get("tfs", 24))
        self.linestyle = kwargs.get("linestyle", kwargs.get("ls", None))
        self.marker = kwargs.get("marker", kwargs.get("mk", None))
        self.markersize = kwargs.get("markersize", kwargs.get("mksize", 10))
        self.markeredgewidth = kwargs.get("markeredgewidth", kwargs.get("mkwidth", 2))
        self.colors = kwargs.get("colors", None)
        self.save = kwargs.get("save", None)
        self.squarefig = kwargs.get("squarefig", kwargs.get("sqfig", False))
        self.equalaxes = kwargs.get("equalaxes", kwargs.get("eqax", False))
        self.bar = kwargs.get("bar", False)
        self.noshow = kwargs.get("noshow", False)
        self.residual = kwargs.get("residual", kwargs.get("res", False))
        self.filelabel = kwargs.get("filelabel", kwargs.get("fl", False))
        self.logy = kwargs.get("logy", False)
        self.xmin = kwargs.get("xmin", 0.0)
        self.xmax = kwargs.get("xmax", 0.0)
        self.ymin = kwargs.get("ymin", 0.0)
        self.ymax = kwargs.get("ymax", 0.0)
        self.xframe = kwargs.get("xframe", 16)
        self.yframe = kwargs.get("yframe", 9)
        self.panels = kwargs.get("panels", None)
        self.subfigureX = kwargs.get("subfigureX", kwargs.get("sfx", -0.15))
        self.subfigureY = kwargs.get("subfigureY", kwargs.get("sfy", 1.0))
        self.ignore = kwargs.get("ignore", kwargs.get("ign", []))
        self.title = kwargs.get("title", None)
        self.notitles = kwargs.get("notitles", False)
        self.datasetlegends = kwargs.get("datasetlegends", kwargs.get("dslegends", None))
        self.sharelabel = kwargs.get("sharelabel", False)
        self.legend_x = kwargs.get("legend_x", 0.02)
        self.legend_y = kwargs.get("legend_y", 0.98)
        self.stats = kwargs.get("stats", False)
        self.colx = kwargs.get("colx", 0)
        self.coly = kwargs.get("coly", ["3"])
        self.heatmap = kwargs.get("heatmap", False)
        self.contour = kwargs.get("contour", False)
        self.colormap = kwargs.get("colormap", kwargs.get("cmap", "viridis"))
        self.levels = kwargs.get("levels", 15)
        self.bins = kwargs.get("bins", 100)
        self.gibbs = kwargs.get("gibbs", False)
        self.temperature = kwargs.get("temperature", kwargs.get("temp", 298.15))
        self.kde = kwargs.get("kde", False)
        self.showdots = kwargs.get("showdots", False)

def texify(txt:str)->str:
    return txt.replace("\\S", "$^{").replace("\\s", "$_{").replace("\\N", "}$") if txt.find("$") < 0 else txt

def version(): #triggered in api operation
    print("plotXVG version %s. MatPlotLib version %s" %
            (importlib.metadata.version("plotxvg"), matplotlib.__version__))
########### xvg utilities ###########
def interpret_legend(line:str):
    legval = None

    #find and save subtitle if one exists
    labkey = "subtitle"
    if line.find(labkey) >= 0:
        legval = line[line.find(labkey)+len(labkey)+1:].strip()
        legval = legval[1:-1]
        return labkey, legval

    labkey = "title"
    if line.find(labkey) >= 0:
        legval = line[line.find(labkey)+len(labkey)+1:].strip()
        legval = legval[1:-1]
        return labkey, legval
    
    for axis in [ "x", "y" ]:
        labkey  = axis+"axis"
        labkey2 = " label" #Space is added to avoid ticklegends for old Grace purposes
        if line.find(labkey) >= 0 and line.find(labkey2) >= 0:
            legval = line[line.find(labkey2)+len(labkey2)+1:].strip()
            legval = legval[1:-1]
            return axis+"label", legval
    legkey = "legend"
    if line.find(legkey) >= 0 and line[0] == 's':
        labval = line[line.find(legkey)+len(legkey)+1:].strip()
        labval = labval[1:-1]
        return legkey, labval
    return None, None

class xvgDataSet:
    '''A simple class to hold an xvg data set'''
    def __init__(self, line:str):
        self.x = []
        self.y = []
        self.z = [] # height values for contour and pcolormesh
        self.dy = None
        if line.find("xydy") >= 0:
            self.dy = []
        self.xmin = 1e9
        self.xmax = -1e9
        self.ymin = 1e9
        self.ymax = -1e9

    def have_dy(self)->bool:
        return self.dy != None

    def add_point(self, x:float, y:float, z:float=None, dy=None):
        self.x.append(x)
        self.y.append(y)
        self.xmin = min(self.xmin, x)
        self.xmax = max(self.xmax, x)
        if z is not None:
            self.z.append(z)
        if dy is not None:
            self.dy.append(dy)
            self.ymin = min(self.ymin, y-dy)
            self.ymax = max(self.ymax, y+dy)
        else:
            self.ymin = min(self.ymin, y)
            self.ymax = max(self.ymax, y)

def read_xvg(args, filename:str, residual:bool=False, filelabel:bool=False):
    labels  = {}
    legends   = []
    dataset  = []
    numwords = None
    col = []
    
    with open(filename, "r") as inf:
        #To find delimiter if it is not a xvg file
        xvg = filename.endswith(".xvg")
        if xvg is False:
            if args.debug:
                print(f"{filename.split('.')[-1]} file found. Reading...\n")
            sample = inf.read(4096) #reads first line (large arbitrary value)
            dialect = csv.Sniffer().sniff(sample) #locates delimiter
            inf.seek(0) #positions reader back to first start position
            
            #save headers in forst row 
            reader = csv.reader(inf, dialect)
            headers = next(reader)
            if "%" in headers[args.colx]:
                if args.debug:
                    print(f"An x-axis with procentage units (such as Progress) cannot be used. Picking column {args.colx+1}.\n")
                col.append(args.colx+1)
            else:
                col.append(args.colx)
            for i in args.coly:
                validcolumn = int(i)
                if validcolumn < len(headers):
                    col.append(validcolumn)
                else:
                    newvalid = validcolumn
                    while newvalid >= len(headers):
                        if args.debug:
                            print(f"Ignoring coly value {newvalid} >= number of total columns ({len(headers)})")
                        newvalid -= 1
                    col.append(newvalid)
            if len(col) == 1 and len(headers) > 1: #meaning no valid y-column inputs were found
                col.append(col[0]+1)
            elif len(headers) <= 1:
                return print("Not enough columns for plotting.")
            #In the case of an xlabel you want to use is in the first column and has a '#' in the beginning
            #it makes this label not being considered a literal string, so we remove citation marks
            labels["xlabel"] = headers[col[0]].split('#')[-1].strip().strip('"') if '#' in headers[col[0]] else headers[col[0]]
            if len(col) == 2:
                labels["ylabel"] = headers[col[1]] #The whole label should be seen from axis if only one column is plotted
            elif len(col) > 2:
                labels["ylabel"] = headers[col[1]].split('(')[-1].split(')')[0] #Split label and unit to legend and axis label
                legends.append(headers[col[1]].split('(')[0])
                for yl in col[2:]:
                    new_label = headers[yl].split('(')[-1].split(')')[0] #Don't repeat unit labels
                    if new_label not in labels["ylabel"]:
                        labels["ylabel"] = labels["ylabel"]+", "+new_label
                    legends.append(headers[yl].split('(')[0])

        #To store labels and legends from xvg files
        for line in inf:
            nhash = line.find("#")
            line = line[:nhash]
            if len(line) == 0:
                continue

            nleg = line.find("@")
            if nleg >= 0:
                myline = line[nleg+1:].strip()
                if myline.find("type") >= 0 and myline.find("loctype") < 0:
                    dataset.append(xvgDataSet(myline))
                elif myline.find("xydy") >= 0: #Specific to xvg files including standard devations
                    dataset.append(xvgDataSet(myline))
                elif len(myline) > 0:
                    labkey, legval = interpret_legend(myline)
                    if labkey and legval:
                        if labkey == "legend":
                            if filelabel:
                                legval += " " + filename
                            legends.append(legval)
                        else:
                            labels[labkey] = legval
                continue
            
            if xvg is False:
                w = line.split(dialect.delimiter)
                numwords = len(col)
            else:
                w = line.split()
                numwords = len(w)
                col = [i for i in range(len(w))]
            if numwords == 2:
                if len(dataset) == 0:
                    dataset.append(xvgDataSet(""))
                try:
                    xx = float(w[col[0]])
                    yy = float(w[col[1]])
                    if residual:
                        yy -= xx
                    dataset[-1].add_point(xx, yy)
                except:
                    if args.debug:
                        print("Could not read line '%s'" % line)
            elif numwords > 2:
                if args.heatmap or args.contour:
                    if numwords == 3:
                        try:
                            xx = float(w[col[0]])
                            yy = float(w[col[1]])
                            zz = float(w[col[2]])
                            if len(dataset) == 0:
                                dataset.append(xvgDataSet(""))
                            dataset[0].add_point(xx, yy, z=zz)
                        except:
                            if args.debug:
                                print("Could not read heatmap line '%s" % line)

                elif len(dataset) > 0 and dataset[0].have_dy() and numwords == 3:
                    try:
                        xx = float(w[col[0]])
                        yy = float(w[col[1]])
                        dy = float(w[col[2]])
                        if residual:
                            yy -= xx
                        if len(dataset) == 0:
                            dataset.append(xvgDataSet(""))
                        dataset[0].add_point(xx, yy, dy=dy)
                    except:
                        if args.debug:
                            print("Could not read line '%s'" % line)
                else:
                    if len(dataset) < numwords-1:
                        for i in range(len(dataset), numwords-1):
                            dataset.append(xvgDataSet(""))
                    for i in range(numwords-1):
                        try:
                            xx = float(w[col[0]])
                            yy = float(w[col[i+1]])
                            if residual:
                                yy -= xx
                            dataset[i].add_point(xx, yy)
                        except:
                            if args.debug:
                                print("Could not read line '%s'" % line)
                        
    if residual:
        ylabel = "ylabel"
        if not ylabel in labels:
            labels[ylabel] = ""
        labels[ylabel] += " (Residual)"
    return legends, labels, dataset
#######################################

class DataSet:
    def __init__(self):
        # legends for datasets
        self.legend   = []
        # labels for axes (and titles)
        self.labels = {}
        self.dataset = []

    def calc_rmsd_r2(self, x, y):
        x = np.asarray(x)
        y = np.asarray(y)
        rmsd = np.sqrt(np.mean((x - y) ** 2))
        
        ss_res = np.sum((x - y) ** 2)
        ss_tot = np.sum((x - np.mean(x)) ** 2)
        r2 = 1 - ss_res / ss_tot if ss_tot != 0 else np.nan
        return rmsd, r2

    def read(self, args, filenm:str, residual:bool, filelabel:bool, arglegend, setcount):
        try:
            legend, label, dataset = read_xvg(args, filenm, residual, filelabel)
        except Exception as e:
            print("Error when reading input files:\n", e)
        if len(dataset) == 0:
            if args.debug:
                print("File %s has no data" % filenm)
        else:
            if args.debug:
                print("Read %d labels and %d legends from %d dataset(s) in input file %d" % (len(label), len(legend), len(dataset), setcount+1))
            for d in dataset:
                self.dataset.append(d)
            for k in label:
                self.labels[k] = label[k]
            # This has to be a list, there can be multiple data sets per file
            #Add labels to axes if there is none in the dataset
            if "xlabel" not in self.labels:
                self.labels["xlabel"] = "(arbitrary units)"
            if "ylabel" not in self.labels:
                self.labels["ylabel"] = "(arbitrary units)"            
            if len(legend) > 0:
                for l in range(len(legend)):
                    if arglegend:
                        if len(arglegend) < len(legend):
                            for i in range(len(legend) - len(arglegend)):
                                arglegend.append("")
                        self.legend.append(texify(arglegend[l] + " " + legend[l]))
                    else:
                        self.legend.append(texify(legend[l]))
            elif arglegend:
                for l in range(len(arglegend)):
                    self.legend.append(texify(arglegend[l]))
                self.legend.append(texify(arglegend))
            if args.stats:
                #Fetch the dataset without residual
                _,_,ori_dataset = read_xvg(args, filenm, False, filelabel)
                #Print R2 and RMSD values in legend
                for d in range(len(ori_dataset)):
                    ds = ori_dataset
                    rmsd, r2 = self.calc_rmsd_r2(ds[d].x, ds[d].y)
                    print_r2 = f"{r2:.2f}"
                    if print_r2 == "1.00":
                        print_r2 = f"{r2:.4f}"
                    self.legend[d] = f"{self.legend[d]}, RMSD = {rmsd:.2f}, R\u00b2 = {print_r2}"

    def set_extent(self, myax, args):
        if len(self.dataset) < 1:
            print("Insufficient data points to set extents.")
            return 0, 0, 0, 0
        xxmin = self.dataset[0].xmin
        xxmax = self.dataset[0].xmax
        yymin = self.dataset[0].ymin
        yymax = self.dataset[0].ymax
        for data in self.dataset[1:]:
            xxmin = min(xxmin, data.xmin)
            xxmax = max(xxmax, data.xmax)
            yymin = min(yymin, data.ymin)
            yymax = max(yymax, data.ymax)
        if args.equalaxes:
            mmin = min(xxmin, yymin)
            mmax = max(xxmax, yymax)
            delta = 5+(mmax-mmin)/20
            mmin -= delta
            mmax += delta
            xxmin = mmin
            xxmax = mmax
            yymin = mmin
            yymax = mmax
        if args.xmin:
            xxmin = args.xmin
        if args.xmax:
            xxmax = args.xmax
        if args.ymin:
            yymin = args.ymin
        if args.ymax:
            yymax = args.ymax
        # Now effectuate the options
        if xxmin == xxmax or yymin == yymax:
            if args.debug:
                print("Warning: min and max for x or y are equal, expanding range.")
            xxmin -= xxmin*0.5
            xxmax += xxmax*0.5
            yymin -= yymax*0.5
            yymax += yymax*0.5
        if args.equalaxes:
            if xxmin == yymin and xxmax == yymax:
                myax.set_aspect('equal', adjustable='box')
            elif args.debug:
                print("Option -eqax overruled by min and max options")
        return xxmin, xxmax, yymin, yymax

    def decorate(self, thisax, args, title, ncolumn, sharelabel_x, sharelabel_y):
        # Now add the fancy stuff
        if args.notitles == False:
            if args.title and title != "None":
                thisax.set_title(texify(title), fontsize=args.titlefontsize/ncolumn+args.allfontsizes)
            elif "title" in self.labels and "subtitle" in self.labels:
                title_text = texify(self.labels["title"])
                subtitle_text = texify(self.labels["subtitle"])
                thisax.set_title(f"{title_text}\n{subtitle_text}", fontsize=args.titlefontsize/ncolumn+args.allfontsizes, pad=args.titlefontsize/ncolumn+args.allfontsizes*0.5)
            elif "title" in self.labels and "subtitle" not in self.labels:
                thisax.set_title(texify(self.labels["title"]), fontsize=args.titlefontsize/ncolumn+args.allfontsizes, pad=args.titlefontsize/ncolumn+args.allfontsizes*0.5)
            elif "title" not in self.labels and "subtitle" in self.labels:
                thisax.set_title(texify(self.labels["subtitle"]), fontsize=args.titlefontsize/ncolumn+args.allfontsizes, pad=args.titlefontsize/ncolumn+args.allfontsizes*0.5)

        if "xlabel" in self.labels and args.panels and sharelabel_x == True: #Print x label for the last row
            pass
        else:
            thisax.set_xlabel(texify(self.labels["xlabel"]), fontsize=args.axislabelfontsize/ncolumn+args.allfontsizes, labelpad=args.axislabelfontsize/ncolumn+args.allfontsizes*0.5)

        if "ylabel" in self.labels and args.panels and sharelabel_y == True: #Print y label for the first column
            pass
        else:
            thisax.set_ylabel(texify(self.labels["ylabel"]), fontsize=args.axislabelfontsize/ncolumn+args.allfontsizes, labelpad=args.axislabelfontsize/ncolumn+args.allfontsizes*0.5)
        # Legend box placement
        if args.legendfontsize > 0 and len(self.legend) > 0 and len(self.dataset[0].z) == 0: #.z added so that legend ends up being the colorbar legend
            thisax.legend(loc='upper left', bbox_to_anchor=(args.legend_x, args.legend_y), fontsize=args.legendfontsize/ncolumn+args.allfontsizes)

    def do_bars(self, thisax, argcolors, idx, total_datasets, setcount, args, group_width):
        print_legend = False
        if args.datasetlegends or (hasattr(self.dataset[0], "dy") and self.legend):
            print_legend = True
        else:
            print_legend = len(self.legend) == len(self.dataset)
        if args.debug:
            print("%d legends read in file nr %d" % ( len(self.legend), setcount+1 ) )
        for n in range(len(self.dataset)):
            xy = self.dataset[n]

            x = np.asarray(xy.x)
            #Compute a suitable spacing based on mean difference between x values
            if len(x) > 1:
                # sort justin case
                xs_sorted = np.sort(x)
                spacing = np.mean(np.diff(xs_sorted)) #mean difference between each consecutive value
                if spacing == 0:
                    spacing = 1.0
            else:
                spacing = 1.0

            # total width for the whole group of bars (all datasets) at each x
            total_group_width = spacing * group_width
            # width of a single bar (split group among total_bars)
            bar_width = total_group_width / total_datasets

            current_index = idx + n
            # compute an offset for the local dataset (placement of bar for each x value)
            offset = (current_index - (total_datasets - 1) / 2.0) * bar_width
            # Place each bar relative to center x
            xpos = x + offset

            #Colors and legends
            mylegend  = None
            if len(self.legend) > n and self.legend[n] not in args.ignore:
                if print_legend:
                    mylegend = self.legend[n]
            mycolor=argcolors[n]
            if args.debug:
                print(f"\t mylegend  {n+1} = {mylegend}")
                print(f"\t mycolor  {n+1} = {mycolor}\n")

            thisax.bar(xpos, xy.y, width=bar_width, bottom=0.0, align="center", label=mylegend, color=mycolor)

    def do_lines(self, thisax, argcolors, arglines, argmarkers, setcount, args, ncolumn):
        print_legend = False
        if args.datasetlegends or (hasattr(self.dataset[0], "dy") and self.legend):
            print_legend = True
        else:
            print_legend = len(self.legend) == len(self.dataset)

        if args.debug:
            print("%d legends read in file nr %d" % ( len(self.legend), setcount+1) )
        for n in range(len(self.dataset)):
            mylegend  = None
            if len(self.legend) > n and self.legend[n] not in args.ignore:
                if print_legend:
                    mylegend = self.legend[n]
            if args.linestyle:
                myline = arglines[n]
            else:
                myline = "None" #plot function only accepts None as a string
            mymarker = "None"
            if args.marker or (args.marker is None and args.linestyle is None):
                mymarker = argmarkers[n]
            mycolor = argcolors[n]
            if args.debug:
                print(f"\t mylegend  {n+1} = {mylegend}")
                print(f"\t mymarker {n+1} = {mymarker}")
                print(f"\t myline   {n+1} = {myline}")
                print(f"\t mycolor  {n+1} = {mycolor}\n")
            if hasattr(self.dataset[n], "dy") and self.dataset[n].dy is not None:
                thisax.errorbar(self.dataset[n].x, self.dataset[n].y, yerr=self.dataset[n].dy,
                                capsize=3, label=mylegend, markersize=args.markersize/ncolumn, linewidth=2/ncolumn,
                                ls=myline, marker=mymarker, color=mycolor, ecolor=mycolor)
            else:
                thisax.plot(self.dataset[n].x, self.dataset[n].y, markersize=args.markersize/ncolumn, linewidth=4/ncolumn,
                            label=mylegend, ls=myline, marker=mymarker, color=mycolor, markeredgewidth=args.markeredgewidth/ncolumn)

    def do_heatmap(self, thisax, args, setcount):
        print_legend = False
        if args.datasetlegends:
            print_legend = True
        else:
            print_legend = len(self.legend) == len(self.dataset)

        mylegend  = None
        if self.legend not in args.ignore:
            if print_legend:
                mylegend = self.legend[setcount]
        if args.debug:
            print("Doing a heat map")

        has_z = len(self.dataset[setcount].z) > 0
        if has_z:
            X, Y, Z = self._make_grid(setcount)
        else:
            X, Y, Z = self._make_histo(args, setcount)
        
        if X is None: 
            return print("Heatmap failed.")
        
        if args.contour:
            # Contour plot with filled levels
            contf = thisax.contourf(X, Y, Z, levels=args.levels, cmap=args.colormap)
            thisax.contour(X, Y, Z, levels=args.levels, colors='k', alpha=0.7, linewidths=0.5) #adds lines
            plot_obj = contf
        else:
            # Heatmap using pcolormesh 
            pcolmesh = thisax.pcolormesh(X, Y, Z, cmap=args.colormap, shading='auto', rasterized=True)
            plot_obj = pcolmesh

        # Add Colorbar (needs reference to figure)
        cbarlegend = "Free Energy (kJ/mol)" if args.gibbs else "Probability Density"
        fig = thisax.get_figure()
        cbar = fig.colorbar(plot_obj, ax=thisax)
        cbar.set_label(cbarlegend, fontsize=args.axislabelfontsize+args.allfontsizes, labelpad=10)
        cbar.ax.tick_params(labelsize=args.tickfontsize+args.allfontsizes)

        if args.showdots:
            thisax.plot(self.dataset[setcount].x, self.dataset[setcount].y, markersize=args.markersize,
                        label=mylegend, linestyle="None", marker="o", color="white", markeredgecolor="black", markeredgewidth=args.markeredgewidth)

    ####### Helper methods for heatmaps ######### 
    def _make_grid(self, setcount): # to create meshgrids for the heatmaps
        ds = self.dataset[setcount]
        x = np.array(ds.x)
        y = np.array(ds.y)
        z = np.array(ds.z)

        # Identify the unique x and y coords to determine grid dimensions
        ux = np.unique(x)
        uy = np.unique(y)
        
        # Check if grid is complete
        if len(z) != len(ux) * len(uy):
            print("Warning: Data is not a perfect rectangle.")
            return None, None, None

        # Reshape Z into a 2D matrix (Ny, Nx)
        # Try both ways of reshaping depending on how gromacs outputs the data (flip and transpose)
        try:
            X, Y = np.meshgrid(ux, uy)
            Z = z.reshape(len(uy), len(ux))
        except:
            # If reshape fails, try swapping dimensions
            X, Y = np.meshgrid(ux, uy)
            Z = z.reshape(len(ux), len(uy)).T
        return X, Y, Z
    
    def _make_histo(self, args, setcount):
        ds = self.dataset[setcount]
        x = np.array(ds.x)
        y = np.array(ds.y)

        if args.kde:
            import importlib.util, sys
            #Check if the user has installed scipy first
            if importlib.util.find_spec("scipy") is None:
                sys.exit("Please install the scipy package for kde calculation.")
            from scipy.stats import gaussian_kde

            #A grid over the data range (Expand a little?)
            x_grid = np.linspace(x.min(), x.max(), 100)
            y_grid = np.linspace(y.min(), y.max(), 100)
            X, Y = np.meshgrid(x_grid, y_grid)

            positions = np.vstack([X.ravel(), Y.ravel()])
            z_values = np.vstack([x, y])
            kernel = gaussian_kde(z_values)
            Z = np.reshape(kernel(positions).T, X.shape)
        else:
            z, xedges, yedges = np.histogram2d(x, y, bins=args.bins, density=True) #creates histogram from x and y, density =True creates prob density like gmx sham
            #find centers
            xcenters = (xedges[:-1] + xedges[1:]) / 2
            ycenters = (yedges[:-1] + yedges[1:]) / 2
            X, Y = np.meshgrid(xcenters, ycenters)
            Z = z.T
        Z = Z/np.max(Z)
        if args.gibbs:
        #compute gibbs free energy: G = -kBT * log(P)
            kB = 0.00831446 #kJ/molK
            T = args.temperature
            Z[Z == 0] = np.nan
            Z = -kB*T * np.log(Z)
            Z -= np.nanmin(Z) #Set lowest energy to zero (and skips nan values)

        return X, Y, Z
    #################################

def process_plot(args, fig, axs, nfiles, ncolumn, nrow):

    rcParams['font.family'] = 'sans-serif'
    rcParams['font.sans-serif'] = [args.fontname]

    numaxs = axs.size if hasattr(axs, 'size') else 1

    arglegend = []
    if args.datasetlegends:
        arglegend = []
        for value in args.datasetlegends:
            if value != "None": #If user only wants to add a legend to one of the datasets in a file, set None
                arglegend.append(value)
            else:
                arglegend.append("")
        if args.debug:
            print("Found the following command-line legends {}".format(arglegend), "\n")
    datasets = []

    # Create new dataset for each file BEFORE plotting
    total_datasets = 0
    nrdatasets = 0
    xmins = []
    xmaxs = []
    ymins = []
    ymaxs = []
    for filenumber in range(nfiles):
        datasets.append(DataSet())
        mylegend = arglegend[total_datasets:] if arglegend[total_datasets:] else None
        if mylegend is not None:
            # Replace None with empty string
            for i in range(len(mylegend)):
                if mylegend[i] is None:
                    mylegend[i] = ""
        datasets[-1].read(args, args.filename[filenumber], args.residual,
                          args.filelabel, mylegend, filenumber)
        nrdatasets = len(datasets[-1].dataset)
        total_datasets += nrdatasets

        # Shortcut for the current axis
        thisax = axs.flat[filenumber % numaxs]
        #Fetch mininmum and maximum values
        xxmin, xxmax, yymin, yymax = datasets[filenumber].set_extent(thisax, args)
        xmins.append(xxmin)
        xmaxs.append(xxmax)
        ymins.append(yymin)
        ymaxs.append(yymax)
    #Save the global x/y minima and maxima respectively
    xxmin = min(xmins)
    xxmax = max(xmaxs)
    yymin = min(ymins)
    yymax = max(ymaxs)

    if args.debug:
        print("Total datasets found: ", total_datasets, "\n")

    #Define colors markers and linstyles before going in to loop
    colors = args.colors if args.colors else []
    if args.marker:
        marker = args.marker
    elif args.marker is None and args.linestyle is None: #If neither markers nor linestyle is defined, add markers
        marker = []
    else:
        marker = None
    linestyle = args.linestyle if args.linestyle else None
    # Build a color list long enough for all datasets (maximum is the length of defcolors)     
    if len(colors) < total_datasets:
        if args.debug:
            print("More datasets than color inputs. Adding colors.\n")
        # Repeat appending from defcolors
        c = 0
        while len(colors) < total_datasets:
            colors.append(defcolors[c % len(defcolors)])
            c += 1

    idx = 0
    nrdatasets = 0
    # Plot one dataset at a time
    if args.bar and args.debug:
        print("Doing bar graphs\n")
    for filenumber in range(nfiles):
        # Shortcut for the current axis
        thisax = axs.flat[filenumber % numaxs]

        #number of datasets within a file
        nrdatasets = len(datasets[filenumber].dataset)
        # Assign colors depending on nr of datasets within each file
        if args.panels:
            these_colors = colors[0:nrdatasets] #Each panel should have the same colors, thus start from index zero in the color list
        else:
            these_colors = colors[idx:idx+nrdatasets] #Multiple datasets plotted together must recieve a new color in the list

        if args.marker:
            if len(args.marker) < nrdatasets: #markers will be applied for each dataset in each file
                c = 0
                while len(marker) < nrdatasets:
                    marker.append(defmarkers[c % len(defmarkers)])
                    c += 1
            elif len(args.marker) >= total_datasets: #markers will be applied to each dataset in total
                marker = args.marker[idx:idx+nrdatasets]
        elif args.marker is None and args.linestyle is None:
            c = 0
            while len(marker) < nrdatasets:
                marker.append(defmarkers[c % len(defmarkers)])
                c += 1
        else:
            marker = None

        if args.linestyle:
            if len(args.linestyle) < nrdatasets:
                c = 0
                while len(linestyle) < nrdatasets:
                    linestyle.append(deflines[c % len(deflines)])
                    c += 1
            elif len(args.linestyle) >= total_datasets:
                linestyle = args.linestyle[idx:idx+nrdatasets]
        else: 
            linestyle = None

        if args.logy:
            thisax.set_yscale('log')

        if args.bar:
            # Pass color list for the datasets in this file so bars can be colored
            datasets[filenumber].do_bars(
                thisax,
                these_colors,
                idx, 
                total_datasets, 
                filenumber,
                args,
                group_width=0.9,
            )
        elif args.heatmap or args.contour:
            datasets[filenumber].do_heatmap(
                thisax,
                args,
                filenumber
            )
        else:
            datasets[filenumber].do_lines(
                thisax,
                these_colors,
                linestyle,
                marker,
                filenumber,
                args,
                ncolumn
            )
        idx += nrdatasets

        if args.panels and numaxs > 1:
            sublabel = string.ascii_uppercase[filenumber] #Add letter to each subplot
            if args.debug:
                print(f"Setting subplot {filenumber+1} to {sublabel}\n")
            thisax.text(args.subfigureX, args.subfigureY, sublabel,
                    transform=thisax.transAxes, 
                    size=args.axislabelfontsize/ncolumn+args.allfontsizes, weight='bold', color='black')
        # Tick font labels
        for aa in ['x', 'y']:
            thisax.tick_params(axis=aa, labelsize=args.tickfontsize/ncolumn+args.allfontsizes)
            
        # If x- or ylabels are not the same they should not be scaled together, fetching local minimas and maximas. 
        if args.panels and args.equalaxes == False: #If equalaxes, use global minimas ans maximas
            if datasets[0].labels.get("xlabel") != datasets[-1].labels.get("xlabel"):
                xxmin = xmins[filenumber]
                xxmax = xmaxs[filenumber]
            if datasets[0].labels.get("ylabel") != datasets[-1].labels.get("ylabel"):
                yymin = ymins[filenumber]
                yymax = ymaxs[filenumber]

        # Scale the plot such that the content is visible
        deltax = (xxmax-xxmin)*0.05
        thisax.set_xlim(xxmin-deltax, xxmax+deltax)
        deltay = (yymax-yymin)*0.05
        thisax.set_ylim(yymin-deltay, yymax+deltay)

        # Set labels and titles
        title = args.title[filenumber] if args.title and filenumber < len(args.title) else "None"
        if args.sharelabel and args.panels:
            if args.panels == 'top':
                rowindex = filenumber // ncolumn #counts rows by taking the division without rest
                columnindex = filenumber % ncolumn #counts columns by taking the rest
                last_row = nrow-1
            else:
                rowindex = filenumber // nrow #reverse engineering for side panels
                columnindex = filenumber % nrow
                last_row = ncolumn-1
            # Define what x- and y-labels to print
            if rowindex == last_row and columnindex == 0: #Last row and forst column (only applies to lower left plot)
                datasets[filenumber].decorate(thisax, args, title, ncolumn, sharelabel_x=False, sharelabel_y=False)
            elif rowindex == last_row: #Last row
                datasets[filenumber].decorate(thisax, args, title, ncolumn, sharelabel_x=False, sharelabel_y=True)
            elif columnindex == 0: #First column
                datasets[filenumber].decorate(thisax, args, title, ncolumn, sharelabel_x=True, sharelabel_y=False)
            else:
                datasets[filenumber].decorate(thisax, args, title, ncolumn, sharelabel_x=True, sharelabel_y=True)
        elif args.sharelabel and not args.panels:
            print("Cannot use the sharelabel flag without the panels flag. Will ignore sharelabel.")
            datasets[filenumber].decorate(thisax, args, title, ncolumn, sharelabel_x=False, sharelabel_y=False)          
        else:
            datasets[filenumber].decorate(thisax, args, title, ncolumn, sharelabel_x=False, sharelabel_y=False)

    # Finally, printing time
    if args.save:
        if args.debug:
            print(f"Saving to: {args.save}")
        # Print just once!
        fig.savefig(args.save, bbox_inches='tight')
        args.save = None


def plot(filenames, **kwargs):

    if isinstance(filenames, str): #If only one file is passed, wrap it in a list
        filenames = [filenames]

    kwargs["filename"] = filenames #Fill the filename argument with a list of files
    args = APIArguments(**kwargs)

    # Define the number of columns and files
    nfiles = len(args.filename) if args.filename else 0
    ncolumn = 1
    nrow = 1
    
    if args.panels and len(args.filename) > 1:
        ncolumn = int(math.sqrt(nfiles)) if nfiles > 0 else 1
        nrow = int(nfiles / ncolumn) if ncolumn > 0 else 1
        if nfiles % ncolumn != 0:
            nrow += 1
        if args.squarefig:
            xframe = (args.yframe)
            yframe = (args.yframe / ncolumn) * nrow
        elif (nfiles == 2 or nfiles == 3) and args.panels == 'top':
            xframe = args.xframe
            yframe = args.yframe * (nrow*0.75) #To increase frame height slightly for two and three panels
        else:
            xframe = args.xframe
            yframe = args.yframe
        if args.panels == 'top':
            fig, axs = plt.subplots(nrow, ncolumn, figsize=(xframe, yframe), constrained_layout=True) #constrained_layout=True usually more recommended than plt.tight_layout()
        else:
            fig, axs = plt.subplots(ncolumn, nrow, figsize=(xframe, yframe), constrained_layout=True)            
    else:
        if args.panels:
            print("Only one file in input. Will ignore -panels command")
        if args.squarefig:
            xframe = args.xframe
            yframe = xframe
        else:
            xframe = args.xframe
            yframe = args.yframe
        fig, axs = plt.subplots(figsize=(xframe, yframe), constrained_layout=True)
        axs = np.array([axs])

    #Pass on for processing
    if args.follow:
        def animate(t):
            try:
                for ax in axs.flat: #to avoid stacking of plots 
                    ax.clear()
                process_plot(args, fig, axs, nfiles, ncolumn, nrow)
            except Exception as e:
                print("Update failed:", e)
        
        ani = FuncAnimation(fig, animate, interval=5000)
        plt.show()
    else:
        process_plot(args, fig, axs, nfiles, ncolumn, nrow)
    if not args.noshow:
        plt.show()

def main():
    matplotlib.use('TkAgg') #only use this when CLI operated and not API (disrupts notebook)

    cliargs = CLIArguments()

    if cliargs.filename:
        # takes argparse arguments and converts them to dictionaries 
        # and unpacks them, giving them the same structure as 
        # the API operated arguments.
        dictargs = vars(cliargs) #Make into dictionary but
        filename = dictargs.pop("filename") #pass filenames separately

        try:
            plot(filename, **dictargs)

        except Exception as e:
            print("Plotting failed:", e)

