# Auto-generated by DjangoCFG - see CLAUDE.md

from __future__ import annotations

from typing import Any

from pydantic import BaseModel, ConfigDict, Field

from ..enums import CleanAsyncRequestRequestOutputFormat, CleanRequestRequestOutputFormat, CleaningRequestDetailStatus


class CleaningRequestList(BaseModel):
    """
    List serializer for cleaning requests.

    Response model (includes read-only fields).
    """

    model_config = ConfigDict(
        validate_assignment=True,
        extra="allow",
        frozen=False,
    )

    uuid: Any = Field(description='Unique request identifier')
    original_filename: Any = Field(description='Original filename')
    original_size_bytes: int = Field(description='Original HTML size in bytes')
    cleaned_size_bytes: int = Field(description='Cleaned HTML size in bytes')
    output_format: Any = Field(description='Output format: html, markdown, a...')
    status: CleaningRequestDetailStatus = Field(description='* `pending` - Pending * `queued`...')
    duration_ms: int | None = Field(None, description='Processing duration in milliseconds')
    created_at: Any = ...



class PaginatedCleaningRequestListList(BaseModel):
    """
    
    Response model (includes read-only fields).
    """

    model_config = ConfigDict(
        validate_assignment=True,
        extra="allow",
        frozen=False,
    )

    count: int = Field(description='Total number of items across all...')
    page: int = Field(description='Current page number (1-based)')
    pages: int = Field(description='Total number of pages')
    page_size: int = Field(description='Number of items per page')
    has_next: bool = Field(description='Whether there is a next page')
    has_previous: bool = Field(description='Whether there is a previous page')
    next_page: int | None = Field(None, description='Next page number (null if no nex...')
    previous_page: int | None = Field(None, description='Previous page number (null if no...')
    results: list[CleaningRequestList] = Field(description='Array of items for current page')



class CleaningRequestDetail(BaseModel):
    """
    Detail serializer for cleaning request.

    Response model (includes read-only fields).
    """

    model_config = ConfigDict(
        validate_assignment=True,
        extra="allow",
        frozen=False,
    )

    uuid: Any = Field(description='Unique request identifier')
    original_filename: Any = Field(description='Original filename')
    original_size_bytes: int = Field(description='Original HTML size in bytes')
    cleaned_html: Any = Field(description='Cleaned HTML content')
    cleaned_size_bytes: int = Field(description='Cleaned HTML size in bytes')
    output_format: Any = Field(description='Output format: html, markdown, a...')
    config: dict[str, Any] = Field(description='CleanerConfig used for this request')
    stats: dict[str, Any] = Field(description='Cleaning statistics (elements re...')
    status: CleaningRequestDetailStatus = Field(description='* `pending` - Pending * `queued`...')
    error_message: Any = Field(description='Error message if request failed')
    duration_ms: int | None = Field(None, description='Processing duration in milliseconds')
    compression_ratio: float = ...
    size_reduction_percent: float = ...
    created_at: Any = ...



class PatternsResponse(BaseModel):
    """
    Extraction patterns response serializer.

    Response model (includes read-only fields).
    """

    model_config = ConfigDict(
        validate_assignment=True,
        extra="allow",
        frozen=False,
    )

    uuid: str = ...
    patterns: list[dict[str, Any]] = ...
    patterns_count: int = ...



class JobStatus(BaseModel):
    """
    Job status serializer.

    Response model (includes read-only fields).
    """

    model_config = ConfigDict(
        validate_assignment=True,
        extra="allow",
        frozen=False,
    )

    uuid: str = ...
    status: str = ...
    job_id: str | None = None
    queued_at: str | None = None
    started_at: str | None = None
    completed_at: str | None = None
    duration_ms: int | None = None
    error: str | None = None



class CleanRequestRequest(BaseModel):
    """
    Request serializer for HTML cleaning (multipart/form-data).

    Request model (no read-only fields).
    """

    model_config = ConfigDict(
        validate_assignment=True,
        extra="allow",
        frozen=False,
    )

    file: Any = Field(description='HTML file to clean')
    output_format: CleanRequestRequestOutputFormat | None = Field(None, description='* `html` - html * `markdown` - m...')
    max_tokens: int | None = Field(None, ge=100, le=100000)
    remove_scripts: bool | None = None
    remove_styles: bool | None = None
    remove_comments: bool | None = None
    remove_hidden: bool | None = None
    filter_classes: bool | None = None
    class_threshold: float | None = Field(None, ge=0.0, le=1.0)
    try_hydration: bool | None = None
    preserve_selectors: list[str] | None = None



class CleanResponse(BaseModel):
    """
    Response serializer for cleaned HTML.

    Response model (includes read-only fields).
    """

    model_config = ConfigDict(
        validate_assignment=True,
        extra="allow",
        frozen=False,
    )

    request_uuid: str = ...
    cleaned_html: str = ...
    original_size: int = ...
    cleaned_size: int = ...
    compression_ratio: float = ...
    size_reduction_percent: float = ...
    duration_ms: int = ...
    output_format: str = ...
    stats: dict[str, Any] = ...



class CleanAsyncRequestRequest(BaseModel):
    """
    Request serializer for async HTML cleaning with agent.

    Request model (no read-only fields).
    """

    model_config = ConfigDict(
        validate_assignment=True,
        extra="allow",
        frozen=False,
    )

    file: Any = Field(description='HTML file to clean')
    url: str | None = Field(None, description='Source URL for context')
    task_prompt: str | None = Field(
    None,
    description='Custom instructions for LLM',
    max_length=2000,
)
    output_format: CleanAsyncRequestRequestOutputFormat | None = Field(None, description='* `html` - html * `markdown` - m...')
    config: dict[str, Any] | None = Field(None, description='Additional config options')



class CleanAsyncResponse(BaseModel):
    """
    Response serializer for async job submission.

    Response model (includes read-only fields).
    """

    model_config = ConfigDict(
        validate_assignment=True,
        extra="allow",
        frozen=False,
    )

    status: str = ...
    job_id: str | None = None
    request_uuid: str = ...
    message: str = ...
    status_url: str = ...



class CleaningStats(BaseModel):
    """
    Statistics serializer.

    Response model (includes read-only fields).
    """

    model_config = ConfigDict(
        validate_assignment=True,
        extra="allow",
        frozen=False,
    )

    total_requests: int = ...
    successful_requests: int = ...
    failed_requests: int = ...
    total_original_bytes: int | None = None
    total_cleaned_bytes: int | None = None
    avg_duration_ms: float | None = None
    overall_compression_ratio: float | None = None
    overall_size_reduction_percent: float | None = None



