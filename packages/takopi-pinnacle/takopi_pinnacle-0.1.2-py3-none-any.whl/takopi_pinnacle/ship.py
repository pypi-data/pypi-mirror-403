from __future__ import annotations

import json
import re
import shlex
import shutil
import subprocess
from dataclasses import dataclass, replace
from datetime import datetime, timezone
from pathlib import Path

from .gitutils import GitError, _run_git

_PR_BODY = "Generated by takopi-pinnacle."
_URL_RE = re.compile(r"https?://\S+")


@dataclass(frozen=True)
class ShipConfig:
    enabled: bool = False
    remote: str = "origin"
    branch: str | None = None
    branch_prefix: str = "pinnacle"
    commit_msg: str | None = None
    open_pr: bool = False
    pr_draft: bool = True
    pr_title: str | None = None
    dry_run: bool = False
    git_user_name: str = "takopi"
    git_user_email: str = "takopi@local"

    def with_enabled(self, enabled: bool) -> "ShipConfig":
        return replace(self, enabled=enabled)

    def with_remote(self, remote: str) -> "ShipConfig":
        return replace(self, remote=remote)

    def with_branch(self, branch: str | None) -> "ShipConfig":
        return replace(self, branch=branch)

    def with_commit_msg(self, commit_msg: str | None) -> "ShipConfig":
        return replace(self, commit_msg=commit_msg)

    def with_open_pr(self, open_pr: bool) -> "ShipConfig":
        return replace(self, open_pr=open_pr)

    def with_pr_draft(self, pr_draft: bool) -> "ShipConfig":
        return replace(self, pr_draft=pr_draft)

    def with_pr_title(self, pr_title: str | None) -> "ShipConfig":
        return replace(self, pr_title=pr_title)

    def with_dry_run(self, dry_run: bool) -> "ShipConfig":
        return replace(self, dry_run=dry_run)


@dataclass(frozen=True)
class ShipResult:
    remote: str
    branch: str
    commit_sha: str | None
    pushed: bool
    pr_url: str | None
    dry_run: bool


def pr_base_branch(repo_root: Path, base_ref: str) -> str:
    return _base_branch_name(repo_root, base_ref)


def format_pr_create_command(cfg: ShipConfig, *, base: str, head: str) -> str:
    args = ["gh", *_pr_create_args(cfg, base=base, head=head)]
    return shlex.join(args)


def ship_repo(
    repo_root: Path,
    cfg: ShipConfig,
    *,
    base_ref: str,
    out_dir: Path | None = None,
) -> ShipResult:
    _ensure_git_identity(repo_root, cfg)
    branch = _ensure_branch(repo_root, cfg, base_ref)

    _run_git(repo_root, ["add", "-A"])
    _reset_out_dir(repo_root, out_dir)

    commit_sha = None
    if _has_staged_changes(repo_root):
        msg = cfg.commit_msg or "pinnacle: update"
        _run_git(repo_root, ["commit", "-m", msg])
        commit_sha = _run_git(repo_root, ["rev-parse", "HEAD"]).stdout.strip()

    pushed = False
    if not cfg.dry_run:
        _run_git(repo_root, ["push", "-u", cfg.remote, branch])
        pushed = True

    pr_url = None
    if cfg.open_pr and not cfg.dry_run:
        pr_url = _open_pr(repo_root, cfg, branch, base_ref)

    return ShipResult(
        remote=cfg.remote,
        branch=branch,
        commit_sha=commit_sha,
        pushed=pushed,
        pr_url=pr_url,
        dry_run=cfg.dry_run,
    )


def _run_gh(
    repo_root: Path, args: list[str], *, check: bool = True
) -> subprocess.CompletedProcess[str]:
    proc = subprocess.run(
        ["gh", *args],
        cwd=repo_root,
        text=True,
        capture_output=True,
        check=False,
    )
    if check and proc.returncode != 0:
        raise GitError(f"gh {' '.join(args)} failed: {proc.stderr.strip()}")
    return proc


def _extract_url(text: str) -> str | None:
    match = _URL_RE.search(text)
    return match.group(0) if match else None


def _gh_auth_ok(repo_root: Path) -> bool:
    proc = _run_gh(repo_root, ["auth", "status"], check=False)
    return proc.returncode == 0


def _gh_pr_view_url(repo_root: Path, branch: str) -> str | None:
    proc = _run_gh(repo_root, ["pr", "view", "--head", branch, "--json", "url"], check=False)
    if proc.returncode != 0:
        return None
    try:
        data = json.loads(proc.stdout or "{}")
    except json.JSONDecodeError:
        return None
    url = data.get("url")
    return url if isinstance(url, str) and url else None


def _open_pr(repo_root: Path, cfg: ShipConfig, branch: str, base_ref: str) -> str | None:
    if shutil.which("gh") is None:
        return None
    if not _gh_auth_ok(repo_root):
        return None

    existing = _gh_pr_view_url(repo_root, branch)
    if existing:
        return existing

    base_branch = pr_base_branch(repo_root, base_ref)
    create_args = _pr_create_args(cfg, base=base_branch, head=branch)
    proc = _run_gh(repo_root, create_args, check=False)
    if proc.returncode != 0:
        raise GitError(f"gh pr create failed: {proc.stderr.strip()}")

    created_url = _extract_url(proc.stdout)
    if created_url:
        return created_url

    return _gh_pr_view_url(repo_root, branch)


def _pr_title(cfg: ShipConfig, branch: str) -> str:
    return cfg.pr_title or f"pinnacle: {branch}"


def _pr_create_args(cfg: ShipConfig, *, base: str, head: str) -> list[str]:
    args = [
        "pr",
        "create",
        "--base",
        base,
        "--head",
        head,
        "--title",
        _pr_title(cfg, head),
        "--body",
        _PR_BODY,
    ]
    if cfg.pr_draft:
        args.append("--draft")
    return args


def _has_staged_changes(repo_root: Path) -> bool:
    proc = _run_git(repo_root, ["diff", "--cached", "--quiet"], check=False)
    if proc.returncode == 0:
        return False
    if proc.returncode == 1:
        return True
    raise GitError(f"git diff --cached --quiet failed: {proc.stderr.strip()}")


def _reset_out_dir(repo_root: Path, out_dir: Path | None) -> None:
    rel = out_dir.as_posix().rstrip("/") if out_dir else ".pinnacle"
    _run_git(repo_root, ["reset", "-q", "--", rel], check=False)


def _ensure_git_identity(repo_root: Path, cfg: ShipConfig) -> None:
    name = _run_git(repo_root, ["config", "--get", "user.name"], check=False).stdout.strip()
    if not name:
        _run_git(repo_root, ["config", "--local", "user.name", cfg.git_user_name])
    email = _run_git(repo_root, ["config", "--get", "user.email"], check=False).stdout.strip()
    if not email:
        _run_git(repo_root, ["config", "--local", "user.email", cfg.git_user_email])


def _current_branch(repo_root: Path) -> str:
    return _run_git(repo_root, ["rev-parse", "--abbrev-ref", "HEAD"]).stdout.strip()


def _branch_exists(repo_root: Path, branch: str) -> bool:
    proc = _run_git(repo_root, ["rev-parse", "--verify", branch], check=False)
    return proc.returncode == 0


def _checkout_branch(repo_root: Path, branch: str) -> None:
    if _branch_exists(repo_root, branch):
        _run_git(repo_root, ["checkout", branch])
    else:
        _run_git(repo_root, ["checkout", "-b", branch])


def _generate_branch_name(repo_root: Path, prefix: str) -> str:
    short_sha = _run_git(repo_root, ["rev-parse", "--short", "HEAD"]).stdout.strip()
    ts = datetime.now(timezone.utc).strftime("%Y%m%d-%H%M")
    return f"{prefix}/{ts}-{short_sha}"


def _ensure_branch(repo_root: Path, cfg: ShipConfig, base_ref: str) -> str:
    current = _current_branch(repo_root)
    protected = _protected_branches(repo_root, base_ref)
    if cfg.branch and cfg.branch in protected:
        raise GitError(f"Refusing to ship on protected branch: {cfg.branch}")

    need_switch = current == "HEAD" or current in protected
    if cfg.branch and current != cfg.branch:
        need_switch = True

    if need_switch:
        target = cfg.branch or _generate_branch_name(repo_root, cfg.branch_prefix)
        if target in protected:
            raise GitError(f"Refusing to ship on protected branch: {target}")
        _checkout_branch(repo_root, target)
        return target

    return current


def _protected_branches(repo_root: Path, base_ref: str) -> set[str]:
    protected = {"main", "master"}
    base_branch = pr_base_branch(repo_root, base_ref)
    if base_branch:
        protected.add(base_branch)
    return protected


def _base_branch_name(repo_root: Path, base_ref: str) -> str:
    ref = _strip_ref_prefix(base_ref)
    remotes = _git_remotes(repo_root)
    parts = ref.split("/", 1)
    if len(parts) == 2 and (parts[0] in remotes or parts[0] in {"origin", "upstream"}):
        return parts[1]
    return ref


def _strip_ref_prefix(ref: str) -> str:
    for prefix in ("refs/heads/", "refs/remotes/"):
        if ref.startswith(prefix):
            return ref[len(prefix) :]
    return ref


def _git_remotes(repo_root: Path) -> set[str]:
    proc = _run_git(repo_root, ["remote"], check=False)
    return {line.strip() for line in proc.stdout.splitlines() if line.strip()}
