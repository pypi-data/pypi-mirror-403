id: optimized-dockerfile
title: Write an Optimized Dockerfile
stack: docker
domain: container
difficulty: Master
xp: 500

goal: >
  Design a highly optimized Dockerfile that minimizes image size
  and reflects production-grade container best practices.

skills:
  - dockerfile-optimization
  - image-size-reduction
  - container-best-practices
  - production-container-design

validator: validator.py

hint:
  - Use a slim base image, minimize layers, and copy only what is required at runtime.

mentor:
  why: Production Dockerfiles balance performance,
       security, and maintainability through deliberate
       optimization decisions.
  intent: applied
  guidance:
    before: |
      Evaluate each Dockerfile instruction for necessity
      and its impact on image size, caching, and attack surface.
    after: >
      Consider how additional optimizations such as
      multi-stage builds or distroless images
      could further improve production readiness.
  tags:
    - docker
    - dockerfile
    - optimization
    - production-containers

solution:
  overview: >
    Master-level Docker labs evaluate judgment in balancing
    image size, clarity, security, and maintainability.
    The goal is not micro-optimization but sustainable,
    production-ready container design.

  approach:
    - Choose a minimal, explicit base image
    - Copy only runtime-required artifacts
    - Minimize the number of layers and instructions
    - Ensure the runtime command is explicit and predictable

  professional_considerations:
    - Smaller images reduce pull time and attack surface
    - Explicit COPY statements prevent accidental bloat
    - Fewer layers simplify debugging and maintenance
    - Optimization must not sacrifice clarity or safety

execution:
  runtime: docker
  requires_execution: true
  required_tools:
    - docker
