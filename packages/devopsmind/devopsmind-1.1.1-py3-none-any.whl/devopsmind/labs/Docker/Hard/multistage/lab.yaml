id: multistage
title: Build an Optimized Image with Multi-Stage Docker Build
stack: docker
domain: container
difficulty: Hard
xp: 150

goal: |
  Build an optimized Docker image using a multi-stage Dockerfile
  that separates build-time dependencies from runtime artifacts.

skills:
  - docker-multistage-builds
  - image-optimization
  - container-best-practices

validator: validator.py

hint:
  - Use a multi-stage Dockerfile a builder stage installs dependencies,
    and the final stage copies only what is required to run app.py.

mentor:
  why: Multi-stage Docker builds reduce image size and attack surface
       while preserving application functionality, a key production practice.
  intent: applied
  guidance:
    before: |
      Think about which artifacts are required at build time
      versus which are required at runtime.
    after: >
      Consider how further base image reduction or dependency pruning
      could reduce image size and attack surface.
  tags:
    - docker
    - multistage-build
    - image-optimization
    - production-containers

solution:
  overview: >
    Hard-level Docker labs evaluate the ability to reason
    about build-time versus runtime concerns. Multi-stage builds
    are used to prevent unnecessary artifacts from reaching
    production images.

  approach:
    - Use an initial builder stage to install dependencies
    - Isolate build tooling from the final runtime image
    - Copy only required runtime artifacts into the final stage
    - Ensure the container runs the application correctly

  professional_considerations:
    - Smaller images reduce attack surface and pull time
    - Clear stage separation improves maintainability
    - Avoid leaking build-time files into production images
    - Favor clarity over cleverness in Dockerfiles

execution:
  runtime: docker
  requires_execution: true
  required_tools:
    - docker
