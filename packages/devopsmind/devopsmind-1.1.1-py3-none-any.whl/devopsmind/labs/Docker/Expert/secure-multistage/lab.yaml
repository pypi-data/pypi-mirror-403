id: secure-multistage
title: Design a Secure Multi-Stage Dockerfile
stack: docker
domain: security
difficulty: Expert
xp: 300

goal: >
  Design a secure multi-stage Dockerfile that applies
  container security best practices such as least privilege
  and minimal runtime images.

skills:
  - docker-security
  - docker-multistage-builds
  - least-privilege
  - container-hardening

validator: validator.py

hint:
  - Use a builder stage and ensure the final image runs as a non-root user.

mentor:
  why: Secure container images reduce blast radius and prevent
       privilege escalation in production environments.
  intent: applied
  guidance:
    before: |
      Consider which build artifacts are required at runtime
      and how user privileges affect container security.
    after: >
      Consider additional hardening techniques such as
      read-only filesystems or more minimal base images.
  tags:
    - docker
    - security
    - multistage-build
    - least-privilege

solution:
  overview: >
    Expert-level Docker security focuses on minimizing attack surface
    and enforcing least privilege at runtime. Multi-stage builds
    prevent build-time tools and secrets from leaking into
    production images.

  approach:
    - Use a builder stage to install dependencies
    - Copy only runtime artifacts into the final stage
    - Create and switch to a non-root user
    - Ensure the application runs with minimal privileges

  professional_considerations:
    - Running as root increases blast radius
    - Smaller images reduce vulnerability exposure
    - Explicit user switching improves auditability
    - Security controls should be simple and verifiable

execution:
  runtime: docker
  requires_execution: true
  required_tools:
    - docker

