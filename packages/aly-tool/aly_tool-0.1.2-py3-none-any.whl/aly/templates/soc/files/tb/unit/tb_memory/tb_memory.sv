// Copyright 2025 ALY Project
// SPDX-License-Identifier: Apache-2.0

//-----------------------------------------------------------------------------
// Testbench for Memory Module with File Loading
// 
// Demonstrates loading a .mem file generated by 'aly firmware'
//-----------------------------------------------------------------------------
`timescale 1ns/1ps

module tb_memory;

    //-------------------------------------------------------------------------
    // Parameters
    //-------------------------------------------------------------------------
    localparam int WIDTH = 32;
    localparam int DEPTH = 256;
    localparam int CLK_PERIOD = 10;
    
    // Memory file - can be overridden via plusarg
    string mem_file = "";

    //-------------------------------------------------------------------------
    // Signals
    //-------------------------------------------------------------------------
    logic                     clk;
    logic                     rst_n;
    
    // Port A
    logic                     a_en;
    logic                     a_we;
    logic [$clog2(DEPTH)-1:0] a_addr;
    logic [WIDTH-1:0]         a_wdata;
    logic [WIDTH/8-1:0]       a_be;
    logic [WIDTH-1:0]         a_rdata;
    
    // Port B
    logic                     b_en;
    logic [$clog2(DEPTH)-1:0] b_addr;
    logic [WIDTH-1:0]         b_rdata;

    //-------------------------------------------------------------------------
    // DUT
    //-------------------------------------------------------------------------
    memory #(
        .WIDTH(WIDTH),
        .DEPTH(DEPTH),
        .MEM_FILE(""),  // Load via initial block for plusarg support
        .DUAL_PORT(1)
    ) dut (
        .clk_i    (clk),
        .rst_ni   (rst_n),
        .a_en_i   (a_en),
        .a_we_i   (a_we),
        .a_addr_i (a_addr),
        .a_wdata_i(a_wdata),
        .a_be_i   (a_be),
        .a_rdata_o(a_rdata),
        .b_en_i   (b_en),
        .b_addr_i (b_addr),
        .b_rdata_o(b_rdata)
    );

    //-------------------------------------------------------------------------
    // Clock Generation
    //-------------------------------------------------------------------------
    initial begin
        clk = 0;
        forever #(CLK_PERIOD/2) clk = ~clk;
    end

    //-------------------------------------------------------------------------
    // Test Variables
    //-------------------------------------------------------------------------
    int test_count = 0;
    int pass_count = 0;
    int fail_count = 0;

    task automatic check(input string name, input logic condition);
        test_count++;
        if (condition) begin
            pass_count++;
            $display("[PASS] %s", name);
        end else begin
            fail_count++;
            $display("[FAIL] %s", name);
        end
    endtask

    task automatic reset_dut();
        rst_n   = 0;
        a_en    = 0;
        a_we    = 0;
        a_addr  = 0;
        a_wdata = 0;
        a_be    = '1;
        b_en    = 0;
        b_addr  = 0;
        repeat(5) @(posedge clk);
        rst_n = 1;
        @(posedge clk);
    endtask

    //-------------------------------------------------------------------------
    // Test Sequence
    //-------------------------------------------------------------------------
    initial begin
        $display("============================================");
        $display("ALY Memory Testbench");
        $display("============================================");
        $display("");

        // Check for memory file plusarg
        if ($value$plusargs("MEM_FILE=%s", mem_file)) begin
            $display("[INFO] Loading memory from: %s", mem_file);
            $readmemh(mem_file, dut.mem);
        end else begin
            $display("[INFO] No MEM_FILE plusarg, using test patterns");
        end

        reset_dut();

        //---------------------------------------------------------------------
        // Test 1: Basic write and read
        //---------------------------------------------------------------------
        $display("[TEST] Basic write and read");
        
        a_en    = 1;
        a_we    = 1;
        a_addr  = 0;
        a_wdata = 32'hDEADBEEF;
        a_be    = 4'b1111;
        @(posedge clk);
        
        a_we   = 0;
        a_addr = 0;
        @(posedge clk);
        
        check("Read back written value", a_rdata == 32'hDEADBEEF);

        //---------------------------------------------------------------------
        // Test 2: Byte-enable write
        //---------------------------------------------------------------------
        $display("[TEST] Byte-enable write");
        
        // Write full word first
        a_we    = 1;
        a_addr  = 1;
        a_wdata = 32'hAAAAAAAA;
        a_be    = 4'b1111;
        @(posedge clk);
        
        // Write only byte 1
        a_wdata = 32'h00BB0000;
        a_be    = 4'b0100;
        @(posedge clk);
        
        // Read back
        a_we = 0;
        @(posedge clk);
        
        check("Byte-enable: only byte 1 changed", a_rdata == 32'hAABBAAAA);

        //---------------------------------------------------------------------
        // Test 3: Dual port access
        //---------------------------------------------------------------------
        $display("[TEST] Dual port simultaneous access");
        
        // Write to address 2 via port A
        a_we    = 1;
        a_addr  = 2;
        a_wdata = 32'h11223344;
        a_be    = 4'b1111;
        
        // Read from address 0 via port B
        b_en   = 1;
        b_addr = 0;
        @(posedge clk);
        
        a_we = 0;
        @(posedge clk);
        
        check("Port B reads addr 0", b_rdata == 32'hDEADBEEF);
        
        // Now read addr 2 via port B
        b_addr = 2;
        @(posedge clk);
        
        check("Port B reads addr 2", b_rdata == 32'h11223344);

        //---------------------------------------------------------------------
        // Test 4: Sequential memory access (if file loaded)
        //---------------------------------------------------------------------
        if (mem_file != "") begin
            $display("[TEST] Reading loaded memory file");
            
            a_we = 0;
            for (int i = 0; i < 8; i++) begin
                a_addr = i[$clog2(DEPTH)-1:0];
                @(posedge clk);
                $display("  mem[%0d] = 0x%08h", i, a_rdata);
            end
        end

        //---------------------------------------------------------------------
        // Summary
        //---------------------------------------------------------------------
        $display("");
        $display("============================================");
        $display("Test Summary: %0d/%0d passed", pass_count, test_count);
        $display("============================================");

        if (fail_count == 0) begin
            $display("ALL TESTS PASSED!");
        end else begin
            $display("SOME TESTS FAILED!");
        end

        $finish;
    end

    // Timeout
    initial begin
        #100000;
        $display("[ERROR] Simulation timeout!");
        $finish;
    end

endmodule
