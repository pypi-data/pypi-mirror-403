"""
LLM-guided context planning.

Analyzes a diff and determines what additional context is needed for code review.
"""

from pydantic import BaseModel, Field

from ...protocols import LLMClient


class DiffFileContext(BaseModel):
    """Context configuration for a file in the diff."""
    file_path: str = Field(..., description="Path to the file")
    lines_before: int = Field(
        default=10,
        ge=0,
        le=50,
        description="Number of lines of context to show before the first change"
    )
    lines_after: int = Field(
        default=10,
        ge=0,
        le=50,
        description="Number of lines of context to show after the last change"
    )
    full_functions: list[str] = Field(
        default_factory=list,
        description="Names of functions/methods within this file to show in full (not skeleton)"
    )


class SymbolRequest(BaseModel):
    """Request for a symbol from another file."""
    symbol_name: str = Field(
        ...,
        description="Name of the symbol (class, function, interface) to include"
    )
    file_hint: str | None = Field(
        default=None,
        description="Optional file path hint if the symbol name is ambiguous"
    )
    full: bool = Field(
        default=False,
        description="If True, show full implementation. If False, show skeleton only."
    )


class ContextPlan(BaseModel):
    """
    Plan for what context to include in the code review.
    
    Generated by the LLM based on analysis of the diff.
    """
    diff_files: list[DiffFileContext] = Field(
        default_factory=list,
        description="Context configuration for each file in the diff"
    )
    related_symbols: list[SymbolRequest] = Field(
        default_factory=list,
        description="Symbols from other files to include for context"
    )
    reasoning: str = Field(
        default="",
        description="Brief explanation of why this context was selected"
    )


CONTEXT_PLANNING_PROMPT = '''You are analyzing a code diff to determine what additional context is needed for a thorough code review.

## Your Task

Given the diff below, determine:

1. **For each file in the diff**: How many lines of context before/after the changes should be shown (0-50). More context is useful when:
   - The change modifies a small part of a larger function
   - Understanding the change requires seeing surrounding code
   - The change interacts with nearby code

2. **Functions to show in full**: Which functions/methods in the diff files should be shown completely (not as skeleton). Include a function if:
   - It was significantly modified
   - Understanding its full logic is essential to review the change
   - It's small and the change touches most of it

3. **Related symbols from other files**: Which classes, functions, or interfaces from OTHER files should be included. Include a symbol if:
   - It's directly used by the changed code
   - Understanding its interface is needed to evaluate the change
   - The change might affect how this symbol should be used

Be **conservative** - only request context that is directly relevant to understanding the changes.
Request symbols as **skeleton only** (full=false) unless the implementation details are truly needed.

## Diff

{diff}

Respond with a JSON object matching the ContextPlan schema.'''


class ContextPlanner:
    """
    Uses an LLM to determine what context is needed for code review.
    """

    def __init__(self, llm_client: LLMClient) -> None:
        """
        Initialize the context planner.
        
        Args:
            llm_client: LLM client for making planning calls
        """
        self.llm = llm_client

    def plan(self, diff: str, trace=None) -> ContextPlan:
        """
        Analyze a diff and create a context plan.
        
        Args:
            diff: The raw diff text to analyze
            trace: Langfuse trace/span object for tracing (optional)
        
        Returns:
            ContextPlan specifying what context to include
        """
        messages = [
            {
                "role": "system",
                "content": "You are a code review context planner. Analyze diffs and determine what additional context is needed for thorough review."
            },
            {
                "role": "user",
                "content": CONTEXT_PLANNING_PROMPT.format(diff=diff)
            }
        ]

        # Start generation span if tracing enabled
        generation = None
        if trace:
            generation = trace.start_generation(
                name="plan_context",
                input=messages,
            )

        response = self.llm.generate(messages, ContextPlan)

        # End generation with output and token usage
        if generation:
            generation.update(
                model=response.model,
                output=response.result.model_dump_json(),
                usage_details={
                    "input": response.token_usage.prompt_tokens,
                    "output": response.token_usage.completion_tokens,
                },
            )
            generation.end()

        return response.result

    def plan_from_file_diffs(self, file_diffs: list, trace=None) -> ContextPlan:
        """
        Create a context plan from FileDiff objects.
        
        Args:
            file_diffs: List of FileDiff objects from the merge request
            trace: Langfuse trace/span object for tracing (optional)
        
        Returns:
            ContextPlan specifying what context to include
        """
        # Combine all diffs into a single string
        diff_parts = []
        for fd in file_diffs:
            diff_parts.append(f"--- {fd.file_path} ---")
            
            # Try to get diff content in order of preference
            if fd.hunks:
                diff_parts.append(fd.format_with_line_numbers())
            elif fd.raw_diff:
                diff_parts.append(fd.raw_diff)
            elif fd.is_new_file and fd.full_content:
                diff_parts.append(f"NEW FILE:\n{fd.format_content_with_line_numbers()}")
            # Skip files with no diff content (avoid empty entries)
            else:
                # Remove the file header we just added since there's no content
                diff_parts.pop()
                continue
            
            diff_parts.append("")
        
        combined_diff = "\n".join(diff_parts)
        return self.plan(combined_diff, trace=trace)
