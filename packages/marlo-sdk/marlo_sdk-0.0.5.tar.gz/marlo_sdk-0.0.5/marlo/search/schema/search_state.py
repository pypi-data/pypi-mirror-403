"""Search state and plan dataclasses."""

from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime
from typing import Any, Literal


@dataclass
class SubQuery:
    """A sub-query generated by the orchestrator for the SQL agent."""

    description: str
    sql_hint: str
    status: Literal["pending", "in_progress", "complete", "failed"] = "pending"
    result_count: int = 0
    error: str | None = None


@dataclass
class SearchPlan:
    """Search plan generated by the orchestrator."""

    intent: str  # What the user is looking for
    filters: dict[str, Any] = field(default_factory=dict)  # Time range, agent, tools, etc.
    search_strategy: Literal["broad", "focused", "temporal"] = "focused"
    priority_fields: list[str] = field(default_factory=list)  # Which data to prioritize
    sub_queries: list[SubQuery] = field(default_factory=list)


@dataclass
class SearchState:
    """Tracks the state of a deep search operation."""

    search_id: str
    original_query: str
    project_id: str
    search_plan: SearchPlan | None = None
    iteration_count: int = 0
    max_iterations: int = 5
    coverage_score: float = 0.0  # 0-1, how well findings answer query
    status: Literal["planning", "querying", "analyzing", "synthesizing", "complete", "failed"] = "planning"
    error: str | None = None
    created_at: datetime = field(default_factory=datetime.utcnow)

    # Statistics
    total_events_searched: int = 0
    total_sessions_searched: int = 0
    total_facts_extracted: int = 0

    def should_continue(self) -> bool:
        """Check if search should continue iterating."""
        if self.status in ("complete", "failed"):
            return False
        if self.iteration_count >= self.max_iterations:
            return False
        if self.coverage_score >= 0.9:
            return False
        return True

    def increment_iteration(self) -> None:
        """Increment iteration counter."""
        self.iteration_count += 1
