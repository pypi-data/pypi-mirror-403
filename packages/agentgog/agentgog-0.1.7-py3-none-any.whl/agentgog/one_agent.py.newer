import os
import logging
from datetime import datetime
from pathlib import Path
from uuid import uuid4

import datetime as dt
import sympy, pandas, numpy

import click
from console import fg, bg

from smolagents import OpenAIModel
from smolagents import CodeAgent, InferenceClientModel, DuckDuckGoSearchTool, WebSearchTool
from smolagents import tool



class CustomFormatter(logging.Formatter):
    def formatTime(self, record, datefmt=None):
        dt = datetime.fromtimestamp(record.created)
        if datefmt:
            return dt.strftime(datefmt)
        else:
            return dt.isoformat()

handler = logging.FileHandler(os.path.expanduser("~/one_agent.log"))
handler.setFormatter(CustomFormatter("[LOG] %(asctime)s|%(message)s", datefmt="%Y-%m-%dT%H:%M:%S"))
logger = logging.getLogger()
logger.addHandler(handler)
logger.setLevel(logging.INFO)

models_free = [ "google/gemma-3-27b-it:free",
    "xiaomi/mimo-v2-flash:free"
    #"nex-agi/deepseek-v3.1-nex-n1:free" # c03 refaktoroval; c05 all API KEYs;  !!!ONLY THIS ONE TRANSLATED C09
#              "z-ai/glm-4.5-air:free", # volal c04 erf! ; On c05 - got stuck-slow
#              "allenai/olmo-3.1-32b-think:free",
#              "google/gemma-3-27b-it:free", # ZPRASILA C03 odpoved! ; chce scpiy-jinak obycejne secte delty!
#              "openai/gpt-oss-20b:free", # limit
#               "meta-llama/llama-3.3-70b-instruct:free", # c04 chce scipy jinak SUMdh-erf; c05 dal, ale nema faktory jen34km
#              "nousresearch/hermes-3-llama-3.1-405b:free", # missed answer c03 - tries to interpolate!; c04 chce scipy.integrate
#              "meta-llama/llama-3.1-405b-instruct:free", #f ; - ocural vysl 4 x nevi evalf; API googlemaps - pak 10x nesmysl
#              "openai/gpt-oss-120b:free"
              ]


# ================================================================================
# SYSTEM_PROMPTS           TRANSLATOR
# --------------------------------------------------------------------------------

SYSTEM_PROMPT_TRANSLATOR = '''You are a Czech-English professional translator with specialization on subtitles. You understand the strict SRT format with segment number, formatted timing information, text, and an empty line. It is crucial to keep the exact format with segment number and timing information along with empty lines! Translate the given prompt - SRT subtitles - from English to Czech and keep the EXACT SRT information; do not add any explanations or comments. Pay extra attention to empty lines; they must appear in the same positions as the input.
To solve the task, you must plan forward to proceed in a series of steps, in a cycle of Thought, Code, and Observation sequences.

At each step, in the 'Thought:' sequence, you should first explain your reasoning for the translation - it is trivial here.
Then in the Code sequence you should write the code in simple Python to pass the translation to the next stage, usually a simple print() function. The code sequence must be opened with '<code>', and closed with '</code>'.
During an intermediate step - though not expected for translations - you can use 'print()' to save whatever important information you will then need.
These print outputs will then appear in the 'Observation:' field, which will be available as input for the next step.
In the end you have to return a final answer using the `final_answer` tool.

Here is an example using final_answer tool:
---
Task: "35
00:04:09,080 --> 00:04:10,400                                                                                                                             There is a

36
00:04:10,400 --> 00:04:12,080
 significant portion

"
Thought: I will translate from English to Czech keeping the exact SRT structure.
<code>
final_answer("""35
00:04:09,080 --> 00:04:10,400                                                                                                                             Je to

36
00:04:10,400 --> 00:04:12,080
 významná část

""")
</code>

---
Task: "This is a test."
Thought: I will translate from English to Czech keeping the exact SRT structure.
<code>
final_answer("Toto je test.")
</code>
'''

# ================================================================================
#    QR PAYMENT  SYSTEM PROMPT
# --------------------------------------------------------------------------------

SYSTEM_PROMPT_QRPAYMENT = '''You are a QR payment coordinator specializing in extracting payment details from user-provided text. Analyze the given text to identify key payment coordinates such as account number, amount, currency, variable symbol (VS), constant symbol (KS), specific symbol (SS), date, and message. Ensure the account is in the format full account (e.g., "1234567890/0300"). If any details are missing, use defaults: amount=0, currency='CZK', vs='', ks='', ss='', date=None, message=''.

To solve the task, you must plan forward to proceed in a series of steps, in a cycle of Thought, Code, and Observation sequences.

At each step, in the 'Thought:' sequence, you should first explain your reasoning for extracting the payment details.
Then in the Code sequence you should use the `generate_qr` tool to create the QR code for the payment with the extracted details. The code sequence must be opened with '<code>', and closed with '</code>'.
During intermediate steps - if any -  you can use 'print()' to save important information for the next step.
These print outputs will appear in the 'Observation:' field as input for the next step.
In the end, you have to return a final answer using the `final_answer` tool, providing the path to the generated QR code file.

Here is an example using final_answer tool:
---
Task: "Transfer 500 CZK to account 1234567890/0300 with message 'Invoice payment'."
Thought: I need to extract payment details: account='1234567890/0300', amount=500, currency='CZK', message='Invoice payment'. Then use generate_qr to create the QR code.
<code>
img_filename = generate_qr(account="1234567890/0300", amount=500, currency="CZK", message="Invoice payment")
final_answer(f"{img_filename}")
</code>

---
Task: "Pay 100 to 0987654321/0800 with VS 123456 on 2023-10-15."
Thought: Extract details: account='0987654321/0800', amount=100, vs='123456', date='2023-10-15'.
<code>
img_filename = generate_qr(account="0987654321/0800", amount=100, vs="123456", date="2023-10-15")
final_answer(f"{img_filename}")
</code>
'''



# ================================================================================
#  TOOL definition
# --------------------------------------------------------------------------------

@tool
def read_file(filename: str) -> str | None:
    """
    This is a tool that returns a content of the filename
    Args:
        filename: The filename
    Returns:
        A string containing the content of the file.
    """
    content = None
    try:
        with open(filename) as f:
            content = f.read()
    except:
        return None
    return content

@tool
def generate_qr(account: str, amount: float = 0, currency: str = "CZK", vs: str = "", ks: str = "", ss: str = "", date: str = "", message: str = "") -> str:
    """
    Generate a QR code for payment based on given parameters. Generates a unique filename for the QR code PNG.
    Args:
        account: The account number (e.g., "1234567890/0300")
        amount: The amount to transfer
        currency: Currency code (default CZK)
        vs: Variable symbol
        ks: Constant symbol
        ss: Specific symbol
        date: Date in YYYY-MM-DD format
        message: Payment message
    Returns:
        The unique filename of the generated QR code PNG.
    """
    import io
    import qrcode
    import datetime as dt

    # Log tool call
    log_event(EVENT="TOOL_CALL", TOOL="generate_qr", ACCOUNT=account, AMOUNT=str(amount), CURRENCY=currency, VS=vs, KS=ks, SS=ss, DATE=date, MESSAGE=message)

    # Generate unique filename
    unique_id = f"{account}_{amount}".replace("/", "_").replace(",", "_").replace(".", "_")
    temp_filename = f"payment_qr_{unique_id}.png"
    temp_path = Path(temp_filename)

    # Constants and helper functions from genqr.py
    alpha2num = {
        'A': 10, 'B': 11, 'C': 12, 'D': 13, 'E': 14, 'F': 15,
        'G': 16, 'H': 17, 'I': 18, 'J': 19, 'K': 20, 'L': 21,
        'M': 22, 'N': 23, 'O': 24, 'P': 25, 'Q': 26, 'R': 27,
        'S': 28, 'T': 29, 'U': 30, 'V': 31, 'W': 32, 'X': 33,
        'Y': 34, 'Z': 35
    }

    def mod_97_10(number_str: str) -> str:
        remainder = int(number_str) % 97
        res = 98 - remainder
        res = str(res)
        if len(res) < 2:
            res = f"0{res}"
        return res

    def alphanum_to_num(iban2: str, mapping: dict) -> str:
        result = []
        for ch in iban2:
            if ch.isdigit():
                result.append(ch)
            elif ch.isalpha() and ch.isupper():
                result.append(str(mapping[ch]))
            else:
                raise ValueError("Invalid character in input")
        return ''.join(result)

    def verify_iban(iban):
        iban2 = f"{iban[4:]}{iban[:4]}"
        iban3 = alphanum_to_num(iban2, alpha2num)
        res = int(iban3) % 97
        return res == 1

    def split_in_groups_of_4(s: str) -> str:
        groups = []
        i = len(s)
        while i > 0:
            start = max(i - 4, 0)
            groups.append(s[start:i])
            i -= 4
        return ' '.join(reversed(groups))

    def calc_iban(bban="300497813/0300", ccode="CZ"):
        bb1 = bban
        if ccode == "CZ":
            acc, bank = bban.split("/")
            pref = ""
            numb = acc
            if "-" in acc:  # IF PREFIX
                pref, numb = acc.split("-")
            if len(numb) < 10:
                nul = 10 - len(numb)
                numb = f"{"0"*nul}{numb}"
            if len(pref) < 6:
                nul = 6 - len(pref)
                pref = f"{"0"*nul}{pref}"
            bb1 = f"{bank}{pref}{numb}"
        bb1 = bb1.replace("/", "").replace(" ","").replace("-", "")
        aiban3 = f"{bb1}{alpha2num[ccode[0]]}{alpha2num[ccode[1]]}00"
        if not aiban3.isdigit():
            raise ValueError("Input must be a string of digits.")
        check = mod_97_10(aiban3)
        aiban4 = f"{ccode}{check}{bb1}"
        if verify_iban(aiban4):
            return aiban4
        else:
            raise ValueError("Invalid IBAN")

    # Main logic
    date_str = ''
    if date:
        try:
            date_obj = dt.datetime.strptime(date, '%Y-%m-%d')
            date_str = date_obj.strftime('%Y%m%d')
        except ValueError:
            raise ValueError("Invalid date format. Please use YYYY-MM-DD.")

    iban = calc_iban(account, ccode="CZ")

    spayd_parts = [
        f"SPD*1.0",
        f"ACC:{iban}",
        f"AM:{amount:.2f}",
        f"CC:{currency}"
    ]

    if vs:
        spayd_parts.append(f"X-VS:{vs}")
    if ks:
        spayd_parts.append(f"X-KS:{ks}")
    if ss:
        spayd_parts.append(f"X-SS:{ss}")
    if message:
        spayd_parts.append(f"MSG:{message}")
    if date_str:
        spayd_parts.append(f"DT:{date_str}")

    spayd_string = '*'.join(spayd_parts)

    # Generate QR code
    qr = qrcode.QRCode()
    qr.add_data(spayd_string)

    # Print ASCII QR
    f = io.StringIO()
    qr.print_ascii(out=f)
    f.seek(0)
    print(f.read())

    qr.make(fit=True)
    img = qr.make_image(fill_color="black", back_color="white")
    with open(str(temp_path), 'wb') as f:
        img.save(f)

    # Log success
    log_event(EVENT="QR_GENERATED", OUTPUT_FILE=str(temp_path))

    return str(temp_path)


# ================================================================================
# split model name
# --------------------------------------------------------------------------------

def log_event(**kwargs):
    """Log an event in a bash-parseable format."""
    kwargs_str = "|".join(f"{k}={v}" for k, v in kwargs.items() if v is not None)
    logging.info(kwargs_str)


def get_model_idshort(model_id):
    """
    Return short model  name
    """
    return model_id.split("/")[-1].split(":")[0]

# ================================================================================
# RUn task
# --------------------------------------------------------------------------------

def run_task(model_id, question, system_prompt=SYSTEM_PROMPT_TRANSLATOR, tools=[read_file]):
    """
    run one task
    """
    ts_start = dt.datetime.now()
    model_idshort = get_model_idshort(model_id)

    log_event(
        MODEL=model_id,
        EVENT="TASK_START",
        DURATION_SEC=None,
        INPUT_FILE=None,
        OUTPUT_FILE=None,
        STATUS="SUCCESS"
    )

    model = OpenAIModel(
        model_id= model_id,
        api_base="https://openrouter.ai/api/v1", # Leave this blank to query OpenAI servers.
        api_key=os.environ["OPENROUTER_API_KEY"], # Switch to the API key for the server you're targeting.
    )
    # Create an agent with no tools         # tools=[DuckDuckGoSearchTool()],
    result = ""

    with CodeAgent(tools=tools,
# #        tools=[WebSearchTool()],
# #        additional_authorized_imports=["sympy", "numpy", "pandas"],
# #        executor_type="modal",  # doesnt work, do not use
        model=model) as agent:

        agent.prompt_templates["system_prompt"] =  system_prompt
        # print(agent.system_prompt) # save the prompt to the disk

        # Run the agent with a task
        result = agent.run(question, reset=True, max_steps=3 ) # LIMIT STEPS
        # print(result) # DEBUG

    ts_end = dt.datetime.now()
    duration = (ts_end - ts_start).total_seconds()
    log_event(
        MODEL=model_id,
        EVENT="TASK_END",
        DURATION_SEC=f"{duration:.1f}",
        INPUT_FILE=None,
        OUTPUT_FILE=None,
        STATUS="SUCCESS"
    )

    # ---------------------- return the result
    return result

# ==============================================  MAIN ===========================
# ==============================================  MAIN ===========================
# ==============================================  MAIN ===========================
@click.group()
def cli():
    pass

@cli.command("translator")
@click.option("--input", "-i", "inputfile", required=True, help="Input SRT file to translate")
@click.option("--model", default=models_free[0], help="Model to use for translation")
def translator(inputfile, model):
    """Translate SRT subtitles from English to Czech."""
    log_event(EVENT="COMMAND", COMMAND="translator")
    OUTPUTFILE_a, OUTPUTFILE_ext = os.path.splitext(inputfile)
    srt = ""
    with open(inputfile) as f:
        srt = f.read()

    PROMPT = f"{srt}"
    print(f"i... {bg.green}{fg.white} MODEL {model} {bg.default}{fg.default}")
    ans = run_task(model, PROMPT, SYSTEM_PROMPT_TRANSLATOR, [read_file])
    output_path = f"{OUTPUTFILE_a}_cs{OUTPUTFILE_ext}"
    with open(output_path, "w") as f:
        f.write(f"{ans}")

    log_event(
        MODEL=model,
        EVENT="OUTPUT_WRITE",
        DURATION_SEC=None,
        INPUT_FILE=inputfile,
        OUTPUT_FILE=output_path,
        STATUS="SUCCESS"
    )

    print(f"i... FINISHED {inputfile}")

@cli.command("qrpayment")
@click.argument("prompt")
@click.option("--model", default=models_free[0], help="Model to use for QR payment generation")
def qrpayment(prompt, model):
    """Generate QR code for payment based on the given prompt."""
    log_event(EVENT="COMMAND", COMMAND="qrpayment")
    print(f"i... {bg.green}{fg.white} MODEL {model} {bg.default}{fg.default}")
    output_path = run_task(model, prompt, SYSTEM_PROMPT_QRPAYMENT, [generate_qr])
    log_event(
        MODEL=model,
        EVENT="QR_GENERATED",
        DURATION_SEC=None,
        INPUT_FILE=None,
        OUTPUT_FILE=output_path,
        STATUS="SUCCESS"
    )
    print(f"i... QR code saved as: {output_path}")

import sys

# ======================================================================================
if __name__ == "__main__":
    log_event(EVENT="RUN_BORDER", MESSAGE="============================================")
    log_event(EVENT="RUN_START", COMMAND=" ".join(sys.argv))
    cli()
