"""
Import Generator - Generate import commands for brownfield adoption.

Supports two output formats:
- imports.tf: Terraform 1.5+ import blocks (recommended)
- imports.sh: Shell script for older Terraform versions
"""

from __future__ import annotations

import logging
from pathlib import Path
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from replimap.core.models import ResourceNode
    from replimap.core.unified_storage import GraphEngineAdapter

logger = logging.getLogger(__name__)


class ImportGenerator:
    """
    Generate Terraform import commands.

    Creates either import blocks (TF 1.5+) or a shell script
    for importing existing resources into Terraform state.
    """

    def generate_import_tf(
        self,
        graph: GraphEngineAdapter,
        output_dir: Path,
    ) -> Path:
        """
        Generate imports.tf with Terraform 1.5+ import blocks.

        Args:
            graph: The graph containing resources
            output_dir: Directory to write the file

        Returns:
            Path to generated file
        """
        lines = [
            "# Generated by RepliMap Codify",
            "# Terraform 1.5+ Import Blocks",
            "#",
            "# These import blocks allow Terraform to adopt existing resources.",
            "#",
            "# Usage:",
            "#   terraform init",
            "#   terraform plan  # Should show: X to import, 0 to add, 0 to change",
            "#   terraform apply",
            "#",
            "# After successful import, you can optionally remove this file.",
            "#",
            "",
        ]

        import_count = 0
        for resource in graph.iter_resources():
            # v3.7.19: Skip phantom nodes (placeholders for missing resources)
            if getattr(resource, "is_phantom", False):
                continue

            import_block = self._generate_import_block(resource)
            if import_block:
                lines.append(import_block)
                import_count += 1

        file_path = output_dir / "imports.tf"
        file_path.write_text("\n".join(lines))

        logger.info(f"Generated {import_count} import blocks")
        return file_path

    def generate_import_sh(
        self,
        graph: GraphEngineAdapter,
        output_dir: Path,
    ) -> Path:
        """
        Generate imports.sh shell script for older Terraform versions.

        Args:
            graph: The graph containing resources
            output_dir: Directory to write the file

        Returns:
            Path to generated file
        """
        lines = [
            "#!/bin/bash",
            "# Generated by RepliMap Codify",
            "# Import Script for Terraform < 1.5",
            "#",
            "# Usage:",
            "#   chmod +x imports.sh",
            "#   ./imports.sh",
            "#",
            "# Note: Run 'terraform init' before running this script.",
            "#",
            "",
            "set -e",
            "",
        ]

        import_count = 0
        for resource in graph.iter_resources():
            # v3.7.19: Skip phantom nodes (placeholders for missing resources)
            if getattr(resource, "is_phantom", False):
                continue

            import_cmd = self._generate_import_command(resource)
            if import_cmd:
                lines.append(import_cmd)
                import_count += 1

        lines.append("")
        lines.append('echo "Import complete. Run terraform plan to verify."')

        file_path = output_dir / "imports.sh"
        file_path.write_text("\n".join(lines))
        file_path.chmod(0o755)  # Make executable

        logger.info(f"Generated {import_count} import commands")
        return file_path

    # ðŸš¨ v3.7.20 FIX: Removed aws_autoscaling_group and aws_s3_bucket_policy
    # Previous logic skipped imports but NOT HCL generation, causing Terraform
    # to show these as "to add" instead of "to import". If a resource was scanned
    # from AWS, it exists and should be imported.
    SKIP_IMPORT_TYPES: set[str] = {
        # Empty - all scanned resources should have import blocks generated
    }

    def _generate_import_block(self, resource: ResourceNode) -> str | None:
        """Generate a Terraform import block for a resource."""
        tf_type = self._get_terraform_type(resource)
        tf_name = resource.terraform_name
        import_id = self._get_import_id(resource)

        if not tf_name or not import_id:
            return None

        # ðŸš¨ v3.7.18: Skip problematic resource types
        if tf_type in self.SKIP_IMPORT_TYPES:
            logger.debug(
                f"Skipping import for {tf_type}.{tf_name} (in SKIP_IMPORT_TYPES)"
            )
            return None

        return f'''import {{
  to = {tf_type}.{tf_name}
  id = "{import_id}"
}}
'''

    def _generate_import_command(self, resource: ResourceNode) -> str | None:
        """Generate a terraform import command for a resource."""
        tf_type = self._get_terraform_type(resource)
        tf_name = resource.terraform_name
        import_id = self._get_import_id(resource)

        if not tf_name or not import_id:
            return None

        # ðŸš¨ v3.7.18: Skip problematic resource types
        if tf_type in self.SKIP_IMPORT_TYPES:
            return None

        return f'terraform import {tf_type}.{tf_name} "{import_id}"'

    def _get_terraform_type(self, resource: ResourceNode) -> str:
        """Get the Terraform type for a resource."""
        if "_terraform_type" in resource.config:
            return resource.config["_terraform_type"]
        return str(resource.resource_type)

    def _get_import_id(self, resource: ResourceNode) -> str | None:
        """Get the import ID for a resource."""
        # Use resolved import ID if available
        if "_import_id" in resource.config:
            return resource.config["_import_id"]
        # Fall back to resource ID
        return resource.id
