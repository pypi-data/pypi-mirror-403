"""
Terraform backend configuration generators.

Supports:
- local (default) - State stored locally
- s3 (with optional DynamoDB locking) - State stored in S3 for team collaboration

The S3 backend enables:
- Team collaboration (shared state)
- State locking (prevents concurrent modifications)
- State versioning (history and rollback)
- Encryption at rest

Usage:
    from replimap.renderers.backend import BackendGenerator, S3BackendConfig

    config = S3BackendConfig(
        bucket="my-terraform-state",
        key="prod/terraform.tfstate",
        region="us-east-1",
        dynamodb_table="terraform-locks",
    )

    generator = BackendGenerator()
    generator.generate_s3_backend(config, output_dir)
"""

from __future__ import annotations

import logging
from dataclasses import dataclass
from pathlib import Path
from typing import Any

logger = logging.getLogger(__name__)


@dataclass
class S3BackendConfig:
    """
    S3 backend configuration.

    Configures Terraform to store state in an S3 bucket with optional
    DynamoDB table for state locking.

    Attributes:
        bucket: S3 bucket name for state storage (required)
        key: Path within bucket for state file (default: terraform.tfstate)
        region: AWS region for S3 bucket
        encrypt: Enable server-side encryption (default: True)
        dynamodb_table: DynamoDB table name for state locking (optional)
        workspace_key_prefix: Prefix for workspace state files (optional)
        role_arn: IAM role ARN to assume for S3 access (optional)
        profile: AWS profile to use for S3 access (optional)
    """

    bucket: str
    key: str = "terraform.tfstate"
    region: str | None = None
    encrypt: bool = True
    dynamodb_table: str | None = None
    workspace_key_prefix: str | None = None
    role_arn: str | None = None
    profile: str | None = None

    def validate(self) -> None:
        """
        Validate configuration.

        Raises:
            ValueError: If required fields are missing or invalid
        """
        if not self.bucket:
            raise ValueError("S3 bucket name is required")
        if not self.bucket.strip():
            raise ValueError("S3 bucket name cannot be empty")
        if not self.key:
            raise ValueError("S3 key (state file path) is required")
        if not self.key.strip():
            raise ValueError("S3 key cannot be empty")

        # Validate bucket name format (basic check)
        if len(self.bucket) < 3 or len(self.bucket) > 63:
            raise ValueError("S3 bucket name must be between 3 and 63 characters")

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for serialization."""
        result = {
            "bucket": self.bucket,
            "key": self.key,
            "encrypt": self.encrypt,
        }
        if self.region:
            result["region"] = self.region
        if self.dynamodb_table:
            result["dynamodb_table"] = self.dynamodb_table
        if self.workspace_key_prefix:
            result["workspace_key_prefix"] = self.workspace_key_prefix
        if self.role_arn:
            result["role_arn"] = self.role_arn
        if self.profile:
            result["profile"] = self.profile
        return result


@dataclass
class LocalBackendConfig:
    """
    Local backend configuration.

    This is the default Terraform backend. State is stored locally
    in the specified file.

    Attributes:
        path: Path to state file (default: terraform.tfstate)
    """

    path: str = "terraform.tfstate"


class BackendGenerator:
    """
    Generate Terraform backend configuration files.

    Creates backend.tf with the configured backend type,
    and optionally bootstrap Terraform code to create S3 backend infrastructure.
    """

    def generate_s3_backend(
        self,
        config: S3BackendConfig,
        output_dir: Path,
    ) -> Path:
        """
        Generate backend.tf for S3 backend.

        Args:
            config: S3 backend configuration
            output_dir: Directory to write backend.tf

        Returns:
            Path to generated file

        Raises:
            ValueError: If configuration is invalid
        """
        config.validate()
        output_dir.mkdir(parents=True, exist_ok=True)

        lines = [
            "# ═══════════════════════════════════════════════════════════════════════════════",
            "# Generated by RepliMap",
            "# S3 Backend Configuration",
            "# ═══════════════════════════════════════════════════════════════════════════════",
            "#",
            "# This backend stores Terraform state in S3, enabling:",
            "#   - Team collaboration (shared state)",
            "#   - State locking (prevents concurrent modifications)",
            "#   - State versioning (history and rollback)",
            "#   - Encryption at rest",
            "#",
            "# To use this backend:",
            "#   1. Ensure the S3 bucket exists (or use --backend-bootstrap)",
            "#   2. Ensure you have write access to the bucket",
            "#   3. Run: terraform init",
            "#",
            "# To migrate existing state:",
            "#   terraform init -migrate-state",
            "#",
            "# ═══════════════════════════════════════════════════════════════════════════════",
            "",
            "terraform {",
            '  backend "s3" {',
            f'    bucket = "{config.bucket}"',
            f'    key    = "{config.key}"',
        ]

        if config.region:
            lines.append(f'    region = "{config.region}"')

        if config.encrypt:
            lines.append("    encrypt = true")

        if config.dynamodb_table:
            lines.append(f'    dynamodb_table = "{config.dynamodb_table}"')

        if config.workspace_key_prefix:
            lines.append(f'    workspace_key_prefix = "{config.workspace_key_prefix}"')

        if config.role_arn:
            lines.append(f'    role_arn = "{config.role_arn}"')

        if config.profile:
            lines.append(f'    profile = "{config.profile}"')

        lines.extend(
            [
                "  }",
                "}",
                "",
            ]
        )

        output_file = output_dir / "backend.tf"
        output_file.write_text("\n".join(lines))

        logger.info(f"Generated S3 backend configuration: {output_file}")
        return output_file

    def generate_local_backend(
        self,
        config: LocalBackendConfig,
        output_dir: Path,
    ) -> Path:
        """
        Generate backend.tf for local backend.

        This is optional - Terraform uses local backend by default.
        Explicitly generating it makes the configuration clear.

        Args:
            config: Local backend configuration
            output_dir: Directory to write backend.tf

        Returns:
            Path to generated file
        """
        output_dir.mkdir(parents=True, exist_ok=True)

        lines = [
            "# ═══════════════════════════════════════════════════════════════════════════════",
            "# Generated by RepliMap",
            "# Local Backend Configuration (default)",
            "# ═══════════════════════════════════════════════════════════════════════════════",
            "#",
            "# State is stored locally in the specified file.",
            "# This is Terraform's default behavior.",
            "#",
            "# For team collaboration, consider using S3 backend:",
            "#   replimap clone --backend s3 --backend-bucket my-bucket",
            "#",
            "# ═══════════════════════════════════════════════════════════════════════════════",
            "",
            "terraform {",
            '  backend "local" {',
            f'    path = "{config.path}"',
            "  }",
            "}",
            "",
        ]

        output_file = output_dir / "backend.tf"
        output_file.write_text("\n".join(lines))

        logger.info(f"Generated local backend configuration: {output_file}")
        return output_file

    def generate_backend_bootstrap(
        self,
        config: S3BackendConfig,
        output_dir: Path,
    ) -> Path:
        """
        Generate Terraform code to create the S3 backend infrastructure.

        This creates:
        - S3 bucket for state storage
        - Bucket versioning (for state history)
        - Bucket encryption (for security)
        - Public access block (for security)
        - DynamoDB table for locking (if configured)

        Run this ONCE to create infrastructure, then configure your
        main project to use this backend.

        Args:
            config: S3 backend configuration
            output_dir: Directory to write bootstrap files

        Returns:
            Path to generated main.tf file
        """
        config.validate()

        # Create bootstrap subdirectory
        bootstrap_dir = output_dir / "bootstrap"
        bootstrap_dir.mkdir(parents=True, exist_ok=True)

        lines = [
            "# ═══════════════════════════════════════════════════════════════════════════════",
            "# Generated by RepliMap",
            "# Bootstrap Terraform Backend Infrastructure",
            "# ═══════════════════════════════════════════════════════════════════════════════",
            "#",
            "# This creates the S3 bucket (and optionally DynamoDB table) for",
            "# storing Terraform state. Run this ONCE to set up the infrastructure.",
            "#",
            "# Usage:",
            "#   cd bootstrap/",
            "#   terraform init",
            "#   terraform apply",
            "#",
            "# Then configure your main project to use this backend.",
            "#",
            "# ═══════════════════════════════════════════════════════════════════════════════",
            "",
            "terraform {",
            '  required_version = ">= 1.0"',
            "",
            "  required_providers {",
            "    aws = {",
            '      source  = "hashicorp/aws"',
            '      version = ">= 5.0"',
            "    }",
            "  }",
            "}",
            "",
            'provider "aws" {',
        ]

        if config.region:
            lines.append(f'  region = "{config.region}"')

        if config.profile:
            lines.append(f'  profile = "{config.profile}"')

        lines.extend(
            [
                "}",
                "",
                "# ═══════════════════════════════════════════════════════════════════════════════",
                "# S3 Bucket for Terraform State",
                "# ═══════════════════════════════════════════════════════════════════════════════",
                "",
                'resource "aws_s3_bucket" "terraform_state" {',
                f'  bucket = "{config.bucket}"',
                "",
                "  # Prevent accidental deletion",
                "  lifecycle {",
                "    prevent_destroy = true",
                "  }",
                "",
                "  tags = {",
                '    Name        = "Terraform State"',
                '    ManagedBy   = "RepliMap"',
                '    Purpose     = "Terraform remote state storage"',
                "  }",
                "}",
                "",
                "# Enable versioning for state history",
                'resource "aws_s3_bucket_versioning" "terraform_state" {',
                "  bucket = aws_s3_bucket.terraform_state.id",
                "",
                "  versioning_configuration {",
                '    status = "Enabled"',
                "  }",
                "}",
                "",
                "# Enable server-side encryption",
                'resource "aws_s3_bucket_server_side_encryption_configuration" "terraform_state" {',
                "  bucket = aws_s3_bucket.terraform_state.id",
                "",
                "  rule {",
                "    apply_server_side_encryption_by_default {",
                '      sse_algorithm = "AES256"',
                "    }",
                "    bucket_key_enabled = true",
                "  }",
                "}",
                "",
                "# Block all public access",
                'resource "aws_s3_bucket_public_access_block" "terraform_state" {',
                "  bucket = aws_s3_bucket.terraform_state.id",
                "",
                "  block_public_acls       = true",
                "  block_public_policy     = true",
                "  ignore_public_acls      = true",
                "  restrict_public_buckets = true",
                "}",
                "",
            ]
        )

        # Add DynamoDB table if configured
        if config.dynamodb_table:
            lines.extend(
                [
                    "# ═══════════════════════════════════════════════════════════════════════════════",
                    "# DynamoDB Table for State Locking",
                    "# ═══════════════════════════════════════════════════════════════════════════════",
                    "#",
                    "# This table prevents concurrent state modifications by acquiring locks.",
                    "# PAY_PER_REQUEST billing means you only pay for what you use.",
                    "#",
                    "",
                    'resource "aws_dynamodb_table" "terraform_locks" {',
                    f'  name         = "{config.dynamodb_table}"',
                    '  billing_mode = "PAY_PER_REQUEST"',
                    '  hash_key     = "LockID"',
                    "",
                    "  attribute {",
                    '    name = "LockID"',
                    '    type = "S"',
                    "  }",
                    "",
                    "  # Prevent accidental deletion",
                    "  lifecycle {",
                    "    prevent_destroy = true",
                    "  }",
                    "",
                    "  tags = {",
                    '    Name      = "Terraform State Locks"',
                    '    ManagedBy = "RepliMap"',
                    '    Purpose   = "Terraform state locking"',
                    "  }",
                    "}",
                    "",
                ]
            )

        # Add outputs
        lines.extend(
            [
                "# ═══════════════════════════════════════════════════════════════════════════════",
                "# Outputs",
                "# ═══════════════════════════════════════════════════════════════════════════════",
                "",
                'output "state_bucket_name" {',
                "  value       = aws_s3_bucket.terraform_state.id",
                '  description = "Name of the S3 bucket for Terraform state"',
                "}",
                "",
                'output "state_bucket_arn" {',
                "  value       = aws_s3_bucket.terraform_state.arn",
                '  description = "ARN of the S3 bucket for Terraform state"',
                "}",
                "",
                'output "state_bucket_region" {',
                "  value       = aws_s3_bucket.terraform_state.region",
                '  description = "Region of the S3 bucket for Terraform state"',
                "}",
                "",
            ]
        )

        if config.dynamodb_table:
            lines.extend(
                [
                    'output "dynamodb_table_name" {',
                    "  value       = aws_dynamodb_table.terraform_locks.name",
                    '  description = "Name of the DynamoDB table for state locking"',
                    "}",
                    "",
                    'output "dynamodb_table_arn" {',
                    "  value       = aws_dynamodb_table.terraform_locks.arn",
                    '  description = "ARN of the DynamoDB table for state locking"',
                    "}",
                    "",
                ]
            )

        # Add backend configuration hint
        lines.extend(
            [
                "# ═══════════════════════════════════════════════════════════════════════════════",
                "# Usage Instructions",
                "# ═══════════════════════════════════════════════════════════════════════════════",
                "#",
                "# After running terraform apply, add this backend config to your main project:",
                "#",
                "# terraform {",
                '#   backend "s3" {',
                f'#     bucket = "{config.bucket}"',
                f'#     key    = "{config.key}"',
            ]
        )

        if config.region:
            lines.append(f'#     region = "{config.region}"')
        if config.dynamodb_table:
            lines.append(f'#     dynamodb_table = "{config.dynamodb_table}"')

        lines.extend(
            [
                "#     encrypt = true",
                "#   }",
                "# }",
                "",
            ]
        )

        output_file = bootstrap_dir / "main.tf"
        output_file.write_text("\n".join(lines))

        logger.info(f"Generated backend bootstrap: {output_file}")
        return output_file
