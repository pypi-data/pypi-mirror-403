<!-- Update version below to match package.json version for cache busting -->
<script src="{% static "omero_autotag/js/bundle.min.js" %}?v=4.3.0"></script>

<script>

$(function() {
  var pluginIndex = {{ forloop.counter }};
  var url="{% url 'autotag_get_items' %}";
  var urlUpdate="{% url 'autotag_process_update' %}";
  var urlCreateTag="{% url 'autotag_create_tag' %}";

  var reactRender = function(datatree, selectedNodes) {
    // Collect selected objects with their IDs
    var selectedObjects = [];
    var nodes = Array.isArray(selectedNodes) ? selectedNodes : [selectedNodes];

    nodes.forEach(function(node) {
      selectedObjects.push({
        id: node.data.obj.id,
        type: node.type,
        name: node.text
      });
    });

    // Collect children objects
    var childrenObjects = [];
    var processedIds = new Set();

    nodes.forEach(function(selectedNode) {
      selectedNode.children.forEach(function(childId) {
        var childNode = datatree.get_node(childId);

        // Skip non-supported children of a tag
        if (selectedNode.type === "tag" && ($.inArray(childNode.type, ["image", "dataset", "project", "screen", "plate", 'acquisition']) < 0)) {
          return;
        }

        // Avoid duplicates based on id and type combination
        var uniqueKey = childNode.data.obj.id + '-' + childNode.type;
        if (!processedIds.has(uniqueKey)) {
          childrenObjects.push({
            id: childNode.data.obj.id,
            type: childNode.type,
            name: childNode.text
          });
          processedIds.add(uniqueKey);
        }
      });
    });

    var availableTypes = ['Screen', 'Plate', 'Acquisition', 'Project', 'Dataset', 'Image'];
    // Filter availableTypes to only include types that exist in childrenObjects or selectedObjects
    var objectTypes = new Set([selectedObjects[0].type]);
    childrenObjects.forEach(function(obj) { objectTypes.add(obj.type); });

    availableTypes = availableTypes.filter(function(type) {
      return objectTypes.has(type.toLowerCase());
    });

    const index = availableTypes.indexOf('Acquisition');
    if (index !== -1) {
      availableTypes[index] = 'Run';
    }  // Rename 'Acquisition' to 'Run' for display

    if (availableTypes.length === 0) {
      return;
    }
    // Last type as default, prioritizing Image > Dataset > Project
    defaultType = availableTypes[availableTypes.length - 1]

    // Call the autotagform with structured data
    autotagform.default(
      selectedObjects,
      childrenObjects,
      availableTypes,
      defaultType,
      url,
      urlUpdate,
      urlCreateTag
    );
  };

  $("#auto_tag_panel").omeroweb_center_plugin({
    plugin_index: pluginIndex,        // From the Django template loop
    empty_on_sel_change: false,       // Do not completely erase content when changing selection
    load_plugin_content: function(selected, dtype, oid) {

      // this may have been called before datatree was initialised...
      var datatree = $.jstree.reference('#dataTree');
      if (!datatree) return;

      // Get all selected items from the tree
      var tree_selected = datatree.get_selected(true);

      if (tree_selected === undefined || tree_selected.length === 0) {
        return;
      }

      // Ensure all selected nodes are loaded
      var nodesToLoad = [];
      tree_selected.forEach(function(node) {
        if (!datatree.is_loaded(node)) {
          nodesToLoad.push(node);
        }
      });

      if (nodesToLoad.length === 0) {
        // All nodes already loaded
        reactRender(datatree, tree_selected);
      } else {
        // Load all unloaded nodes, then render
        var loadedCount = 0;
        var totalToLoad = nodesToLoad.length;

        var checkAllLoaded = function() {
          if (loadedCount === totalToLoad) {
            reactRender(datatree, tree_selected);
          }
        };

        nodesToLoad.forEach(function(node) {
          datatree.load_node(node, function(loadedNode, status) {
            loadedCount++;
            checkAllLoaded();
          });
        });
      }
    },

    plugin_enabled: function(selected){
      // Required for multi-selection support
      // supported_obj_types only works for single selection
      if (selected.length == 0) {
        return false;
      }
      var dtype = selected[0]['id'].split('-')[0];
      if (selected.length > 0) {
          return ($.inArray(dtype, ["image", "dataset", "project", "screen", "plate", "acquisition", "tag", "orphaned", "experimenter"]) > -1);
      } else {
          return false;
      }
    }
  });
});

</script>
