"""Markdown report generator for graphs."""

from pathlib import Path
from typing import Optional, cast

import networkx as nx

from ..converters.models import GraphMetadata
from ..utils.stats_calculator import calculate_graph_stats
from ..utils.string_formatter import format_property_key, format_property_value


class ReportGenerator:
    """Generate markdown reports describing graph structure."""

    def visualize(
        self,
        graph: nx.DiGraph,
        output_path: Path,
        source_model_count: int = 1,
        include_samples: bool = True,
    ) -> None:
        """Generate markdown report for graph.

        Args:
            graph: NetworkX directed graph to document.
            output_path: Path for output markdown file (extension added if missing).
            source_model_count: Number of source Pydantic models.
            include_samples: Whether to include sample nodes/edges.

        Raises:
            ValueError: If graph is empty.
        """
        if not self.validate_graph(graph):
            raise ValueError("Cannot generate report for empty graph")

        # Ensure .md extension
        if not str(output_path).endswith(".md"):
            output_path = Path(str(output_path) + ".md")

        # Calculate statistics
        metadata = calculate_graph_stats(graph, source_model_count)

        # Generate report sections
        report_parts = [
            self._create_header(),
            self._create_overview(metadata),
            self._create_node_type_distribution(metadata),
            self._create_edge_type_distribution(metadata),
        ]

        if include_samples:
            report_parts.append(self._create_sample_nodes(graph))
            report_parts.append(self._create_sample_edges(graph))

        # Write report
        with open(output_path, "w", encoding="utf-8") as f:
            f.write("\n\n".join(report_parts))

    def validate_graph(self, graph: nx.DiGraph) -> bool:
        """Validate that graph is not empty."""
        node_count = cast(int, graph.number_of_nodes())
        return node_count > 0

    @staticmethod
    def _create_header() -> str:
        """Create report header."""
        return "# Knowledge Graph Report\n\nAutomatically generated by docling-graph."

    @staticmethod
    def _create_overview(metadata: GraphMetadata) -> str:
        """Create overview section."""
        return f"""## Overview

- **Total Nodes**: {metadata.node_count}
- **Total Edges**: {metadata.edge_count}
- **Source Models**: {metadata.source_models}
- **Generated**: {metadata.created_at.strftime("%Y-%m-%d %H:%M:%S")}"""

    @staticmethod
    def _create_node_type_distribution(metadata: GraphMetadata) -> str:
        """Create node type distribution section."""
        lines = ["## Node Type Distribution", ""]

        if not metadata.node_types:
            lines.append("*No node type information available.*")
        else:
            lines.append("| Node Type | Count | Percentage |")
            lines.append("|-----------|-------|------------|")

            total = metadata.node_count
            for node_type, count in sorted(
                metadata.node_types.items(), key=lambda x: x[1], reverse=True
            ):
                percentage = (count / total * 100) if total > 0 else 0
                lines.append(f"| {node_type} | {count} | {percentage:.1f}% |")

        return "\n".join(lines)

    @staticmethod
    def _create_edge_type_distribution(metadata: GraphMetadata) -> str:
        """Create edge type distribution section."""
        lines = ["## Edge Type Distribution", ""]

        if not metadata.edge_types:
            lines.append("*No edge type information available.*")
        else:
            lines.append("| Edge Type | Count | Percentage |")
            lines.append("|-----------|-------|------------|")

            total = metadata.edge_count
            for edge_type, count in sorted(
                metadata.edge_types.items(), key=lambda x: x[1], reverse=True
            ):
                percentage = (count / total * 100) if total > 0 else 0
                lines.append(f"| {edge_type} | {count} | {percentage:.1f}% |")

        return "\n".join(lines)

    @staticmethod
    def _create_sample_nodes(graph: nx.DiGraph, max_samples: int = 5) -> str:
        """Create sample nodes section."""
        lines = ["## Sample Nodes", ""]

        sample_nodes = list(graph.nodes(data=True))[:max_samples]

        for node_id, data in sample_nodes:
            lines.append(f"### Node: {node_id}")
            lines.append("")

            for key, value in data.items():
                formatted_key = format_property_key(key)
                formatted_value = format_property_value(value, max_length=100)
                lines.append(f"- **{formatted_key}**: {formatted_value}")

            lines.append("")

        return "\n".join(lines)

    @staticmethod
    def _create_sample_edges(graph: nx.DiGraph, max_samples: int = 5) -> str:
        """Create sample edges section."""
        lines = ["## Sample Edges", ""]

        sample_edges = list(graph.edges(data=True))[:max_samples]

        for source, target, data in sample_edges:
            label = data.get("label", "related_to")
            lines.append(f"### {source} â†’ {target}")
            lines.append(f"**Type**: {label}")
            lines.append("")

        return "\n".join(lines)
