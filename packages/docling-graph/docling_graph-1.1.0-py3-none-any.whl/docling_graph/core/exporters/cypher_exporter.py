"""Cypher script exporter for Neo4j direct import."""

import re
from pathlib import Path
from typing import Any, Dict, Optional, TextIO, cast

import networkx as nx

from ..converters.config import ExportConfig


class CypherExporter:
    """Export graph to Cypher script for Neo4j."""

    def __init__(self, config: ExportConfig | None = None) -> None:
        """Initialize Cypher exporter.

        Args:
            config: Export configuration. Uses defaults if None.
        """
        self.config = config or ExportConfig()

    def export(self, graph: nx.DiGraph, output_path: Path) -> None:
        """Export graph to Cypher script.

        Args:
            graph: NetworkX directed graph to export.
            output_path: File path where to save Cypher script.

        Raises:
            ValueError: If graph is empty.
        """
        if not self.validate_graph(graph):
            raise ValueError("Cannot export empty graph")

        output_path.parent.mkdir(parents=True, exist_ok=True)

        with open(output_path, "w", encoding=self.config.CYPHER_ENCODING) as f:
            # Write header
            f.write("// Cypher script generated by docling-graph\n")
            f.write("// Import this into Neo4j\n\n")

            # Write node creation statements
            f.write("// --- Create Nodes ---\n")
            self._write_nodes(graph, f)

            # Write relationship creation statements
            f.write("\n// --- Create Relationships ---\n")
            self._write_relationships(graph, f)

    def validate_graph(self, graph: nx.DiGraph) -> bool:
        """Validate that graph is not empty.

        Args:
            graph: NetworkX directed graph.

        Returns:
            True if graph has nodes.
        """
        # number_of_nodes() is not typed in stubs; cast to int for mypy
        num_nodes = cast(int, graph.number_of_nodes())
        return num_nodes > 0

    @staticmethod
    def _escape_cypher_string(value: Any) -> str:
        """Escape strings for use in Cypher queries.

        Args:
            value: Value to escape.

        Returns:
            Escaped string safe for Cypher.
        """
        # Ensure we operate on a string for proper typing
        val_str: str = value if isinstance(value, str) else str(value)

        # Escape backslashes, quotes, and newlines
        return (
            val_str.replace("\\", "\\\\")
            .replace("'", "\\'")
            .replace('"', '\\"')
            .replace("\n", "\\n")
        )

    @staticmethod
    def _sanitize_identifier(identifier: str) -> str:
        """Sanitize identifier for use in Cypher.

        Args:
            identifier: Identifier to sanitize.

        Returns:
            Sanitized identifier safe for Cypher.
        """
        # Replace non-alphanumeric characters with underscore
        sanitized = re.sub(r"[^a-zA-Z0-9_]", "_", str(identifier))
        # Ensure it doesn't start with a number
        if sanitized and sanitized[0].isdigit():
            sanitized = "n_" + sanitized
        return sanitized or "node"

    def _write_nodes(self, graph: nx.DiGraph, file: TextIO) -> None:
        """Write node creation statements.

        Args:
            graph: NetworkX directed graph.
            file: File object to write to.
        """
        node_vars: Dict[str, str] = {}

        for i, (node_id, data) in enumerate(graph.nodes(data=True)):
            # Create sanitized variable name
            base_var = self._sanitize_identifier(node_id)
            node_var = f"{base_var}_{i}"
            node_vars[node_id] = node_var

            # Get node label
            label = data.get("label", "Node")

            # Build properties
            props = []
            for key, value in data.items():
                if key != "label" and value is not None:
                    escaped_value = self._escape_cypher_string(value)
                    props.append(f'{key}: "{escaped_value}"')

            props_str = ", ".join(props)

            # Write CREATE statement
            if props_str:
                file.write(f"CREATE ({node_var}:{label} {{{props_str}}})\n")
            else:
                file.write(f"CREATE ({node_var}:{label})\n")

        # Store node vars for relationship creation
        self._node_vars = node_vars

    def _write_relationships(self, graph: nx.DiGraph, file: TextIO) -> None:
        """Write relationship creation statements.

        Args:
            graph: NetworkX directed graph.
            file: File object to write to.
        """
        for source, target, data in graph.edges(data=True):
            source_var = self._node_vars.get(source)
            target_var = self._node_vars.get(target)

            if not source_var or not target_var:
                continue

            # Get relationship type
            rel_type = data.get("label", "RELATED_TO").upper()
            rel_type = self._sanitize_identifier(rel_type)

            # Build properties
            props = []
            for key, value in data.items():
                if key != "label" and value is not None:
                    escaped_value = self._escape_cypher_string(value)
                    props.append(f'{key}: "{escaped_value}"')

            # Write MATCH and CREATE statements
            file.write(f"MATCH ({source_var}), ({target_var})\n")
            if props:
                props_str = ", ".join(props)
                file.write(f"CREATE ({source_var})-[:{rel_type} {{{props_str}}}]->({target_var})\n")
            else:
                file.write(f"CREATE ({source_var})-[:{rel_type}]->({target_var})\n")
            file.write("\n")
