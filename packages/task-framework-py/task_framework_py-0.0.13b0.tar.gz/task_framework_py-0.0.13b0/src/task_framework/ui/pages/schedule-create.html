<!DOCTYPE html>
<html lang="en" class="h-full">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Create Schedule - Task Framework</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/htmx.org@1.9.10"></script>
  <style>
    .nav-item {
      transition: all 0.2s ease-in-out;
    }

    .custom-scrollbar::-webkit-scrollbar {
      width: 6px;
    }

    .custom-scrollbar::-webkit-scrollbar-track {
      background: #1f2937;
    }

    .custom-scrollbar::-webkit-scrollbar-thumb {
      background: #4b5563;
      border-radius: 3px;
    }
  </style>
</head>

<body class="h-full bg-gray-50">
  <!-- API Utilities (loaded via htmx) -->
  <div hx-get="/ui/components/api-utils.html" hx-trigger="load" hx-swap="outerHTML"></div>

  <div class="flex h-screen overflow-hidden">
    <!-- Sidebar -->
    <div hx-get="/ui/components/sidebar.html" hx-trigger="load" hx-swap="outerHTML">
      <aside class="w-64 bg-gray-800 text-white flex items-center justify-center">
        <div class="text-gray-400 text-sm">Loading...</div>
      </aside>
    </div>

    <!-- Main Content -->
    <div class="flex-1 overflow-auto">
      <!-- Breadcrumb -->
      <div class="bg-white shadow-sm border-b border-gray-200">
        <div class="px-6 py-3">
          <div class="flex items-center text-sm text-gray-600">
            <a href="/ui/schedules" class="hover:text-blue-600">Schedules</a>
            <svg class="w-4 h-4 mx-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
            </svg>
            <span id="breadcrumb-action">Create</span>
          </div>
        </div>
      </div>

      <!-- Header -->
      <div class="bg-white border-b border-gray-200 px-6 py-4">
        <div>
          <h1 id="page-title" class="text-2xl font-bold text-gray-900">
            Create Schedule
          </h1>
          <p class="mt-1 text-sm text-gray-500">
            Configure cron-based schedule for task execution
          </p>
        </div>
      </div>

      <!-- Loading State -->
      <div id="loading-state" class="hidden flex items-center justify-center py-12">
        <div class="text-center">
          <svg class="animate-spin h-8 w-8 text-blue-600 mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none"
            viewBox="0 0 24 24">
            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
            <path class="opacity-75" fill="currentColor"
              d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">
            </path>
          </svg>
          <p class="mt-2 text-sm text-gray-600">Loading schedule...</p>
        </div>
      </div>

      <!-- Form -->
      <div id="schedule-form" class="px-6 py-6">
        <form onsubmit="saveSchedule(event)" class="max-w-4xl">
          <!-- Basic Configuration -->
          <div class="bg-white rounded-lg shadow p-6 mb-6">
            <h2 class="text-lg font-semibold text-gray-900 mb-4">
              Basic Configuration
            </h2>

            <!-- Cron Expression -->
            <div class="mb-4">
              <label class="block text-sm font-medium text-gray-700 mb-2">
                Cron Expression *
              </label>
              <input type="text" id="schedule-cron" required placeholder="0 9 * * *"
                class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500" />
              <p class="mt-1 text-xs text-gray-500">
                5-field standard cron format (minute hour day month weekday).
                Example: "0 9 * * *" = daily at 9:00 AM
              </p>
            </div>

            <!-- Timezone -->
            <div class="mb-4">
              <label class="block text-sm font-medium text-gray-700 mb-2">
                Timezone *
              </label>
              <input type="text" id="schedule-timezone" required placeholder="America/New_York"
                class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500" />
              <p class="mt-1 text-xs text-gray-500">
                IANA timezone identifier (e.g., UTC, America/New_York,
                Europe/London)
              </p>
            </div>

            <!-- State -->
            <div class="mb-4">
              <label class="block text-sm font-medium text-gray-700 mb-2">
                Initial State
              </label>
              <select id="schedule-state"
                class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                <option value="active" selected>Active</option>
                <option value="paused">Paused</option>
                <option value="canceled">Canceled</option>
              </select>
            </div>

            <!-- Task Definition -->
            <div class="mb-4">
              <label class="block text-sm font-medium text-gray-700 mb-2">
                Task Definition *
              </label>
              <p class="text-xs text-gray-500 mb-2">
                Select the task to execute on this schedule.
              </p>
              <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                <div>
                  <label class="block text-xs text-gray-600 mb-1">Task ID</label>
                  <select id="schedule-task-id"
                    class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                    onchange="updateVersionOptions('schedule-task-id', 'schedule-task-version')" required>
                    <option value="">-- Select Task --</option>
                  </select>
                </div>
                <div>
                  <label class="block text-xs text-gray-600 mb-1">Version</label>
                  <select id="schedule-task-version"
                    class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                    <option value="">-- Select Version --</option>
                  </select>
                </div>
              </div>
            </div>
          </div>

          <!-- Inputs Template -->
          <div class="bg-white rounded-lg shadow p-6 mb-6">
            <h2 class="text-lg font-semibold text-gray-900 mb-4">
              Input Artifacts Template
            </h2>
            <p class="text-sm text-gray-600 mb-4">
              Define input artifacts that will be provided to each scheduled
              run. At least one input artifact is required.
            </p>

            <div id="inputs-container" class="space-y-4">
              <!-- Inputs will be added here -->
            </div>

            <button type="button" onclick="addInput()"
              class="mt-2 px-4 py-2 border border-gray-300 rounded-lg text-sm font-medium text-gray-700 hover:bg-gray-50">
              <svg class="w-4 h-4 inline-block -mt-1 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" />
              </svg>
              Add Input Artifact
            </button>
          </div>

          <!-- Task Parameters -->
          <div class="bg-white rounded-lg shadow p-6 mb-6">
            <h2 class="text-lg font-semibold text-gray-900 mb-4">
              Task Parameters
            </h2>
            <textarea id="schedule-params" rows="4" placeholder="{}"
              class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 font-mono text-sm"></textarea>
            <p class="mt-1 text-xs text-gray-500">
              JSON object with task-specific parameters
            </p>
          </div>

          <!-- Metadata -->
          <div class="bg-white rounded-lg shadow p-6 mb-6">
            <h2 class="text-lg font-semibold text-gray-900 mb-4">Metadata</h2>
            <textarea id="schedule-metadata" rows="4" placeholder="{}"
              class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 font-mono text-sm"></textarea>
            <p class="mt-1 text-xs text-gray-500">
              JSON object with schedule metadata
            </p>
          </div>

          <!-- Advanced Options -->
          <div class="bg-white rounded-lg shadow p-6 mb-6">
            <h2 class="text-lg font-semibold text-gray-900 mb-4">
              Advanced Options
            </h2>

            <!-- Concurrency Policy -->
            <div class="mb-4">
              <label class="block text-sm font-medium text-gray-700 mb-2">
                Concurrency Policy
              </label>
              <select id="schedule-concurrency"
                class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                <option value="allow" selected>
                  Allow (run concurrent executions)
                </option>
                <option value="forbid">
                  Forbid (skip if previous still running)
                </option>
                <option value="replace">
                  Replace (stop previous and start new)
                </option>
              </select>
            </div>

            <!-- Max Attempts -->
            <div class="mb-4">
              <label class="block text-sm font-medium text-gray-700 mb-2">
                Max Retry Attempts
              </label>
              <input type="number" id="schedule-max-attempts" min="1" value="1"
                class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500" />
              <p class="mt-1 text-xs text-gray-500">
                Maximum number of retry attempts per run (minimum: 1)
              </p>
            </div>

            <!-- Webhook Configuration -->
            <div>
              <div class="flex items-center justify-between mb-2">
                <label class="block text-sm font-medium text-gray-700">
                  Webhook Callbacks
                </label>
                <button type="button" onclick="addWebhook()"
                  class="text-xs text-blue-600 hover:text-blue-700 font-medium flex items-center">
                  <svg class="w-3 h-3 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
                  </svg>
                  Add Webhook
                </button>
              </div>
              <p class="mt-1 text-xs text-gray-500 mb-3">
                Optional webhook URLs to receive notifications when scheduled thread state changes.
              </p>

              <!-- Webhooks Container -->
              <div id="webhooks-container" class="space-y-3">
                <!-- Webhooks will be added here dynamically -->
              </div>
            </div>
          </div>

          <!-- Submit -->
          <div class="flex justify-end gap-3">
            <a href="/ui/schedules"
              class="px-6 py-2 border border-gray-300 rounded-lg text-sm font-medium text-gray-700 hover:bg-gray-50">
              Cancel
            </a>
            <button type="submit" id="submit-button"
              class="px-6 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg text-sm font-medium">
              <span id="submit-button-text">Create Schedule</span>
            </button>
          </div>
        </form>
      </div>
    </div>
  </div>

  <script>
    // STORAGE_KEYS is now defined in api-utils.html

    let editingScheduleId = null;
    let inputCounter = 0;
    let webhookCounter = 0;
    let availableTasks = [];

    /**
     * Wait for API utilities to be loaded
     */
    function waitForApiUtils() {
      return new Promise((resolve) => {
        if (typeof apiFetch !== "undefined") {
          resolve();
        } else {
          const checkInterval = setInterval(() => {
            if (typeof apiFetch !== "undefined") {
              clearInterval(checkInterval);
              resolve();
            }
          }, 50);
        }
      });
    }

    /**
     * Initialize page
     */
    document.addEventListener("DOMContentLoaded", async function () {
      await waitForApiUtils();
      await loadAvailableTasks();

      // Check if editing (schedule ID in URL)
      const pathParts = window.location.pathname.split("/");
      const lastPart = pathParts[pathParts.length - 1];

      if (
        lastPart &&
        lastPart !== "create" &&
        lastPart.startsWith("schedule_")
      ) {
        editingScheduleId = lastPart;
        document.getElementById("page-title").textContent = "Edit Schedule";
        document.getElementById("breadcrumb-action").textContent = "Edit";
        document.getElementById("submit-button-text").textContent =
          "Update Schedule";
        loadScheduleForEdit();
      } else {
        // Add default artifact for new schedules
        addInput();
      }
    });

    /**
     * Load available tasks for dropdown
     */
    async function loadAvailableTasks() {
      const apiKey = localStorage.getItem(STORAGE_KEYS.API_KEY);
      if (!apiKey) return;

      try {
        const response = await fetch('/admin/tasks', {
          headers: {
            'X-API-Key': apiKey,
            'Content-Type': 'application/json'
          }
        });

        if (response.ok) {
          const data = await response.json();
          availableTasks = data.tasks || [];
          populateTaskDropdown();
        }
      } catch (error) {
        console.error('Error loading tasks:', error);
      }
    }

    /**
     * Populate task dropdown
     */
    function populateTaskDropdown() {
      const taskSelect = document.getElementById('schedule-task-id');
      taskSelect.innerHTML = '<option value="">-- Select Task --</option>';

      availableTasks.forEach(task => {
        const option = document.createElement('option');
        option.value = task.task_id;
        option.textContent = `${task.name} (${task.task_id})`;
        option.dataset.versions = JSON.stringify(task.versions || []);
        taskSelect.appendChild(option);
      });
    }

    /**
     * Update version options when task is selected
     */
    function updateVersionOptions(taskSelectId, versionSelectId) {
      const taskSelect = document.getElementById(taskSelectId);
      const versionSelect = document.getElementById(versionSelectId);
      const selectedOption = taskSelect.selectedOptions[0];

      versionSelect.innerHTML = '<option value="">-- Select Version --</option>';

      if (selectedOption && selectedOption.dataset.versions) {
        const versions = JSON.parse(selectedOption.dataset.versions);
        versions.forEach(version => {
          const option = document.createElement('option');
          option.value = version;
          option.textContent = version;
          versionSelect.appendChild(option);
        });
      }
    }

    /**
     * Load schedule for editing
     */
    async function loadScheduleForEdit() {
      const apiKey = localStorage.getItem(STORAGE_KEYS.API_KEY);
      const appId = localStorage.getItem(STORAGE_KEYS.APP_ID);
      const userId = localStorage.getItem(STORAGE_KEYS.USER_ID);

      document.getElementById("loading-state").classList.remove("hidden");
      document.getElementById("schedule-form").classList.add("hidden");

      try {
        const response = await apiFetch(`/schedules/${editingScheduleId}`);

        const schedule = await response.json();
        populateForm(schedule);

        document.getElementById("loading-state").classList.add("hidden");
        document.getElementById("schedule-form").classList.remove("hidden");
      } catch (error) {
        console.error("Error loading schedule:", error);
        alert(`Error: ${error.message}`);
        window.location.href = "/ui/schedules";
      }
    }

    /**
     * Populate form with schedule data
     */
    function populateForm(schedule) {
      document.getElementById("schedule-cron").value = schedule.cron || "";
      document.getElementById("schedule-timezone").value =
        schedule.timezone || "";
      document.getElementById("schedule-state").value =
        schedule.state || "active";
      document.getElementById("schedule-concurrency").value =
        schedule.concurrency_policy || "allow";
      document.getElementById("schedule-max-attempts").value =
        schedule.max_attempts || 1;

      // Task definition
      if (schedule.task_id) {
        document.getElementById("schedule-task-id").value = schedule.task_id;
        updateVersionOptions('schedule-task-id', 'schedule-task-version');
        if (schedule.task_version) {
          document.getElementById("schedule-task-version").value = schedule.task_version;
        }
      }

      if (schedule.params) {
        document.getElementById("schedule-params").value = JSON.stringify(
          schedule.params,
          null,
          2
        );
      }

      if (schedule.metadata) {
        document.getElementById("schedule-metadata").value = JSON.stringify(
          schedule.metadata,
          null,
          2
        );
      }

      // Load inputs
      if (schedule.inputs_template && schedule.inputs_template.length > 0) {
        schedule.inputs_template.forEach((input) => {
          addInput(input);
        });
      }

      // Load webhooks
      if (schedule.webhooks && schedule.webhooks.length > 0) {
        schedule.webhooks.forEach((webhook) => {
          addWebhook(webhook);
        });
      }
    }

    /**
     * Add input artifact
     */
    function addInput(existingInput = null) {
      inputCounter++;
      const container = document.getElementById("inputs-container");
      const inputDiv = document.createElement("div");
      inputDiv.className =
        "input-artifact-item border border-gray-300 rounded-lg p-4 bg-gray-50";

      const kind = existingInput?.kind || "text";
      const ref = existingInput?.ref || "";
      const mediaType = existingInput?.media_type || "";
      const explain = existingInput?.explain || "";

      inputDiv.innerHTML = `
          <div class="flex items-center justify-between mb-3">
            <h5 class="text-sm font-semibold text-gray-700">Artifact #${inputCounter}</h5>
            <button
              type="button"
              onclick="removeInput(this)"
              class="text-sm text-red-600 hover:text-red-700"
            >
              Remove
            </button>
          </div>

          <div class="space-y-3">
            <!-- Artifact Kind -->
            <div>
              <label class="block text-xs font-medium text-gray-700 mb-1">
                Kind <span class="text-red-500">*</span>
              </label>
              <select
                class="artifact-kind w-full px-3 py-2 text-sm border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                onchange="updateInputFields(this)"
                required
              >
                <option value="text" ${kind === "text" ? "selected" : ""
        }>text - Plain text content</option>
                <option value="json" ${kind === "json" ? "selected" : ""
        }>json - JSON data</option>
                <option value="url" ${kind === "url" ? "selected" : ""
        }>url - URL reference</option>
                <option value="rich_text" ${kind === "rich_text" ? "selected" : ""
        }>rich_text - Markdown/formatted text</option>
              </select>
            </div>

            <!-- Artifact Ref -->
            <div>
              <label class="block text-xs font-medium text-gray-700 mb-1">
                Reference (optional)
              </label>
              <input
                type="text"
                class="artifact-ref w-full px-3 py-2 text-sm border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                placeholder="e.g., input:data, input:config"
                value="${escapeHtml(ref)}"
              />
              <p class="mt-1 text-xs text-gray-500">Stable reference name (unique within thread)</p>
            </div>

            <!-- Artifact Content Fields (dynamic based on kind) -->
            <div class="artifact-content-fields">
              <!-- Content fields will be inserted here -->
            </div>

            <!-- Media Type (optional) -->
            <div>
              <label class="block text-xs font-medium text-gray-700 mb-1">
                Media Type (optional)
              </label>
              <input
                type="text"
                class="artifact-media-type w-full px-3 py-2 text-sm border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                placeholder="e.g., text/plain, application/json"
                value="${escapeHtml(mediaType)}"
              />
            </div>

            <!-- Artifact Explain -->
            <div>
              <label class="block text-xs font-medium text-gray-700 mb-1">
                Description (optional)
              </label>
              <input
                type="text"
                class="artifact-explain w-full px-3 py-2 text-sm border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                placeholder="Human-readable description"
                value="${escapeHtml(explain)}"
              />
            </div>
          </div>
        `;

      container.appendChild(inputDiv);

      // Update content fields based on kind and populate if editing
      const select = inputDiv.querySelector(".artifact-kind");
      updateInputFields(select, existingInput);
    }

    /**
     * Update input content fields based on kind
     */
    function updateInputFields(selectElement, existingInput = null) {
      const kind = selectElement.value;
      const artifactItem = selectElement.closest(".input-artifact-item");
      const contentFields = artifactItem.querySelector(
        ".artifact-content-fields"
      );

      let fieldsHtml = "";

      switch (kind) {
        case "text":
        case "rich_text":
          const textValue = existingInput?.text || "";
          fieldsHtml = `
              <div class="artifact-field-text">
                <label class="block text-xs font-medium text-gray-700 mb-1">
                  Text Content <span class="text-red-500">*</span>
                </label>
                <textarea
                  class="artifact-text w-full px-3 py-2 text-sm border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                  rows="4"
                  placeholder="${kind === "rich_text"
              ? "Enter markdown content..."
              : "Enter text content..."
            }"
                  required>${escapeHtml(textValue)}</textarea>
              </div>
            `;
          break;

        case "json":
          const jsonValue = existingInput?.value
            ? JSON.stringify(existingInput.value, null, 2)
            : "";
          fieldsHtml = `
              <div class="artifact-field-json">
                <label class="block text-xs font-medium text-gray-700 mb-1">
                  JSON Value <span class="text-red-500">*</span>
                </label>
                <textarea
                  class="artifact-value w-full px-3 py-2 text-sm border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 font-mono"
                  rows="4"
                  placeholder='{"key": "value", "number": 123}'
                  required>${escapeHtml(jsonValue)}</textarea>
                <p class="mt-1 text-xs text-gray-500">Must be valid JSON</p>
              </div>
            `;
          break;

        case "url":
          const urlValue = existingInput?.url || "";
          fieldsHtml = `
              <div class="artifact-field-url">
                <label class="block text-xs font-medium text-gray-700 mb-1">
                  URL <span class="text-red-500">*</span>
                </label>
                <input
                  type="url"
                  class="artifact-url w-full px-3 py-2 text-sm border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                  placeholder="https://example.com/resource"
                  value="${escapeHtml(urlValue)}"
                  required
                />
              </div>
            `;
          break;
      }

      contentFields.innerHTML = fieldsHtml;
    }

    /**
     * Remove input artifact
     */
    function removeInput(button) {
      const container = document.getElementById("inputs-container");
      const items = container.querySelectorAll(".input-artifact-item");

      // Don't allow removing the last artifact
      if (items.length > 1) {
        button.closest(".input-artifact-item").remove();
      } else {
        alert("At least one input artifact is required.");
      }
    }

    /**
     * Collect input artifacts from form
     */
    function collectInputs() {
      const inputs = [];
      const inputDivs = document.querySelectorAll(
        "#inputs-container > .input-artifact-item"
      );

      inputDivs.forEach((div, index) => {
        const kind = div.querySelector(".artifact-kind").value;
        const ref = div.querySelector(".artifact-ref").value.trim();
        const mediaType = div
          .querySelector(".artifact-media-type")
          .value.trim();
        const explain = div.querySelector(".artifact-explain").value.trim();

        const artifact = { kind };

        if (ref) artifact.ref = ref;
        if (mediaType) artifact.media_type = mediaType;
        if (explain) artifact.explain = explain;

        // Add content based on kind
        if (kind === "text" || kind === "rich_text") {
          const textElement = div.querySelector(".artifact-text");
          if (textElement) {
            artifact.text = textElement.value;
          } else {
            throw new Error(`Missing text content in artifact #${index + 1}`);
          }
        } else if (kind === "json") {
          const valueElement = div.querySelector(".artifact-value");
          if (valueElement) {
            const value = valueElement.value.trim();
            try {
              artifact.value = JSON.parse(value);
            } catch (e) {
              throw new Error(
                `Invalid JSON in artifact #${index + 1}: ${e.message}`
              );
            }
          } else {
            throw new Error(`Missing JSON value in artifact #${index + 1}`);
          }
        } else if (kind === "url") {
          const urlElement = div.querySelector(".artifact-url");
          if (urlElement) {
            artifact.url = urlElement.value;
          } else {
            throw new Error(`Missing URL in artifact #${index + 1}`);
          }
        }

        inputs.push(artifact);
      });

      if (inputs.length === 0) {
        throw new Error("At least one input artifact is required");
      }

      return inputs;
    }

    /**
     * Add a new webhook
     */
    function addWebhook(existingWebhook = null) {
      webhookCounter++;
      const container = document.getElementById('webhooks-container');

      const url = existingWebhook?.callback_url || '';
      const events = existingWebhook?.events ? existingWebhook.events.join(', ') : '';
      const apiKey = existingWebhook?.api_key || '';

      const webhookHtml = `
            <div class="webhook-item border border-gray-300 rounded-lg p-3 bg-white">
                <div class="flex items-center justify-between mb-2">
                    <span class="text-xs font-semibold text-gray-700">Webhook #${webhookCounter}</span>
                    <button 
                        type="button" 
                        onclick="removeWebhook(this)"
                        class="text-xs text-red-600 hover:text-red-700">
                        Remove
                    </button>
                </div>
                <div class="space-y-2">
                    <div>
                        <label class="block text-xs font-medium text-gray-700 mb-1">
                            Callback URL <span class="text-red-500">*</span>
                        </label>
                        <input 
                            type="url" 
                            class="webhook-url w-full px-3 py-2 text-xs border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                            placeholder="https://example.com/webhook"
                            value="${escapeHtml(url)}"
                            required
                        />
                    </div>
                    <div>
                        <label class="block text-xs font-medium text-gray-700 mb-1">
                            Events (optional, defaults to succeeded/failed/stopped)
                        </label>
                        <input 
                            type="text" 
                            class="webhook-events w-full px-3 py-2 text-xs border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                            placeholder="thread.succeeded, thread.failed"
                            value="${escapeHtml(events)}"
                        />
                        <p class="mt-1 text-xs text-gray-500">Comma-separated event names</p>
                    </div>
                    <div>
                        <label class="block text-xs font-medium text-gray-700 mb-1">
                            Webhook API Key (optional)
                        </label>
                        <input 
                            type="password" 
                            class="webhook-api-key w-full px-3 py-2 text-xs border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                            placeholder="X-API-Key for webhook endpoint"
                            value="${escapeHtml(apiKey)}"
                        />
                        <p class="mt-1 text-xs text-gray-500">If the webhook endpoint requires authentication, provide the X-API-Key header value</p>
                    </div>
                </div>
            </div>
        `;

      container.insertAdjacentHTML('beforeend', webhookHtml);
    }

    /**
     * Remove a webhook
     */
    function removeWebhook(button) {
      button.closest('.webhook-item').remove();
    }

    /**
     * Collect webhooks from form
     */
    function collectWebhooks() {
      const webhooks = [];
      const items = document.querySelectorAll('.webhook-item');

      items.forEach(item => {
        const url = item.querySelector('.webhook-url').value.trim();
        const eventsStr = item.querySelector('.webhook-events').value.trim();
        const apiKey = item.querySelector('.webhook-api-key').value.trim();

        if (url) {
          const webhook = { callback_url: url };

          if (eventsStr) {
            webhook.events = eventsStr.split(',').map(e => e.trim()).filter(e => e);
          } else {
            webhook.events = ['thread.succeeded', 'thread.failed', 'thread.stopped'];
          }

          if (apiKey) {
            webhook.api_key = apiKey;
          }

          webhooks.push(webhook);
        }
      });

      return webhooks;
    }

    /**
     * Escape HTML helper
     */
    function escapeHtml(text) {
      if (!text) return '';
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    /**
     * Save schedule (create or update)
     */
    async function saveSchedule(event) {
      event.preventDefault();

      const apiKey = localStorage.getItem(STORAGE_KEYS.API_KEY);
      const appId = localStorage.getItem(STORAGE_KEYS.APP_ID);
      const userId = localStorage.getItem(STORAGE_KEYS.USER_ID);

      const submitButton = document.getElementById("submit-button");
      submitButton.disabled = true;

      try {
        // Collect form data
        const cron = document.getElementById("schedule-cron").value.trim();
        const timezone = document
          .getElementById("schedule-timezone")
          .value.trim();
        const state = document.getElementById("schedule-state").value;
        const concurrency = document.getElementById(
          "schedule-concurrency"
        ).value;
        const maxAttempts = parseInt(
          document.getElementById("schedule-max-attempts").value
        );

        const paramsText = document
          .getElementById("schedule-params")
          .value.trim();
        const metadataText = document
          .getElementById("schedule-metadata")
          .value.trim();

        let params = {};
        let metadata = {};

        if (paramsText) {
          try {
            params = JSON.parse(paramsText);
          } catch (e) {
            throw new Error(`Invalid JSON in parameters: ${e.message}`);
          }
        }

        if (metadataText) {
          try {
            metadata = JSON.parse(metadataText);
          } catch (e) {
            throw new Error(`Invalid JSON in metadata: ${e.message}`);
          }
        }

        const inputs = collectInputs();

        const payload = {
          cron,
          timezone,
          state,
          concurrency_policy: concurrency,
          max_attempts: maxAttempts,
          inputs_template: inputs,
          params,
          metadata,
          webhooks: collectWebhooks(),
        };

        // Task definition (optional)
        const taskId = document.getElementById("schedule-task-id").value.trim();
        const taskVersion = document.getElementById("schedule-task-version").value.trim();
        if (taskId) {
          payload.task_id = taskId;
        }
        if (taskVersion) {
          payload.task_version = taskVersion;
        }

        // Create or update
        let url = editingScheduleId
          ? `/schedules/${editingScheduleId}`
          : `/schedules`;

        // For creating new schedules, include task_id and task_version as query params
        if (!editingScheduleId && taskId) {
          const params = new URLSearchParams();
          params.append('task_id', taskId);
          if (taskVersion) {
            params.append('task_version', taskVersion);
          }
          url = `/schedules?${params.toString()}`;
        }

        const method = editingScheduleId ? "PATCH" : "POST";

        const response = await apiFetch(url, {
          method,
          body: JSON.stringify(payload),
        });

        const result = await response.json();
        window.location.href = `/ui/schedules/${result.id}`;
      } catch (error) {
        console.error("Error saving schedule:", error);
        alert(`Error: ${error.message}`);
        submitButton.disabled = false;
      }
    }

    /**
     * Utility function
     */
    function escapeHtml(text) {
      if (!text) return "";
      const div = document.createElement("div");
      div.textContent = text;
      return div.innerHTML;
    }
  </script>
</body>

</html>